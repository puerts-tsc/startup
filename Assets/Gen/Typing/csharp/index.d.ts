//@ts-nocheck
interface T extends object {
}
export namespace System {
    interface Array {
        toArray(): any[]
        [Symbol.iterator](): Generator<any>
    }
    interface Array$1<T> extends System.Array {
        get_Item(index: number): T;
        set_Item(index: number, value: T): void;
        toArray(): T[];
        [Symbol.iterator](): Generator<T>
    }
}
export namespace UnityEngine {
    interface GameObject {
        GetInChild<T extends UnityEngine.Component>($type: new (...args: any[]) => T, $includeInactive?: boolean): System.Array$1<T>;
        AddComponent<T extends UnityEngine.Component>($type: new (...args: any[]) => T): T;
    }
}
export namespace System.Collections.Generic {
    interface List$1<T> {
        forEach(fn: (v: T, k?: number) => boolean | void): void;
        toArray: T[];
        [Symbol.iterator](): {
            next(): {
                value: { key: number, value: T }, done: boolean
            };
        };
    }
    interface Dictionary$2<TKey, TValue> {
        forEach(fn: (v: TValue, k?: TKey) => boolean | void): void;
        keys: TKey[];
        values: TValue[];
        map: Map<TKey, TValue>;
        [Symbol.iterator](): {
            next(): {
                value: { key: TKey, value: TValue }, done: boolean
            };
        };
    }
}
export namespace UnityEngine {
    interface Transform {
        [Symbol.iterator](): Generator<Transform, void, unknown>;
    }
    interface GameObject {
        [Symbol.iterator](): Generator<Transform, void, unknown>;
    }
}
    interface $Ref<T> {
        value: T
    }
    export namespace System {
        interface Array$1<T> extends System.Array {
            get_Item(index: number):T;
            set_Item(index: number, value: T):void;
        }
    }
    type $Task<T> = System.Threading.Tasks.Task$1<T>
    export namespace UnityEngine {
        export class Debug extends System.Object{ 
            public static get unityLogger(): UnityEngine.ILogger;
            public static get developerConsoleVisible(): boolean;
            public static set developerConsoleVisible(value: boolean);
            public static get isDebugBuild(): boolean;
            public static DrawLine($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $color: UnityEngine.Color, $duration: number):void;
            public static DrawLine($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $color: UnityEngine.Color):void;
            public static DrawLine($start: UnityEngine.Vector3, $end: UnityEngine.Vector3):void;
            public static DrawLine($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $color: UnityEngine.Color, $duration: number, $depthTest: boolean):void;
            public static DrawRay($start: UnityEngine.Vector3, $dir: UnityEngine.Vector3, $color: UnityEngine.Color, $duration: number):void;
            public static DrawRay($start: UnityEngine.Vector3, $dir: UnityEngine.Vector3, $color: UnityEngine.Color):void;
            public static DrawRay($start: UnityEngine.Vector3, $dir: UnityEngine.Vector3):void;
            public static DrawRay($start: UnityEngine.Vector3, $dir: UnityEngine.Vector3, $color: UnityEngine.Color, $duration: number, $depthTest: boolean):void;
            public static Break():void;
            public static DebugBreak():void;
            public static Log($message: any):void;
            public static Log($message: any, $context: UnityEngine.Object):void;
            public static LogFormat($format: string, ...args: any[]):void;
            public static LogFormat($context: UnityEngine.Object, $format: string, ...args: any[]):void;
            public static LogFormat($logType: UnityEngine.LogType, $logOptions: UnityEngine.LogOption, $context: UnityEngine.Object, $format: string, ...args: any[]):void;
            public static LogError($message: any):void;
            public static LogError($message: any, $context: UnityEngine.Object):void;
            public static LogErrorFormat($format: string, ...args: any[]):void;
            public static LogErrorFormat($context: UnityEngine.Object, $format: string, ...args: any[]):void;
            public static ClearDeveloperConsole():void;
            public static LogException($exception: System.Exception):void;
            public static LogException($exception: System.Exception, $context: UnityEngine.Object):void;
            public static LogWarning($message: any):void;
            public static LogWarning($message: any, $context: UnityEngine.Object):void;
            public static LogWarningFormat($format: string, ...args: any[]):void;
            public static LogWarningFormat($context: UnityEngine.Object, $format: string, ...args: any[]):void;
            public static Assert($condition: boolean):void;
            public static Assert($condition: boolean, $context: UnityEngine.Object):void;
            public static Assert($condition: boolean, $message: any):void;
            public static Assert($condition: boolean, $message: string):void;
            public static Assert($condition: boolean, $message: any, $context: UnityEngine.Object):void;
            public static Assert($condition: boolean, $message: string, $context: UnityEngine.Object):void;
            public static AssertFormat($condition: boolean, $format: string, ...args: any[]):void;
            public static AssertFormat($condition: boolean, $context: UnityEngine.Object, $format: string, ...args: any[]):void;
            public static LogAssertion($message: any):void;
            public static LogAssertion($message: any, $context: UnityEngine.Object):void;
            public static LogAssertionFormat($format: string, ...args: any[]):void;
            public static LogAssertionFormat($context: UnityEngine.Object, $format: string, ...args: any[]):void;
            public constructor();
        }
        export interface ILogger extends UnityEngine.ILogHandler{ 
            logHandler: UnityEngine.ILogHandler;
            logEnabled: boolean;
            filterLogType: UnityEngine.LogType;
            IsLogTypeAllowed($logType: UnityEngine.LogType):boolean;
            Log($logType: UnityEngine.LogType, $message: any):void;
            Log($logType: UnityEngine.LogType, $message: any, $context: UnityEngine.Object):void;
            Log($logType: UnityEngine.LogType, $tag: string, $message: any):void;
            Log($logType: UnityEngine.LogType, $tag: string, $message: any, $context: UnityEngine.Object):void;
            Log($message: any):void;
            Log($tag: string, $message: any):void;
            Log($tag: string, $message: any, $context: UnityEngine.Object):void;
            LogWarning($tag: string, $message: any):void;
            LogWarning($tag: string, $message: any, $context: UnityEngine.Object):void;
            LogError($tag: string, $message: any):void;
            LogError($tag: string, $message: any, $context: UnityEngine.Object):void;
            LogFormat($logType: UnityEngine.LogType, $format: string, ...args: any[]):void;
            LogException($exception: System.Exception):void;
            LogFormat($logType: UnityEngine.LogType, $context: UnityEngine.Object, $format: string, ...args: any[]):void;
            LogException($exception: System.Exception, $context: UnityEngine.Object):void;
        }
        export interface ILogHandler{ 
            LogFormat($logType: UnityEngine.LogType, $context: UnityEngine.Object, $format: string, ...args: any[]):void;
            LogException($exception: System.Exception, $context: UnityEngine.Object):void;
        }
        export class Vector3 extends System.ValueType implements System.IEquatable$1<UnityEngine.Vector3>, System.IFormattable{ 
            public static kEpsilon: number;
            public static kEpsilonNormalSqrt: number;
            public x: number;
            public y: number;
            public z: number;
            public get normalized(): UnityEngine.Vector3;
            public get magnitude(): number;
            public get sqrMagnitude(): number;
            public static get zero(): UnityEngine.Vector3;
            public static get one(): UnityEngine.Vector3;
            public static get forward(): UnityEngine.Vector3;
            public static get back(): UnityEngine.Vector3;
            public static get up(): UnityEngine.Vector3;
            public static get down(): UnityEngine.Vector3;
            public static get left(): UnityEngine.Vector3;
            public static get right(): UnityEngine.Vector3;
            public static get positiveInfinity(): UnityEngine.Vector3;
            public static get negativeInfinity(): UnityEngine.Vector3;
            public static Slerp($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $t: number):UnityEngine.Vector3;
            public static SlerpUnclamped($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $t: number):UnityEngine.Vector3;
            public static OrthoNormalize($normal: $Ref<UnityEngine.Vector3>, $tangent: $Ref<UnityEngine.Vector3>):void;
            public static OrthoNormalize($normal: $Ref<UnityEngine.Vector3>, $tangent: $Ref<UnityEngine.Vector3>, $binormal: $Ref<UnityEngine.Vector3>):void;
            public static RotateTowards($current: UnityEngine.Vector3, $target: UnityEngine.Vector3, $maxRadiansDelta: number, $maxMagnitudeDelta: number):UnityEngine.Vector3;
            public static Lerp($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $t: number):UnityEngine.Vector3;
            public static LerpUnclamped($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $t: number):UnityEngine.Vector3;
            public static MoveTowards($current: UnityEngine.Vector3, $target: UnityEngine.Vector3, $maxDistanceDelta: number):UnityEngine.Vector3;
            public static SmoothDamp($current: UnityEngine.Vector3, $target: UnityEngine.Vector3, $currentVelocity: $Ref<UnityEngine.Vector3>, $smoothTime: number, $maxSpeed: number):UnityEngine.Vector3;
            public static SmoothDamp($current: UnityEngine.Vector3, $target: UnityEngine.Vector3, $currentVelocity: $Ref<UnityEngine.Vector3>, $smoothTime: number):UnityEngine.Vector3;
            public static SmoothDamp($current: UnityEngine.Vector3, $target: UnityEngine.Vector3, $currentVelocity: $Ref<UnityEngine.Vector3>, $smoothTime: number, $maxSpeed: number, $deltaTime: number):UnityEngine.Vector3;
            public get_Item($index: number):number;
            public set_Item($index: number, $value: number):void;
            public Set($newX: number, $newY: number, $newZ: number):void;
            public static Scale($a: UnityEngine.Vector3, $b: UnityEngine.Vector3):UnityEngine.Vector3;
            public Scale($scale: UnityEngine.Vector3):void;
            public static Cross($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3):UnityEngine.Vector3;
            public Equals($other: any):boolean;
            public Equals($other: UnityEngine.Vector3):boolean;
            public static Reflect($inDirection: UnityEngine.Vector3, $inNormal: UnityEngine.Vector3):UnityEngine.Vector3;
            public static Normalize($value: UnityEngine.Vector3):UnityEngine.Vector3;
            public Normalize():void;
            public static Dot($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3):number;
            public static Project($vector: UnityEngine.Vector3, $onNormal: UnityEngine.Vector3):UnityEngine.Vector3;
            public static ProjectOnPlane($vector: UnityEngine.Vector3, $planeNormal: UnityEngine.Vector3):UnityEngine.Vector3;
            public static Angle($from: UnityEngine.Vector3, $to: UnityEngine.Vector3):number;
            public static SignedAngle($from: UnityEngine.Vector3, $to: UnityEngine.Vector3, $axis: UnityEngine.Vector3):number;
            public static Distance($a: UnityEngine.Vector3, $b: UnityEngine.Vector3):number;
            public static ClampMagnitude($vector: UnityEngine.Vector3, $maxLength: number):UnityEngine.Vector3;
            public static Magnitude($vector: UnityEngine.Vector3):number;
            public static SqrMagnitude($vector: UnityEngine.Vector3):number;
            public static Min($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3):UnityEngine.Vector3;
            public static Max($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3):UnityEngine.Vector3;
            public static op_Addition($a: UnityEngine.Vector3, $b: UnityEngine.Vector3):UnityEngine.Vector3;
            public static op_Subtraction($a: UnityEngine.Vector3, $b: UnityEngine.Vector3):UnityEngine.Vector3;
            public static op_UnaryNegation($a: UnityEngine.Vector3):UnityEngine.Vector3;
            public static op_Multiply($a: UnityEngine.Vector3, $d: number):UnityEngine.Vector3;
            public static op_Multiply($d: number, $a: UnityEngine.Vector3):UnityEngine.Vector3;
            public static op_Division($a: UnityEngine.Vector3, $d: number):UnityEngine.Vector3;
            public static op_Equality($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3):boolean;
            public static op_Inequality($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3):boolean;
            public ToString():string;
            public ToString($format: string):string;
            public ToString($format: string, $formatProvider: System.IFormatProvider):string;
            public constructor($x: number, $y: number, $z: number);
            public constructor($x: number, $y: number);
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
            public constructor();
        }
        interface Vector3 {
            ToVector3Int():UnityEngine.Vector3Int;
            SetX($value: number):UnityEngine.Vector3;
            SetY($value: number):UnityEngine.Vector3;
        }
        export class Color extends System.ValueType implements System.IEquatable$1<UnityEngine.Color>, System.IFormattable{ 
            public r: number;
            public g: number;
            public b: number;
            public a: number;
            public static get red(): UnityEngine.Color;
            public static get green(): UnityEngine.Color;
            public static get blue(): UnityEngine.Color;
            public static get white(): UnityEngine.Color;
            public static get black(): UnityEngine.Color;
            public static get yellow(): UnityEngine.Color;
            public static get cyan(): UnityEngine.Color;
            public static get magenta(): UnityEngine.Color;
            public static get gray(): UnityEngine.Color;
            public static get grey(): UnityEngine.Color;
            public static get clear(): UnityEngine.Color;
            public get grayscale(): number;
            public get linear(): UnityEngine.Color;
            public get gamma(): UnityEngine.Color;
            public get maxColorComponent(): number;
            public ToString():string;
            public ToString($format: string):string;
            public ToString($format: string, $formatProvider: System.IFormatProvider):string;
            public Equals($other: any):boolean;
            public Equals($other: UnityEngine.Color):boolean;
            public static op_Addition($a: UnityEngine.Color, $b: UnityEngine.Color):UnityEngine.Color;
            public static op_Subtraction($a: UnityEngine.Color, $b: UnityEngine.Color):UnityEngine.Color;
            public static op_Multiply($a: UnityEngine.Color, $b: UnityEngine.Color):UnityEngine.Color;
            public static op_Multiply($a: UnityEngine.Color, $b: number):UnityEngine.Color;
            public static op_Multiply($b: number, $a: UnityEngine.Color):UnityEngine.Color;
            public static op_Division($a: UnityEngine.Color, $b: number):UnityEngine.Color;
            public static op_Equality($lhs: UnityEngine.Color, $rhs: UnityEngine.Color):boolean;
            public static op_Inequality($lhs: UnityEngine.Color, $rhs: UnityEngine.Color):boolean;
            public static Lerp($a: UnityEngine.Color, $b: UnityEngine.Color, $t: number):UnityEngine.Color;
            public static LerpUnclamped($a: UnityEngine.Color, $b: UnityEngine.Color, $t: number):UnityEngine.Color;
            public static op_Implicit($c: UnityEngine.Color):UnityEngine.Vector4;
            public static op_Implicit($v: UnityEngine.Vector4):UnityEngine.Color;
            public get_Item($index: number):number;
            public set_Item($index: number, $value: number):void;
            public static RGBToHSV($rgbColor: UnityEngine.Color, $H: $Ref<number>, $S: $Ref<number>, $V: $Ref<number>):void;
            public static HSVToRGB($H: number, $S: number, $V: number):UnityEngine.Color;
            public static HSVToRGB($H: number, $S: number, $V: number, $hdr: boolean):UnityEngine.Color;
            public constructor($r: number, $g: number, $b: number, $a: number);
            public constructor($r: number, $g: number, $b: number);
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
            public constructor();
        }
        interface Color {
            WithAlpha($alpha: number):UnityEngine.Color;
        }
        export class Object extends System.Object{ 
            public get name(): string;
            public set name(value: string);
            public get hideFlags(): UnityEngine.HideFlags;
            public set hideFlags(value: UnityEngine.HideFlags);
            public GetInstanceID():number;
            public static op_Implicit($exists: UnityEngine.Object):boolean;
            public static Instantiate($original: UnityEngine.Object, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion):UnityEngine.Object;
            public static Instantiate($original: UnityEngine.Object, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $parent: UnityEngine.Transform):UnityEngine.Object;
            public static Instantiate($original: UnityEngine.Object):UnityEngine.Object;
            public static Instantiate($original: UnityEngine.Object, $parent: UnityEngine.Transform):UnityEngine.Object;
            public static Instantiate($original: UnityEngine.Object, $parent: UnityEngine.Transform, $instantiateInWorldSpace: boolean):UnityEngine.Object;
            public static Instantiate($original: UnityEngine.Object):UnityEngine.Object;
            public static Instantiate($original: UnityEngine.Object, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion):UnityEngine.Object;
            public static Instantiate($original: UnityEngine.Object, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $parent: UnityEngine.Transform):UnityEngine.Object;
            public static Instantiate($original: UnityEngine.Object, $parent: UnityEngine.Transform):UnityEngine.Object;
            public static Instantiate($original: UnityEngine.Object, $parent: UnityEngine.Transform, $worldPositionStays: boolean):UnityEngine.Object;
            public static Destroy($obj: UnityEngine.Object, $t: number):void;
            public static Destroy($obj: UnityEngine.Object):void;
            public static DestroyImmediate($obj: UnityEngine.Object, $allowDestroyingAssets: boolean):void;
            public static DestroyImmediate($obj: UnityEngine.Object):void;
            public static FindObjectsOfType($type: System.Type):System.Array$1<UnityEngine.Object>;
            public static FindObjectsOfType($type: System.Type, $includeInactive: boolean):System.Array$1<UnityEngine.Object>;
            public static DontDestroyOnLoad($target: UnityEngine.Object):void;
            public static FindObjectOfType($type: System.Type):UnityEngine.Object;
            public static FindObjectOfType($type: System.Type, $includeInactive: boolean):UnityEngine.Object;
            public static op_Equality($x: UnityEngine.Object, $y: UnityEngine.Object):boolean;
            public static op_Inequality($x: UnityEngine.Object, $y: UnityEngine.Object):boolean;
            public constructor();
        }
        interface Object {
            DestroySelf($delay: number):boolean;
            DestroySelf():void;
            IsNull():boolean;
            RenameObject($newName: string):void;
            GetObjectPath():string;
            dataPathRoot():string;
            ResourcePath():string;
            GetAssetPath():string;
        }
        export enum LogType{ Error = 0, Assert = 1, Warning = 2, Log = 3, Exception = 4 }
        export enum LogOption{ None = 0, NoStacktrace = 1 }
        export class GameObject extends UnityEngine.Object{ 
            public get transform(): UnityEngine.Transform;
            public get layer(): number;
            public set layer(value: number);
            public get activeSelf(): boolean;
            public get activeInHierarchy(): boolean;
            public get isStatic(): boolean;
            public set isStatic(value: boolean);
            public get tag(): string;
            public set tag(value: string);
            public get scene(): UnityEngine.SceneManagement.Scene;
            public get sceneCullingMask(): bigint;
            public get gameObject(): UnityEngine.GameObject;
            public static CreatePrimitive($type: UnityEngine.PrimitiveType):UnityEngine.GameObject;
            public GetComponent($type: System.Type):UnityEngine.Component;
            public GetComponent($type: string):UnityEngine.Component;
            public GetComponentInChildren($type: System.Type, $includeInactive: boolean):UnityEngine.Component;
            public GetComponentInChildren($type: System.Type):UnityEngine.Component;
            public GetComponentInParent($type: System.Type, $includeInactive: boolean):UnityEngine.Component;
            public GetComponentInParent($type: System.Type):UnityEngine.Component;
            public GetComponents($type: System.Type):System.Array$1<UnityEngine.Component>;
            public GetComponents($type: System.Type, $results: System.Collections.Generic.List$1<UnityEngine.Component>):void;
            public GetComponentsInChildren($type: System.Type):System.Array$1<UnityEngine.Component>;
            public GetComponentsInChildren($type: System.Type, $includeInactive: boolean):System.Array$1<UnityEngine.Component>;
            public GetComponentsInParent($type: System.Type):System.Array$1<UnityEngine.Component>;
            public GetComponentsInParent($type: System.Type, $includeInactive: boolean):System.Array$1<UnityEngine.Component>;
            public TryGetComponent($type: System.Type, $component: $Ref<UnityEngine.Component>):boolean;
            public static FindWithTag($tag: string):UnityEngine.GameObject;
            public SendMessageUpwards($methodName: string, $options: UnityEngine.SendMessageOptions):void;
            public SendMessage($methodName: string, $options: UnityEngine.SendMessageOptions):void;
            public BroadcastMessage($methodName: string, $options: UnityEngine.SendMessageOptions):void;
            public AddComponent($componentType: System.Type):UnityEngine.Component;
            public SetActive($value: boolean):void;
            public CompareTag($tag: string):boolean;
            public static FindGameObjectWithTag($tag: string):UnityEngine.GameObject;
            public static FindGameObjectsWithTag($tag: string):System.Array$1<UnityEngine.GameObject>;
            public SendMessageUpwards($methodName: string, $value: any, $options: UnityEngine.SendMessageOptions):void;
            public SendMessageUpwards($methodName: string, $value: any):void;
            public SendMessageUpwards($methodName: string):void;
            public SendMessage($methodName: string, $value: any, $options: UnityEngine.SendMessageOptions):void;
            public SendMessage($methodName: string, $value: any):void;
            public SendMessage($methodName: string):void;
            public BroadcastMessage($methodName: string, $parameter: any, $options: UnityEngine.SendMessageOptions):void;
            public BroadcastMessage($methodName: string, $parameter: any):void;
            public BroadcastMessage($methodName: string):void;
            public static Find($name: string):UnityEngine.GameObject;
            public constructor($name: string);
            public constructor();
            public constructor($name: string, ...components: System.Type[]);
            public DestroySelf($delay: number):null;
            public DestroySelf():null;
        }
        interface GameObject {
            AddComponent($toAdd: UnityEngine.Component):UnityEngine.Component;
            Init($comp: UnityEngine.Component):void;
            RequireComponent($type: System.Type):UnityEngine.MonoBehaviour;
            SetActiveAll($active: boolean, $recursively: boolean, $includeInactive?: boolean):void;
            FindFirstComponentInChild($layerStr: string, $type: System.Type):UnityEngine.Component;
            DestroySelf($delay: number):boolean;
            SetLayer($layer: number, $withChildren: boolean):void;
            ResetTransform():void;
            SetParent($parent: UnityEngine.Transform):void;
            SetParent($parent: UnityEngine.GameObject):void;
            AddComponentOnce($type: System.Type):UnityEngine.MonoBehaviour;
            ToggleShow():boolean;
            LogName():void;
            SyncAssets($path?: string):void;
            _GetPrefabSavePath($getDirName?: boolean):string;
            GameObjectAssetPath():string;
            Show():void;
            Hide():void;
            Toggle():void;
            FindOrCreate($name: string):UnityEngine.GameObject;
            FindOrCreateRoot($name: string):UnityEngine.GameObject;
            ChildGameObjects($expr?: System.Linq.Expressions.Expression$1<System.Func$2<UnityEngine.Transform, boolean>>, $directOnly?: boolean):System.Collections.Generic.List$1<UnityEngine.GameObject>;
            Childs($expr?: System.Linq.Expressions.Expression$1<System.Func$2<UnityEngine.Transform, boolean>>, $directOnly?: boolean):System.Collections.Generic.List$1<UnityEngine.Transform>;
            GetPath():string;
            GetClassPath():string;
            GetMenu():UnityEngine.UI.Extensions.Menu;
            IsInLayerMask($mask: UnityEngine.LayerMask):boolean;
            AddTag(...tags: string[]):void;
            RemoveTag(...tags: string[]):void;
            ChangeTag($old: string, $tag: string):void;
            HasTag($tag: string):boolean;
            AnyTags(...tags: string[]):boolean;
            BothTags(...tags: string[]):boolean;
            GetTags():System.Array$1<string>;
            FindTags($tags: MoreTags.TagNames):System.Array$1<string>;
            GetChildrenList($self?: boolean):System.Collections.Generic.IEnumerable$1<UnityEngine.GameObject>;
        }
        export class Component extends UnityEngine.Object{ 
            public get transform(): UnityEngine.Transform;
            public get gameObject(): UnityEngine.GameObject;
            public get tag(): string;
            public set tag(value: string);
            public GetComponent($type: System.Type):UnityEngine.Component;
            public TryGetComponent($type: System.Type, $component: $Ref<UnityEngine.Component>):boolean;
            public GetComponent($type: string):UnityEngine.Component;
            public GetComponentInChildren($t: System.Type, $includeInactive: boolean):UnityEngine.Component;
            public GetComponentInChildren($t: System.Type):UnityEngine.Component;
            public GetComponentsInChildren($t: System.Type, $includeInactive: boolean):System.Array$1<UnityEngine.Component>;
            public GetComponentsInChildren($t: System.Type):System.Array$1<UnityEngine.Component>;
            public GetComponentInParent($t: System.Type):UnityEngine.Component;
            public GetComponentsInParent($t: System.Type, $includeInactive: boolean):System.Array$1<UnityEngine.Component>;
            public GetComponentsInParent($t: System.Type):System.Array$1<UnityEngine.Component>;
            public GetComponents($type: System.Type):System.Array$1<UnityEngine.Component>;
            public GetComponents($type: System.Type, $results: System.Collections.Generic.List$1<UnityEngine.Component>):void;
            public CompareTag($tag: string):boolean;
            public SendMessageUpwards($methodName: string, $value: any, $options: UnityEngine.SendMessageOptions):void;
            public SendMessageUpwards($methodName: string, $value: any):void;
            public SendMessageUpwards($methodName: string):void;
            public SendMessageUpwards($methodName: string, $options: UnityEngine.SendMessageOptions):void;
            public SendMessage($methodName: string, $value: any):void;
            public SendMessage($methodName: string):void;
            public SendMessage($methodName: string, $value: any, $options: UnityEngine.SendMessageOptions):void;
            public SendMessage($methodName: string, $options: UnityEngine.SendMessageOptions):void;
            public BroadcastMessage($methodName: string, $parameter: any, $options: UnityEngine.SendMessageOptions):void;
            public BroadcastMessage($methodName: string, $parameter: any):void;
            public BroadcastMessage($methodName: string):void;
            public BroadcastMessage($methodName: string, $options: UnityEngine.SendMessageOptions):void;
            public constructor();
        }
        interface Component {
            GetCopyOf($other: UnityEngine.Component):UnityEngine.Component;
            RequireComponent($type: System.Type):UnityEngine.MonoBehaviour;
            AddComponentOnce($type: System.Type):UnityEngine.MonoBehaviour;
            MyPosition($position: UnityEngine.Vector3):UnityEngine.Component;
            MyLocalScale($xyz: number):UnityEngine.Component;
            MyRotation($rotation: UnityEngine.Quaternion):UnityEngine.Component;
            Show():void;
            Hide():void;
            Toggle():void;
            Active($enable?: boolean):void;
            X($withParent?: boolean, $x?: number):number;
            Y($withParent?: boolean, $y?: number):number;
            Z($withParent?: boolean, $z?: number):number;
            IntX($withParent?: boolean, $x?: number):number;
            IntY($withParent?: boolean, $y?: number):number;
            IntZ($withParent?: boolean, $z?: number):number;
            XAdd($x: number):UnityEngine.Vector3;
            YAdd($y: number):UnityEngine.Vector3;
            ZAdd($z: number):UnityEngine.Vector3;
            XY($withParent?: boolean, $x?: number, $y?: number):UnityEngine.Vector2Int;
            XZ($withParent?: boolean, $x?: number, $z?: number):UnityEngine.Vector2Int;
            getvVector3Int($withParent?: boolean, $x?: number, $y?: number, $z?: number):UnityEngine.Vector3Int;
            addVector3($x: number, $y: number, $z: number):UnityEngine.Vector3;
            addVector3($x: number, $y: number, $z: number):UnityEngine.Vector3;
            ChildGameObjects($expr?: System.Linq.Expressions.Expression$1<System.Func$2<UnityEngine.Transform, boolean>>, $directOnly?: boolean):System.Collections.Generic.List$1<UnityEngine.GameObject>;
            Childs($expr?: System.Linq.Expressions.Expression$1<System.Func$2<UnityEngine.Transform, boolean>>, $directOnly?: boolean):System.Collections.Generic.List$1<UnityEngine.Transform>;
            GetPath():string;
            GetClassPath():string;
            TransformToType($type: System.Type):UnityEngine.Component;
        }
        export class Time extends System.Object{ 
            public static get time(): number;
            public static get timeAsDouble(): number;
            public static get timeSinceLevelLoad(): number;
            public static get timeSinceLevelLoadAsDouble(): number;
            public static get deltaTime(): number;
            public static get fixedTime(): number;
            public static get fixedTimeAsDouble(): number;
            public static get unscaledTime(): number;
            public static get unscaledTimeAsDouble(): number;
            public static get fixedUnscaledTime(): number;
            public static get fixedUnscaledTimeAsDouble(): number;
            public static get unscaledDeltaTime(): number;
            public static get fixedUnscaledDeltaTime(): number;
            public static get fixedDeltaTime(): number;
            public static set fixedDeltaTime(value: number);
            public static get maximumDeltaTime(): number;
            public static set maximumDeltaTime(value: number);
            public static get smoothDeltaTime(): number;
            public static get maximumParticleDeltaTime(): number;
            public static set maximumParticleDeltaTime(value: number);
            public static get timeScale(): number;
            public static set timeScale(value: number);
            public static get frameCount(): number;
            public static get renderedFrameCount(): number;
            public static get realtimeSinceStartup(): number;
            public static get realtimeSinceStartupAsDouble(): number;
            public static get captureDeltaTime(): number;
            public static set captureDeltaTime(value: number);
            public static get captureFramerate(): number;
            public static set captureFramerate(value: number);
            public static get inFixedTimeStep(): boolean;
            public constructor();
        }
        export class Transform extends UnityEngine.Component implements System.Collections.IEnumerable{ 
            public get position(): UnityEngine.Vector3;
            public set position(value: UnityEngine.Vector3);
            public get localPosition(): UnityEngine.Vector3;
            public set localPosition(value: UnityEngine.Vector3);
            public get eulerAngles(): UnityEngine.Vector3;
            public set eulerAngles(value: UnityEngine.Vector3);
            public get localEulerAngles(): UnityEngine.Vector3;
            public set localEulerAngles(value: UnityEngine.Vector3);
            public get right(): UnityEngine.Vector3;
            public set right(value: UnityEngine.Vector3);
            public get up(): UnityEngine.Vector3;
            public set up(value: UnityEngine.Vector3);
            public get forward(): UnityEngine.Vector3;
            public set forward(value: UnityEngine.Vector3);
            public get rotation(): UnityEngine.Quaternion;
            public set rotation(value: UnityEngine.Quaternion);
            public get localRotation(): UnityEngine.Quaternion;
            public set localRotation(value: UnityEngine.Quaternion);
            public get localScale(): UnityEngine.Vector3;
            public set localScale(value: UnityEngine.Vector3);
            public get parent(): UnityEngine.Transform;
            public set parent(value: UnityEngine.Transform);
            public get worldToLocalMatrix(): UnityEngine.Matrix4x4;
            public get localToWorldMatrix(): UnityEngine.Matrix4x4;
            public get root(): UnityEngine.Transform;
            public get childCount(): number;
            public get lossyScale(): UnityEngine.Vector3;
            public get hasChanged(): boolean;
            public set hasChanged(value: boolean);
            public get hierarchyCapacity(): number;
            public set hierarchyCapacity(value: number);
            public get hierarchyCount(): number;
            public SetParent($p: UnityEngine.Transform):void;
            public SetParent($parent: UnityEngine.Transform, $worldPositionStays: boolean):void;
            public SetPositionAndRotation($position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion):void;
            public Translate($translation: UnityEngine.Vector3, $relativeTo: UnityEngine.Space):void;
            public Translate($translation: UnityEngine.Vector3):void;
            public Translate($x: number, $y: number, $z: number, $relativeTo: UnityEngine.Space):void;
            public Translate($x: number, $y: number, $z: number):void;
            public Translate($translation: UnityEngine.Vector3, $relativeTo: UnityEngine.Transform):void;
            public Translate($x: number, $y: number, $z: number, $relativeTo: UnityEngine.Transform):void;
            public Rotate($eulers: UnityEngine.Vector3, $relativeTo: UnityEngine.Space):void;
            public Rotate($eulers: UnityEngine.Vector3):void;
            public Rotate($xAngle: number, $yAngle: number, $zAngle: number, $relativeTo: UnityEngine.Space):void;
            public Rotate($xAngle: number, $yAngle: number, $zAngle: number):void;
            public Rotate($axis: UnityEngine.Vector3, $angle: number, $relativeTo: UnityEngine.Space):void;
            public Rotate($axis: UnityEngine.Vector3, $angle: number):void;
            public RotateAround($point: UnityEngine.Vector3, $axis: UnityEngine.Vector3, $angle: number):void;
            public LookAt($target: UnityEngine.Transform, $worldUp: UnityEngine.Vector3):void;
            public LookAt($target: UnityEngine.Transform):void;
            public LookAt($worldPosition: UnityEngine.Vector3, $worldUp: UnityEngine.Vector3):void;
            public LookAt($worldPosition: UnityEngine.Vector3):void;
            public TransformDirection($direction: UnityEngine.Vector3):UnityEngine.Vector3;
            public TransformDirection($x: number, $y: number, $z: number):UnityEngine.Vector3;
            public InverseTransformDirection($direction: UnityEngine.Vector3):UnityEngine.Vector3;
            public InverseTransformDirection($x: number, $y: number, $z: number):UnityEngine.Vector3;
            public TransformVector($vector: UnityEngine.Vector3):UnityEngine.Vector3;
            public TransformVector($x: number, $y: number, $z: number):UnityEngine.Vector3;
            public InverseTransformVector($vector: UnityEngine.Vector3):UnityEngine.Vector3;
            public InverseTransformVector($x: number, $y: number, $z: number):UnityEngine.Vector3;
            public TransformPoint($position: UnityEngine.Vector3):UnityEngine.Vector3;
            public TransformPoint($x: number, $y: number, $z: number):UnityEngine.Vector3;
            public InverseTransformPoint($position: UnityEngine.Vector3):UnityEngine.Vector3;
            public InverseTransformPoint($x: number, $y: number, $z: number):UnityEngine.Vector3;
            public DetachChildren():void;
            public SetAsFirstSibling():void;
            public SetAsLastSibling():void;
            public SetSiblingIndex($index: number):void;
            public GetSiblingIndex():number;
            public Find($n: string):UnityEngine.Transform;
            public IsChildOf($parent: UnityEngine.Transform):boolean;
            public GetEnumerator():System.Collections.IEnumerator;
            public GetChild($index: number):UnityEngine.Transform;
        }
        interface Transform {
            RequireComponent($type: System.Type):UnityEngine.MonoBehaviour;
            FindChildGameObject($layerStr: string):UnityEngine.GameObject;
            FindFirstComponentInChild($layerStr: string, $type: System.Type):UnityEngine.Component;
            DestroySelf($delay: number):boolean;
            ResetTransform():void;
            CopyTempTransform():UnityEngine.Transform;
            ResetParent($parent: UnityEngine.Transform, $resetTransform?: boolean):void;
            LookAt_2D($pos: UnityEngine.Vector3):void;
            LookAtDir($dir: UnityEngine.Vector3):void;
            LookAtDir_2D($dir: UnityEngine.Vector3):void;
            AddComonentOnce($type: System.Type):UnityEngine.MonoBehaviour;
            FindOrCreate($name: string):UnityEngine.Transform;
            AlignTo($dest: UnityEngine.Transform, $moveToLast?: boolean):UnityEngine.Transform;
            AlignTo($dest: UnityEngine.RectTransform, $moveToLast?: boolean):UnityEngine.RectTransform;
            ClearChildTransforms($expr?: System.Linq.Expressions.Expression$1<System.Func$2<UnityEngine.Transform, boolean>>, $directOnly?: boolean):void;
            ChildGameObjects($expr?: System.Linq.Expressions.Expression$1<System.Func$2<UnityEngine.Transform, boolean>>, $directOnly?: boolean):System.Collections.Generic.List$1<UnityEngine.GameObject>;
            Childs($expr?: System.Linq.Expressions.Expression$1<System.Func$2<UnityEngine.Transform, boolean>>, $directOnly?: boolean):System.Collections.Generic.List$1<UnityEngine.Transform>;
        }
        export class Quaternion extends System.ValueType implements System.IEquatable$1<UnityEngine.Quaternion>, System.IFormattable{ 
            public x: number;
            public y: number;
            public z: number;
            public w: number;
            public static kEpsilon: number;
            public static get identity(): UnityEngine.Quaternion;
            public get eulerAngles(): UnityEngine.Vector3;
            public set eulerAngles(value: UnityEngine.Vector3);
            public get normalized(): UnityEngine.Quaternion;
            public static FromToRotation($fromDirection: UnityEngine.Vector3, $toDirection: UnityEngine.Vector3):UnityEngine.Quaternion;
            public static Inverse($rotation: UnityEngine.Quaternion):UnityEngine.Quaternion;
            public static Slerp($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion, $t: number):UnityEngine.Quaternion;
            public static SlerpUnclamped($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion, $t: number):UnityEngine.Quaternion;
            public static Lerp($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion, $t: number):UnityEngine.Quaternion;
            public static LerpUnclamped($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion, $t: number):UnityEngine.Quaternion;
            public static AngleAxis($angle: number, $axis: UnityEngine.Vector3):UnityEngine.Quaternion;
            public static LookRotation($forward: UnityEngine.Vector3, $upwards: UnityEngine.Vector3):UnityEngine.Quaternion;
            public static LookRotation($forward: UnityEngine.Vector3):UnityEngine.Quaternion;
            public get_Item($index: number):number;
            public set_Item($index: number, $value: number):void;
            public Set($newX: number, $newY: number, $newZ: number, $newW: number):void;
            public static op_Multiply($lhs: UnityEngine.Quaternion, $rhs: UnityEngine.Quaternion):UnityEngine.Quaternion;
            public static op_Multiply($rotation: UnityEngine.Quaternion, $point: UnityEngine.Vector3):UnityEngine.Vector3;
            public static op_Equality($lhs: UnityEngine.Quaternion, $rhs: UnityEngine.Quaternion):boolean;
            public static op_Inequality($lhs: UnityEngine.Quaternion, $rhs: UnityEngine.Quaternion):boolean;
            public static Dot($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion):number;
            public SetLookRotation($view: UnityEngine.Vector3):void;
            public SetLookRotation($view: UnityEngine.Vector3, $up: UnityEngine.Vector3):void;
            public static Angle($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion):number;
            public static Euler($x: number, $y: number, $z: number):UnityEngine.Quaternion;
            public static Euler($euler: UnityEngine.Vector3):UnityEngine.Quaternion;
            public ToAngleAxis($angle: $Ref<number>, $axis: $Ref<UnityEngine.Vector3>):void;
            public SetFromToRotation($fromDirection: UnityEngine.Vector3, $toDirection: UnityEngine.Vector3):void;
            public static RotateTowards($from: UnityEngine.Quaternion, $to: UnityEngine.Quaternion, $maxDegreesDelta: number):UnityEngine.Quaternion;
            public static Normalize($q: UnityEngine.Quaternion):UnityEngine.Quaternion;
            public Normalize():void;
            public Equals($other: any):boolean;
            public Equals($other: UnityEngine.Quaternion):boolean;
            public ToString():string;
            public ToString($format: string):string;
            public ToString($format: string, $formatProvider: System.IFormatProvider):string;
            public constructor($x: number, $y: number, $z: number, $w: number);
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
            public constructor();
        }
        export class Matrix4x4 extends System.ValueType implements System.IEquatable$1<UnityEngine.Matrix4x4>, System.IFormattable{ 
            public m00: number;
            public m10: number;
            public m20: number;
            public m30: number;
            public m01: number;
            public m11: number;
            public m21: number;
            public m31: number;
            public m02: number;
            public m12: number;
            public m22: number;
            public m32: number;
            public m03: number;
            public m13: number;
            public m23: number;
            public m33: number;
            public get rotation(): UnityEngine.Quaternion;
            public get lossyScale(): UnityEngine.Vector3;
            public get isIdentity(): boolean;
            public get determinant(): number;
            public get decomposeProjection(): UnityEngine.FrustumPlanes;
            public get inverse(): UnityEngine.Matrix4x4;
            public get transpose(): UnityEngine.Matrix4x4;
            public static get zero(): UnityEngine.Matrix4x4;
            public static get identity(): UnityEngine.Matrix4x4;
            public ValidTRS():boolean;
            public static Determinant($m: UnityEngine.Matrix4x4):number;
            public static TRS($pos: UnityEngine.Vector3, $q: UnityEngine.Quaternion, $s: UnityEngine.Vector3):UnityEngine.Matrix4x4;
            public SetTRS($pos: UnityEngine.Vector3, $q: UnityEngine.Quaternion, $s: UnityEngine.Vector3):void;
            public static Inverse3DAffine($input: UnityEngine.Matrix4x4, $result: $Ref<UnityEngine.Matrix4x4>):boolean;
            public static Inverse($m: UnityEngine.Matrix4x4):UnityEngine.Matrix4x4;
            public static Transpose($m: UnityEngine.Matrix4x4):UnityEngine.Matrix4x4;
            public static Ortho($left: number, $right: number, $bottom: number, $top: number, $zNear: number, $zFar: number):UnityEngine.Matrix4x4;
            public static Perspective($fov: number, $aspect: number, $zNear: number, $zFar: number):UnityEngine.Matrix4x4;
            public static LookAt($from: UnityEngine.Vector3, $to: UnityEngine.Vector3, $up: UnityEngine.Vector3):UnityEngine.Matrix4x4;
            public static Frustum($left: number, $right: number, $bottom: number, $top: number, $zNear: number, $zFar: number):UnityEngine.Matrix4x4;
            public static Frustum($fp: UnityEngine.FrustumPlanes):UnityEngine.Matrix4x4;
            public get_Item($index: number):number;
            public set_Item($index: number, $value: number):void;
            public Equals($other: any):boolean;
            public Equals($other: UnityEngine.Matrix4x4):boolean;
            public static op_Multiply($lhs: UnityEngine.Matrix4x4, $rhs: UnityEngine.Matrix4x4):UnityEngine.Matrix4x4;
            public static op_Multiply($lhs: UnityEngine.Matrix4x4, $vector: UnityEngine.Vector4):UnityEngine.Vector4;
            public static op_Equality($lhs: UnityEngine.Matrix4x4, $rhs: UnityEngine.Matrix4x4):boolean;
            public static op_Inequality($lhs: UnityEngine.Matrix4x4, $rhs: UnityEngine.Matrix4x4):boolean;
            public GetColumn($index: number):UnityEngine.Vector4;
            public GetRow($index: number):UnityEngine.Vector4;
            public SetColumn($index: number, $column: UnityEngine.Vector4):void;
            public SetRow($index: number, $row: UnityEngine.Vector4):void;
            public MultiplyPoint($point: UnityEngine.Vector3):UnityEngine.Vector3;
            public MultiplyPoint3x4($point: UnityEngine.Vector3):UnityEngine.Vector3;
            public MultiplyVector($vector: UnityEngine.Vector3):UnityEngine.Vector3;
            public TransformPlane($plane: UnityEngine.Plane):UnityEngine.Plane;
            public static Scale($vector: UnityEngine.Vector3):UnityEngine.Matrix4x4;
            public static Translate($vector: UnityEngine.Vector3):UnityEngine.Matrix4x4;
            public static Rotate($q: UnityEngine.Quaternion):UnityEngine.Matrix4x4;
            public ToString():string;
            public ToString($format: string):string;
            public ToString($format: string, $formatProvider: System.IFormatProvider):string;
            public constructor($column0: UnityEngine.Vector4, $column1: UnityEngine.Vector4, $column2: UnityEngine.Vector4, $column3: UnityEngine.Vector4);
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
            public constructor();
        }
        export enum Space{ World = 0, Self = 1 }
        export enum SendMessageOptions{ RequireReceiver = 0, DontRequireReceiver = 1 }
        export enum PrimitiveType{ Sphere = 0, Capsule = 1, Cylinder = 2, Cube = 3, Plane = 4, Quad = 5 }
        export enum HideFlags{ None = 0, HideInHierarchy = 1, HideInInspector = 2, DontSaveInEditor = 4, NotEditable = 8, DontSaveInBuild = 16, DontUnloadUnusedAsset = 32, DontSave = 52, HideAndDontSave = 61 }
        export class ParticleSystem extends UnityEngine.Component{ 
            public get isPlaying(): boolean;
            public get isEmitting(): boolean;
            public get isStopped(): boolean;
            public get isPaused(): boolean;
            public get particleCount(): number;
            public get time(): number;
            public set time(value: number);
            public get randomSeed(): number;
            public set randomSeed(value: number);
            public get useAutoRandomSeed(): boolean;
            public set useAutoRandomSeed(value: boolean);
            public get proceduralSimulationSupported(): boolean;
            public get main(): UnityEngine.ParticleSystem.MainModule;
            public get emission(): UnityEngine.ParticleSystem.EmissionModule;
            public get shape(): UnityEngine.ParticleSystem.ShapeModule;
            public get velocityOverLifetime(): UnityEngine.ParticleSystem.VelocityOverLifetimeModule;
            public get limitVelocityOverLifetime(): UnityEngine.ParticleSystem.LimitVelocityOverLifetimeModule;
            public get inheritVelocity(): UnityEngine.ParticleSystem.InheritVelocityModule;
            public get lifetimeByEmitterSpeed(): UnityEngine.ParticleSystem.LifetimeByEmitterSpeedModule;
            public get forceOverLifetime(): UnityEngine.ParticleSystem.ForceOverLifetimeModule;
            public get colorOverLifetime(): UnityEngine.ParticleSystem.ColorOverLifetimeModule;
            public get colorBySpeed(): UnityEngine.ParticleSystem.ColorBySpeedModule;
            public get sizeOverLifetime(): UnityEngine.ParticleSystem.SizeOverLifetimeModule;
            public get sizeBySpeed(): UnityEngine.ParticleSystem.SizeBySpeedModule;
            public get rotationOverLifetime(): UnityEngine.ParticleSystem.RotationOverLifetimeModule;
            public get rotationBySpeed(): UnityEngine.ParticleSystem.RotationBySpeedModule;
            public get externalForces(): UnityEngine.ParticleSystem.ExternalForcesModule;
            public get noise(): UnityEngine.ParticleSystem.NoiseModule;
            public get collision(): UnityEngine.ParticleSystem.CollisionModule;
            public get trigger(): UnityEngine.ParticleSystem.TriggerModule;
            public get subEmitters(): UnityEngine.ParticleSystem.SubEmittersModule;
            public get textureSheetAnimation(): UnityEngine.ParticleSystem.TextureSheetAnimationModule;
            public get lights(): UnityEngine.ParticleSystem.LightsModule;
            public get trails(): UnityEngine.ParticleSystem.TrailModule;
            public get customData(): UnityEngine.ParticleSystem.CustomDataModule;
            public SetParticles($particles: System.Array$1<UnityEngine.ParticleSystem.Particle>, $size: number, $offset: number):void;
            public SetParticles($particles: System.Array$1<UnityEngine.ParticleSystem.Particle>, $size: number):void;
            public SetParticles($particles: System.Array$1<UnityEngine.ParticleSystem.Particle>):void;
            public SetParticles($particles: Unity.Collections.NativeArray$1<UnityEngine.ParticleSystem.Particle>, $size: number, $offset: number):void;
            public SetParticles($particles: Unity.Collections.NativeArray$1<UnityEngine.ParticleSystem.Particle>, $size: number):void;
            public SetParticles($particles: Unity.Collections.NativeArray$1<UnityEngine.ParticleSystem.Particle>):void;
            public GetParticles($particles: System.Array$1<UnityEngine.ParticleSystem.Particle>, $size: number, $offset: number):number;
            public GetParticles($particles: System.Array$1<UnityEngine.ParticleSystem.Particle>, $size: number):number;
            public GetParticles($particles: System.Array$1<UnityEngine.ParticleSystem.Particle>):number;
            public GetParticles($particles: Unity.Collections.NativeArray$1<UnityEngine.ParticleSystem.Particle>, $size: number, $offset: number):number;
            public GetParticles($particles: Unity.Collections.NativeArray$1<UnityEngine.ParticleSystem.Particle>, $size: number):number;
            public GetParticles($particles: Unity.Collections.NativeArray$1<UnityEngine.ParticleSystem.Particle>):number;
            public SetCustomParticleData($customData: System.Collections.Generic.List$1<UnityEngine.Vector4>, $streamIndex: UnityEngine.ParticleSystemCustomData):void;
            public GetCustomParticleData($customData: System.Collections.Generic.List$1<UnityEngine.Vector4>, $streamIndex: UnityEngine.ParticleSystemCustomData):number;
            public GetPlaybackState():UnityEngine.ParticleSystem.PlaybackState;
            public SetPlaybackState($playbackState: UnityEngine.ParticleSystem.PlaybackState):void;
            public GetTrails():UnityEngine.ParticleSystem.Trails;
            public SetTrails($trailData: UnityEngine.ParticleSystem.Trails):void;
            public Simulate($t: number, $withChildren: boolean, $restart: boolean, $fixedTimeStep: boolean):void;
            public Simulate($t: number, $withChildren: boolean, $restart: boolean):void;
            public Simulate($t: number, $withChildren: boolean):void;
            public Simulate($t: number):void;
            public Play($withChildren: boolean):void;
            public Play():void;
            public Pause($withChildren: boolean):void;
            public Pause():void;
            public Stop($withChildren: boolean, $stopBehavior: UnityEngine.ParticleSystemStopBehavior):void;
            public Stop($withChildren: boolean):void;
            public Stop():void;
            public Clear($withChildren: boolean):void;
            public Clear():void;
            public IsAlive($withChildren: boolean):boolean;
            public IsAlive():boolean;
            public Emit($count: number):void;
            public Emit($emitParams: UnityEngine.ParticleSystem.EmitParams, $count: number):void;
            public TriggerSubEmitter($subEmitterIndex: number):void;
            public TriggerSubEmitter($subEmitterIndex: number, $particle: $Ref<UnityEngine.ParticleSystem.Particle>):void;
            public TriggerSubEmitter($subEmitterIndex: number, $particles: System.Collections.Generic.List$1<UnityEngine.ParticleSystem.Particle>):void;
            public static ResetPreMappedBufferMemory():void;
            public static SetMaximumPreMappedBufferCounts($vertexBuffersCount: number, $indexBuffersCount: number):void;
            public AllocateAxisOfRotationAttribute():void;
            public AllocateMeshIndexAttribute():void;
            public AllocateCustomDataAttribute($stream: UnityEngine.ParticleSystemCustomData):void;
            public constructor();
        }
        interface ParticleSystem {
            GetCollisionEvents($go: UnityEngine.GameObject, $collisionEvents: System.Array$1<UnityEngine.ParticleCollisionEvent>):number;
            GetSafeCollisionEventSize():number;
            GetCollisionEvents($go: UnityEngine.GameObject, $collisionEvents: System.Collections.Generic.List$1<UnityEngine.ParticleCollisionEvent>):number;
            GetSafeTriggerParticlesSize($type: UnityEngine.ParticleSystemTriggerEventType):number;
            GetTriggerParticles($type: UnityEngine.ParticleSystemTriggerEventType, $particles: System.Collections.Generic.List$1<UnityEngine.ParticleSystem.Particle>):number;
            GetTriggerParticles($type: UnityEngine.ParticleSystemTriggerEventType, $particles: System.Collections.Generic.List$1<UnityEngine.ParticleSystem.Particle>, $colliderData: $Ref<UnityEngine.ParticleSystem.ColliderData>):number;
            SetTriggerParticles($type: UnityEngine.ParticleSystemTriggerEventType, $particles: System.Collections.Generic.List$1<UnityEngine.ParticleSystem.Particle>, $offset: number, $count: number):void;
            SetTriggerParticles($type: UnityEngine.ParticleSystemTriggerEventType, $particles: System.Collections.Generic.List$1<UnityEngine.ParticleSystem.Particle>):void;
        }
        export class Color32 extends System.ValueType implements System.IFormattable{ 
            public r: number;
            public g: number;
            public b: number;
            public a: number;
            public static op_Implicit($c: UnityEngine.Color):UnityEngine.Color32;
            public static op_Implicit($c: UnityEngine.Color32):UnityEngine.Color;
            public static Lerp($a: UnityEngine.Color32, $b: UnityEngine.Color32, $t: number):UnityEngine.Color32;
            public static LerpUnclamped($a: UnityEngine.Color32, $b: UnityEngine.Color32, $t: number):UnityEngine.Color32;
            public get_Item($index: number):number;
            public set_Item($index: number, $value: number):void;
            public ToString():string;
            public ToString($format: string):string;
            public ToString($format: string, $formatProvider: System.IFormatProvider):string;
            public constructor($r: number, $g: number, $b: number, $a: number);
            public constructor();
        }
        export enum ParticleSystemSimulationSpace{ Local = 0, World = 1, Custom = 2 }
        export enum ParticleSystemScalingMode{ Hierarchy = 0, Local = 1, Shape = 2 }
        export class Vector4 extends System.ValueType implements System.IEquatable$1<UnityEngine.Vector4>, System.IFormattable{ 
            public static kEpsilon: number;
            public x: number;
            public y: number;
            public z: number;
            public w: number;
            public get normalized(): UnityEngine.Vector4;
            public get magnitude(): number;
            public get sqrMagnitude(): number;
            public static get zero(): UnityEngine.Vector4;
            public static get one(): UnityEngine.Vector4;
            public static get positiveInfinity(): UnityEngine.Vector4;
            public static get negativeInfinity(): UnityEngine.Vector4;
            public get_Item($index: number):number;
            public set_Item($index: number, $value: number):void;
            public Set($newX: number, $newY: number, $newZ: number, $newW: number):void;
            public static Lerp($a: UnityEngine.Vector4, $b: UnityEngine.Vector4, $t: number):UnityEngine.Vector4;
            public static LerpUnclamped($a: UnityEngine.Vector4, $b: UnityEngine.Vector4, $t: number):UnityEngine.Vector4;
            public static MoveTowards($current: UnityEngine.Vector4, $target: UnityEngine.Vector4, $maxDistanceDelta: number):UnityEngine.Vector4;
            public static Scale($a: UnityEngine.Vector4, $b: UnityEngine.Vector4):UnityEngine.Vector4;
            public Scale($scale: UnityEngine.Vector4):void;
            public Equals($other: any):boolean;
            public Equals($other: UnityEngine.Vector4):boolean;
            public static Normalize($a: UnityEngine.Vector4):UnityEngine.Vector4;
            public Normalize():void;
            public static Dot($a: UnityEngine.Vector4, $b: UnityEngine.Vector4):number;
            public static Project($a: UnityEngine.Vector4, $b: UnityEngine.Vector4):UnityEngine.Vector4;
            public static Distance($a: UnityEngine.Vector4, $b: UnityEngine.Vector4):number;
            public static Magnitude($a: UnityEngine.Vector4):number;
            public static Min($lhs: UnityEngine.Vector4, $rhs: UnityEngine.Vector4):UnityEngine.Vector4;
            public static Max($lhs: UnityEngine.Vector4, $rhs: UnityEngine.Vector4):UnityEngine.Vector4;
            public static op_Addition($a: UnityEngine.Vector4, $b: UnityEngine.Vector4):UnityEngine.Vector4;
            public static op_Subtraction($a: UnityEngine.Vector4, $b: UnityEngine.Vector4):UnityEngine.Vector4;
            public static op_UnaryNegation($a: UnityEngine.Vector4):UnityEngine.Vector4;
            public static op_Multiply($a: UnityEngine.Vector4, $d: number):UnityEngine.Vector4;
            public static op_Multiply($d: number, $a: UnityEngine.Vector4):UnityEngine.Vector4;
            public static op_Division($a: UnityEngine.Vector4, $d: number):UnityEngine.Vector4;
            public static op_Equality($lhs: UnityEngine.Vector4, $rhs: UnityEngine.Vector4):boolean;
            public static op_Inequality($lhs: UnityEngine.Vector4, $rhs: UnityEngine.Vector4):boolean;
            public static op_Implicit($v: UnityEngine.Vector3):UnityEngine.Vector4;
            public static op_Implicit($v: UnityEngine.Vector4):UnityEngine.Vector3;
            public static op_Implicit($v: UnityEngine.Vector2):UnityEngine.Vector4;
            public static op_Implicit($v: UnityEngine.Vector4):UnityEngine.Vector2;
            public ToString():string;
            public ToString($format: string):string;
            public ToString($format: string, $formatProvider: System.IFormatProvider):string;
            public static SqrMagnitude($a: UnityEngine.Vector4):number;
            public SqrMagnitude():number;
            public constructor($x: number, $y: number, $z: number, $w: number);
            public constructor($x: number, $y: number, $z: number);
            public constructor($x: number, $y: number);
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
            public constructor();
        }
        export enum ParticleSystemCustomData{ Custom1 = 0, Custom2 = 1 }
        export enum ParticleSystemStopBehavior{ StopEmittingAndClear = 0, StopEmitting = 1 }
        export class Canvas extends UnityEngine.Behaviour{ 
            public get renderMode(): UnityEngine.RenderMode;
            public set renderMode(value: UnityEngine.RenderMode);
            public get isRootCanvas(): boolean;
            public get pixelRect(): UnityEngine.Rect;
            public get scaleFactor(): number;
            public set scaleFactor(value: number);
            public get referencePixelsPerUnit(): number;
            public set referencePixelsPerUnit(value: number);
            public get overridePixelPerfect(): boolean;
            public set overridePixelPerfect(value: boolean);
            public get pixelPerfect(): boolean;
            public set pixelPerfect(value: boolean);
            public get planeDistance(): number;
            public set planeDistance(value: number);
            public get renderOrder(): number;
            public get overrideSorting(): boolean;
            public set overrideSorting(value: boolean);
            public get sortingOrder(): number;
            public set sortingOrder(value: number);
            public get targetDisplay(): number;
            public set targetDisplay(value: number);
            public get sortingLayerID(): number;
            public set sortingLayerID(value: number);
            public get cachedSortingLayerValue(): number;
            public get additionalShaderChannels(): UnityEngine.AdditionalCanvasShaderChannels;
            public set additionalShaderChannels(value: UnityEngine.AdditionalCanvasShaderChannels);
            public get sortingLayerName(): string;
            public set sortingLayerName(value: string);
            public get rootCanvas(): UnityEngine.Canvas;
            public get renderingDisplaySize(): UnityEngine.Vector2;
            public get worldCamera(): UnityEngine.Camera;
            public set worldCamera(value: UnityEngine.Camera);
            public get normalizedSortingGridSize(): number;
            public set normalizedSortingGridSize(value: number);
            public static add_preWillRenderCanvases($value: UnityEngine.Canvas.WillRenderCanvases):void;
            public static remove_preWillRenderCanvases($value: UnityEngine.Canvas.WillRenderCanvases):void;
            public static add_willRenderCanvases($value: UnityEngine.Canvas.WillRenderCanvases):void;
            public static remove_willRenderCanvases($value: UnityEngine.Canvas.WillRenderCanvases):void;
            public static GetDefaultCanvasMaterial():UnityEngine.Material;
            public static GetETC1SupportedCanvasMaterial():UnityEngine.Material;
            public static ForceUpdateCanvases():void;
            public constructor();
        }
        interface Canvas {
            GetEventCamera():UnityEngine.Camera;
        }
        export class Behaviour extends UnityEngine.Component{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get isActiveAndEnabled(): boolean;
            public constructor();
        }
        export enum RenderMode{ ScreenSpaceOverlay = 0, ScreenSpaceCamera = 1, WorldSpace = 2 }
        export class Rect extends System.ValueType implements System.IEquatable$1<UnityEngine.Rect>, System.IFormattable{ 
            public static get zero(): UnityEngine.Rect;
            public get x(): number;
            public set x(value: number);
            public get y(): number;
            public set y(value: number);
            public get position(): UnityEngine.Vector2;
            public set position(value: UnityEngine.Vector2);
            public get center(): UnityEngine.Vector2;
            public set center(value: UnityEngine.Vector2);
            public get min(): UnityEngine.Vector2;
            public set min(value: UnityEngine.Vector2);
            public get max(): UnityEngine.Vector2;
            public set max(value: UnityEngine.Vector2);
            public get width(): number;
            public set width(value: number);
            public get height(): number;
            public set height(value: number);
            public get size(): UnityEngine.Vector2;
            public set size(value: UnityEngine.Vector2);
            public get xMin(): number;
            public set xMin(value: number);
            public get yMin(): number;
            public set yMin(value: number);
            public get xMax(): number;
            public set xMax(value: number);
            public get yMax(): number;
            public set yMax(value: number);
            public static MinMaxRect($xmin: number, $ymin: number, $xmax: number, $ymax: number):UnityEngine.Rect;
            public Set($x: number, $y: number, $width: number, $height: number):void;
            public Contains($point: UnityEngine.Vector2):boolean;
            public Contains($point: UnityEngine.Vector3):boolean;
            public Contains($point: UnityEngine.Vector3, $allowInverse: boolean):boolean;
            public Overlaps($other: UnityEngine.Rect):boolean;
            public Overlaps($other: UnityEngine.Rect, $allowInverse: boolean):boolean;
            public static NormalizedToPoint($rectangle: UnityEngine.Rect, $normalizedRectCoordinates: UnityEngine.Vector2):UnityEngine.Vector2;
            public static PointToNormalized($rectangle: UnityEngine.Rect, $point: UnityEngine.Vector2):UnityEngine.Vector2;
            public static op_Inequality($lhs: UnityEngine.Rect, $rhs: UnityEngine.Rect):boolean;
            public static op_Equality($lhs: UnityEngine.Rect, $rhs: UnityEngine.Rect):boolean;
            public Equals($other: any):boolean;
            public Equals($other: UnityEngine.Rect):boolean;
            public ToString():string;
            public ToString($format: string):string;
            public ToString($format: string, $formatProvider: System.IFormatProvider):string;
            public constructor($x: number, $y: number, $width: number, $height: number);
            public constructor($position: UnityEngine.Vector2, $size: UnityEngine.Vector2);
            public constructor($source: UnityEngine.Rect);
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
            public constructor();
        }
        interface Rect {
            Encapsulates($b: UnityEngine.Rect):boolean;
            ExpandBy($margin: number):UnityEngine.Rect;
            ExpandBy($xMargin: number, $yMargin: number):UnityEngine.Rect;
            ExpandBy($left: number, $top: number, $right: number, $bottom: number):UnityEngine.Rect;
            TransformSpace($oldContainer: UnityEngine.Rect, $newContainer: UnityEngine.Rect):UnityEngine.Rect;
        }
        export enum AdditionalCanvasShaderChannels{ None = 0, TexCoord1 = 1, TexCoord2 = 2, TexCoord3 = 4, Normal = 8, Tangent = 16 }
        export class Vector2 extends System.ValueType implements System.IEquatable$1<UnityEngine.Vector2>, System.IFormattable{ 
            public x: number;
            public y: number;
            public static kEpsilon: number;
            public static kEpsilonNormalSqrt: number;
            public get normalized(): UnityEngine.Vector2;
            public get magnitude(): number;
            public get sqrMagnitude(): number;
            public static get zero(): UnityEngine.Vector2;
            public static get one(): UnityEngine.Vector2;
            public static get up(): UnityEngine.Vector2;
            public static get down(): UnityEngine.Vector2;
            public static get left(): UnityEngine.Vector2;
            public static get right(): UnityEngine.Vector2;
            public static get positiveInfinity(): UnityEngine.Vector2;
            public static get negativeInfinity(): UnityEngine.Vector2;
            public get_Item($index: number):number;
            public set_Item($index: number, $value: number):void;
            public Set($newX: number, $newY: number):void;
            public static Lerp($a: UnityEngine.Vector2, $b: UnityEngine.Vector2, $t: number):UnityEngine.Vector2;
            public static LerpUnclamped($a: UnityEngine.Vector2, $b: UnityEngine.Vector2, $t: number):UnityEngine.Vector2;
            public static MoveTowards($current: UnityEngine.Vector2, $target: UnityEngine.Vector2, $maxDistanceDelta: number):UnityEngine.Vector2;
            public static Scale($a: UnityEngine.Vector2, $b: UnityEngine.Vector2):UnityEngine.Vector2;
            public Scale($scale: UnityEngine.Vector2):void;
            public Normalize():void;
            public ToString():string;
            public ToString($format: string):string;
            public ToString($format: string, $formatProvider: System.IFormatProvider):string;
            public Equals($other: any):boolean;
            public Equals($other: UnityEngine.Vector2):boolean;
            public static Reflect($inDirection: UnityEngine.Vector2, $inNormal: UnityEngine.Vector2):UnityEngine.Vector2;
            public static Perpendicular($inDirection: UnityEngine.Vector2):UnityEngine.Vector2;
            public static Dot($lhs: UnityEngine.Vector2, $rhs: UnityEngine.Vector2):number;
            public static Angle($from: UnityEngine.Vector2, $to: UnityEngine.Vector2):number;
            public static SignedAngle($from: UnityEngine.Vector2, $to: UnityEngine.Vector2):number;
            public static Distance($a: UnityEngine.Vector2, $b: UnityEngine.Vector2):number;
            public static ClampMagnitude($vector: UnityEngine.Vector2, $maxLength: number):UnityEngine.Vector2;
            public static SqrMagnitude($a: UnityEngine.Vector2):number;
            public SqrMagnitude():number;
            public static Min($lhs: UnityEngine.Vector2, $rhs: UnityEngine.Vector2):UnityEngine.Vector2;
            public static Max($lhs: UnityEngine.Vector2, $rhs: UnityEngine.Vector2):UnityEngine.Vector2;
            public static SmoothDamp($current: UnityEngine.Vector2, $target: UnityEngine.Vector2, $currentVelocity: $Ref<UnityEngine.Vector2>, $smoothTime: number, $maxSpeed: number):UnityEngine.Vector2;
            public static SmoothDamp($current: UnityEngine.Vector2, $target: UnityEngine.Vector2, $currentVelocity: $Ref<UnityEngine.Vector2>, $smoothTime: number):UnityEngine.Vector2;
            public static SmoothDamp($current: UnityEngine.Vector2, $target: UnityEngine.Vector2, $currentVelocity: $Ref<UnityEngine.Vector2>, $smoothTime: number, $maxSpeed: number, $deltaTime: number):UnityEngine.Vector2;
            public static op_Addition($a: UnityEngine.Vector2, $b: UnityEngine.Vector2):UnityEngine.Vector2;
            public static op_Subtraction($a: UnityEngine.Vector2, $b: UnityEngine.Vector2):UnityEngine.Vector2;
            public static op_Multiply($a: UnityEngine.Vector2, $b: UnityEngine.Vector2):UnityEngine.Vector2;
            public static op_Division($a: UnityEngine.Vector2, $b: UnityEngine.Vector2):UnityEngine.Vector2;
            public static op_UnaryNegation($a: UnityEngine.Vector2):UnityEngine.Vector2;
            public static op_Multiply($a: UnityEngine.Vector2, $d: number):UnityEngine.Vector2;
            public static op_Multiply($d: number, $a: UnityEngine.Vector2):UnityEngine.Vector2;
            public static op_Division($a: UnityEngine.Vector2, $d: number):UnityEngine.Vector2;
            public static op_Equality($lhs: UnityEngine.Vector2, $rhs: UnityEngine.Vector2):boolean;
            public static op_Inequality($lhs: UnityEngine.Vector2, $rhs: UnityEngine.Vector2):boolean;
            public static op_Implicit($v: UnityEngine.Vector3):UnityEngine.Vector2;
            public static op_Implicit($v: UnityEngine.Vector2):UnityEngine.Vector3;
            public constructor($x: number, $y: number);
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
            public constructor();
        }
        interface Vector2 {
            TransformInputBasedOnCanvasType($canvas: UnityEngine.Canvas):UnityEngine.Vector2;
            TransformInputBasedOnCanvasType($rt: UnityEngine.RectTransform):UnityEngine.Vector3;
            TransformSpace($oldContainer: UnityEngine.Rect, $newContainer: UnityEngine.Rect):UnityEngine.Vector2;
        }
        export class Camera extends UnityEngine.Behaviour{ 
            public static onPreCull: UnityEngine.Camera.CameraCallback;
            public static onPreRender: UnityEngine.Camera.CameraCallback;
            public static onPostRender: UnityEngine.Camera.CameraCallback;
            public get nearClipPlane(): number;
            public set nearClipPlane(value: number);
            public get farClipPlane(): number;
            public set farClipPlane(value: number);
            public get fieldOfView(): number;
            public set fieldOfView(value: number);
            public get renderingPath(): UnityEngine.RenderingPath;
            public set renderingPath(value: UnityEngine.RenderingPath);
            public get actualRenderingPath(): UnityEngine.RenderingPath;
            public get allowHDR(): boolean;
            public set allowHDR(value: boolean);
            public get allowMSAA(): boolean;
            public set allowMSAA(value: boolean);
            public get allowDynamicResolution(): boolean;
            public set allowDynamicResolution(value: boolean);
            public get forceIntoRenderTexture(): boolean;
            public set forceIntoRenderTexture(value: boolean);
            public get orthographicSize(): number;
            public set orthographicSize(value: number);
            public get orthographic(): boolean;
            public set orthographic(value: boolean);
            public get opaqueSortMode(): UnityEngine.Rendering.OpaqueSortMode;
            public set opaqueSortMode(value: UnityEngine.Rendering.OpaqueSortMode);
            public get transparencySortMode(): UnityEngine.TransparencySortMode;
            public set transparencySortMode(value: UnityEngine.TransparencySortMode);
            public get transparencySortAxis(): UnityEngine.Vector3;
            public set transparencySortAxis(value: UnityEngine.Vector3);
            public get depth(): number;
            public set depth(value: number);
            public get aspect(): number;
            public set aspect(value: number);
            public get velocity(): UnityEngine.Vector3;
            public get cullingMask(): number;
            public set cullingMask(value: number);
            public get eventMask(): number;
            public set eventMask(value: number);
            public get layerCullSpherical(): boolean;
            public set layerCullSpherical(value: boolean);
            public get cameraType(): UnityEngine.CameraType;
            public set cameraType(value: UnityEngine.CameraType);
            public get overrideSceneCullingMask(): bigint;
            public set overrideSceneCullingMask(value: bigint);
            public get layerCullDistances(): System.Array$1<number>;
            public set layerCullDistances(value: System.Array$1<number>);
            public get useOcclusionCulling(): boolean;
            public set useOcclusionCulling(value: boolean);
            public get cullingMatrix(): UnityEngine.Matrix4x4;
            public set cullingMatrix(value: UnityEngine.Matrix4x4);
            public get backgroundColor(): UnityEngine.Color;
            public set backgroundColor(value: UnityEngine.Color);
            public get clearFlags(): UnityEngine.CameraClearFlags;
            public set clearFlags(value: UnityEngine.CameraClearFlags);
            public get depthTextureMode(): UnityEngine.DepthTextureMode;
            public set depthTextureMode(value: UnityEngine.DepthTextureMode);
            public get clearStencilAfterLightingPass(): boolean;
            public set clearStencilAfterLightingPass(value: boolean);
            public get usePhysicalProperties(): boolean;
            public set usePhysicalProperties(value: boolean);
            public get sensorSize(): UnityEngine.Vector2;
            public set sensorSize(value: UnityEngine.Vector2);
            public get lensShift(): UnityEngine.Vector2;
            public set lensShift(value: UnityEngine.Vector2);
            public get focalLength(): number;
            public set focalLength(value: number);
            public get gateFit(): UnityEngine.Camera.GateFitMode;
            public set gateFit(value: UnityEngine.Camera.GateFitMode);
            public get rect(): UnityEngine.Rect;
            public set rect(value: UnityEngine.Rect);
            public get pixelRect(): UnityEngine.Rect;
            public set pixelRect(value: UnityEngine.Rect);
            public get pixelWidth(): number;
            public get pixelHeight(): number;
            public get scaledPixelWidth(): number;
            public get scaledPixelHeight(): number;
            public get targetTexture(): UnityEngine.RenderTexture;
            public set targetTexture(value: UnityEngine.RenderTexture);
            public get activeTexture(): UnityEngine.RenderTexture;
            public get targetDisplay(): number;
            public set targetDisplay(value: number);
            public get cameraToWorldMatrix(): UnityEngine.Matrix4x4;
            public get worldToCameraMatrix(): UnityEngine.Matrix4x4;
            public set worldToCameraMatrix(value: UnityEngine.Matrix4x4);
            public get projectionMatrix(): UnityEngine.Matrix4x4;
            public set projectionMatrix(value: UnityEngine.Matrix4x4);
            public get nonJitteredProjectionMatrix(): UnityEngine.Matrix4x4;
            public set nonJitteredProjectionMatrix(value: UnityEngine.Matrix4x4);
            public get useJitteredProjectionMatrixForTransparentRendering(): boolean;
            public set useJitteredProjectionMatrixForTransparentRendering(value: boolean);
            public get previousViewProjectionMatrix(): UnityEngine.Matrix4x4;
            public static get main(): UnityEngine.Camera;
            public static get current(): UnityEngine.Camera;
            public get scene(): UnityEngine.SceneManagement.Scene;
            public set scene(value: UnityEngine.SceneManagement.Scene);
            public get stereoEnabled(): boolean;
            public get stereoSeparation(): number;
            public set stereoSeparation(value: number);
            public get stereoConvergence(): number;
            public set stereoConvergence(value: number);
            public get areVRStereoViewMatricesWithinSingleCullTolerance(): boolean;
            public get stereoTargetEye(): UnityEngine.StereoTargetEyeMask;
            public set stereoTargetEye(value: UnityEngine.StereoTargetEyeMask);
            public get stereoActiveEye(): UnityEngine.Camera.MonoOrStereoscopicEye;
            public static get allCamerasCount(): number;
            public static get allCameras(): System.Array$1<UnityEngine.Camera>;
            public get commandBufferCount(): number;
            public Reset():void;
            public ResetTransparencySortSettings():void;
            public ResetAspect():void;
            public ResetCullingMatrix():void;
            public SetReplacementShader($shader: UnityEngine.Shader, $replacementTag: string):void;
            public ResetReplacementShader():void;
            public GetGateFittedFieldOfView():number;
            public GetGateFittedLensShift():UnityEngine.Vector2;
            public SetTargetBuffers($colorBuffer: UnityEngine.RenderBuffer, $depthBuffer: UnityEngine.RenderBuffer):void;
            public SetTargetBuffers($colorBuffer: System.Array$1<UnityEngine.RenderBuffer>, $depthBuffer: UnityEngine.RenderBuffer):void;
            public ResetWorldToCameraMatrix():void;
            public ResetProjectionMatrix():void;
            public CalculateObliqueMatrix($clipPlane: UnityEngine.Vector4):UnityEngine.Matrix4x4;
            public WorldToScreenPoint($position: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye):UnityEngine.Vector3;
            public WorldToViewportPoint($position: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye):UnityEngine.Vector3;
            public ViewportToWorldPoint($position: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye):UnityEngine.Vector3;
            public ScreenToWorldPoint($position: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye):UnityEngine.Vector3;
            public WorldToScreenPoint($position: UnityEngine.Vector3):UnityEngine.Vector3;
            public WorldToViewportPoint($position: UnityEngine.Vector3):UnityEngine.Vector3;
            public ViewportToWorldPoint($position: UnityEngine.Vector3):UnityEngine.Vector3;
            public ScreenToWorldPoint($position: UnityEngine.Vector3):UnityEngine.Vector3;
            public ScreenToViewportPoint($position: UnityEngine.Vector3):UnityEngine.Vector3;
            public ViewportToScreenPoint($position: UnityEngine.Vector3):UnityEngine.Vector3;
            public ViewportPointToRay($pos: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye):UnityEngine.Ray;
            public ViewportPointToRay($pos: UnityEngine.Vector3):UnityEngine.Ray;
            public ScreenPointToRay($pos: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye):UnityEngine.Ray;
            public ScreenPointToRay($pos: UnityEngine.Vector3):UnityEngine.Ray;
            public CalculateFrustumCorners($viewport: UnityEngine.Rect, $z: number, $eye: UnityEngine.Camera.MonoOrStereoscopicEye, $outCorners: System.Array$1<UnityEngine.Vector3>):void;
            public static CalculateProjectionMatrixFromPhysicalProperties($output: $Ref<UnityEngine.Matrix4x4>, $focalLength: number, $sensorSize: UnityEngine.Vector2, $lensShift: UnityEngine.Vector2, $nearClip: number, $farClip: number, $gateFitParameters?: UnityEngine.Camera.GateFitParameters):void;
            public static FocalLengthToFieldOfView($focalLength: number, $sensorSize: number):number;
            public static FieldOfViewToFocalLength($fieldOfView: number, $sensorSize: number):number;
            public static HorizontalToVerticalFieldOfView($horizontalFieldOfView: number, $aspectRatio: number):number;
            public static VerticalToHorizontalFieldOfView($verticalFieldOfView: number, $aspectRatio: number):number;
            public GetStereoNonJitteredProjectionMatrix($eye: UnityEngine.Camera.StereoscopicEye):UnityEngine.Matrix4x4;
            public GetStereoViewMatrix($eye: UnityEngine.Camera.StereoscopicEye):UnityEngine.Matrix4x4;
            public CopyStereoDeviceProjectionMatrixToNonJittered($eye: UnityEngine.Camera.StereoscopicEye):void;
            public GetStereoProjectionMatrix($eye: UnityEngine.Camera.StereoscopicEye):UnityEngine.Matrix4x4;
            public SetStereoProjectionMatrix($eye: UnityEngine.Camera.StereoscopicEye, $matrix: UnityEngine.Matrix4x4):void;
            public ResetStereoProjectionMatrices():void;
            public SetStereoViewMatrix($eye: UnityEngine.Camera.StereoscopicEye, $matrix: UnityEngine.Matrix4x4):void;
            public ResetStereoViewMatrices():void;
            public static GetAllCameras($cameras: System.Array$1<UnityEngine.Camera>):number;
            public RenderToCubemap($cubemap: UnityEngine.Cubemap, $faceMask: number):boolean;
            public RenderToCubemap($cubemap: UnityEngine.Cubemap):boolean;
            public RenderToCubemap($cubemap: UnityEngine.RenderTexture, $faceMask: number):boolean;
            public RenderToCubemap($cubemap: UnityEngine.RenderTexture):boolean;
            public RenderToCubemap($cubemap: UnityEngine.RenderTexture, $faceMask: number, $stereoEye: UnityEngine.Camera.MonoOrStereoscopicEye):boolean;
            public Render():void;
            public RenderWithShader($shader: UnityEngine.Shader, $replacementTag: string):void;
            public RenderDontRestore():void;
            public SubmitRenderRequests($renderRequests: System.Collections.Generic.List$1<UnityEngine.Camera.RenderRequest>):void;
            public static SetupCurrent($cur: UnityEngine.Camera):void;
            public CopyFrom($other: UnityEngine.Camera):void;
            public RemoveCommandBuffers($evt: UnityEngine.Rendering.CameraEvent):void;
            public RemoveAllCommandBuffers():void;
            public AddCommandBuffer($evt: UnityEngine.Rendering.CameraEvent, $buffer: UnityEngine.Rendering.CommandBuffer):void;
            public AddCommandBufferAsync($evt: UnityEngine.Rendering.CameraEvent, $buffer: UnityEngine.Rendering.CommandBuffer, $queueType: UnityEngine.Rendering.ComputeQueueType):void;
            public RemoveCommandBuffer($evt: UnityEngine.Rendering.CameraEvent, $buffer: UnityEngine.Rendering.CommandBuffer):void;
            public GetCommandBuffers($evt: UnityEngine.Rendering.CameraEvent):System.Array$1<UnityEngine.Rendering.CommandBuffer>;
            public TryGetCullingParameters($cullingParameters: $Ref<UnityEngine.Rendering.ScriptableCullingParameters>):boolean;
            public TryGetCullingParameters($stereoAware: boolean, $cullingParameters: $Ref<UnityEngine.Rendering.ScriptableCullingParameters>):boolean;
            public constructor();
        }
        export class Material extends UnityEngine.Object{ 
            public get shader(): UnityEngine.Shader;
            public set shader(value: UnityEngine.Shader);
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public get mainTexture(): UnityEngine.Texture;
            public set mainTexture(value: UnityEngine.Texture);
            public get mainTextureOffset(): UnityEngine.Vector2;
            public set mainTextureOffset(value: UnityEngine.Vector2);
            public get mainTextureScale(): UnityEngine.Vector2;
            public set mainTextureScale(value: UnityEngine.Vector2);
            public get renderQueue(): number;
            public set renderQueue(value: number);
            public get globalIlluminationFlags(): UnityEngine.MaterialGlobalIlluminationFlags;
            public set globalIlluminationFlags(value: UnityEngine.MaterialGlobalIlluminationFlags);
            public get doubleSidedGI(): boolean;
            public set doubleSidedGI(value: boolean);
            public get enableInstancing(): boolean;
            public set enableInstancing(value: boolean);
            public get passCount(): number;
            public get shaderKeywords(): System.Array$1<string>;
            public set shaderKeywords(value: System.Array$1<string>);
            public HasProperty($nameID: number):boolean;
            public HasProperty($name: string):boolean;
            public HasFloat($name: string):boolean;
            public HasFloat($nameID: number):boolean;
            public HasInt($name: string):boolean;
            public HasInt($nameID: number):boolean;
            public HasInteger($name: string):boolean;
            public HasInteger($nameID: number):boolean;
            public HasTexture($name: string):boolean;
            public HasTexture($nameID: number):boolean;
            public HasMatrix($name: string):boolean;
            public HasMatrix($nameID: number):boolean;
            public HasVector($name: string):boolean;
            public HasVector($nameID: number):boolean;
            public HasColor($name: string):boolean;
            public HasColor($nameID: number):boolean;
            public HasBuffer($name: string):boolean;
            public HasBuffer($nameID: number):boolean;
            public HasConstantBuffer($name: string):boolean;
            public HasConstantBuffer($nameID: number):boolean;
            public EnableKeyword($keyword: string):void;
            public DisableKeyword($keyword: string):void;
            public IsKeywordEnabled($keyword: string):boolean;
            public SetShaderPassEnabled($passName: string, $enabled: boolean):void;
            public GetShaderPassEnabled($passName: string):boolean;
            public GetPassName($pass: number):string;
            public FindPass($passName: string):number;
            public SetOverrideTag($tag: string, $val: string):void;
            public GetTag($tag: string, $searchFallbacks: boolean, $defaultValue: string):string;
            public GetTag($tag: string, $searchFallbacks: boolean):string;
            public Lerp($start: UnityEngine.Material, $end: UnityEngine.Material, $t: number):void;
            public SetPass($pass: number):boolean;
            public CopyPropertiesFromMaterial($mat: UnityEngine.Material):void;
            public ComputeCRC():number;
            public GetTexturePropertyNames():System.Array$1<string>;
            public GetTexturePropertyNameIDs():System.Array$1<number>;
            public GetTexturePropertyNames($outNames: System.Collections.Generic.List$1<string>):void;
            public GetTexturePropertyNameIDs($outNames: System.Collections.Generic.List$1<number>):void;
            public SetInt($name: string, $value: number):void;
            public SetInt($nameID: number, $value: number):void;
            public SetFloat($name: string, $value: number):void;
            public SetFloat($nameID: number, $value: number):void;
            public SetInteger($name: string, $value: number):void;
            public SetInteger($nameID: number, $value: number):void;
            public SetColor($name: string, $value: UnityEngine.Color):void;
            public SetColor($nameID: number, $value: UnityEngine.Color):void;
            public SetVector($name: string, $value: UnityEngine.Vector4):void;
            public SetVector($nameID: number, $value: UnityEngine.Vector4):void;
            public SetMatrix($name: string, $value: UnityEngine.Matrix4x4):void;
            public SetMatrix($nameID: number, $value: UnityEngine.Matrix4x4):void;
            public SetTexture($name: string, $value: UnityEngine.Texture):void;
            public SetTexture($nameID: number, $value: UnityEngine.Texture):void;
            public SetTexture($name: string, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement):void;
            public SetTexture($nameID: number, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement):void;
            public SetBuffer($name: string, $value: UnityEngine.ComputeBuffer):void;
            public SetBuffer($nameID: number, $value: UnityEngine.ComputeBuffer):void;
            public SetBuffer($name: string, $value: UnityEngine.GraphicsBuffer):void;
            public SetBuffer($nameID: number, $value: UnityEngine.GraphicsBuffer):void;
            public SetConstantBuffer($name: string, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number):void;
            public SetConstantBuffer($nameID: number, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number):void;
            public SetConstantBuffer($name: string, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number):void;
            public SetConstantBuffer($nameID: number, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number):void;
            public SetFloatArray($name: string, $values: System.Collections.Generic.List$1<number>):void;
            public SetFloatArray($nameID: number, $values: System.Collections.Generic.List$1<number>):void;
            public SetFloatArray($name: string, $values: System.Array$1<number>):void;
            public SetFloatArray($nameID: number, $values: System.Array$1<number>):void;
            public SetColorArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Color>):void;
            public SetColorArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Color>):void;
            public SetColorArray($name: string, $values: System.Array$1<UnityEngine.Color>):void;
            public SetColorArray($nameID: number, $values: System.Array$1<UnityEngine.Color>):void;
            public SetVectorArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
            public SetVectorArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
            public SetVectorArray($name: string, $values: System.Array$1<UnityEngine.Vector4>):void;
            public SetVectorArray($nameID: number, $values: System.Array$1<UnityEngine.Vector4>):void;
            public SetMatrixArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>):void;
            public SetMatrixArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>):void;
            public SetMatrixArray($name: string, $values: System.Array$1<UnityEngine.Matrix4x4>):void;
            public SetMatrixArray($nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>):void;
            public GetInt($name: string):number;
            public GetInt($nameID: number):number;
            public GetFloat($name: string):number;
            public GetFloat($nameID: number):number;
            public GetInteger($name: string):number;
            public GetInteger($nameID: number):number;
            public GetColor($name: string):UnityEngine.Color;
            public GetColor($nameID: number):UnityEngine.Color;
            public GetVector($name: string):UnityEngine.Vector4;
            public GetVector($nameID: number):UnityEngine.Vector4;
            public GetMatrix($name: string):UnityEngine.Matrix4x4;
            public GetMatrix($nameID: number):UnityEngine.Matrix4x4;
            public GetTexture($name: string):UnityEngine.Texture;
            public GetTexture($nameID: number):UnityEngine.Texture;
            public GetFloatArray($name: string):System.Array$1<number>;
            public GetFloatArray($nameID: number):System.Array$1<number>;
            public GetColorArray($name: string):System.Array$1<UnityEngine.Color>;
            public GetColorArray($nameID: number):System.Array$1<UnityEngine.Color>;
            public GetVectorArray($name: string):System.Array$1<UnityEngine.Vector4>;
            public GetVectorArray($nameID: number):System.Array$1<UnityEngine.Vector4>;
            public GetMatrixArray($name: string):System.Array$1<UnityEngine.Matrix4x4>;
            public GetMatrixArray($nameID: number):System.Array$1<UnityEngine.Matrix4x4>;
            public GetFloatArray($name: string, $values: System.Collections.Generic.List$1<number>):void;
            public GetFloatArray($nameID: number, $values: System.Collections.Generic.List$1<number>):void;
            public GetColorArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Color>):void;
            public GetColorArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Color>):void;
            public GetVectorArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
            public GetVectorArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
            public GetMatrixArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>):void;
            public GetMatrixArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>):void;
            public SetTextureOffset($name: string, $value: UnityEngine.Vector2):void;
            public SetTextureOffset($nameID: number, $value: UnityEngine.Vector2):void;
            public SetTextureScale($name: string, $value: UnityEngine.Vector2):void;
            public SetTextureScale($nameID: number, $value: UnityEngine.Vector2):void;
            public GetTextureOffset($name: string):UnityEngine.Vector2;
            public GetTextureOffset($nameID: number):UnityEngine.Vector2;
            public GetTextureScale($name: string):UnityEngine.Vector2;
            public GetTextureScale($nameID: number):UnityEngine.Vector2;
            public constructor($shader: UnityEngine.Shader);
            public constructor($source: UnityEngine.Material);
            public constructor();
        }
        interface Material {
            DOGradientColor($gradient: UnityEngine.Gradient, $duration: number):DG.Tweening.Sequence;
            DOGradientColor($gradient: UnityEngine.Gradient, $property: string, $duration: number):DG.Tweening.Sequence;
            DOOffset($endValue: UnityEngine.Vector2, $propertyID: number, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            DOTiling($endValue: UnityEngine.Vector2, $propertyID: number, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
        }
        export class MonoBehaviour extends UnityEngine.Behaviour{ 
            public get useGUILayout(): boolean;
            public set useGUILayout(value: boolean);
            public IsInvoking():boolean;
            public CancelInvoke():void;
            public Invoke($methodName: string, $time: number):void;
            public InvokeRepeating($methodName: string, $time: number, $repeatRate: number):void;
            public CancelInvoke($methodName: string):void;
            public IsInvoking($methodName: string):boolean;
            public StartCoroutine($methodName: string):UnityEngine.Coroutine;
            public StartCoroutine($methodName: string, $value: any):UnityEngine.Coroutine;
            public StartCoroutine($routine: System.Collections.IEnumerator):UnityEngine.Coroutine;
            public StopCoroutine($routine: System.Collections.IEnumerator):void;
            public StopCoroutine($routine: UnityEngine.Coroutine):void;
            public StopCoroutine($methodName: string):void;
            public StopAllCoroutines():void;
            public static print($message: any):void;
            public constructor();
        }
        interface MonoBehaviour {
            AddComonentOnce($type: System.Type):UnityEngine.MonoBehaviour;
            StartCoroutine($funcs: System.Action):void;
            StartCoroutine(...funcs: System.Action[]):void;
            StartCoroutine($funcs: System.Action, $time?: number):void;
            StartCoroutine($time: number, ...funcs: System.Action[]):void;
            Register($duration: number, $onComplete: System.Action, $onUpdate?: System.Action, $isLooped?: boolean, $useRealTime?: boolean):Tetris.Tools.Timer;
        }
        export class Coroutine extends UnityEngine.YieldInstruction{ 
        }
        export class YieldInstruction extends System.Object{ 
            public constructor();
        }
        export interface ICanvasRaycastFilter{ 
            IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
        }
        export interface ISerializationCallbackReceiver{ 
            OnBeforeSerialize():void;
            OnAfterDeserialize():void;
        }
        export class Animator extends UnityEngine.Behaviour{ 
            public get isOptimizable(): boolean;
            public get isHuman(): boolean;
            public get hasRootMotion(): boolean;
            public get humanScale(): number;
            public get isInitialized(): boolean;
            public get deltaPosition(): UnityEngine.Vector3;
            public get deltaRotation(): UnityEngine.Quaternion;
            public get velocity(): UnityEngine.Vector3;
            public get angularVelocity(): UnityEngine.Vector3;
            public get rootPosition(): UnityEngine.Vector3;
            public set rootPosition(value: UnityEngine.Vector3);
            public get rootRotation(): UnityEngine.Quaternion;
            public set rootRotation(value: UnityEngine.Quaternion);
            public get applyRootMotion(): boolean;
            public set applyRootMotion(value: boolean);
            public get updateMode(): UnityEngine.AnimatorUpdateMode;
            public set updateMode(value: UnityEngine.AnimatorUpdateMode);
            public get hasTransformHierarchy(): boolean;
            public get gravityWeight(): number;
            public get bodyPosition(): UnityEngine.Vector3;
            public set bodyPosition(value: UnityEngine.Vector3);
            public get bodyRotation(): UnityEngine.Quaternion;
            public set bodyRotation(value: UnityEngine.Quaternion);
            public get stabilizeFeet(): boolean;
            public set stabilizeFeet(value: boolean);
            public get layerCount(): number;
            public get parameters(): System.Array$1<UnityEngine.AnimatorControllerParameter>;
            public get parameterCount(): number;
            public get feetPivotActive(): number;
            public set feetPivotActive(value: number);
            public get pivotWeight(): number;
            public get pivotPosition(): UnityEngine.Vector3;
            public get isMatchingTarget(): boolean;
            public get speed(): number;
            public set speed(value: number);
            public get targetPosition(): UnityEngine.Vector3;
            public get targetRotation(): UnityEngine.Quaternion;
            public get cullingMode(): UnityEngine.AnimatorCullingMode;
            public set cullingMode(value: UnityEngine.AnimatorCullingMode);
            public get playbackTime(): number;
            public set playbackTime(value: number);
            public get recorderStartTime(): number;
            public set recorderStartTime(value: number);
            public get recorderStopTime(): number;
            public set recorderStopTime(value: number);
            public get recorderMode(): UnityEngine.AnimatorRecorderMode;
            public get runtimeAnimatorController(): UnityEngine.RuntimeAnimatorController;
            public set runtimeAnimatorController(value: UnityEngine.RuntimeAnimatorController);
            public get hasBoundPlayables(): boolean;
            public get avatar(): UnityEngine.Avatar;
            public set avatar(value: UnityEngine.Avatar);
            public get playableGraph(): UnityEngine.Playables.PlayableGraph;
            public get layersAffectMassCenter(): boolean;
            public set layersAffectMassCenter(value: boolean);
            public get leftFeetBottomHeight(): number;
            public get rightFeetBottomHeight(): number;
            public get logWarnings(): boolean;
            public set logWarnings(value: boolean);
            public get fireEvents(): boolean;
            public set fireEvents(value: boolean);
            public get keepAnimatorControllerStateOnDisable(): boolean;
            public set keepAnimatorControllerStateOnDisable(value: boolean);
            public GetFloat($name: string):number;
            public GetFloat($id: number):number;
            public SetFloat($name: string, $value: number):void;
            public SetFloat($name: string, $value: number, $dampTime: number, $deltaTime: number):void;
            public SetFloat($id: number, $value: number):void;
            public SetFloat($id: number, $value: number, $dampTime: number, $deltaTime: number):void;
            public GetBool($name: string):boolean;
            public GetBool($id: number):boolean;
            public SetBool($name: string, $value: boolean):void;
            public SetBool($id: number, $value: boolean):void;
            public GetInteger($name: string):number;
            public GetInteger($id: number):number;
            public SetInteger($name: string, $value: number):void;
            public SetInteger($id: number, $value: number):void;
            public SetTrigger($name: string):void;
            public SetTrigger($id: number):void;
            public ResetTrigger($name: string):void;
            public ResetTrigger($id: number):void;
            public IsParameterControlledByCurve($name: string):boolean;
            public IsParameterControlledByCurve($id: number):boolean;
            public GetIKPosition($goal: UnityEngine.AvatarIKGoal):UnityEngine.Vector3;
            public SetIKPosition($goal: UnityEngine.AvatarIKGoal, $goalPosition: UnityEngine.Vector3):void;
            public GetIKRotation($goal: UnityEngine.AvatarIKGoal):UnityEngine.Quaternion;
            public SetIKRotation($goal: UnityEngine.AvatarIKGoal, $goalRotation: UnityEngine.Quaternion):void;
            public GetIKPositionWeight($goal: UnityEngine.AvatarIKGoal):number;
            public SetIKPositionWeight($goal: UnityEngine.AvatarIKGoal, $value: number):void;
            public GetIKRotationWeight($goal: UnityEngine.AvatarIKGoal):number;
            public SetIKRotationWeight($goal: UnityEngine.AvatarIKGoal, $value: number):void;
            public GetIKHintPosition($hint: UnityEngine.AvatarIKHint):UnityEngine.Vector3;
            public SetIKHintPosition($hint: UnityEngine.AvatarIKHint, $hintPosition: UnityEngine.Vector3):void;
            public GetIKHintPositionWeight($hint: UnityEngine.AvatarIKHint):number;
            public SetIKHintPositionWeight($hint: UnityEngine.AvatarIKHint, $value: number):void;
            public SetLookAtPosition($lookAtPosition: UnityEngine.Vector3):void;
            public SetLookAtWeight($weight: number):void;
            public SetLookAtWeight($weight: number, $bodyWeight: number):void;
            public SetLookAtWeight($weight: number, $bodyWeight: number, $headWeight: number):void;
            public SetLookAtWeight($weight: number, $bodyWeight: number, $headWeight: number, $eyesWeight: number):void;
            public SetLookAtWeight($weight: number, $bodyWeight: number, $headWeight: number, $eyesWeight: number, $clampWeight: number):void;
            public SetBoneLocalRotation($humanBoneId: UnityEngine.HumanBodyBones, $rotation: UnityEngine.Quaternion):void;
            public GetBehaviours($fullPathHash: number, $layerIndex: number):System.Array$1<UnityEngine.StateMachineBehaviour>;
            public GetLayerName($layerIndex: number):string;
            public GetLayerIndex($layerName: string):number;
            public GetLayerWeight($layerIndex: number):number;
            public SetLayerWeight($layerIndex: number, $weight: number):void;
            public GetCurrentAnimatorStateInfo($layerIndex: number):UnityEngine.AnimatorStateInfo;
            public GetNextAnimatorStateInfo($layerIndex: number):UnityEngine.AnimatorStateInfo;
            public GetAnimatorTransitionInfo($layerIndex: number):UnityEngine.AnimatorTransitionInfo;
            public GetCurrentAnimatorClipInfoCount($layerIndex: number):number;
            public GetNextAnimatorClipInfoCount($layerIndex: number):number;
            public GetCurrentAnimatorClipInfo($layerIndex: number):System.Array$1<UnityEngine.AnimatorClipInfo>;
            public GetNextAnimatorClipInfo($layerIndex: number):System.Array$1<UnityEngine.AnimatorClipInfo>;
            public GetCurrentAnimatorClipInfo($layerIndex: number, $clips: System.Collections.Generic.List$1<UnityEngine.AnimatorClipInfo>):void;
            public GetNextAnimatorClipInfo($layerIndex: number, $clips: System.Collections.Generic.List$1<UnityEngine.AnimatorClipInfo>):void;
            public IsInTransition($layerIndex: number):boolean;
            public GetParameter($index: number):UnityEngine.AnimatorControllerParameter;
            public MatchTarget($matchPosition: UnityEngine.Vector3, $matchRotation: UnityEngine.Quaternion, $targetBodyPart: UnityEngine.AvatarTarget, $weightMask: UnityEngine.MatchTargetWeightMask, $startNormalizedTime: number):void;
            public MatchTarget($matchPosition: UnityEngine.Vector3, $matchRotation: UnityEngine.Quaternion, $targetBodyPart: UnityEngine.AvatarTarget, $weightMask: UnityEngine.MatchTargetWeightMask, $startNormalizedTime: number, $targetNormalizedTime: number):void;
            public MatchTarget($matchPosition: UnityEngine.Vector3, $matchRotation: UnityEngine.Quaternion, $targetBodyPart: UnityEngine.AvatarTarget, $weightMask: UnityEngine.MatchTargetWeightMask, $startNormalizedTime: number, $targetNormalizedTime: number, $completeMatch: boolean):void;
            public InterruptMatchTarget():void;
            public InterruptMatchTarget($completeMatch: boolean):void;
            public CrossFadeInFixedTime($stateName: string, $fixedTransitionDuration: number):void;
            public CrossFadeInFixedTime($stateName: string, $fixedTransitionDuration: number, $layer: number):void;
            public CrossFadeInFixedTime($stateName: string, $fixedTransitionDuration: number, $layer: number, $fixedTimeOffset: number):void;
            public CrossFadeInFixedTime($stateName: string, $fixedTransitionDuration: number, $layer: number, $fixedTimeOffset: number, $normalizedTransitionTime: number):void;
            public CrossFadeInFixedTime($stateHashName: number, $fixedTransitionDuration: number, $layer: number, $fixedTimeOffset: number):void;
            public CrossFadeInFixedTime($stateHashName: number, $fixedTransitionDuration: number, $layer: number):void;
            public CrossFadeInFixedTime($stateHashName: number, $fixedTransitionDuration: number):void;
            public CrossFadeInFixedTime($stateHashName: number, $fixedTransitionDuration: number, $layer: number, $fixedTimeOffset: number, $normalizedTransitionTime: number):void;
            public WriteDefaultValues():void;
            public CrossFade($stateName: string, $normalizedTransitionDuration: number, $layer: number, $normalizedTimeOffset: number):void;
            public CrossFade($stateName: string, $normalizedTransitionDuration: number, $layer: number):void;
            public CrossFade($stateName: string, $normalizedTransitionDuration: number):void;
            public CrossFade($stateName: string, $normalizedTransitionDuration: number, $layer: number, $normalizedTimeOffset: number, $normalizedTransitionTime: number):void;
            public CrossFade($stateHashName: number, $normalizedTransitionDuration: number, $layer: number, $normalizedTimeOffset: number, $normalizedTransitionTime: number):void;
            public CrossFade($stateHashName: number, $normalizedTransitionDuration: number, $layer: number, $normalizedTimeOffset: number):void;
            public CrossFade($stateHashName: number, $normalizedTransitionDuration: number, $layer: number):void;
            public CrossFade($stateHashName: number, $normalizedTransitionDuration: number):void;
            public PlayInFixedTime($stateName: string, $layer: number):void;
            public PlayInFixedTime($stateName: string):void;
            public PlayInFixedTime($stateName: string, $layer: number, $fixedTime: number):void;
            public PlayInFixedTime($stateNameHash: number, $layer: number, $fixedTime: number):void;
            public PlayInFixedTime($stateNameHash: number, $layer: number):void;
            public PlayInFixedTime($stateNameHash: number):void;
            public Play($stateName: string, $layer: number):void;
            public Play($stateName: string):void;
            public Play($stateName: string, $layer: number, $normalizedTime: number):void;
            public Play($stateNameHash: number, $layer: number, $normalizedTime: number):void;
            public Play($stateNameHash: number, $layer: number):void;
            public Play($stateNameHash: number):void;
            public SetTarget($targetIndex: UnityEngine.AvatarTarget, $targetNormalizedTime: number):void;
            public GetBoneTransform($humanBoneId: UnityEngine.HumanBodyBones):UnityEngine.Transform;
            public StartPlayback():void;
            public StopPlayback():void;
            public StartRecording($frameCount: number):void;
            public StopRecording():void;
            public HasState($layerIndex: number, $stateID: number):boolean;
            public static StringToHash($name: string):number;
            public Update($deltaTime: number):void;
            public Rebind():void;
            public ApplyBuiltinRootMotion():void;
            public constructor();
        }
        interface Animator {
            GetCurrentClipLength($defaultVal?: number):number;
            GetNextClipLength($defaultVal?: number):number;
        }
        export class TouchScreenKeyboard extends System.Object{ 
            public static get isSupported(): boolean;
            public static get isInPlaceEditingAllowed(): boolean;
            public get text(): string;
            public set text(value: string);
            public static get hideInput(): boolean;
            public static set hideInput(value: boolean);
            public get active(): boolean;
            public set active(value: boolean);
            public get status(): UnityEngine.TouchScreenKeyboard.Status;
            public get characterLimit(): number;
            public set characterLimit(value: number);
            public get canGetSelection(): boolean;
            public get canSetSelection(): boolean;
            public get selection(): UnityEngine.RangeInt;
            public set selection(value: UnityEngine.RangeInt);
            public get type(): UnityEngine.TouchScreenKeyboardType;
            public get targetDisplay(): number;
            public set targetDisplay(value: number);
            public static get area(): UnityEngine.Rect;
            public static get visible(): boolean;
            public static Open($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean, $textPlaceholder: string, $characterLimit: number):UnityEngine.TouchScreenKeyboard;
            public static Open($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean, $textPlaceholder: string):UnityEngine.TouchScreenKeyboard;
            public static Open($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean):UnityEngine.TouchScreenKeyboard;
            public static Open($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean):UnityEngine.TouchScreenKeyboard;
            public static Open($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean):UnityEngine.TouchScreenKeyboard;
            public static Open($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean):UnityEngine.TouchScreenKeyboard;
            public static Open($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType):UnityEngine.TouchScreenKeyboard;
            public static Open($text: string):UnityEngine.TouchScreenKeyboard;
            public constructor($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean, $textPlaceholder: string, $characterLimit: number);
            public constructor();
        }
        export enum TouchScreenKeyboardType{ Default = 0, ASCIICapable = 1, NumbersAndPunctuation = 2, URL = 3, NumberPad = 4, PhonePad = 5, NamePhonePad = 6, EmailAddress = 7, NintendoNetworkAccount = 8, Social = 9, Search = 10, DecimalPad = 11, OneTimeCode = 12 }
        export class Event extends System.Object{ 
            public get rawType(): UnityEngine.EventType;
            public get mousePosition(): UnityEngine.Vector2;
            public set mousePosition(value: UnityEngine.Vector2);
            public get delta(): UnityEngine.Vector2;
            public set delta(value: UnityEngine.Vector2);
            public get pointerType(): UnityEngine.PointerType;
            public set pointerType(value: UnityEngine.PointerType);
            public get button(): number;
            public set button(value: number);
            public get modifiers(): UnityEngine.EventModifiers;
            public set modifiers(value: UnityEngine.EventModifiers);
            public get pressure(): number;
            public set pressure(value: number);
            public get clickCount(): number;
            public set clickCount(value: number);
            public get character(): number;
            public set character(value: number);
            public get keyCode(): UnityEngine.KeyCode;
            public set keyCode(value: UnityEngine.KeyCode);
            public get displayIndex(): number;
            public set displayIndex(value: number);
            public get type(): UnityEngine.EventType;
            public set type(value: UnityEngine.EventType);
            public get commandName(): string;
            public set commandName(value: string);
            public get shift(): boolean;
            public set shift(value: boolean);
            public get control(): boolean;
            public set control(value: boolean);
            public get alt(): boolean;
            public set alt(value: boolean);
            public get command(): boolean;
            public set command(value: boolean);
            public get capsLock(): boolean;
            public set capsLock(value: boolean);
            public get numeric(): boolean;
            public set numeric(value: boolean);
            public get functionKey(): boolean;
            public static get current(): UnityEngine.Event;
            public static set current(value: UnityEngine.Event);
            public get isKey(): boolean;
            public get isMouse(): boolean;
            public get isScrollWheel(): boolean;
            public GetTypeForControl($controlID: number):UnityEngine.EventType;
            public static PopEvent($outEvent: UnityEngine.Event):boolean;
            public static GetEventCount():number;
            public static KeyboardEvent($key: string):UnityEngine.Event;
            public Use():void;
            public constructor();
            public constructor($displayIndex: number);
            public constructor($other: UnityEngine.Event);
        }
        export type AndroidJavaRunnable = () => void;
        var AndroidJavaRunnable: {new (func: () => void): AndroidJavaRunnable;}
        export class AndroidJavaException extends System.Exception implements System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable{ 
            public get StackTrace(): string;
        }
        export class AndroidJavaObject extends System.Object implements System.IDisposable{ 
            public Dispose():void;
            public Call($methodName: string, ...args: any[]):void;
            public CallStatic($methodName: string, ...args: any[]):void;
            public GetRawObject():System.IntPtr;
            public GetRawClass():System.IntPtr;
            public constructor($className: string, $args: System.Array$1<string>);
            public constructor($className: string, $args: System.Array$1<UnityEngine.AndroidJavaObject>);
            public constructor($className: string, $args: System.Array$1<UnityEngine.AndroidJavaClass>);
            public constructor($className: string, $args: System.Array$1<UnityEngine.AndroidJavaProxy>);
            public constructor($className: string, $args: System.Array$1<UnityEngine.AndroidJavaRunnable>);
            public constructor($className: string, ...args: any[]);
            public constructor();
        }
        export class AndroidJavaClass extends UnityEngine.AndroidJavaObject implements System.IDisposable{ 
            public constructor($className: string);
            public constructor($className: string, $args: System.Array$1<string>);
            public constructor($className: string, $args: System.Array$1<UnityEngine.AndroidJavaObject>);
            public constructor($className: string, $args: System.Array$1<UnityEngine.AndroidJavaClass>);
            public constructor($className: string, $args: System.Array$1<UnityEngine.AndroidJavaProxy>);
            public constructor($className: string, $args: System.Array$1<UnityEngine.AndroidJavaRunnable>);
            public constructor($className: string, ...args: any[]);
            public constructor();
        }
        export class AndroidJavaProxy extends System.Object{ 
        }
        export class jvalue extends System.ValueType{ 
            public z: boolean;
            public b: number;
            public c: number;
            public s: number;
            public i: number;
            public j: bigint;
            public f: number;
            public d: number;
            public l: System.IntPtr;
        }
        export class AndroidJNIHelper extends System.Object{ 
            public static get debug(): boolean;
            public static set debug(value: boolean);
            public static GetConstructorID($javaClass: System.IntPtr):System.IntPtr;
            public static GetConstructorID($javaClass: System.IntPtr, $signature: string):System.IntPtr;
            public static GetMethodID($javaClass: System.IntPtr, $methodName: string):System.IntPtr;
            public static GetMethodID($javaClass: System.IntPtr, $methodName: string, $signature: string):System.IntPtr;
            public static GetMethodID($javaClass: System.IntPtr, $methodName: string, $signature: string, $isStatic: boolean):System.IntPtr;
            public static GetFieldID($javaClass: System.IntPtr, $fieldName: string):System.IntPtr;
            public static GetFieldID($javaClass: System.IntPtr, $fieldName: string, $signature: string):System.IntPtr;
            public static GetFieldID($javaClass: System.IntPtr, $fieldName: string, $signature: string, $isStatic: boolean):System.IntPtr;
            public static CreateJavaRunnable($jrunnable: UnityEngine.AndroidJavaRunnable):System.IntPtr;
            public static CreateJavaProxy($proxy: UnityEngine.AndroidJavaProxy):System.IntPtr;
            public static ConvertToJNIArray($array: System.Array):System.IntPtr;
            public static CreateJNIArgArray($args: System.Array$1<any>):System.Array$1<UnityEngine.jvalue>;
            public static DeleteJNIArgArray($args: System.Array$1<any>, $jniArgs: System.Array$1<UnityEngine.jvalue>):void;
            public static GetConstructorID($jclass: System.IntPtr, $args: System.Array$1<any>):System.IntPtr;
            public static GetMethodID($jclass: System.IntPtr, $methodName: string, $args: System.Array$1<any>, $isStatic: boolean):System.IntPtr;
            public static GetSignature($obj: any):string;
            public static GetSignature($args: System.Array$1<any>):string;
        }
        export class AndroidJNI extends System.Object{ 
            public static AttachCurrentThread():number;
            public static DetachCurrentThread():number;
            public static GetVersion():number;
            public static FindClass($name: string):System.IntPtr;
            public static FromReflectedMethod($refMethod: System.IntPtr):System.IntPtr;
            public static FromReflectedField($refField: System.IntPtr):System.IntPtr;
            public static ToReflectedMethod($clazz: System.IntPtr, $methodID: System.IntPtr, $isStatic: boolean):System.IntPtr;
            public static ToReflectedField($clazz: System.IntPtr, $fieldID: System.IntPtr, $isStatic: boolean):System.IntPtr;
            public static GetSuperclass($clazz: System.IntPtr):System.IntPtr;
            public static IsAssignableFrom($clazz1: System.IntPtr, $clazz2: System.IntPtr):boolean;
            public static Throw($obj: System.IntPtr):number;
            public static ThrowNew($clazz: System.IntPtr, $message: string):number;
            public static ExceptionOccurred():System.IntPtr;
            public static ExceptionDescribe():void;
            public static ExceptionClear():void;
            public static FatalError($message: string):void;
            public static PushLocalFrame($capacity: number):number;
            public static PopLocalFrame($ptr: System.IntPtr):System.IntPtr;
            public static NewGlobalRef($obj: System.IntPtr):System.IntPtr;
            public static DeleteGlobalRef($obj: System.IntPtr):void;
            public static NewWeakGlobalRef($obj: System.IntPtr):System.IntPtr;
            public static DeleteWeakGlobalRef($obj: System.IntPtr):void;
            public static NewLocalRef($obj: System.IntPtr):System.IntPtr;
            public static DeleteLocalRef($obj: System.IntPtr):void;
            public static IsSameObject($obj1: System.IntPtr, $obj2: System.IntPtr):boolean;
            public static EnsureLocalCapacity($capacity: number):number;
            public static AllocObject($clazz: System.IntPtr):System.IntPtr;
            public static NewObject($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):System.IntPtr;
            public static GetObjectClass($obj: System.IntPtr):System.IntPtr;
            public static IsInstanceOf($obj: System.IntPtr, $clazz: System.IntPtr):boolean;
            public static GetMethodID($clazz: System.IntPtr, $name: string, $sig: string):System.IntPtr;
            public static GetFieldID($clazz: System.IntPtr, $name: string, $sig: string):System.IntPtr;
            public static GetStaticMethodID($clazz: System.IntPtr, $name: string, $sig: string):System.IntPtr;
            public static GetStaticFieldID($clazz: System.IntPtr, $name: string, $sig: string):System.IntPtr;
            public static NewString($chars: string):System.IntPtr;
            public static NewString($chars: System.Array$1<number>):System.IntPtr;
            public static NewStringUTF($bytes: string):System.IntPtr;
            public static GetStringChars($str: System.IntPtr):string;
            public static GetStringLength($str: System.IntPtr):number;
            public static GetStringUTFLength($str: System.IntPtr):number;
            public static GetStringUTFChars($str: System.IntPtr):string;
            public static CallStringMethod($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):string;
            public static CallObjectMethod($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):System.IntPtr;
            public static CallIntMethod($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):number;
            public static CallBooleanMethod($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):boolean;
            public static CallShortMethod($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):number;
            public static CallSByteMethod($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):number;
            public static CallCharMethod($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):number;
            public static CallFloatMethod($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):number;
            public static CallDoubleMethod($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):number;
            public static CallLongMethod($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):bigint;
            public static CallVoidMethod($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):void;
            public static GetStringField($obj: System.IntPtr, $fieldID: System.IntPtr):string;
            public static GetObjectField($obj: System.IntPtr, $fieldID: System.IntPtr):System.IntPtr;
            public static GetBooleanField($obj: System.IntPtr, $fieldID: System.IntPtr):boolean;
            public static GetSByteField($obj: System.IntPtr, $fieldID: System.IntPtr):number;
            public static GetCharField($obj: System.IntPtr, $fieldID: System.IntPtr):number;
            public static GetShortField($obj: System.IntPtr, $fieldID: System.IntPtr):number;
            public static GetIntField($obj: System.IntPtr, $fieldID: System.IntPtr):number;
            public static GetLongField($obj: System.IntPtr, $fieldID: System.IntPtr):bigint;
            public static GetFloatField($obj: System.IntPtr, $fieldID: System.IntPtr):number;
            public static GetDoubleField($obj: System.IntPtr, $fieldID: System.IntPtr):number;
            public static SetStringField($obj: System.IntPtr, $fieldID: System.IntPtr, $val: string):void;
            public static SetObjectField($obj: System.IntPtr, $fieldID: System.IntPtr, $val: System.IntPtr):void;
            public static SetBooleanField($obj: System.IntPtr, $fieldID: System.IntPtr, $val: boolean):void;
            public static SetSByteField($obj: System.IntPtr, $fieldID: System.IntPtr, $val: number):void;
            public static SetCharField($obj: System.IntPtr, $fieldID: System.IntPtr, $val: number):void;
            public static SetShortField($obj: System.IntPtr, $fieldID: System.IntPtr, $val: number):void;
            public static SetIntField($obj: System.IntPtr, $fieldID: System.IntPtr, $val: number):void;
            public static SetLongField($obj: System.IntPtr, $fieldID: System.IntPtr, $val: bigint):void;
            public static SetFloatField($obj: System.IntPtr, $fieldID: System.IntPtr, $val: number):void;
            public static SetDoubleField($obj: System.IntPtr, $fieldID: System.IntPtr, $val: number):void;
            public static CallStaticStringMethod($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):string;
            public static CallStaticObjectMethod($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):System.IntPtr;
            public static CallStaticIntMethod($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):number;
            public static CallStaticBooleanMethod($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):boolean;
            public static CallStaticShortMethod($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):number;
            public static CallStaticSByteMethod($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):number;
            public static CallStaticCharMethod($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):number;
            public static CallStaticFloatMethod($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):number;
            public static CallStaticDoubleMethod($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):number;
            public static CallStaticLongMethod($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):bigint;
            public static CallStaticVoidMethod($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>):void;
            public static GetStaticStringField($clazz: System.IntPtr, $fieldID: System.IntPtr):string;
            public static GetStaticObjectField($clazz: System.IntPtr, $fieldID: System.IntPtr):System.IntPtr;
            public static GetStaticBooleanField($clazz: System.IntPtr, $fieldID: System.IntPtr):boolean;
            public static GetStaticSByteField($clazz: System.IntPtr, $fieldID: System.IntPtr):number;
            public static GetStaticCharField($clazz: System.IntPtr, $fieldID: System.IntPtr):number;
            public static GetStaticShortField($clazz: System.IntPtr, $fieldID: System.IntPtr):number;
            public static GetStaticIntField($clazz: System.IntPtr, $fieldID: System.IntPtr):number;
            public static GetStaticLongField($clazz: System.IntPtr, $fieldID: System.IntPtr):bigint;
            public static GetStaticFloatField($clazz: System.IntPtr, $fieldID: System.IntPtr):number;
            public static GetStaticDoubleField($clazz: System.IntPtr, $fieldID: System.IntPtr):number;
            public static SetStaticStringField($clazz: System.IntPtr, $fieldID: System.IntPtr, $val: string):void;
            public static SetStaticObjectField($clazz: System.IntPtr, $fieldID: System.IntPtr, $val: System.IntPtr):void;
            public static SetStaticBooleanField($clazz: System.IntPtr, $fieldID: System.IntPtr, $val: boolean):void;
            public static SetStaticSByteField($clazz: System.IntPtr, $fieldID: System.IntPtr, $val: number):void;
            public static SetStaticCharField($clazz: System.IntPtr, $fieldID: System.IntPtr, $val: number):void;
            public static SetStaticShortField($clazz: System.IntPtr, $fieldID: System.IntPtr, $val: number):void;
            public static SetStaticIntField($clazz: System.IntPtr, $fieldID: System.IntPtr, $val: number):void;
            public static SetStaticLongField($clazz: System.IntPtr, $fieldID: System.IntPtr, $val: bigint):void;
            public static SetStaticFloatField($clazz: System.IntPtr, $fieldID: System.IntPtr, $val: number):void;
            public static SetStaticDoubleField($clazz: System.IntPtr, $fieldID: System.IntPtr, $val: number):void;
            public static ToBooleanArray($array: System.Array$1<boolean>):System.IntPtr;
            public static ToSByteArray($array: System.Array$1<number>):System.IntPtr;
            public static ToCharArray($array: System.Array$1<number>):System.IntPtr;
            public static ToShortArray($array: System.Array$1<number>):System.IntPtr;
            public static ToIntArray($array: System.Array$1<number>):System.IntPtr;
            public static ToLongArray($array: System.Array$1<bigint>):System.IntPtr;
            public static ToFloatArray($array: System.Array$1<number>):System.IntPtr;
            public static ToDoubleArray($array: System.Array$1<number>):System.IntPtr;
            public static ToObjectArray($array: System.Array$1<System.IntPtr>, $arrayClass: System.IntPtr):System.IntPtr;
            public static ToObjectArray($array: System.Array$1<System.IntPtr>):System.IntPtr;
            public static FromBooleanArray($array: System.IntPtr):System.Array$1<boolean>;
            public static FromSByteArray($array: System.IntPtr):System.Array$1<number>;
            public static FromCharArray($array: System.IntPtr):System.Array$1<number>;
            public static FromShortArray($array: System.IntPtr):System.Array$1<number>;
            public static FromIntArray($array: System.IntPtr):System.Array$1<number>;
            public static FromLongArray($array: System.IntPtr):System.Array$1<bigint>;
            public static FromFloatArray($array: System.IntPtr):System.Array$1<number>;
            public static FromDoubleArray($array: System.IntPtr):System.Array$1<number>;
            public static FromObjectArray($array: System.IntPtr):System.Array$1<System.IntPtr>;
            public static GetArrayLength($array: System.IntPtr):number;
            public static NewBooleanArray($size: number):System.IntPtr;
            public static NewSByteArray($size: number):System.IntPtr;
            public static NewCharArray($size: number):System.IntPtr;
            public static NewShortArray($size: number):System.IntPtr;
            public static NewIntArray($size: number):System.IntPtr;
            public static NewLongArray($size: number):System.IntPtr;
            public static NewFloatArray($size: number):System.IntPtr;
            public static NewDoubleArray($size: number):System.IntPtr;
            public static NewObjectArray($size: number, $clazz: System.IntPtr, $obj: System.IntPtr):System.IntPtr;
            public static GetBooleanArrayElement($array: System.IntPtr, $index: number):boolean;
            public static GetSByteArrayElement($array: System.IntPtr, $index: number):number;
            public static GetCharArrayElement($array: System.IntPtr, $index: number):number;
            public static GetShortArrayElement($array: System.IntPtr, $index: number):number;
            public static GetIntArrayElement($array: System.IntPtr, $index: number):number;
            public static GetLongArrayElement($array: System.IntPtr, $index: number):bigint;
            public static GetFloatArrayElement($array: System.IntPtr, $index: number):number;
            public static GetDoubleArrayElement($array: System.IntPtr, $index: number):number;
            public static GetObjectArrayElement($array: System.IntPtr, $index: number):System.IntPtr;
            public static SetBooleanArrayElement($array: System.IntPtr, $index: number, $val: boolean):void;
            public static SetSByteArrayElement($array: System.IntPtr, $index: number, $val: number):void;
            public static SetCharArrayElement($array: System.IntPtr, $index: number, $val: number):void;
            public static SetShortArrayElement($array: System.IntPtr, $index: number, $val: number):void;
            public static SetIntArrayElement($array: System.IntPtr, $index: number, $val: number):void;
            public static SetLongArrayElement($array: System.IntPtr, $index: number, $val: bigint):void;
            public static SetFloatArrayElement($array: System.IntPtr, $index: number, $val: number):void;
            public static SetDoubleArrayElement($array: System.IntPtr, $index: number, $val: number):void;
            public static SetObjectArrayElement($array: System.IntPtr, $index: number, $obj: System.IntPtr):void;
        }
        export class AnimationInfo extends System.ValueType{ 
        }
        export enum AnimatorUpdateMode{ Normal = 0, AnimatePhysics = 1, UnscaledTime = 2 }
        export enum AvatarIKGoal{ LeftFoot = 0, RightFoot = 1, LeftHand = 2, RightHand = 3 }
        export enum AvatarIKHint{ LeftKnee = 0, RightKnee = 1, LeftElbow = 2, RightElbow = 3 }
        export enum HumanBodyBones{ Hips = 0, LeftUpperLeg = 1, RightUpperLeg = 2, LeftLowerLeg = 3, RightLowerLeg = 4, LeftFoot = 5, RightFoot = 6, Spine = 7, Chest = 8, UpperChest = 54, Neck = 9, Head = 10, LeftShoulder = 11, RightShoulder = 12, LeftUpperArm = 13, RightUpperArm = 14, LeftLowerArm = 15, RightLowerArm = 16, LeftHand = 17, RightHand = 18, LeftToes = 19, RightToes = 20, LeftEye = 21, RightEye = 22, Jaw = 23, LeftThumbProximal = 24, LeftThumbIntermediate = 25, LeftThumbDistal = 26, LeftIndexProximal = 27, LeftIndexIntermediate = 28, LeftIndexDistal = 29, LeftMiddleProximal = 30, LeftMiddleIntermediate = 31, LeftMiddleDistal = 32, LeftRingProximal = 33, LeftRingIntermediate = 34, LeftRingDistal = 35, LeftLittleProximal = 36, LeftLittleIntermediate = 37, LeftLittleDistal = 38, RightThumbProximal = 39, RightThumbIntermediate = 40, RightThumbDistal = 41, RightIndexProximal = 42, RightIndexIntermediate = 43, RightIndexDistal = 44, RightMiddleProximal = 45, RightMiddleIntermediate = 46, RightMiddleDistal = 47, RightRingProximal = 48, RightRingIntermediate = 49, RightRingDistal = 50, RightLittleProximal = 51, RightLittleIntermediate = 52, RightLittleDistal = 53, LastBone = 55 }
        export class StateMachineBehaviour extends UnityEngine.ScriptableObject{ 
            public OnStateEnter($animator: UnityEngine.Animator, $stateInfo: UnityEngine.AnimatorStateInfo, $layerIndex: number):void;
            public OnStateUpdate($animator: UnityEngine.Animator, $stateInfo: UnityEngine.AnimatorStateInfo, $layerIndex: number):void;
            public OnStateExit($animator: UnityEngine.Animator, $stateInfo: UnityEngine.AnimatorStateInfo, $layerIndex: number):void;
            public OnStateMove($animator: UnityEngine.Animator, $stateInfo: UnityEngine.AnimatorStateInfo, $layerIndex: number):void;
            public OnStateIK($animator: UnityEngine.Animator, $stateInfo: UnityEngine.AnimatorStateInfo, $layerIndex: number):void;
            public OnStateMachineEnter($animator: UnityEngine.Animator, $stateMachinePathHash: number):void;
            public OnStateMachineExit($animator: UnityEngine.Animator, $stateMachinePathHash: number):void;
            public OnStateEnter($animator: UnityEngine.Animator, $stateInfo: UnityEngine.AnimatorStateInfo, $layerIndex: number, $controller: UnityEngine.Animations.AnimatorControllerPlayable):void;
            public OnStateUpdate($animator: UnityEngine.Animator, $stateInfo: UnityEngine.AnimatorStateInfo, $layerIndex: number, $controller: UnityEngine.Animations.AnimatorControllerPlayable):void;
            public OnStateExit($animator: UnityEngine.Animator, $stateInfo: UnityEngine.AnimatorStateInfo, $layerIndex: number, $controller: UnityEngine.Animations.AnimatorControllerPlayable):void;
            public OnStateMove($animator: UnityEngine.Animator, $stateInfo: UnityEngine.AnimatorStateInfo, $layerIndex: number, $controller: UnityEngine.Animations.AnimatorControllerPlayable):void;
            public OnStateIK($animator: UnityEngine.Animator, $stateInfo: UnityEngine.AnimatorStateInfo, $layerIndex: number, $controller: UnityEngine.Animations.AnimatorControllerPlayable):void;
            public OnStateMachineEnter($animator: UnityEngine.Animator, $stateMachinePathHash: number, $controller: UnityEngine.Animations.AnimatorControllerPlayable):void;
            public OnStateMachineExit($animator: UnityEngine.Animator, $stateMachinePathHash: number, $controller: UnityEngine.Animations.AnimatorControllerPlayable):void;
        }
        export class ScriptableObject extends UnityEngine.Object{ 
            public static CreateInstance($className: string):UnityEngine.ScriptableObject;
            public static CreateInstance($type: System.Type):UnityEngine.ScriptableObject;
            public constructor();
        }
        interface ScriptableObject {
            Save():UnityEngine.ScriptableObject;
            Restore():UnityEngine.ScriptableObject;
        }
        export class AnimatorStateInfo extends System.ValueType{ 
            public get fullPathHash(): number;
            public get shortNameHash(): number;
            public get normalizedTime(): number;
            public get length(): number;
            public get speed(): number;
            public get speedMultiplier(): number;
            public get tagHash(): number;
            public get loop(): boolean;
            public IsName($name: string):boolean;
            public IsTag($tag: string):boolean;
        }
        export class AnimatorTransitionInfo extends System.ValueType{ 
            public get fullPathHash(): number;
            public get nameHash(): number;
            public get userNameHash(): number;
            public get durationUnit(): UnityEngine.DurationUnit;
            public get duration(): number;
            public get normalizedTime(): number;
            public get anyState(): boolean;
            public IsName($name: string):boolean;
            public IsUserName($name: string):boolean;
        }
        export class AnimatorClipInfo extends System.ValueType{ 
            public get clip(): UnityEngine.AnimationClip;
            public get weight(): number;
        }
        export class AnimatorControllerParameter extends System.Object{ 
            public get nameHash(): number;
            public get type(): UnityEngine.AnimatorControllerParameterType;
            public set type(value: UnityEngine.AnimatorControllerParameterType);
            public get defaultFloat(): number;
            public set defaultFloat(value: number);
            public get defaultInt(): number;
            public set defaultInt(value: number);
            public get defaultBool(): boolean;
            public set defaultBool(value: boolean);
            public constructor();
        }
        export enum AvatarTarget{ Root = 0, Body = 1, LeftFoot = 2, RightFoot = 3, LeftHand = 4, RightHand = 5 }
        export class MatchTargetWeightMask extends System.ValueType{ 
            public get positionXYZWeight(): UnityEngine.Vector3;
            public set positionXYZWeight(value: UnityEngine.Vector3);
            public get rotationWeight(): number;
            public set rotationWeight(value: number);
            public constructor($positionXYZWeight: UnityEngine.Vector3, $rotationWeight: number);
            public constructor();
        }
        export enum AnimatorCullingMode{ AlwaysAnimate = 0, CullUpdateTransforms = 1, CullCompletely = 2, BasedOnRenderers = 1 }
        export enum AnimatorRecorderMode{ Offline = 0, Playback = 1, Record = 2 }
        export class RuntimeAnimatorController extends UnityEngine.Object{ 
            public get animationClips(): System.Array$1<UnityEngine.AnimationClip>;
        }
        export class Avatar extends UnityEngine.Object{ 
            public get isValid(): boolean;
            public get isHuman(): boolean;
            public get humanDescription(): UnityEngine.HumanDescription;
        }
        export interface IAnimationClipSource{ 
            GetAnimationClips($results: System.Collections.Generic.List$1<UnityEngine.AnimationClip>):void;
        }
        export class AnimationClip extends UnityEngine.Motion{ 
            public get length(): number;
            public get frameRate(): number;
            public set frameRate(value: number);
            public get wrapMode(): UnityEngine.WrapMode;
            public set wrapMode(value: UnityEngine.WrapMode);
            public get localBounds(): UnityEngine.Bounds;
            public set localBounds(value: UnityEngine.Bounds);
            public get legacy(): boolean;
            public set legacy(value: boolean);
            public get humanMotion(): boolean;
            public get empty(): boolean;
            public get hasGenericRootTransform(): boolean;
            public get hasMotionFloatCurves(): boolean;
            public get hasMotionCurves(): boolean;
            public get hasRootCurves(): boolean;
            public get events(): System.Array$1<UnityEngine.AnimationEvent>;
            public set events(value: System.Array$1<UnityEngine.AnimationEvent>);
            public SampleAnimation($go: UnityEngine.GameObject, $time: number):void;
            public SetCurve($relativePath: string, $type: System.Type, $propertyName: string, $curve: UnityEngine.AnimationCurve):void;
            public EnsureQuaternionContinuity():void;
            public ClearCurves():void;
            public AddEvent($evt: UnityEngine.AnimationEvent):void;
            public constructor();
        }
        export class Motion extends UnityEngine.Object{ 
            public get averageDuration(): number;
            public get averageAngularSpeed(): number;
            public get averageSpeed(): UnityEngine.Vector3;
            public get apparentSpeed(): number;
            public get isLooping(): boolean;
            public get legacy(): boolean;
            public get isHumanMotion(): boolean;
        }
        export class SharedBetweenAnimatorsAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export enum PlayMode{ StopSameLayer = 0, StopAll = 4 }
        export enum QueueMode{ CompleteOthers = 0, PlayNow = 2 }
        export enum AnimationBlendMode{ Blend = 0, Additive = 1 }
        export enum AnimationPlayMode{ Stop = 0, Queue = 1, Mix = 2 }
        export enum AnimationCullingType{ AlwaysAnimate = 0, BasedOnRenderers = 1, BasedOnClipBounds = 2, BasedOnUserBounds = 3 }
        export class Animation extends UnityEngine.Behaviour implements System.Collections.IEnumerable{ 
            public get clip(): UnityEngine.AnimationClip;
            public set clip(value: UnityEngine.AnimationClip);
            public get playAutomatically(): boolean;
            public set playAutomatically(value: boolean);
            public get wrapMode(): UnityEngine.WrapMode;
            public set wrapMode(value: UnityEngine.WrapMode);
            public get isPlaying(): boolean;
            public get animatePhysics(): boolean;
            public set animatePhysics(value: boolean);
            public get cullingType(): UnityEngine.AnimationCullingType;
            public set cullingType(value: UnityEngine.AnimationCullingType);
            public get localBounds(): UnityEngine.Bounds;
            public set localBounds(value: UnityEngine.Bounds);
            public Stop():void;
            public Stop($name: string):void;
            public Rewind():void;
            public Rewind($name: string):void;
            public Sample():void;
            public IsPlaying($name: string):boolean;
            public get_Item($name: string):UnityEngine.AnimationState;
            public Play():boolean;
            public Play($mode: UnityEngine.PlayMode):boolean;
            public Play($animation: string):boolean;
            public Play($animation: string, $mode: UnityEngine.PlayMode):boolean;
            public CrossFade($animation: string):void;
            public CrossFade($animation: string, $fadeLength: number):void;
            public CrossFade($animation: string, $fadeLength: number, $mode: UnityEngine.PlayMode):void;
            public Blend($animation: string):void;
            public Blend($animation: string, $targetWeight: number):void;
            public Blend($animation: string, $targetWeight: number, $fadeLength: number):void;
            public CrossFadeQueued($animation: string):UnityEngine.AnimationState;
            public CrossFadeQueued($animation: string, $fadeLength: number):UnityEngine.AnimationState;
            public CrossFadeQueued($animation: string, $fadeLength: number, $queue: UnityEngine.QueueMode):UnityEngine.AnimationState;
            public CrossFadeQueued($animation: string, $fadeLength: number, $queue: UnityEngine.QueueMode, $mode: UnityEngine.PlayMode):UnityEngine.AnimationState;
            public PlayQueued($animation: string):UnityEngine.AnimationState;
            public PlayQueued($animation: string, $queue: UnityEngine.QueueMode):UnityEngine.AnimationState;
            public PlayQueued($animation: string, $queue: UnityEngine.QueueMode, $mode: UnityEngine.PlayMode):UnityEngine.AnimationState;
            public AddClip($clip: UnityEngine.AnimationClip, $newName: string):void;
            public AddClip($clip: UnityEngine.AnimationClip, $newName: string, $firstFrame: number, $lastFrame: number):void;
            public AddClip($clip: UnityEngine.AnimationClip, $newName: string, $firstFrame: number, $lastFrame: number, $addLoopFrame: boolean):void;
            public RemoveClip($clip: UnityEngine.AnimationClip):void;
            public RemoveClip($clipName: string):void;
            public GetClipCount():number;
            public SyncLayer($layer: number):void;
            public GetEnumerator():System.Collections.IEnumerator;
            public GetClip($name: string):UnityEngine.AnimationClip;
            public constructor();
        }
        export enum WrapMode{ Once = 1, Loop = 2, PingPong = 4, Default = 0, ClampForever = 8, Clamp = 1 }
        export class AnimationState extends UnityEngine.TrackedReference{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get weight(): number;
            public set weight(value: number);
            public get wrapMode(): UnityEngine.WrapMode;
            public set wrapMode(value: UnityEngine.WrapMode);
            public get time(): number;
            public set time(value: number);
            public get normalizedTime(): number;
            public set normalizedTime(value: number);
            public get speed(): number;
            public set speed(value: number);
            public get normalizedSpeed(): number;
            public set normalizedSpeed(value: number);
            public get length(): number;
            public get layer(): number;
            public set layer(value: number);
            public get clip(): UnityEngine.AnimationClip;
            public get name(): string;
            public set name(value: string);
            public get blendMode(): UnityEngine.AnimationBlendMode;
            public set blendMode(value: UnityEngine.AnimationBlendMode);
            public AddMixingTransform($mix: UnityEngine.Transform):void;
            public AddMixingTransform($mix: UnityEngine.Transform, $recursive: boolean):void;
            public RemoveMixingTransform($mix: UnityEngine.Transform):void;
            public constructor();
        }
        export class TrackedReference extends System.Object{ 
            public static op_Equality($x: UnityEngine.TrackedReference, $y: UnityEngine.TrackedReference):boolean;
            public static op_Inequality($x: UnityEngine.TrackedReference, $y: UnityEngine.TrackedReference):boolean;
            public static op_Implicit($exists: UnityEngine.TrackedReference):boolean;
        }
        export class Bounds extends System.ValueType implements System.IEquatable$1<UnityEngine.Bounds>, System.IFormattable{ 
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            public get size(): UnityEngine.Vector3;
            public set size(value: UnityEngine.Vector3);
            public get extents(): UnityEngine.Vector3;
            public set extents(value: UnityEngine.Vector3);
            public get min(): UnityEngine.Vector3;
            public set min(value: UnityEngine.Vector3);
            public get max(): UnityEngine.Vector3;
            public set max(value: UnityEngine.Vector3);
            public Equals($other: any):boolean;
            public Equals($other: UnityEngine.Bounds):boolean;
            public static op_Equality($lhs: UnityEngine.Bounds, $rhs: UnityEngine.Bounds):boolean;
            public static op_Inequality($lhs: UnityEngine.Bounds, $rhs: UnityEngine.Bounds):boolean;
            public SetMinMax($min: UnityEngine.Vector3, $max: UnityEngine.Vector3):void;
            public Encapsulate($point: UnityEngine.Vector3):void;
            public Encapsulate($bounds: UnityEngine.Bounds):void;
            public Expand($amount: number):void;
            public Expand($amount: UnityEngine.Vector3):void;
            public Intersects($bounds: UnityEngine.Bounds):boolean;
            public IntersectRay($ray: UnityEngine.Ray):boolean;
            public IntersectRay($ray: UnityEngine.Ray, $distance: $Ref<number>):boolean;
            public ToString():string;
            public ToString($format: string):string;
            public ToString($format: string, $formatProvider: System.IFormatProvider):string;
            public Contains($point: UnityEngine.Vector3):boolean;
            public SqrDistance($point: UnityEngine.Vector3):number;
            public ClosestPoint($point: UnityEngine.Vector3):UnityEngine.Vector3;
            public constructor($center: UnityEngine.Vector3, $size: UnityEngine.Vector3);
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
            public constructor();
        }
        export class AnimationEvent extends System.Object{ 
            public get stringParameter(): string;
            public set stringParameter(value: string);
            public get floatParameter(): number;
            public set floatParameter(value: number);
            public get intParameter(): number;
            public set intParameter(value: number);
            public get objectReferenceParameter(): UnityEngine.Object;
            public set objectReferenceParameter(value: UnityEngine.Object);
            public get functionName(): string;
            public set functionName(value: string);
            public get time(): number;
            public set time(value: number);
            public get messageOptions(): UnityEngine.SendMessageOptions;
            public set messageOptions(value: UnityEngine.SendMessageOptions);
            public get isFiredByLegacy(): boolean;
            public get isFiredByAnimator(): boolean;
            public get animationState(): UnityEngine.AnimationState;
            public get animatorStateInfo(): UnityEngine.AnimatorStateInfo;
            public get animatorClipInfo(): UnityEngine.AnimatorClipInfo;
            public constructor();
        }
        export class AnimationCurve extends System.Object implements System.IEquatable$1<UnityEngine.AnimationCurve>{ 
            public get keys(): System.Array$1<UnityEngine.Keyframe>;
            public set keys(value: System.Array$1<UnityEngine.Keyframe>);
            public get length(): number;
            public get preWrapMode(): UnityEngine.WrapMode;
            public set preWrapMode(value: UnityEngine.WrapMode);
            public get postWrapMode(): UnityEngine.WrapMode;
            public set postWrapMode(value: UnityEngine.WrapMode);
            public Evaluate($time: number):number;
            public AddKey($time: number, $value: number):number;
            public AddKey($key: UnityEngine.Keyframe):number;
            public MoveKey($index: number, $key: UnityEngine.Keyframe):number;
            public RemoveKey($index: number):void;
            public get_Item($index: number):UnityEngine.Keyframe;
            public SmoothTangents($index: number, $weight: number):void;
            public static Constant($timeStart: number, $timeEnd: number, $value: number):UnityEngine.AnimationCurve;
            public static Linear($timeStart: number, $valueStart: number, $timeEnd: number, $valueEnd: number):UnityEngine.AnimationCurve;
            public static EaseInOut($timeStart: number, $valueStart: number, $timeEnd: number, $valueEnd: number):UnityEngine.AnimationCurve;
            public Equals($o: any):boolean;
            public Equals($other: UnityEngine.AnimationCurve):boolean;
            public constructor(...keys: UnityEngine.Keyframe[]);
            public constructor();
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
        }
        interface AnimationCurve {
            Clear():UnityEngine.AnimationCurve;
        }
        export enum AnimatorControllerParameterType{ Float = 1, Int = 3, Bool = 4, Trigger = 9 }
        export enum DurationUnit{ Fixed = 0, Normalized = 1 }
        export class AnimatorOverrideController extends UnityEngine.RuntimeAnimatorController{ 
            public get runtimeAnimatorController(): UnityEngine.RuntimeAnimatorController;
            public set runtimeAnimatorController(value: UnityEngine.RuntimeAnimatorController);
            public get overridesCount(): number;
            public get_Item($name: string):UnityEngine.AnimationClip;
            public set_Item($name: string, $value: UnityEngine.AnimationClip):void;
            public get_Item($clip: UnityEngine.AnimationClip):UnityEngine.AnimationClip;
            public set_Item($clip: UnityEngine.AnimationClip, $value: UnityEngine.AnimationClip):void;
            public GetOverrides($overrides: System.Collections.Generic.List$1<System.Collections.Generic.KeyValuePair$2<UnityEngine.AnimationClip, UnityEngine.AnimationClip>>):void;
            public ApplyOverrides($overrides: System.Collections.Generic.IList$1<System.Collections.Generic.KeyValuePair$2<UnityEngine.AnimationClip, UnityEngine.AnimationClip>>):void;
            public constructor();
            public constructor($controller: UnityEngine.RuntimeAnimatorController);
        }
        export class AnimationClipPair extends System.Object{ 
        }
        export class AnimatorUtility extends System.Object{ 
            public static OptimizeTransformHierarchy($go: UnityEngine.GameObject, $exposedTransforms: System.Array$1<string>):void;
            public static DeoptimizeTransformHierarchy($go: UnityEngine.GameObject):void;
            public constructor();
        }
        export enum BodyDof{ SpineFrontBack = 0, SpineLeftRight = 1, SpineRollLeftRight = 2, ChestFrontBack = 3, ChestLeftRight = 4, ChestRollLeftRight = 5, UpperChestFrontBack = 6, UpperChestLeftRight = 7, UpperChestRollLeftRight = 8, LastBodyDof = 9 }
        export enum HeadDof{ NeckFrontBack = 0, NeckLeftRight = 1, NeckRollLeftRight = 2, HeadFrontBack = 3, HeadLeftRight = 4, HeadRollLeftRight = 5, LeftEyeDownUp = 6, LeftEyeInOut = 7, RightEyeDownUp = 8, RightEyeInOut = 9, JawDownUp = 10, JawLeftRight = 11, LastHeadDof = 12 }
        export enum LegDof{ UpperLegFrontBack = 0, UpperLegInOut = 1, UpperLegRollInOut = 2, LegCloseOpen = 3, LegRollInOut = 4, FootCloseOpen = 5, FootInOut = 6, ToesUpDown = 7, LastLegDof = 8 }
        export enum ArmDof{ ShoulderDownUp = 0, ShoulderFrontBack = 1, ArmDownUp = 2, ArmFrontBack = 3, ArmRollInOut = 4, ForeArmCloseOpen = 5, ForeArmRollInOut = 6, HandDownUp = 7, HandInOut = 8, LastArmDof = 9 }
        export enum FingerDof{ ProximalDownUp = 0, ProximalInOut = 1, IntermediateCloseOpen = 2, DistalCloseOpen = 3, LastFingerDof = 4 }
        export enum HumanPartDof{ Body = 0, Head = 1, LeftLeg = 2, RightLeg = 3, LeftArm = 4, RightArm = 5, LeftThumb = 6, LeftIndex = 7, LeftMiddle = 8, LeftRing = 9, LeftLittle = 10, RightThumb = 11, RightIndex = 12, RightMiddle = 13, RightRing = 14, RightLittle = 15, LastHumanPartDof = 16 }
        export class HumanDescription extends System.ValueType{ 
            public human: System.Array$1<UnityEngine.HumanBone>;
            public skeleton: System.Array$1<UnityEngine.SkeletonBone>;
            public get upperArmTwist(): number;
            public set upperArmTwist(value: number);
            public get lowerArmTwist(): number;
            public set lowerArmTwist(value: number);
            public get upperLegTwist(): number;
            public set upperLegTwist(value: number);
            public get lowerLegTwist(): number;
            public set lowerLegTwist(value: number);
            public get armStretch(): number;
            public set armStretch(value: number);
            public get legStretch(): number;
            public set legStretch(value: number);
            public get feetSpacing(): number;
            public set feetSpacing(value: number);
            public get hasTranslationDoF(): boolean;
            public set hasTranslationDoF(value: boolean);
        }
        export class SkeletonBone extends System.ValueType{ 
            public name: string;
            public position: UnityEngine.Vector3;
            public rotation: UnityEngine.Quaternion;
            public scale: UnityEngine.Vector3;
        }
        export class HumanLimit extends System.ValueType{ 
            public get useDefaultValues(): boolean;
            public set useDefaultValues(value: boolean);
            public get min(): UnityEngine.Vector3;
            public set min(value: UnityEngine.Vector3);
            public get max(): UnityEngine.Vector3;
            public set max(value: UnityEngine.Vector3);
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            public get axisLength(): number;
            public set axisLength(value: number);
        }
        export class HumanBone extends System.ValueType{ 
            public limit: UnityEngine.HumanLimit;
            public get boneName(): string;
            public set boneName(value: string);
            public get humanName(): string;
            public set humanName(value: string);
        }
        export class AvatarBuilder extends System.Object{ 
            public static BuildHumanAvatar($go: UnityEngine.GameObject, $humanDescription: UnityEngine.HumanDescription):UnityEngine.Avatar;
            public static BuildGenericAvatar($go: UnityEngine.GameObject, $rootMotionTransformName: string):UnityEngine.Avatar;
            public constructor();
        }
        export enum AvatarMaskBodyPart{ Root = 0, Body = 1, Head = 2, LeftLeg = 3, RightLeg = 4, LeftArm = 5, RightArm = 6, LeftFingers = 7, RightFingers = 8, LeftFootIK = 9, RightFootIK = 10, LeftHandIK = 11, RightHandIK = 12, LastBodyPart = 13 }
        export class AvatarMask extends UnityEngine.Object{ 
            public get transformCount(): number;
            public set transformCount(value: number);
            public GetHumanoidBodyPartActive($index: UnityEngine.AvatarMaskBodyPart):boolean;
            public SetHumanoidBodyPartActive($index: UnityEngine.AvatarMaskBodyPart, $value: boolean):void;
            public AddTransformPath($transform: UnityEngine.Transform):void;
            public AddTransformPath($transform: UnityEngine.Transform, $recursive: boolean):void;
            public RemoveTransformPath($transform: UnityEngine.Transform):void;
            public RemoveTransformPath($transform: UnityEngine.Transform, $recursive: boolean):void;
            public GetTransformPath($index: number):string;
            public SetTransformPath($index: number, $path: string):void;
            public GetTransformActive($index: number):boolean;
            public SetTransformActive($index: number, $value: boolean):void;
            public constructor();
        }
        export class HumanPose extends System.ValueType{ 
            public bodyPosition: UnityEngine.Vector3;
            public bodyRotation: UnityEngine.Quaternion;
            public muscles: System.Array$1<number>;
        }
        export class HumanPoseHandler extends System.Object implements System.IDisposable{ 
            public Dispose():void;
            public GetHumanPose($humanPose: $Ref<UnityEngine.HumanPose>):void;
            public SetHumanPose($humanPose: $Ref<UnityEngine.HumanPose>):void;
            public GetInternalHumanPose($humanPose: $Ref<UnityEngine.HumanPose>):void;
            public SetInternalHumanPose($humanPose: $Ref<UnityEngine.HumanPose>):void;
            public GetInternalAvatarPose($avatarPose: Unity.Collections.NativeArray$1<number>):void;
            public SetInternalAvatarPose($avatarPose: Unity.Collections.NativeArray$1<number>):void;
            public constructor($avatar: UnityEngine.Avatar, $root: UnityEngine.Transform);
            public constructor($avatar: UnityEngine.Avatar, $jointPaths: System.Array$1<string>);
            public constructor();
        }
        export class HumanTrait extends System.Object{ 
            public static get MuscleCount(): number;
            public static get MuscleName(): System.Array$1<string>;
            public static get BoneCount(): number;
            public static get BoneName(): System.Array$1<string>;
            public static get RequiredBoneCount(): number;
            public static MuscleFromBone($i: number, $dofIndex: number):number;
            public static BoneFromMuscle($i: number):number;
            public static RequiredBone($i: number):boolean;
            public static GetMuscleDefaultMin($i: number):number;
            public static GetMuscleDefaultMax($i: number):number;
            public static GetBoneDefaultHierarchyMass($i: number):number;
            public static GetParentBone($i: number):number;
            public constructor();
        }
        export enum AssetBundleLoadResult{ Success = 0, Cancelled = 1, NotMatchingCrc = 2, FailedCache = 3, NotValidAssetBundle = 4, NoSerializedData = 5, NotCompatible = 6, AlreadyLoaded = 7, FailedRead = 8, FailedDecompression = 9, FailedWrite = 10, FailedDeleteRecompressionTarget = 11, RecompressionTargetIsLoaded = 12, RecompressionTargetExistsButNotArchive = 13 }
        export class AssetBundle extends UnityEngine.Object{ 
            public get isStreamedSceneAssetBundle(): boolean;
            public static get memoryBudgetKB(): number;
            public static set memoryBudgetKB(value: number);
            public static UnloadAllAssetBundles($unloadAllObjects: boolean):void;
            public static GetAllLoadedAssetBundles():System.Collections.Generic.IEnumerable$1<UnityEngine.AssetBundle>;
            public static LoadFromFileAsync($path: string):UnityEngine.AssetBundleCreateRequest;
            public static LoadFromFileAsync($path: string, $crc: number):UnityEngine.AssetBundleCreateRequest;
            public static LoadFromFileAsync($path: string, $crc: number, $offset: bigint):UnityEngine.AssetBundleCreateRequest;
            public static LoadFromFile($path: string):UnityEngine.AssetBundle;
            public static LoadFromFile($path: string, $crc: number):UnityEngine.AssetBundle;
            public static LoadFromFile($path: string, $crc: number, $offset: bigint):UnityEngine.AssetBundle;
            public static LoadFromMemoryAsync($binary: System.Array$1<number>):UnityEngine.AssetBundleCreateRequest;
            public static LoadFromMemoryAsync($binary: System.Array$1<number>, $crc: number):UnityEngine.AssetBundleCreateRequest;
            public static LoadFromMemory($binary: System.Array$1<number>):UnityEngine.AssetBundle;
            public static LoadFromMemory($binary: System.Array$1<number>, $crc: number):UnityEngine.AssetBundle;
            public static LoadFromStreamAsync($stream: System.IO.Stream, $crc: number, $managedReadBufferSize: number):UnityEngine.AssetBundleCreateRequest;
            public static LoadFromStreamAsync($stream: System.IO.Stream, $crc: number):UnityEngine.AssetBundleCreateRequest;
            public static LoadFromStreamAsync($stream: System.IO.Stream):UnityEngine.AssetBundleCreateRequest;
            public static LoadFromStream($stream: System.IO.Stream, $crc: number, $managedReadBufferSize: number):UnityEngine.AssetBundle;
            public static LoadFromStream($stream: System.IO.Stream, $crc: number):UnityEngine.AssetBundle;
            public static LoadFromStream($stream: System.IO.Stream):UnityEngine.AssetBundle;
            public Contains($name: string):boolean;
            public LoadAsset($name: string):UnityEngine.Object;
            public LoadAsset($name: string, $type: System.Type):UnityEngine.Object;
            public LoadAssetAsync($name: string):UnityEngine.AssetBundleRequest;
            public LoadAssetAsync($name: string, $type: System.Type):UnityEngine.AssetBundleRequest;
            public LoadAssetWithSubAssets($name: string):System.Array$1<UnityEngine.Object>;
            public LoadAssetWithSubAssets($name: string, $type: System.Type):System.Array$1<UnityEngine.Object>;
            public LoadAssetWithSubAssetsAsync($name: string):UnityEngine.AssetBundleRequest;
            public LoadAssetWithSubAssetsAsync($name: string, $type: System.Type):UnityEngine.AssetBundleRequest;
            public LoadAllAssets():System.Array$1<UnityEngine.Object>;
            public LoadAllAssets($type: System.Type):System.Array$1<UnityEngine.Object>;
            public LoadAllAssetsAsync():UnityEngine.AssetBundleRequest;
            public LoadAllAssetsAsync($type: System.Type):UnityEngine.AssetBundleRequest;
            public Unload($unloadAllLoadedObjects: boolean):void;
            public UnloadAsync($unloadAllLoadedObjects: boolean):UnityEngine.AsyncOperation;
            public GetAllAssetNames():System.Array$1<string>;
            public GetAllScenePaths():System.Array$1<string>;
            public static RecompressAssetBundleAsync($inputPath: string, $outputPath: string, $method: UnityEngine.BuildCompression, $expectedCRC?: number, $priority?: UnityEngine.ThreadPriority):UnityEngine.AssetBundleRecompressOperation;
        }
        export class AssetBundleCreateRequest extends UnityEngine.AsyncOperation{ 
            public get assetBundle(): UnityEngine.AssetBundle;
            public constructor();
        }
        export class AsyncOperation extends UnityEngine.YieldInstruction{ 
            public get isDone(): boolean;
            public get progress(): number;
            public get priority(): number;
            public set priority(value: number);
            public get allowSceneActivation(): boolean;
            public set allowSceneActivation(value: boolean);
            public add_completed($value: System.Action$1<UnityEngine.AsyncOperation>):void;
            public remove_completed($value: System.Action$1<UnityEngine.AsyncOperation>):void;
            public constructor();
        }
        interface AsyncOperation {
            GetAwaiter():System.Runtime.CompilerServices.TaskAwaiter;
        }
        export class AssetBundleRequest extends UnityEngine.ResourceRequest{ 
            public get asset(): UnityEngine.Object;
            public get allAssets(): System.Array$1<UnityEngine.Object>;
            public constructor();
        }
        export class ResourceRequest extends UnityEngine.AsyncOperation{ 
            public get asset(): UnityEngine.Object;
            public constructor();
        }
        export class AssetBundleRecompressOperation extends UnityEngine.AsyncOperation{ 
            public get humanReadableResult(): string;
            public get inputPath(): string;
            public get outputPath(): string;
            public get result(): UnityEngine.AssetBundleLoadResult;
            public get success(): boolean;
            public constructor();
        }
        export class BuildCompression extends System.ValueType{ 
            public static Uncompressed: UnityEngine.BuildCompression;
            public static LZ4: UnityEngine.BuildCompression;
            public static LZMA: UnityEngine.BuildCompression;
            public static UncompressedRuntime: UnityEngine.BuildCompression;
            public static LZ4Runtime: UnityEngine.BuildCompression;
            public get compression(): UnityEngine.CompressionType;
            public get level(): UnityEngine.CompressionLevel;
            public get blockSize(): number;
        }
        export enum ThreadPriority{ Low = 0, BelowNormal = 1, Normal = 2, High = 4 }
        export class AssetBundleManifest extends UnityEngine.Object{ 
            public GetAllAssetBundles():System.Array$1<string>;
            public GetAllAssetBundlesWithVariant():System.Array$1<string>;
            public GetAssetBundleHash($assetBundleName: string):UnityEngine.Hash128;
            public GetDirectDependencies($assetBundleName: string):System.Array$1<string>;
            public GetAllDependencies($assetBundleName: string):System.Array$1<string>;
        }
        export class Hash128 extends System.ValueType implements System.IComparable, System.IComparable$1<UnityEngine.Hash128>, System.IEquatable$1<UnityEngine.Hash128>{ 
            public get isValid(): boolean;
            public CompareTo($rhs: UnityEngine.Hash128):number;
            public static Parse($hashString: string):UnityEngine.Hash128;
            public static Compute($data: string):UnityEngine.Hash128;
            public static Compute($val: number):UnityEngine.Hash128;
            public static Compute($val: number):UnityEngine.Hash128;
            public Append($data: string):void;
            public Append($val: number):void;
            public Append($val: number):void;
            public Equals($obj: any):boolean;
            public Equals($obj: UnityEngine.Hash128):boolean;
            public CompareTo($obj: any):number;
            public static op_Equality($hash1: UnityEngine.Hash128, $hash2: UnityEngine.Hash128):boolean;
            public static op_Inequality($hash1: UnityEngine.Hash128, $hash2: UnityEngine.Hash128):boolean;
            public static op_LessThan($x: UnityEngine.Hash128, $y: UnityEngine.Hash128):boolean;
            public static op_GreaterThan($x: UnityEngine.Hash128, $y: UnityEngine.Hash128):boolean;
            public constructor($u32_0: number, $u32_1: number, $u32_2: number, $u32_3: number);
            public constructor($u64_0: bigint, $u64_1: bigint);
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
            public constructor();
        }
        export enum CompressionType{ None = 0, Lzma = 1, Lz4 = 2, Lz4HC = 3 }
        export enum CompressionLevel{ None = 0, Fastest = 1, Fast = 2, Normal = 3, High = 4, Maximum = 5 }
        export class AudioSettings extends System.Object{ 
            public static get driverCapabilities(): UnityEngine.AudioSpeakerMode;
            public static get speakerMode(): UnityEngine.AudioSpeakerMode;
            public static set speakerMode(value: UnityEngine.AudioSpeakerMode);
            public static get dspTime(): number;
            public static get outputSampleRate(): number;
            public static set outputSampleRate(value: number);
            public static GetDSPBufferSize($bufferLength: $Ref<number>, $numBuffers: $Ref<number>):void;
            public static GetSpatializerPluginName():string;
            public static GetConfiguration():UnityEngine.AudioConfiguration;
            public static Reset($config: UnityEngine.AudioConfiguration):boolean;
            public static add_OnAudioConfigurationChanged($value: UnityEngine.AudioSettings.AudioConfigurationChangeHandler):void;
            public static remove_OnAudioConfigurationChanged($value: UnityEngine.AudioSettings.AudioConfigurationChangeHandler):void;
            public constructor();
        }
        export enum AudioSpeakerMode{ Raw = 0, Mono = 1, Stereo = 2, Quad = 3, Surround = 4, Mode5point1 = 5, Mode7point1 = 6, Prologic = 7 }
        export class AudioConfiguration extends System.ValueType{ 
            public speakerMode: UnityEngine.AudioSpeakerMode;
            public dspBufferSize: number;
            public sampleRate: number;
            public numRealVoices: number;
            public numVirtualVoices: number;
        }
        export class AudioSource extends UnityEngine.AudioBehaviour{ 
            public get volume(): number;
            public set volume(value: number);
            public get pitch(): number;
            public set pitch(value: number);
            public get time(): number;
            public set time(value: number);
            public get timeSamples(): number;
            public set timeSamples(value: number);
            public get clip(): UnityEngine.AudioClip;
            public set clip(value: UnityEngine.AudioClip);
            public get outputAudioMixerGroup(): UnityEngine.Audio.AudioMixerGroup;
            public set outputAudioMixerGroup(value: UnityEngine.Audio.AudioMixerGroup);
            public get isPlaying(): boolean;
            public get isVirtual(): boolean;
            public get loop(): boolean;
            public set loop(value: boolean);
            public get ignoreListenerVolume(): boolean;
            public set ignoreListenerVolume(value: boolean);
            public get playOnAwake(): boolean;
            public set playOnAwake(value: boolean);
            public get ignoreListenerPause(): boolean;
            public set ignoreListenerPause(value: boolean);
            public get velocityUpdateMode(): UnityEngine.AudioVelocityUpdateMode;
            public set velocityUpdateMode(value: UnityEngine.AudioVelocityUpdateMode);
            public get panStereo(): number;
            public set panStereo(value: number);
            public get spatialBlend(): number;
            public set spatialBlend(value: number);
            public get spatialize(): boolean;
            public set spatialize(value: boolean);
            public get spatializePostEffects(): boolean;
            public set spatializePostEffects(value: boolean);
            public get reverbZoneMix(): number;
            public set reverbZoneMix(value: number);
            public get bypassEffects(): boolean;
            public set bypassEffects(value: boolean);
            public get bypassListenerEffects(): boolean;
            public set bypassListenerEffects(value: boolean);
            public get bypassReverbZones(): boolean;
            public set bypassReverbZones(value: boolean);
            public get dopplerLevel(): number;
            public set dopplerLevel(value: number);
            public get spread(): number;
            public set spread(value: number);
            public get priority(): number;
            public set priority(value: number);
            public get mute(): boolean;
            public set mute(value: boolean);
            public get minDistance(): number;
            public set minDistance(value: number);
            public get maxDistance(): number;
            public set maxDistance(value: number);
            public get rolloffMode(): UnityEngine.AudioRolloffMode;
            public set rolloffMode(value: UnityEngine.AudioRolloffMode);
            public Play():void;
            public Play($delay: bigint):void;
            public PlayDelayed($delay: number):void;
            public PlayScheduled($time: number):void;
            public PlayOneShot($clip: UnityEngine.AudioClip):void;
            public PlayOneShot($clip: UnityEngine.AudioClip, $volumeScale: number):void;
            public SetScheduledStartTime($time: number):void;
            public SetScheduledEndTime($time: number):void;
            public Stop():void;
            public Pause():void;
            public UnPause():void;
            public static PlayClipAtPoint($clip: UnityEngine.AudioClip, $position: UnityEngine.Vector3):void;
            public static PlayClipAtPoint($clip: UnityEngine.AudioClip, $position: UnityEngine.Vector3, $volume: number):void;
            public SetCustomCurve($type: UnityEngine.AudioSourceCurveType, $curve: UnityEngine.AnimationCurve):void;
            public GetCustomCurve($type: UnityEngine.AudioSourceCurveType):UnityEngine.AnimationCurve;
            public GetOutputData($samples: System.Array$1<number>, $channel: number):void;
            public GetSpectrumData($samples: System.Array$1<number>, $channel: number, $window: UnityEngine.FFTWindow):void;
            public SetSpatializerFloat($index: number, $value: number):boolean;
            public GetSpatializerFloat($index: number, $value: $Ref<number>):boolean;
            public GetAmbisonicDecoderFloat($index: number, $value: $Ref<number>):boolean;
            public SetAmbisonicDecoderFloat($index: number, $value: number):boolean;
            public constructor();
        }
        interface AudioSource {
            DOFade($endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<number, number, DG.Tweening.Plugins.Options.FloatOptions>;
            DOPitch($endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<number, number, DG.Tweening.Plugins.Options.FloatOptions>;
        }
        export class AudioBehaviour extends UnityEngine.Behaviour{ 
            public constructor();
        }
        export class AudioClip extends UnityEngine.Object{ 
            public get length(): number;
            public get samples(): number;
            public get channels(): number;
            public get frequency(): number;
            public get loadType(): UnityEngine.AudioClipLoadType;
            public get preloadAudioData(): boolean;
            public get ambisonic(): boolean;
            public get loadInBackground(): boolean;
            public get loadState(): UnityEngine.AudioDataLoadState;
            public LoadAudioData():boolean;
            public UnloadAudioData():boolean;
            public GetData($data: System.Array$1<number>, $offsetSamples: number):boolean;
            public SetData($data: System.Array$1<number>, $offsetSamples: number):boolean;
            public static Create($name: string, $lengthSamples: number, $channels: number, $frequency: number, $stream: boolean):UnityEngine.AudioClip;
            public static Create($name: string, $lengthSamples: number, $channels: number, $frequency: number, $stream: boolean, $pcmreadercallback: UnityEngine.AudioClip.PCMReaderCallback):UnityEngine.AudioClip;
            public static Create($name: string, $lengthSamples: number, $channels: number, $frequency: number, $stream: boolean, $pcmreadercallback: UnityEngine.AudioClip.PCMReaderCallback, $pcmsetpositioncallback: UnityEngine.AudioClip.PCMSetPositionCallback):UnityEngine.AudioClip;
        }
        export enum AudioVelocityUpdateMode{ Auto = 0, Fixed = 1, Dynamic = 2 }
        export enum AudioSourceCurveType{ CustomRolloff = 0, SpatialBlend = 1, ReverbZoneMix = 2, Spread = 3 }
        export enum AudioRolloffMode{ Logarithmic = 0, Linear = 1, Custom = 2 }
        export enum FFTWindow{ Rectangular = 0, Triangle = 1, Hamming = 2, Hanning = 3, Blackman = 4, BlackmanHarris = 5 }
        export class AudioLowPassFilter extends UnityEngine.Behaviour{ 
            public get customCutoffCurve(): UnityEngine.AnimationCurve;
            public set customCutoffCurve(value: UnityEngine.AnimationCurve);
            public get cutoffFrequency(): number;
            public set cutoffFrequency(value: number);
            public get lowpassResonanceQ(): number;
            public set lowpassResonanceQ(value: number);
            public constructor();
        }
        export class AudioHighPassFilter extends UnityEngine.Behaviour{ 
            public get cutoffFrequency(): number;
            public set cutoffFrequency(value: number);
            public get highpassResonanceQ(): number;
            public set highpassResonanceQ(value: number);
            public constructor();
        }
        export class AudioReverbFilter extends UnityEngine.Behaviour{ 
            public get reverbPreset(): UnityEngine.AudioReverbPreset;
            public set reverbPreset(value: UnityEngine.AudioReverbPreset);
            public get dryLevel(): number;
            public set dryLevel(value: number);
            public get room(): number;
            public set room(value: number);
            public get roomHF(): number;
            public set roomHF(value: number);
            public get decayTime(): number;
            public set decayTime(value: number);
            public get decayHFRatio(): number;
            public set decayHFRatio(value: number);
            public get reflectionsLevel(): number;
            public set reflectionsLevel(value: number);
            public get reflectionsDelay(): number;
            public set reflectionsDelay(value: number);
            public get reverbLevel(): number;
            public set reverbLevel(value: number);
            public get reverbDelay(): number;
            public set reverbDelay(value: number);
            public get diffusion(): number;
            public set diffusion(value: number);
            public get density(): number;
            public set density(value: number);
            public get hfReference(): number;
            public set hfReference(value: number);
            public get roomLF(): number;
            public set roomLF(value: number);
            public get lfReference(): number;
            public set lfReference(value: number);
            public constructor();
        }
        export enum AudioReverbPreset{ Off = 0, Generic = 1, PaddedCell = 2, Room = 3, Bathroom = 4, Livingroom = 5, Stoneroom = 6, Auditorium = 7, Concerthall = 8, Cave = 9, Arena = 10, Hangar = 11, CarpetedHallway = 12, Hallway = 13, StoneCorridor = 14, Alley = 15, Forest = 16, City = 17, Mountains = 18, Quarry = 19, Plain = 20, ParkingLot = 21, SewerPipe = 22, Underwater = 23, Drugged = 24, Dizzy = 25, Psychotic = 26, User = 27 }
        export enum AudioDataLoadState{ Unloaded = 0, Loading = 1, Loaded = 2, Failed = 3 }
        export enum AudioCompressionFormat{ PCM = 0, Vorbis = 1, ADPCM = 2, MP3 = 3, VAG = 4, HEVAG = 5, XMA = 6, AAC = 7, GCADPCM = 8, ATRAC9 = 9 }
        export enum AudioClipLoadType{ DecompressOnLoad = 0, CompressedInMemory = 1, Streaming = 2 }
        export class AudioListener extends UnityEngine.AudioBehaviour{ 
            public static get volume(): number;
            public static set volume(value: number);
            public static get pause(): boolean;
            public static set pause(value: boolean);
            public get velocityUpdateMode(): UnityEngine.AudioVelocityUpdateMode;
            public set velocityUpdateMode(value: UnityEngine.AudioVelocityUpdateMode);
            public static GetOutputData($samples: System.Array$1<number>, $channel: number):void;
            public static GetSpectrumData($samples: System.Array$1<number>, $channel: number, $window: UnityEngine.FFTWindow):void;
            public constructor();
        }
        export class AudioReverbZone extends UnityEngine.Behaviour{ 
            public get minDistance(): number;
            public set minDistance(value: number);
            public get maxDistance(): number;
            public set maxDistance(value: number);
            public get reverbPreset(): UnityEngine.AudioReverbPreset;
            public set reverbPreset(value: UnityEngine.AudioReverbPreset);
            public get room(): number;
            public set room(value: number);
            public get roomHF(): number;
            public set roomHF(value: number);
            public get roomLF(): number;
            public set roomLF(value: number);
            public get decayTime(): number;
            public set decayTime(value: number);
            public get decayHFRatio(): number;
            public set decayHFRatio(value: number);
            public get reflections(): number;
            public set reflections(value: number);
            public get reflectionsDelay(): number;
            public set reflectionsDelay(value: number);
            public get reverb(): number;
            public set reverb(value: number);
            public get reverbDelay(): number;
            public set reverbDelay(value: number);
            public get HFReference(): number;
            public set HFReference(value: number);
            public get LFReference(): number;
            public set LFReference(value: number);
            public get diffusion(): number;
            public set diffusion(value: number);
            public get density(): number;
            public set density(value: number);
            public constructor();
        }
        export class AudioDistortionFilter extends UnityEngine.Behaviour{ 
            public get distortionLevel(): number;
            public set distortionLevel(value: number);
            public constructor();
        }
        export class AudioEchoFilter extends UnityEngine.Behaviour{ 
            public get delay(): number;
            public set delay(value: number);
            public get decayRatio(): number;
            public set decayRatio(value: number);
            public get dryMix(): number;
            public set dryMix(value: number);
            public get wetMix(): number;
            public set wetMix(value: number);
            public constructor();
        }
        export class AudioChorusFilter extends UnityEngine.Behaviour{ 
            public get dryMix(): number;
            public set dryMix(value: number);
            public get wetMix1(): number;
            public set wetMix1(value: number);
            public get wetMix2(): number;
            public set wetMix2(value: number);
            public get wetMix3(): number;
            public set wetMix3(value: number);
            public get delay(): number;
            public set delay(value: number);
            public get rate(): number;
            public set rate(value: number);
            public get depth(): number;
            public set depth(value: number);
            public constructor();
        }
        export class Microphone extends System.Object{ 
            public static get devices(): System.Array$1<string>;
            public static Start($deviceName: string, $loop: boolean, $lengthSec: number, $frequency: number):UnityEngine.AudioClip;
            public static End($deviceName: string):void;
            public static IsRecording($deviceName: string):boolean;
            public static GetPosition($deviceName: string):number;
            public static GetDeviceCaps($deviceName: string, $minFreq: $Ref<number>, $maxFreq: $Ref<number>):void;
            public constructor();
        }
        export class AudioRenderer extends System.Object{ 
            public static Start():boolean;
            public static Stop():boolean;
            public static GetSampleCountForCaptureFrame():number;
            public static Render($buffer: Unity.Collections.NativeArray$1<number>):boolean;
            public constructor();
        }
        export enum WebCamFlags{ FrontFacing = 1, AutoFocusPointSupported = 2 }
        export enum WebCamKind{ WideAngle = 1, Telephoto = 2, ColorAndDepth = 3, UltraWideAngle = 4 }
        export class WebCamDevice extends System.ValueType{ 
            public get name(): string;
            public get isFrontFacing(): boolean;
            public get kind(): UnityEngine.WebCamKind;
            public get depthCameraName(): string;
            public get isAutoFocusPointSupported(): boolean;
            public get availableResolutions(): System.Array$1<UnityEngine.Resolution>;
        }
        export class Resolution extends System.ValueType{ 
            public get width(): number;
            public set width(value: number);
            public get height(): number;
            public set height(value: number);
            public get refreshRate(): number;
            public set refreshRate(value: number);
        }
        export class WebCamTexture extends UnityEngine.Texture{ 
            public static get devices(): System.Array$1<UnityEngine.WebCamDevice>;
            public get isPlaying(): boolean;
            public get deviceName(): string;
            public set deviceName(value: string);
            public get requestedFPS(): number;
            public set requestedFPS(value: number);
            public get requestedWidth(): number;
            public set requestedWidth(value: number);
            public get requestedHeight(): number;
            public set requestedHeight(value: number);
            public get videoRotationAngle(): number;
            public get videoVerticallyMirrored(): boolean;
            public get didUpdateThisFrame(): boolean;
            public get autoFocusPoint(): System.Nullable$1<UnityEngine.Vector2>;
            public set autoFocusPoint(value: System.Nullable$1<UnityEngine.Vector2>);
            public get isDepth(): boolean;
            public Play():void;
            public Pause():void;
            public Stop():void;
            public GetPixel($x: number, $y: number):UnityEngine.Color;
            public GetPixels():System.Array$1<UnityEngine.Color>;
            public GetPixels($x: number, $y: number, $blockWidth: number, $blockHeight: number):System.Array$1<UnityEngine.Color>;
            public GetPixels32():System.Array$1<UnityEngine.Color32>;
            public GetPixels32($colors: System.Array$1<UnityEngine.Color32>):System.Array$1<UnityEngine.Color32>;
            public constructor($deviceName: string, $requestedWidth: number, $requestedHeight: number, $requestedFPS: number);
            public constructor($deviceName: string, $requestedWidth: number, $requestedHeight: number);
            public constructor($deviceName: string);
            public constructor($requestedWidth: number, $requestedHeight: number, $requestedFPS: number);
            public constructor($requestedWidth: number, $requestedHeight: number);
            public constructor();
        }
        export class Texture extends UnityEngine.Object{ 
            public static GenerateAllMips: number;
            public static get masterTextureLimit(): number;
            public static set masterTextureLimit(value: number);
            public get mipmapCount(): number;
            public static get anisotropicFiltering(): UnityEngine.AnisotropicFiltering;
            public static set anisotropicFiltering(value: UnityEngine.AnisotropicFiltering);
            public get graphicsFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public get width(): number;
            public set width(value: number);
            public get height(): number;
            public set height(value: number);
            public get dimension(): UnityEngine.Rendering.TextureDimension;
            public set dimension(value: UnityEngine.Rendering.TextureDimension);
            public get isReadable(): boolean;
            public get wrapMode(): UnityEngine.TextureWrapMode;
            public set wrapMode(value: UnityEngine.TextureWrapMode);
            public get wrapModeU(): UnityEngine.TextureWrapMode;
            public set wrapModeU(value: UnityEngine.TextureWrapMode);
            public get wrapModeV(): UnityEngine.TextureWrapMode;
            public set wrapModeV(value: UnityEngine.TextureWrapMode);
            public get wrapModeW(): UnityEngine.TextureWrapMode;
            public set wrapModeW(value: UnityEngine.TextureWrapMode);
            public get filterMode(): UnityEngine.FilterMode;
            public set filterMode(value: UnityEngine.FilterMode);
            public get anisoLevel(): number;
            public set anisoLevel(value: number);
            public get mipMapBias(): number;
            public set mipMapBias(value: number);
            public get texelSize(): UnityEngine.Vector2;
            public get updateCount(): number;
            public static get totalTextureMemory(): bigint;
            public static get desiredTextureMemory(): bigint;
            public static get targetTextureMemory(): bigint;
            public static get currentTextureMemory(): bigint;
            public static get nonStreamingTextureMemory(): bigint;
            public static get streamingMipmapUploadCount(): bigint;
            public static get streamingRendererCount(): bigint;
            public static get streamingTextureCount(): bigint;
            public static get nonStreamingTextureCount(): bigint;
            public static get streamingTexturePendingLoadCount(): bigint;
            public static get streamingTextureLoadingCount(): bigint;
            public static get streamingTextureForceLoadAll(): boolean;
            public static set streamingTextureForceLoadAll(value: boolean);
            public static get streamingTextureDiscardUnusedMips(): boolean;
            public static set streamingTextureDiscardUnusedMips(value: boolean);
            public static get allowThreadedTextureCreation(): boolean;
            public static set allowThreadedTextureCreation(value: boolean);
            public static SetGlobalAnisotropicFilteringLimits($forcedMin: number, $globalMax: number):void;
            public GetNativeTexturePtr():System.IntPtr;
            public IncrementUpdateCount():void;
            public static SetStreamingTextureMaterialDebugProperties():void;
        }
        export class ClothSphereColliderPair extends System.ValueType{ 
            public get first(): UnityEngine.SphereCollider;
            public set first(value: UnityEngine.SphereCollider);
            public get second(): UnityEngine.SphereCollider;
            public set second(value: UnityEngine.SphereCollider);
            public constructor($a: UnityEngine.SphereCollider);
            public constructor($a: UnityEngine.SphereCollider, $b: UnityEngine.SphereCollider);
            public constructor();
        }
        export class SphereCollider extends UnityEngine.Collider{ 
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            public get radius(): number;
            public set radius(value: number);
            public constructor();
        }
        export class Collider extends UnityEngine.Component{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get attachedRigidbody(): UnityEngine.Rigidbody;
            public get attachedArticulationBody(): UnityEngine.ArticulationBody;
            public get isTrigger(): boolean;
            public set isTrigger(value: boolean);
            public get contactOffset(): number;
            public set contactOffset(value: number);
            public get bounds(): UnityEngine.Bounds;
            public get sharedMaterial(): UnityEngine.PhysicMaterial;
            public set sharedMaterial(value: UnityEngine.PhysicMaterial);
            public get material(): UnityEngine.PhysicMaterial;
            public set material(value: UnityEngine.PhysicMaterial);
            public ClosestPoint($position: UnityEngine.Vector3):UnityEngine.Vector3;
            public Raycast($ray: UnityEngine.Ray, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number):boolean;
            public ClosestPointOnBounds($position: UnityEngine.Vector3):UnityEngine.Vector3;
            public constructor();
        }
        export class ClothSkinningCoefficient extends System.ValueType{ 
            public maxDistance: number;
            public collisionSphereDistance: number;
        }
        export class Cloth extends UnityEngine.Component{ 
            public get vertices(): System.Array$1<UnityEngine.Vector3>;
            public get normals(): System.Array$1<UnityEngine.Vector3>;
            public get coefficients(): System.Array$1<UnityEngine.ClothSkinningCoefficient>;
            public set coefficients(value: System.Array$1<UnityEngine.ClothSkinningCoefficient>);
            public get capsuleColliders(): System.Array$1<UnityEngine.CapsuleCollider>;
            public set capsuleColliders(value: System.Array$1<UnityEngine.CapsuleCollider>);
            public get sphereColliders(): System.Array$1<UnityEngine.ClothSphereColliderPair>;
            public set sphereColliders(value: System.Array$1<UnityEngine.ClothSphereColliderPair>);
            public get sleepThreshold(): number;
            public set sleepThreshold(value: number);
            public get bendingStiffness(): number;
            public set bendingStiffness(value: number);
            public get stretchingStiffness(): number;
            public set stretchingStiffness(value: number);
            public get damping(): number;
            public set damping(value: number);
            public get externalAcceleration(): UnityEngine.Vector3;
            public set externalAcceleration(value: UnityEngine.Vector3);
            public get randomAcceleration(): UnityEngine.Vector3;
            public set randomAcceleration(value: UnityEngine.Vector3);
            public get useGravity(): boolean;
            public set useGravity(value: boolean);
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get friction(): number;
            public set friction(value: number);
            public get collisionMassScale(): number;
            public set collisionMassScale(value: number);
            public get enableContinuousCollision(): boolean;
            public set enableContinuousCollision(value: boolean);
            public get useVirtualParticles(): number;
            public set useVirtualParticles(value: number);
            public get worldVelocityScale(): number;
            public set worldVelocityScale(value: number);
            public get worldAccelerationScale(): number;
            public set worldAccelerationScale(value: number);
            public get clothSolverFrequency(): number;
            public set clothSolverFrequency(value: number);
            public get useTethers(): boolean;
            public set useTethers(value: boolean);
            public get stiffnessFrequency(): number;
            public set stiffnessFrequency(value: number);
            public get selfCollisionDistance(): number;
            public set selfCollisionDistance(value: number);
            public get selfCollisionStiffness(): number;
            public set selfCollisionStiffness(value: number);
            public ClearTransformMotion():void;
            public GetSelfAndInterCollisionIndices($indices: System.Collections.Generic.List$1<number>):void;
            public SetSelfAndInterCollisionIndices($indices: System.Collections.Generic.List$1<number>):void;
            public GetVirtualParticleIndices($indicesOutList: System.Collections.Generic.List$1<number>):void;
            public SetVirtualParticleIndices($indicesIn: System.Collections.Generic.List$1<number>):void;
            public GetVirtualParticleWeights($weightsOutList: System.Collections.Generic.List$1<UnityEngine.Vector3>):void;
            public SetVirtualParticleWeights($weights: System.Collections.Generic.List$1<UnityEngine.Vector3>):void;
            public SetEnabledFading($enabled: boolean, $interpolationTime: number):void;
            public SetEnabledFading($enabled: boolean):void;
            public constructor();
        }
        export class CapsuleCollider extends UnityEngine.Collider{ 
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            public get radius(): number;
            public set radius(value: number);
            public get height(): number;
            public set height(value: number);
            public get direction(): number;
            public set direction(value: number);
            public constructor();
        }
        export enum ClusterInputType{ Button = 0, Axis = 1, Tracker = 2, CustomProvidedInput = 3 }
        export class ClusterSerialization extends System.Object{ 
            public static SaveTimeManagerState($buffer: Unity.Collections.NativeArray$1<number>):number;
            public static RestoreTimeManagerState($buffer: Unity.Collections.NativeArray$1<number>):boolean;
            public static SaveInputManagerState($buffer: Unity.Collections.NativeArray$1<number>):number;
            public static RestoreInputManagerState($buffer: Unity.Collections.NativeArray$1<number>):boolean;
            public static SaveClusterInputState($buffer: Unity.Collections.NativeArray$1<number>):number;
            public static RestoreClusterInputState($buffer: Unity.Collections.NativeArray$1<number>):boolean;
        }
        export enum RuntimePlatform{ OSXEditor = 0, OSXPlayer = 1, WindowsPlayer = 2, OSXWebPlayer = 3, OSXDashboardPlayer = 4, WindowsWebPlayer = 5, WindowsEditor = 7, IPhonePlayer = 8, XBOX360 = 10, PS3 = 9, Android = 11, NaCl = 12, FlashPlayer = 15, LinuxPlayer = 13, LinuxEditor = 16, WebGLPlayer = 17, MetroPlayerX86 = 18, WSAPlayerX86 = 18, MetroPlayerX64 = 19, WSAPlayerX64 = 19, MetroPlayerARM = 20, WSAPlayerARM = 20, WP8Player = 21, BB10Player = 22, BlackBerryPlayer = 22, TizenPlayer = 23, PSP2 = 24, PS4 = 25, PSM = 26, XboxOne = 27, SamsungTVPlayer = 28, WiiU = 30, tvOS = 31, Switch = 32, Lumin = 33, Stadia = 34, CloudRendering = 35, GameCoreScarlett = 36, GameCoreXboxSeries = 36, GameCoreXboxOne = 37, PS5 = 38 }
        export enum SystemLanguage{ Afrikaans = 0, Arabic = 1, Basque = 2, Belarusian = 3, Bulgarian = 4, Catalan = 5, Chinese = 6, Czech = 7, Danish = 8, Dutch = 9, English = 10, Estonian = 11, Faroese = 12, Finnish = 13, French = 14, German = 15, Greek = 16, Hebrew = 17, Hugarian = 18, Icelandic = 19, Indonesian = 20, Italian = 21, Japanese = 22, Korean = 23, Latvian = 24, Lithuanian = 25, Norwegian = 26, Polish = 27, Portuguese = 28, Romanian = 29, Russian = 30, SerboCroatian = 31, Slovak = 32, Slovenian = 33, Spanish = 34, Swedish = 35, Thai = 36, Turkish = 37, Ukrainian = 38, Vietnamese = 39, ChineseSimplified = 40, ChineseTraditional = 41, Unknown = 42, Hungarian = 18 }
        export class SortingLayer extends System.ValueType{ 
            public get id(): number;
            public get name(): string;
            public get value(): number;
            public static get layers(): System.Array$1<UnityEngine.SortingLayer>;
            public static GetLayerValueFromID($id: number):number;
            public static GetLayerValueFromName($name: string):number;
            public static NameToID($name: string):number;
            public static IDToName($id: number):string;
            public static IsValid($id: number):boolean;
        }
        export enum WeightedMode{ None = 0, In = 1, Out = 2, Both = 3 }
        export class Keyframe extends System.ValueType{ 
            public get time(): number;
            public set time(value: number);
            public get value(): number;
            public set value(value: number);
            public get inTangent(): number;
            public set inTangent(value: number);
            public get outTangent(): number;
            public set outTangent(value: number);
            public get inWeight(): number;
            public set inWeight(value: number);
            public get outWeight(): number;
            public set outWeight(value: number);
            public get weightedMode(): UnityEngine.WeightedMode;
            public set weightedMode(value: UnityEngine.WeightedMode);
            public constructor($time: number, $value: number);
            public constructor($time: number, $value: number, $inTangent: number, $outTangent: number);
            public constructor($time: number, $value: number, $inTangent: number, $outTangent: number, $inWeight: number, $outWeight: number);
            public constructor();
        }
        export class Application extends System.Object{ 
            public static get isPlaying(): boolean;
            public static get isFocused(): boolean;
            public static get buildGUID(): string;
            public static get runInBackground(): boolean;
            public static set runInBackground(value: boolean);
            public static get isBatchMode(): boolean;
            public static get dataPath(): string;
            public static get streamingAssetsPath(): string;
            public static get persistentDataPath(): string;
            public static get temporaryCachePath(): string;
            public static get absoluteURL(): string;
            public static get unityVersion(): string;
            public static get version(): string;
            public static get installerName(): string;
            public static get identifier(): string;
            public static get installMode(): UnityEngine.ApplicationInstallMode;
            public static get sandboxType(): UnityEngine.ApplicationSandboxType;
            public static get productName(): string;
            public static get companyName(): string;
            public static get cloudProjectId(): string;
            public static get targetFrameRate(): number;
            public static set targetFrameRate(value: number);
            public static get consoleLogPath(): string;
            public static get backgroundLoadingPriority(): UnityEngine.ThreadPriority;
            public static set backgroundLoadingPriority(value: UnityEngine.ThreadPriority);
            public static get genuine(): boolean;
            public static get genuineCheckAvailable(): boolean;
            public static get platform(): UnityEngine.RuntimePlatform;
            public static get isMobilePlatform(): boolean;
            public static get isConsolePlatform(): boolean;
            public static get systemLanguage(): UnityEngine.SystemLanguage;
            public static get internetReachability(): UnityEngine.NetworkReachability;
            public static get isEditor(): boolean;
            public static Quit($exitCode: number):void;
            public static Quit():void;
            public static Unload():void;
            public static CanStreamedLevelBeLoaded($levelIndex: number):boolean;
            public static CanStreamedLevelBeLoaded($levelName: string):boolean;
            public static IsPlaying($obj: UnityEngine.Object):boolean;
            public static GetBuildTags():System.Array$1<string>;
            public static SetBuildTags($buildTags: System.Array$1<string>):void;
            public static HasProLicense():boolean;
            public static RequestAdvertisingIdentifierAsync($delegateMethod: UnityEngine.Application.AdvertisingIdentifierCallback):boolean;
            public static OpenURL($url: string):void;
            public static GetStackTraceLogType($logType: UnityEngine.LogType):UnityEngine.StackTraceLogType;
            public static SetStackTraceLogType($logType: UnityEngine.LogType, $stackTraceType: UnityEngine.StackTraceLogType):void;
            public static RequestUserAuthorization($mode: UnityEngine.UserAuthorization):UnityEngine.AsyncOperation;
            public static HasUserAuthorization($mode: UnityEngine.UserAuthorization):boolean;
            public static add_lowMemory($value: UnityEngine.Application.LowMemoryCallback):void;
            public static remove_lowMemory($value: UnityEngine.Application.LowMemoryCallback):void;
            public static add_logMessageReceived($value: UnityEngine.Application.LogCallback):void;
            public static remove_logMessageReceived($value: UnityEngine.Application.LogCallback):void;
            public static add_logMessageReceivedThreaded($value: UnityEngine.Application.LogCallback):void;
            public static remove_logMessageReceivedThreaded($value: UnityEngine.Application.LogCallback):void;
            public static add_onBeforeRender($value: UnityEngine.Events.UnityAction):void;
            public static remove_onBeforeRender($value: UnityEngine.Events.UnityAction):void;
            public static add_focusChanged($value: System.Action$1<boolean>):void;
            public static remove_focusChanged($value: System.Action$1<boolean>):void;
            public static add_deepLinkActivated($value: System.Action$1<string>):void;
            public static remove_deepLinkActivated($value: System.Action$1<string>):void;
            public static add_wantsToQuit($value: System.Func$1<boolean>):void;
            public static remove_wantsToQuit($value: System.Func$1<boolean>):void;
            public static add_quitting($value: System.Action):void;
            public static remove_quitting($value: System.Action):void;
            public static add_unloading($value: System.Action):void;
            public static remove_unloading($value: System.Action):void;
            public constructor();
        }
        export enum ApplicationInstallMode{ Unknown = 0, Store = 1, DeveloperBuild = 2, Adhoc = 3, Enterprise = 4, Editor = 5 }
        export enum ApplicationSandboxType{ Unknown = 0, NotSandboxed = 1, Sandboxed = 2, SandboxBroken = 3 }
        export enum StackTraceLogType{ None = 0, ScriptOnly = 1, Full = 2 }
        export enum UserAuthorization{ WebCam = 1, Microphone = 2 }
        export enum NetworkReachability{ NotReachable = 0, ReachableViaCarrierDataNetwork = 1, ReachableViaLocalAreaNetwork = 2 }
        export enum AudioType{ UNKNOWN = 0, ACC = 1, AIFF = 2, IT = 10, MOD = 12, MPEG = 13, OGGVORBIS = 14, S3M = 17, WAV = 20, XM = 21, XMA = 22, VAG = 23, AUDIOQUEUE = 24 }
        export class CachedAssetBundle extends System.ValueType{ 
            public get name(): string;
            public set name(value: string);
            public get hash(): UnityEngine.Hash128;
            public set hash(value: UnityEngine.Hash128);
            public constructor($name: string, $hash: UnityEngine.Hash128);
            public constructor();
        }
        export class Cache extends System.ValueType implements System.IEquatable$1<UnityEngine.Cache>{ 
            public get valid(): boolean;
            public get ready(): boolean;
            public get readOnly(): boolean;
            public get path(): string;
            public get index(): number;
            public get spaceFree(): bigint;
            public get maximumAvailableStorageSpace(): bigint;
            public set maximumAvailableStorageSpace(value: bigint);
            public get spaceOccupied(): bigint;
            public get expirationDelay(): number;
            public set expirationDelay(value: number);
            public static op_Equality($lhs: UnityEngine.Cache, $rhs: UnityEngine.Cache):boolean;
            public static op_Inequality($lhs: UnityEngine.Cache, $rhs: UnityEngine.Cache):boolean;
            public Equals($other: any):boolean;
            public Equals($other: UnityEngine.Cache):boolean;
            public ClearCache():boolean;
            public ClearCache($expiration: number):boolean;
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
        }
        export enum RenderingPath{ UsePlayerSettings = -1, VertexLit = 0, Forward = 1, DeferredLighting = 2, DeferredShading = 3 }
        export enum TransparencySortMode{ Default = 0, Perspective = 1, Orthographic = 2, CustomAxis = 3 }
        export enum CameraType{ Game = 1, SceneView = 2, Preview = 4, VR = 8, Reflection = 16 }
        export enum CameraClearFlags{ Skybox = 1, Color = 2, SolidColor = 2, Depth = 3, Nothing = 4 }
        export enum DepthTextureMode{ None = 0, Depth = 1, DepthNormals = 2, MotionVectors = 4 }
        export class Shader extends UnityEngine.Object{ 
            public get maximumLOD(): number;
            public set maximumLOD(value: number);
            public static get globalMaximumLOD(): number;
            public static set globalMaximumLOD(value: number);
            public get isSupported(): boolean;
            public static get globalRenderPipeline(): string;
            public static set globalRenderPipeline(value: string);
            public get renderQueue(): number;
            public get passCount(): number;
            public static Find($name: string):UnityEngine.Shader;
            public static EnableKeyword($keyword: string):void;
            public static DisableKeyword($keyword: string):void;
            public static IsKeywordEnabled($keyword: string):boolean;
            public static WarmupAllShaders():void;
            public static PropertyToID($name: string):number;
            public GetDependency($name: string):UnityEngine.Shader;
            public FindPassTagValue($passIndex: number, $tagName: UnityEngine.Rendering.ShaderTagId):UnityEngine.Rendering.ShaderTagId;
            public static SetGlobalInt($name: string, $value: number):void;
            public static SetGlobalInt($nameID: number, $value: number):void;
            public static SetGlobalFloat($name: string, $value: number):void;
            public static SetGlobalFloat($nameID: number, $value: number):void;
            public static SetGlobalInteger($name: string, $value: number):void;
            public static SetGlobalInteger($nameID: number, $value: number):void;
            public static SetGlobalVector($name: string, $value: UnityEngine.Vector4):void;
            public static SetGlobalVector($nameID: number, $value: UnityEngine.Vector4):void;
            public static SetGlobalColor($name: string, $value: UnityEngine.Color):void;
            public static SetGlobalColor($nameID: number, $value: UnityEngine.Color):void;
            public static SetGlobalMatrix($name: string, $value: UnityEngine.Matrix4x4):void;
            public static SetGlobalMatrix($nameID: number, $value: UnityEngine.Matrix4x4):void;
            public static SetGlobalTexture($name: string, $value: UnityEngine.Texture):void;
            public static SetGlobalTexture($nameID: number, $value: UnityEngine.Texture):void;
            public static SetGlobalTexture($name: string, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement):void;
            public static SetGlobalTexture($nameID: number, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement):void;
            public static SetGlobalBuffer($name: string, $value: UnityEngine.ComputeBuffer):void;
            public static SetGlobalBuffer($nameID: number, $value: UnityEngine.ComputeBuffer):void;
            public static SetGlobalBuffer($name: string, $value: UnityEngine.GraphicsBuffer):void;
            public static SetGlobalBuffer($nameID: number, $value: UnityEngine.GraphicsBuffer):void;
            public static SetGlobalConstantBuffer($name: string, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number):void;
            public static SetGlobalConstantBuffer($nameID: number, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number):void;
            public static SetGlobalConstantBuffer($name: string, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number):void;
            public static SetGlobalConstantBuffer($nameID: number, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number):void;
            public static SetGlobalFloatArray($name: string, $values: System.Collections.Generic.List$1<number>):void;
            public static SetGlobalFloatArray($nameID: number, $values: System.Collections.Generic.List$1<number>):void;
            public static SetGlobalFloatArray($name: string, $values: System.Array$1<number>):void;
            public static SetGlobalFloatArray($nameID: number, $values: System.Array$1<number>):void;
            public static SetGlobalVectorArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
            public static SetGlobalVectorArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
            public static SetGlobalVectorArray($name: string, $values: System.Array$1<UnityEngine.Vector4>):void;
            public static SetGlobalVectorArray($nameID: number, $values: System.Array$1<UnityEngine.Vector4>):void;
            public static SetGlobalMatrixArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>):void;
            public static SetGlobalMatrixArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>):void;
            public static SetGlobalMatrixArray($name: string, $values: System.Array$1<UnityEngine.Matrix4x4>):void;
            public static SetGlobalMatrixArray($nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>):void;
            public static GetGlobalInt($name: string):number;
            public static GetGlobalInt($nameID: number):number;
            public static GetGlobalFloat($name: string):number;
            public static GetGlobalFloat($nameID: number):number;
            public static GetGlobalInteger($name: string):number;
            public static GetGlobalInteger($nameID: number):number;
            public static GetGlobalVector($name: string):UnityEngine.Vector4;
            public static GetGlobalVector($nameID: number):UnityEngine.Vector4;
            public static GetGlobalColor($name: string):UnityEngine.Color;
            public static GetGlobalColor($nameID: number):UnityEngine.Color;
            public static GetGlobalMatrix($name: string):UnityEngine.Matrix4x4;
            public static GetGlobalMatrix($nameID: number):UnityEngine.Matrix4x4;
            public static GetGlobalTexture($name: string):UnityEngine.Texture;
            public static GetGlobalTexture($nameID: number):UnityEngine.Texture;
            public static GetGlobalFloatArray($name: string):System.Array$1<number>;
            public static GetGlobalFloatArray($nameID: number):System.Array$1<number>;
            public static GetGlobalVectorArray($name: string):System.Array$1<UnityEngine.Vector4>;
            public static GetGlobalVectorArray($nameID: number):System.Array$1<UnityEngine.Vector4>;
            public static GetGlobalMatrixArray($name: string):System.Array$1<UnityEngine.Matrix4x4>;
            public static GetGlobalMatrixArray($nameID: number):System.Array$1<UnityEngine.Matrix4x4>;
            public static GetGlobalFloatArray($name: string, $values: System.Collections.Generic.List$1<number>):void;
            public static GetGlobalFloatArray($nameID: number, $values: System.Collections.Generic.List$1<number>):void;
            public static GetGlobalVectorArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
            public static GetGlobalVectorArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
            public static GetGlobalMatrixArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>):void;
            public static GetGlobalMatrixArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>):void;
            public GetPropertyCount():number;
            public FindPropertyIndex($propertyName: string):number;
            public GetPropertyName($propertyIndex: number):string;
            public GetPropertyNameId($propertyIndex: number):number;
            public GetPropertyType($propertyIndex: number):UnityEngine.Rendering.ShaderPropertyType;
            public GetPropertyDescription($propertyIndex: number):string;
            public GetPropertyFlags($propertyIndex: number):UnityEngine.Rendering.ShaderPropertyFlags;
            public GetPropertyAttributes($propertyIndex: number):System.Array$1<string>;
            public GetPropertyDefaultFloatValue($propertyIndex: number):number;
            public GetPropertyDefaultVectorValue($propertyIndex: number):UnityEngine.Vector4;
            public GetPropertyRangeLimits($propertyIndex: number):UnityEngine.Vector2;
            public GetPropertyTextureDimension($propertyIndex: number):UnityEngine.Rendering.TextureDimension;
            public GetPropertyTextureDefaultName($propertyIndex: number):string;
            public FindTextureStack($propertyIndex: number, $stackName: $Ref<string>, $layerIndex: $Ref<number>):boolean;
        }
        export class RenderTexture extends UnityEngine.Texture{ 
            public get width(): number;
            public set width(value: number);
            public get height(): number;
            public set height(value: number);
            public get dimension(): UnityEngine.Rendering.TextureDimension;
            public set dimension(value: UnityEngine.Rendering.TextureDimension);
            public get graphicsFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public set graphicsFormat(value: UnityEngine.Experimental.Rendering.GraphicsFormat);
            public get useMipMap(): boolean;
            public set useMipMap(value: boolean);
            public get sRGB(): boolean;
            public get vrUsage(): UnityEngine.VRTextureUsage;
            public set vrUsage(value: UnityEngine.VRTextureUsage);
            public get memorylessMode(): UnityEngine.RenderTextureMemoryless;
            public set memorylessMode(value: UnityEngine.RenderTextureMemoryless);
            public get format(): UnityEngine.RenderTextureFormat;
            public set format(value: UnityEngine.RenderTextureFormat);
            public get stencilFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public set stencilFormat(value: UnityEngine.Experimental.Rendering.GraphicsFormat);
            public get autoGenerateMips(): boolean;
            public set autoGenerateMips(value: boolean);
            public get volumeDepth(): number;
            public set volumeDepth(value: number);
            public get antiAliasing(): number;
            public set antiAliasing(value: number);
            public get bindTextureMS(): boolean;
            public set bindTextureMS(value: boolean);
            public get enableRandomWrite(): boolean;
            public set enableRandomWrite(value: boolean);
            public get useDynamicScale(): boolean;
            public set useDynamicScale(value: boolean);
            public get isPowerOfTwo(): boolean;
            public set isPowerOfTwo(value: boolean);
            public static get active(): UnityEngine.RenderTexture;
            public static set active(value: UnityEngine.RenderTexture);
            public get colorBuffer(): UnityEngine.RenderBuffer;
            public get depthBuffer(): UnityEngine.RenderBuffer;
            public get depth(): number;
            public set depth(value: number);
            public get descriptor(): UnityEngine.RenderTextureDescriptor;
            public set descriptor(value: UnityEngine.RenderTextureDescriptor);
            public GetNativeDepthBufferPtr():System.IntPtr;
            public DiscardContents($discardColor: boolean, $discardDepth: boolean):void;
            public DiscardContents():void;
            public ResolveAntiAliasedSurface():void;
            public ResolveAntiAliasedSurface($target: UnityEngine.RenderTexture):void;
            public SetGlobalShaderProperty($propertyName: string):void;
            public Create():boolean;
            public Release():void;
            public IsCreated():boolean;
            public GenerateMips():void;
            public ConvertToEquirect($equirect: UnityEngine.RenderTexture, $eye?: UnityEngine.Camera.MonoOrStereoscopicEye):void;
            public static SupportsStencil($rt: UnityEngine.RenderTexture):boolean;
            public static ReleaseTemporary($temp: UnityEngine.RenderTexture):void;
            public static GetTemporary($desc: UnityEngine.RenderTextureDescriptor):UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless, $vrUsage: UnityEngine.VRTextureUsage, $useDynamicScale: boolean):UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless, $vrUsage: UnityEngine.VRTextureUsage):UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless):UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number):UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat):UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless, $vrUsage: UnityEngine.VRTextureUsage, $useDynamicScale: boolean):UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless, $vrUsage: UnityEngine.VRTextureUsage):UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless):UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number):UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite):UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat):UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number):UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number):UnityEngine.RenderTexture;
            public constructor($desc: UnityEngine.RenderTextureDescriptor);
            public constructor($textureToCopy: UnityEngine.RenderTexture);
            public constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat);
            public constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat);
            public constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number);
            public constructor($width: number, $height: number, $depth: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite);
            public constructor($width: number, $height: number, $depth: number, $format: UnityEngine.RenderTextureFormat);
            public constructor($width: number, $height: number, $depth: number);
            public constructor($width: number, $height: number, $depth: number, $format: UnityEngine.RenderTextureFormat, $mipCount: number);
            public constructor();
        }
        export class RenderBuffer extends System.ValueType{ 
            public GetNativeRenderBufferPtr():System.IntPtr;
        }
        export class Ray extends System.ValueType implements System.IFormattable{ 
            public get origin(): UnityEngine.Vector3;
            public set origin(value: UnityEngine.Vector3);
            public get direction(): UnityEngine.Vector3;
            public set direction(value: UnityEngine.Vector3);
            public GetPoint($distance: number):UnityEngine.Vector3;
            public ToString():string;
            public ToString($format: string):string;
            public ToString($format: string, $formatProvider: System.IFormatProvider):string;
            public constructor($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3);
            public constructor();
        }
        export enum StereoTargetEyeMask{ None = 0, Left = 1, Right = 2, Both = 3 }
        export class Cubemap extends UnityEngine.Texture{ 
            public get format(): UnityEngine.TextureFormat;
            public get isReadable(): boolean;
            public get streamingMipmaps(): boolean;
            public get streamingMipmapsPriority(): number;
            public get requestedMipmapLevel(): number;
            public set requestedMipmapLevel(value: number);
            public get desiredMipmapLevel(): number;
            public get loadingMipmapLevel(): number;
            public get loadedMipmapLevel(): number;
            public UpdateExternalTexture($nativeTexture: System.IntPtr):void;
            public SmoothEdges($smoothRegionWidthInPixels: number):void;
            public SmoothEdges():void;
            public GetPixels($face: UnityEngine.CubemapFace, $miplevel: number):System.Array$1<UnityEngine.Color>;
            public GetPixels($face: UnityEngine.CubemapFace):System.Array$1<UnityEngine.Color>;
            public SetPixels($colors: System.Array$1<UnityEngine.Color>, $face: UnityEngine.CubemapFace, $miplevel: number):void;
            public SetPixels($colors: System.Array$1<UnityEngine.Color>, $face: UnityEngine.CubemapFace):void;
            public ClearRequestedMipmapLevel():void;
            public IsRequestedMipmapLevelLoaded():boolean;
            public static CreateExternalTexture($width: number, $format: UnityEngine.TextureFormat, $mipmap: boolean, $nativeTex: System.IntPtr):UnityEngine.Cubemap;
            public SetPixel($face: UnityEngine.CubemapFace, $x: number, $y: number, $color: UnityEngine.Color):void;
            public GetPixel($face: UnityEngine.CubemapFace, $x: number, $y: number):UnityEngine.Color;
            public Apply($updateMipmaps: boolean, $makeNoLongerReadable: boolean):void;
            public Apply($updateMipmaps: boolean):void;
            public Apply():void;
            public constructor($width: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            public constructor($width: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            public constructor($width: number, $format: UnityEngine.TextureFormat, $mipCount: number);
            public constructor($width: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number);
            public constructor($width: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean);
            public constructor();
        }
        export class BoundingSphere extends System.ValueType{ 
            public position: UnityEngine.Vector3;
            public radius: number;
            public constructor($pos: UnityEngine.Vector3, $rad: number);
            public constructor($packedSphere: UnityEngine.Vector4);
            public constructor();
        }
        export class CullingGroupEvent extends System.ValueType{ 
            public get index(): number;
            public get isVisible(): boolean;
            public get wasVisible(): boolean;
            public get hasBecomeVisible(): boolean;
            public get hasBecomeInvisible(): boolean;
            public get currentDistance(): number;
            public get previousDistance(): number;
        }
        export class CullingGroup extends System.Object implements System.IDisposable{ 
            public get onStateChanged(): UnityEngine.CullingGroup.StateChanged;
            public set onStateChanged(value: UnityEngine.CullingGroup.StateChanged);
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get targetCamera(): UnityEngine.Camera;
            public set targetCamera(value: UnityEngine.Camera);
            public Dispose():void;
            public SetBoundingSpheres($array: System.Array$1<UnityEngine.BoundingSphere>):void;
            public SetBoundingSphereCount($count: number):void;
            public EraseSwapBack($index: number):void;
            public QueryIndices($visible: boolean, $result: System.Array$1<number>, $firstIndex: number):number;
            public QueryIndices($distanceIndex: number, $result: System.Array$1<number>, $firstIndex: number):number;
            public QueryIndices($visible: boolean, $distanceIndex: number, $result: System.Array$1<number>, $firstIndex: number):number;
            public IsVisible($index: number):boolean;
            public GetDistance($index: number):number;
            public SetBoundingDistances($distances: System.Array$1<number>):void;
            public SetDistanceReferencePoint($point: UnityEngine.Vector3):void;
            public SetDistanceReferencePoint($transform: UnityEngine.Transform):void;
            public constructor();
        }
        export class FlareLayer extends UnityEngine.Behaviour{ 
        }
        export class ReflectionProbe extends UnityEngine.Behaviour{ 
            public get size(): UnityEngine.Vector3;
            public set size(value: UnityEngine.Vector3);
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            public get nearClipPlane(): number;
            public set nearClipPlane(value: number);
            public get farClipPlane(): number;
            public set farClipPlane(value: number);
            public get intensity(): number;
            public set intensity(value: number);
            public get bounds(): UnityEngine.Bounds;
            public get hdr(): boolean;
            public set hdr(value: boolean);
            public get renderDynamicObjects(): boolean;
            public set renderDynamicObjects(value: boolean);
            public get shadowDistance(): number;
            public set shadowDistance(value: number);
            public get resolution(): number;
            public set resolution(value: number);
            public get cullingMask(): number;
            public set cullingMask(value: number);
            public get clearFlags(): UnityEngine.Rendering.ReflectionProbeClearFlags;
            public set clearFlags(value: UnityEngine.Rendering.ReflectionProbeClearFlags);
            public get backgroundColor(): UnityEngine.Color;
            public set backgroundColor(value: UnityEngine.Color);
            public get blendDistance(): number;
            public set blendDistance(value: number);
            public get boxProjection(): boolean;
            public set boxProjection(value: boolean);
            public get mode(): UnityEngine.Rendering.ReflectionProbeMode;
            public set mode(value: UnityEngine.Rendering.ReflectionProbeMode);
            public get importance(): number;
            public set importance(value: number);
            public get refreshMode(): UnityEngine.Rendering.ReflectionProbeRefreshMode;
            public set refreshMode(value: UnityEngine.Rendering.ReflectionProbeRefreshMode);
            public get timeSlicingMode(): UnityEngine.Rendering.ReflectionProbeTimeSlicingMode;
            public set timeSlicingMode(value: UnityEngine.Rendering.ReflectionProbeTimeSlicingMode);
            public get bakedTexture(): UnityEngine.Texture;
            public set bakedTexture(value: UnityEngine.Texture);
            public get customBakedTexture(): UnityEngine.Texture;
            public set customBakedTexture(value: UnityEngine.Texture);
            public get realtimeTexture(): UnityEngine.RenderTexture;
            public set realtimeTexture(value: UnityEngine.RenderTexture);
            public get texture(): UnityEngine.Texture;
            public get textureHDRDecodeValues(): UnityEngine.Vector4;
            public static get minBakedCubemapResolution(): number;
            public static get maxBakedCubemapResolution(): number;
            public static get defaultTextureHDRDecodeValues(): UnityEngine.Vector4;
            public static get defaultTexture(): UnityEngine.Texture;
            public Reset():void;
            public RenderProbe():number;
            public RenderProbe($targetTexture: UnityEngine.RenderTexture):number;
            public IsFinishedRendering($renderId: number):boolean;
            public static BlendCubemap($src: UnityEngine.Texture, $dst: UnityEngine.Texture, $blend: number, $target: UnityEngine.RenderTexture):boolean;
            public static add_reflectionProbeChanged($value: System.Action$2<UnityEngine.ReflectionProbe, UnityEngine.ReflectionProbe.ReflectionProbeEvent>):void;
            public static remove_reflectionProbeChanged($value: System.Action$2<UnityEngine.ReflectionProbe, UnityEngine.ReflectionProbe.ReflectionProbeEvent>):void;
            public static add_defaultReflectionSet($value: System.Action$1<UnityEngine.Cubemap>):void;
            public static remove_defaultReflectionSet($value: System.Action$1<UnityEngine.Cubemap>):void;
            public constructor();
        }
        export class CrashReport extends System.Object{ 
            public time: Date;
            public text: string;
            public static get reports(): System.Array$1<UnityEngine.CrashReport>;
            public static get lastReport(): UnityEngine.CrashReport;
            public static RemoveAll():void;
            public Remove():void;
        }
        export class ExposedPropertyResolver extends System.ValueType{ 
        }
        export interface IExposedPropertyTable{ 
            SetReferenceValue($id: UnityEngine.PropertyName, $value: UnityEngine.Object):void;
            GetReferenceValue($id: UnityEngine.PropertyName, $idValid: $Ref<boolean>):UnityEngine.Object;
            ClearReferenceValue($id: UnityEngine.PropertyName):void;
        }
        export class PropertyName extends System.ValueType implements System.IEquatable$1<UnityEngine.PropertyName>{ 
            public static IsNullOrEmpty($prop: UnityEngine.PropertyName):boolean;
            public static op_Equality($lhs: UnityEngine.PropertyName, $rhs: UnityEngine.PropertyName):boolean;
            public static op_Inequality($lhs: UnityEngine.PropertyName, $rhs: UnityEngine.PropertyName):boolean;
            public Equals($other: any):boolean;
            public Equals($other: UnityEngine.PropertyName):boolean;
            public static op_Implicit($name: string):UnityEngine.PropertyName;
            public static op_Implicit($id: number):UnityEngine.PropertyName;
            public constructor($name: string);
            public constructor($other: UnityEngine.PropertyName);
            public constructor($id: number);
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
            public constructor();
        }
        export class BoundsInt extends System.ValueType implements System.IEquatable$1<UnityEngine.BoundsInt>, System.IFormattable{ 
            public get x(): number;
            public set x(value: number);
            public get y(): number;
            public set y(value: number);
            public get z(): number;
            public set z(value: number);
            public get center(): UnityEngine.Vector3;
            public get min(): UnityEngine.Vector3Int;
            public set min(value: UnityEngine.Vector3Int);
            public get max(): UnityEngine.Vector3Int;
            public set max(value: UnityEngine.Vector3Int);
            public get xMin(): number;
            public set xMin(value: number);
            public get yMin(): number;
            public set yMin(value: number);
            public get zMin(): number;
            public set zMin(value: number);
            public get xMax(): number;
            public set xMax(value: number);
            public get yMax(): number;
            public set yMax(value: number);
            public get zMax(): number;
            public set zMax(value: number);
            public get position(): UnityEngine.Vector3Int;
            public set position(value: UnityEngine.Vector3Int);
            public get size(): UnityEngine.Vector3Int;
            public set size(value: UnityEngine.Vector3Int);
            public get allPositionsWithin(): UnityEngine.BoundsInt.PositionEnumerator;
            public SetMinMax($minPosition: UnityEngine.Vector3Int, $maxPosition: UnityEngine.Vector3Int):void;
            public ClampToBounds($bounds: UnityEngine.BoundsInt):void;
            public Contains($position: UnityEngine.Vector3Int):boolean;
            public ToString():string;
            public ToString($format: string):string;
            public ToString($format: string, $formatProvider: System.IFormatProvider):string;
            public static op_Equality($lhs: UnityEngine.BoundsInt, $rhs: UnityEngine.BoundsInt):boolean;
            public static op_Inequality($lhs: UnityEngine.BoundsInt, $rhs: UnityEngine.BoundsInt):boolean;
            public Equals($other: any):boolean;
            public Equals($other: UnityEngine.BoundsInt):boolean;
            public constructor($xMin: number, $yMin: number, $zMin: number, $sizeX: number, $sizeY: number, $sizeZ: number);
            public constructor($position: UnityEngine.Vector3Int, $size: UnityEngine.Vector3Int);
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
            public constructor();
        }
        export class Vector3Int extends System.ValueType implements System.IEquatable$1<UnityEngine.Vector3Int>, System.IFormattable{ 
            public get x(): number;
            public set x(value: number);
            public get y(): number;
            public set y(value: number);
            public get z(): number;
            public set z(value: number);
            public get magnitude(): number;
            public get sqrMagnitude(): number;
            public static get zero(): UnityEngine.Vector3Int;
            public static get one(): UnityEngine.Vector3Int;
            public static get up(): UnityEngine.Vector3Int;
            public static get down(): UnityEngine.Vector3Int;
            public static get left(): UnityEngine.Vector3Int;
            public static get right(): UnityEngine.Vector3Int;
            public static get forward(): UnityEngine.Vector3Int;
            public static get back(): UnityEngine.Vector3Int;
            public Set($x: number, $y: number, $z: number):void;
            public get_Item($index: number):number;
            public set_Item($index: number, $value: number):void;
            public static Distance($a: UnityEngine.Vector3Int, $b: UnityEngine.Vector3Int):number;
            public static Min($lhs: UnityEngine.Vector3Int, $rhs: UnityEngine.Vector3Int):UnityEngine.Vector3Int;
            public static Max($lhs: UnityEngine.Vector3Int, $rhs: UnityEngine.Vector3Int):UnityEngine.Vector3Int;
            public static Scale($a: UnityEngine.Vector3Int, $b: UnityEngine.Vector3Int):UnityEngine.Vector3Int;
            public Scale($scale: UnityEngine.Vector3Int):void;
            public Clamp($min: UnityEngine.Vector3Int, $max: UnityEngine.Vector3Int):void;
            public static op_Implicit($v: UnityEngine.Vector3Int):UnityEngine.Vector3;
            public static op_Explicit($v: UnityEngine.Vector3Int):UnityEngine.Vector2Int;
            public static FloorToInt($v: UnityEngine.Vector3):UnityEngine.Vector3Int;
            public static CeilToInt($v: UnityEngine.Vector3):UnityEngine.Vector3Int;
            public static RoundToInt($v: UnityEngine.Vector3):UnityEngine.Vector3Int;
            public static op_Addition($a: UnityEngine.Vector3Int, $b: UnityEngine.Vector3Int):UnityEngine.Vector3Int;
            public static op_Subtraction($a: UnityEngine.Vector3Int, $b: UnityEngine.Vector3Int):UnityEngine.Vector3Int;
            public static op_Multiply($a: UnityEngine.Vector3Int, $b: UnityEngine.Vector3Int):UnityEngine.Vector3Int;
            public static op_UnaryNegation($a: UnityEngine.Vector3Int):UnityEngine.Vector3Int;
            public static op_Multiply($a: UnityEngine.Vector3Int, $b: number):UnityEngine.Vector3Int;
            public static op_Multiply($a: number, $b: UnityEngine.Vector3Int):UnityEngine.Vector3Int;
            public static op_Division($a: UnityEngine.Vector3Int, $b: number):UnityEngine.Vector3Int;
            public static op_Equality($lhs: UnityEngine.Vector3Int, $rhs: UnityEngine.Vector3Int):boolean;
            public static op_Inequality($lhs: UnityEngine.Vector3Int, $rhs: UnityEngine.Vector3Int):boolean;
            public Equals($other: any):boolean;
            public Equals($other: UnityEngine.Vector3Int):boolean;
            public ToString():string;
            public ToString($format: string):string;
            public ToString($format: string, $formatProvider: System.IFormatProvider):string;
            public constructor($x: number, $y: number, $z: number);
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
            public constructor();
        }
        export class GeometryUtility extends System.Object{ 
            public static CalculateFrustumPlanes($camera: UnityEngine.Camera):System.Array$1<UnityEngine.Plane>;
            public static CalculateFrustumPlanes($worldToProjectionMatrix: UnityEngine.Matrix4x4):System.Array$1<UnityEngine.Plane>;
            public static CalculateFrustumPlanes($camera: UnityEngine.Camera, $planes: System.Array$1<UnityEngine.Plane>):void;
            public static CalculateFrustumPlanes($worldToProjectionMatrix: UnityEngine.Matrix4x4, $planes: System.Array$1<UnityEngine.Plane>):void;
            public static CalculateBounds($positions: System.Array$1<UnityEngine.Vector3>, $transform: UnityEngine.Matrix4x4):UnityEngine.Bounds;
            public static TryCreatePlaneFromPolygon($vertices: System.Array$1<UnityEngine.Vector3>, $plane: $Ref<UnityEngine.Plane>):boolean;
            public static TestPlanesAABB($planes: System.Array$1<UnityEngine.Plane>, $bounds: UnityEngine.Bounds):boolean;
            public constructor();
        }
        export class Plane extends System.ValueType implements System.IFormattable{ 
            public get normal(): UnityEngine.Vector3;
            public set normal(value: UnityEngine.Vector3);
            public get distance(): number;
            public set distance(value: number);
            public get flipped(): UnityEngine.Plane;
            public SetNormalAndPosition($inNormal: UnityEngine.Vector3, $inPoint: UnityEngine.Vector3):void;
            public Set3Points($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $c: UnityEngine.Vector3):void;
            public Flip():void;
            public Translate($translation: UnityEngine.Vector3):void;
            public static Translate($plane: UnityEngine.Plane, $translation: UnityEngine.Vector3):UnityEngine.Plane;
            public ClosestPointOnPlane($point: UnityEngine.Vector3):UnityEngine.Vector3;
            public GetDistanceToPoint($point: UnityEngine.Vector3):number;
            public GetSide($point: UnityEngine.Vector3):boolean;
            public SameSide($inPt0: UnityEngine.Vector3, $inPt1: UnityEngine.Vector3):boolean;
            public Raycast($ray: UnityEngine.Ray, $enter: $Ref<number>):boolean;
            public ToString():string;
            public ToString($format: string):string;
            public ToString($format: string, $formatProvider: System.IFormatProvider):string;
            public constructor($inNormal: UnityEngine.Vector3, $inPoint: UnityEngine.Vector3);
            public constructor($inNormal: UnityEngine.Vector3, $d: number);
            public constructor($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $c: UnityEngine.Vector3);
            public constructor();
        }
        export class Ray2D extends System.ValueType implements System.IFormattable{ 
            public get origin(): UnityEngine.Vector2;
            public set origin(value: UnityEngine.Vector2);
            public get direction(): UnityEngine.Vector2;
            public set direction(value: UnityEngine.Vector2);
            public GetPoint($distance: number):UnityEngine.Vector2;
            public ToString():string;
            public ToString($format: string):string;
            public ToString($format: string, $formatProvider: System.IFormatProvider):string;
            public constructor($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2);
            public constructor();
        }
        export class RectInt extends System.ValueType implements System.IEquatable$1<UnityEngine.RectInt>, System.IFormattable{ 
            public get x(): number;
            public set x(value: number);
            public get y(): number;
            public set y(value: number);
            public get center(): UnityEngine.Vector2;
            public get min(): UnityEngine.Vector2Int;
            public set min(value: UnityEngine.Vector2Int);
            public get max(): UnityEngine.Vector2Int;
            public set max(value: UnityEngine.Vector2Int);
            public get width(): number;
            public set width(value: number);
            public get height(): number;
            public set height(value: number);
            public get xMin(): number;
            public set xMin(value: number);
            public get yMin(): number;
            public set yMin(value: number);
            public get xMax(): number;
            public set xMax(value: number);
            public get yMax(): number;
            public set yMax(value: number);
            public get position(): UnityEngine.Vector2Int;
            public set position(value: UnityEngine.Vector2Int);
            public get size(): UnityEngine.Vector2Int;
            public set size(value: UnityEngine.Vector2Int);
            public get allPositionsWithin(): UnityEngine.RectInt.PositionEnumerator;
            public SetMinMax($minPosition: UnityEngine.Vector2Int, $maxPosition: UnityEngine.Vector2Int):void;
            public ClampToBounds($bounds: UnityEngine.RectInt):void;
            public Contains($position: UnityEngine.Vector2Int):boolean;
            public Overlaps($other: UnityEngine.RectInt):boolean;
            public ToString():string;
            public ToString($format: string):string;
            public ToString($format: string, $formatProvider: System.IFormatProvider):string;
            public Equals($other: UnityEngine.RectInt):boolean;
            public constructor($xMin: number, $yMin: number, $width: number, $height: number);
            public constructor($position: UnityEngine.Vector2Int, $size: UnityEngine.Vector2Int);
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
            public constructor();
        }
        export class Vector2Int extends System.ValueType implements System.IEquatable$1<UnityEngine.Vector2Int>, System.IFormattable{ 
            public get x(): number;
            public set x(value: number);
            public get y(): number;
            public set y(value: number);
            public get magnitude(): number;
            public get sqrMagnitude(): number;
            public static get zero(): UnityEngine.Vector2Int;
            public static get one(): UnityEngine.Vector2Int;
            public static get up(): UnityEngine.Vector2Int;
            public static get down(): UnityEngine.Vector2Int;
            public static get left(): UnityEngine.Vector2Int;
            public static get right(): UnityEngine.Vector2Int;
            public Set($x: number, $y: number):void;
            public get_Item($index: number):number;
            public set_Item($index: number, $value: number):void;
            public static Distance($a: UnityEngine.Vector2Int, $b: UnityEngine.Vector2Int):number;
            public static Min($lhs: UnityEngine.Vector2Int, $rhs: UnityEngine.Vector2Int):UnityEngine.Vector2Int;
            public static Max($lhs: UnityEngine.Vector2Int, $rhs: UnityEngine.Vector2Int):UnityEngine.Vector2Int;
            public static Scale($a: UnityEngine.Vector2Int, $b: UnityEngine.Vector2Int):UnityEngine.Vector2Int;
            public Scale($scale: UnityEngine.Vector2Int):void;
            public Clamp($min: UnityEngine.Vector2Int, $max: UnityEngine.Vector2Int):void;
            public static op_Implicit($v: UnityEngine.Vector2Int):UnityEngine.Vector2;
            public static op_Explicit($v: UnityEngine.Vector2Int):UnityEngine.Vector3Int;
            public static FloorToInt($v: UnityEngine.Vector2):UnityEngine.Vector2Int;
            public static CeilToInt($v: UnityEngine.Vector2):UnityEngine.Vector2Int;
            public static RoundToInt($v: UnityEngine.Vector2):UnityEngine.Vector2Int;
            public static op_UnaryNegation($v: UnityEngine.Vector2Int):UnityEngine.Vector2Int;
            public static op_Addition($a: UnityEngine.Vector2Int, $b: UnityEngine.Vector2Int):UnityEngine.Vector2Int;
            public static op_Subtraction($a: UnityEngine.Vector2Int, $b: UnityEngine.Vector2Int):UnityEngine.Vector2Int;
            public static op_Multiply($a: UnityEngine.Vector2Int, $b: UnityEngine.Vector2Int):UnityEngine.Vector2Int;
            public static op_Multiply($a: number, $b: UnityEngine.Vector2Int):UnityEngine.Vector2Int;
            public static op_Multiply($a: UnityEngine.Vector2Int, $b: number):UnityEngine.Vector2Int;
            public static op_Division($a: UnityEngine.Vector2Int, $b: number):UnityEngine.Vector2Int;
            public static op_Equality($lhs: UnityEngine.Vector2Int, $rhs: UnityEngine.Vector2Int):boolean;
            public static op_Inequality($lhs: UnityEngine.Vector2Int, $rhs: UnityEngine.Vector2Int):boolean;
            public Equals($other: any):boolean;
            public Equals($other: UnityEngine.Vector2Int):boolean;
            public ToString():string;
            public ToString($format: string):string;
            public ToString($format: string, $formatProvider: System.IFormatProvider):string;
            public constructor($x: number, $y: number);
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
            public constructor();
        }
        export class RectOffset extends System.Object implements System.IFormattable{ 
            public get left(): number;
            public set left(value: number);
            public get right(): number;
            public set right(value: number);
            public get top(): number;
            public set top(value: number);
            public get bottom(): number;
            public set bottom(value: number);
            public get horizontal(): number;
            public get vertical(): number;
            public ToString():string;
            public ToString($format: string):string;
            public ToString($format: string, $formatProvider: System.IFormatProvider):string;
            public Add($rect: UnityEngine.Rect):UnityEngine.Rect;
            public Remove($rect: UnityEngine.Rect):UnityEngine.Rect;
            public constructor();
            public constructor($left: number, $right: number, $top: number, $bottom: number);
        }
        export class DynamicGI extends System.Object{ 
            public static get indirectScale(): number;
            public static set indirectScale(value: number);
            public static get updateThreshold(): number;
            public static set updateThreshold(value: number);
            public static get materialUpdateTimeSlice(): number;
            public static set materialUpdateTimeSlice(value: number);
            public static get synchronousMode(): boolean;
            public static set synchronousMode(value: boolean);
            public static get isConverged(): boolean;
            public static SetEmissive($renderer: UnityEngine.Renderer, $color: UnityEngine.Color):void;
            public static SetEnvironmentData($input: System.Array$1<number>):void;
            public static UpdateEnvironment():void;
            public constructor();
        }
        export class Renderer extends UnityEngine.Component{ 
            public get bounds(): UnityEngine.Bounds;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get isVisible(): boolean;
            public get shadowCastingMode(): UnityEngine.Rendering.ShadowCastingMode;
            public set shadowCastingMode(value: UnityEngine.Rendering.ShadowCastingMode);
            public get receiveShadows(): boolean;
            public set receiveShadows(value: boolean);
            public get forceRenderingOff(): boolean;
            public set forceRenderingOff(value: boolean);
            public get staticShadowCaster(): boolean;
            public set staticShadowCaster(value: boolean);
            public get motionVectorGenerationMode(): UnityEngine.MotionVectorGenerationMode;
            public set motionVectorGenerationMode(value: UnityEngine.MotionVectorGenerationMode);
            public get lightProbeUsage(): UnityEngine.Rendering.LightProbeUsage;
            public set lightProbeUsage(value: UnityEngine.Rendering.LightProbeUsage);
            public get reflectionProbeUsage(): UnityEngine.Rendering.ReflectionProbeUsage;
            public set reflectionProbeUsage(value: UnityEngine.Rendering.ReflectionProbeUsage);
            public get renderingLayerMask(): number;
            public set renderingLayerMask(value: number);
            public get rendererPriority(): number;
            public set rendererPriority(value: number);
            public get rayTracingMode(): UnityEngine.Experimental.Rendering.RayTracingMode;
            public set rayTracingMode(value: UnityEngine.Experimental.Rendering.RayTracingMode);
            public get sortingLayerName(): string;
            public set sortingLayerName(value: string);
            public get sortingLayerID(): number;
            public set sortingLayerID(value: number);
            public get sortingOrder(): number;
            public set sortingOrder(value: number);
            public get allowOcclusionWhenDynamic(): boolean;
            public set allowOcclusionWhenDynamic(value: boolean);
            public get isPartOfStaticBatch(): boolean;
            public get worldToLocalMatrix(): UnityEngine.Matrix4x4;
            public get localToWorldMatrix(): UnityEngine.Matrix4x4;
            public get lightProbeProxyVolumeOverride(): UnityEngine.GameObject;
            public set lightProbeProxyVolumeOverride(value: UnityEngine.GameObject);
            public get probeAnchor(): UnityEngine.Transform;
            public set probeAnchor(value: UnityEngine.Transform);
            public get lightmapIndex(): number;
            public set lightmapIndex(value: number);
            public get realtimeLightmapIndex(): number;
            public set realtimeLightmapIndex(value: number);
            public get lightmapScaleOffset(): UnityEngine.Vector4;
            public set lightmapScaleOffset(value: UnityEngine.Vector4);
            public get realtimeLightmapScaleOffset(): UnityEngine.Vector4;
            public set realtimeLightmapScaleOffset(value: UnityEngine.Vector4);
            public get materials(): System.Array$1<UnityEngine.Material>;
            public set materials(value: System.Array$1<UnityEngine.Material>);
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public get sharedMaterial(): UnityEngine.Material;
            public set sharedMaterial(value: UnityEngine.Material);
            public get sharedMaterials(): System.Array$1<UnityEngine.Material>;
            public set sharedMaterials(value: System.Array$1<UnityEngine.Material>);
            public HasPropertyBlock():boolean;
            public SetPropertyBlock($properties: UnityEngine.MaterialPropertyBlock):void;
            public SetPropertyBlock($properties: UnityEngine.MaterialPropertyBlock, $materialIndex: number):void;
            public GetPropertyBlock($properties: UnityEngine.MaterialPropertyBlock):void;
            public GetPropertyBlock($properties: UnityEngine.MaterialPropertyBlock, $materialIndex: number):void;
            public GetMaterials($m: System.Collections.Generic.List$1<UnityEngine.Material>):void;
            public GetSharedMaterials($m: System.Collections.Generic.List$1<UnityEngine.Material>):void;
            public GetClosestReflectionProbes($result: System.Collections.Generic.List$1<UnityEngine.Rendering.ReflectionProbeBlendInfo>):void;
            public constructor();
        }
        interface Renderer {
            UpdateGIMaterials():void;
        }
        export class LightingSettings extends UnityEngine.Object{ 
            public get bakedGI(): boolean;
            public set bakedGI(value: boolean);
            public get realtimeGI(): boolean;
            public set realtimeGI(value: boolean);
            public get realtimeEnvironmentLighting(): boolean;
            public set realtimeEnvironmentLighting(value: boolean);
            public get autoGenerate(): boolean;
            public set autoGenerate(value: boolean);
            public get mixedBakeMode(): UnityEngine.MixedLightingMode;
            public set mixedBakeMode(value: UnityEngine.MixedLightingMode);
            public get albedoBoost(): number;
            public set albedoBoost(value: number);
            public get indirectScale(): number;
            public set indirectScale(value: number);
            public get lightmapper(): UnityEngine.LightingSettings.Lightmapper;
            public set lightmapper(value: UnityEngine.LightingSettings.Lightmapper);
            public get lightmapMaxSize(): number;
            public set lightmapMaxSize(value: number);
            public get lightmapResolution(): number;
            public set lightmapResolution(value: number);
            public get lightmapPadding(): number;
            public set lightmapPadding(value: number);
            public get compressLightmaps(): boolean;
            public set compressLightmaps(value: boolean);
            public get ao(): boolean;
            public set ao(value: boolean);
            public get aoMaxDistance(): number;
            public set aoMaxDistance(value: number);
            public get aoExponentIndirect(): number;
            public set aoExponentIndirect(value: number);
            public get aoExponentDirect(): number;
            public set aoExponentDirect(value: number);
            public get extractAO(): boolean;
            public set extractAO(value: boolean);
            public get directionalityMode(): UnityEngine.LightmapsMode;
            public set directionalityMode(value: UnityEngine.LightmapsMode);
            public get exportTrainingData(): boolean;
            public set exportTrainingData(value: boolean);
            public get trainingDataDestination(): string;
            public set trainingDataDestination(value: string);
            public get indirectResolution(): number;
            public set indirectResolution(value: number);
            public get finalGather(): boolean;
            public set finalGather(value: boolean);
            public get finalGatherRayCount(): number;
            public set finalGatherRayCount(value: number);
            public get finalGatherFiltering(): boolean;
            public set finalGatherFiltering(value: boolean);
            public get sampling(): UnityEngine.LightingSettings.Sampling;
            public set sampling(value: UnityEngine.LightingSettings.Sampling);
            public get directSampleCount(): number;
            public set directSampleCount(value: number);
            public get indirectSampleCount(): number;
            public set indirectSampleCount(value: number);
            public get maxBounces(): number;
            public set maxBounces(value: number);
            public get minBounces(): number;
            public set minBounces(value: number);
            public get prioritizeView(): boolean;
            public set prioritizeView(value: boolean);
            public get filteringMode(): UnityEngine.LightingSettings.FilterMode;
            public set filteringMode(value: UnityEngine.LightingSettings.FilterMode);
            public get denoiserTypeDirect(): UnityEngine.LightingSettings.DenoiserType;
            public set denoiserTypeDirect(value: UnityEngine.LightingSettings.DenoiserType);
            public get denoiserTypeIndirect(): UnityEngine.LightingSettings.DenoiserType;
            public set denoiserTypeIndirect(value: UnityEngine.LightingSettings.DenoiserType);
            public get denoiserTypeAO(): UnityEngine.LightingSettings.DenoiserType;
            public set denoiserTypeAO(value: UnityEngine.LightingSettings.DenoiserType);
            public get filterTypeDirect(): UnityEngine.LightingSettings.FilterType;
            public set filterTypeDirect(value: UnityEngine.LightingSettings.FilterType);
            public get filterTypeIndirect(): UnityEngine.LightingSettings.FilterType;
            public set filterTypeIndirect(value: UnityEngine.LightingSettings.FilterType);
            public get filterTypeAO(): UnityEngine.LightingSettings.FilterType;
            public set filterTypeAO(value: UnityEngine.LightingSettings.FilterType);
            public get filteringGaussRadiusDirect(): number;
            public set filteringGaussRadiusDirect(value: number);
            public get filteringGaussRadiusIndirect(): number;
            public set filteringGaussRadiusIndirect(value: number);
            public get filteringGaussRadiusAO(): number;
            public set filteringGaussRadiusAO(value: number);
            public get filteringAtrousPositionSigmaDirect(): number;
            public set filteringAtrousPositionSigmaDirect(value: number);
            public get filteringAtrousPositionSigmaIndirect(): number;
            public set filteringAtrousPositionSigmaIndirect(value: number);
            public get filteringAtrousPositionSigmaAO(): number;
            public set filteringAtrousPositionSigmaAO(value: number);
            public get environmentSampleCount(): number;
            public set environmentSampleCount(value: number);
            public get lightProbeSampleCountMultiplier(): number;
            public set lightProbeSampleCountMultiplier(value: number);
            public constructor();
        }
        export enum MixedLightingMode{ IndirectOnly = 0, Shadowmask = 2, Subtractive = 1 }
        export enum LightmapsMode{ NonDirectional = 0, CombinedDirectional = 1, SeparateDirectional = 2, Single = 0, Dual = 1, Directional = 2 }
        export class Gizmos extends System.Object{ 
            public static get color(): UnityEngine.Color;
            public static set color(value: UnityEngine.Color);
            public static get matrix(): UnityEngine.Matrix4x4;
            public static set matrix(value: UnityEngine.Matrix4x4);
            public static get exposure(): UnityEngine.Texture;
            public static set exposure(value: UnityEngine.Texture);
            public static get probeSize(): number;
            public static DrawLine($from: UnityEngine.Vector3, $to: UnityEngine.Vector3):void;
            public static DrawWireSphere($center: UnityEngine.Vector3, $radius: number):void;
            public static DrawSphere($center: UnityEngine.Vector3, $radius: number):void;
            public static DrawWireCube($center: UnityEngine.Vector3, $size: UnityEngine.Vector3):void;
            public static DrawCube($center: UnityEngine.Vector3, $size: UnityEngine.Vector3):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $scale: UnityEngine.Vector3):void;
            public static DrawWireMesh($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $scale: UnityEngine.Vector3):void;
            public static DrawIcon($center: UnityEngine.Vector3, $name: string, $allowScaling: boolean):void;
            public static DrawIcon($center: UnityEngine.Vector3, $name: string, $allowScaling: boolean, $tint: UnityEngine.Color):void;
            public static DrawGUITexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: UnityEngine.Material):void;
            public static DrawFrustum($center: UnityEngine.Vector3, $fov: number, $maxRange: number, $minRange: number, $aspect: number):void;
            public static DrawRay($r: UnityEngine.Ray):void;
            public static DrawRay($from: UnityEngine.Vector3, $direction: UnityEngine.Vector3):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3):void;
            public static DrawMesh($mesh: UnityEngine.Mesh):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $scale: UnityEngine.Vector3):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $submeshIndex: number):void;
            public static DrawWireMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion):void;
            public static DrawWireMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3):void;
            public static DrawWireMesh($mesh: UnityEngine.Mesh):void;
            public static DrawWireMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $scale: UnityEngine.Vector3):void;
            public static DrawWireMesh($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion):void;
            public static DrawWireMesh($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3):void;
            public static DrawWireMesh($mesh: UnityEngine.Mesh, $submeshIndex: number):void;
            public static DrawIcon($center: UnityEngine.Vector3, $name: string):void;
            public static DrawGUITexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture):void;
            public static DrawGUITexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $mat: UnityEngine.Material):void;
            public static DrawGUITexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number):void;
            public constructor();
        }
        export class Mesh extends UnityEngine.Object{ 
            public get indexFormat(): UnityEngine.Rendering.IndexFormat;
            public set indexFormat(value: UnityEngine.Rendering.IndexFormat);
            public get vertexBufferCount(): number;
            public get blendShapeCount(): number;
            public get bindposes(): System.Array$1<UnityEngine.Matrix4x4>;
            public set bindposes(value: System.Array$1<UnityEngine.Matrix4x4>);
            public get isReadable(): boolean;
            public get vertexCount(): number;
            public get subMeshCount(): number;
            public set subMeshCount(value: number);
            public get bounds(): UnityEngine.Bounds;
            public set bounds(value: UnityEngine.Bounds);
            public get vertices(): System.Array$1<UnityEngine.Vector3>;
            public set vertices(value: System.Array$1<UnityEngine.Vector3>);
            public get normals(): System.Array$1<UnityEngine.Vector3>;
            public set normals(value: System.Array$1<UnityEngine.Vector3>);
            public get tangents(): System.Array$1<UnityEngine.Vector4>;
            public set tangents(value: System.Array$1<UnityEngine.Vector4>);
            public get uv(): System.Array$1<UnityEngine.Vector2>;
            public set uv(value: System.Array$1<UnityEngine.Vector2>);
            public get uv2(): System.Array$1<UnityEngine.Vector2>;
            public set uv2(value: System.Array$1<UnityEngine.Vector2>);
            public get uv3(): System.Array$1<UnityEngine.Vector2>;
            public set uv3(value: System.Array$1<UnityEngine.Vector2>);
            public get uv4(): System.Array$1<UnityEngine.Vector2>;
            public set uv4(value: System.Array$1<UnityEngine.Vector2>);
            public get uv5(): System.Array$1<UnityEngine.Vector2>;
            public set uv5(value: System.Array$1<UnityEngine.Vector2>);
            public get uv6(): System.Array$1<UnityEngine.Vector2>;
            public set uv6(value: System.Array$1<UnityEngine.Vector2>);
            public get uv7(): System.Array$1<UnityEngine.Vector2>;
            public set uv7(value: System.Array$1<UnityEngine.Vector2>);
            public get uv8(): System.Array$1<UnityEngine.Vector2>;
            public set uv8(value: System.Array$1<UnityEngine.Vector2>);
            public get colors(): System.Array$1<UnityEngine.Color>;
            public set colors(value: System.Array$1<UnityEngine.Color>);
            public get colors32(): System.Array$1<UnityEngine.Color32>;
            public set colors32(value: System.Array$1<UnityEngine.Color32>);
            public get vertexAttributeCount(): number;
            public get triangles(): System.Array$1<number>;
            public set triangles(value: System.Array$1<number>);
            public get boneWeights(): System.Array$1<UnityEngine.BoneWeight>;
            public set boneWeights(value: System.Array$1<UnityEngine.BoneWeight>);
            public SetIndexBufferParams($indexCount: number, $format: UnityEngine.Rendering.IndexFormat):void;
            public GetVertexAttribute($index: number):UnityEngine.Rendering.VertexAttributeDescriptor;
            public HasVertexAttribute($attr: UnityEngine.Rendering.VertexAttribute):boolean;
            public GetVertexAttributeDimension($attr: UnityEngine.Rendering.VertexAttribute):number;
            public GetVertexAttributeFormat($attr: UnityEngine.Rendering.VertexAttribute):UnityEngine.Rendering.VertexAttributeFormat;
            public GetNativeVertexBufferPtr($index: number):System.IntPtr;
            public GetNativeIndexBufferPtr():System.IntPtr;
            public ClearBlendShapes():void;
            public GetBlendShapeName($shapeIndex: number):string;
            public GetBlendShapeIndex($blendShapeName: string):number;
            public GetBlendShapeFrameCount($shapeIndex: number):number;
            public GetBlendShapeFrameWeight($shapeIndex: number, $frameIndex: number):number;
            public GetBlendShapeFrameVertices($shapeIndex: number, $frameIndex: number, $deltaVertices: System.Array$1<UnityEngine.Vector3>, $deltaNormals: System.Array$1<UnityEngine.Vector3>, $deltaTangents: System.Array$1<UnityEngine.Vector3>):void;
            public AddBlendShapeFrame($shapeName: string, $frameWeight: number, $deltaVertices: System.Array$1<UnityEngine.Vector3>, $deltaNormals: System.Array$1<UnityEngine.Vector3>, $deltaTangents: System.Array$1<UnityEngine.Vector3>):void;
            public SetBoneWeights($bonesPerVertex: Unity.Collections.NativeArray$1<number>, $weights: Unity.Collections.NativeArray$1<UnityEngine.BoneWeight1>):void;
            public GetAllBoneWeights():Unity.Collections.NativeArray$1<UnityEngine.BoneWeight1>;
            public GetBonesPerVertex():Unity.Collections.NativeArray$1<number>;
            public SetSubMesh($index: number, $desc: UnityEngine.Rendering.SubMeshDescriptor, $flags?: UnityEngine.Rendering.MeshUpdateFlags):void;
            public GetSubMesh($index: number):UnityEngine.Rendering.SubMeshDescriptor;
            public MarkModified():void;
            public GetUVDistributionMetric($uvSetIndex: number):number;
            public GetVertices($vertices: System.Collections.Generic.List$1<UnityEngine.Vector3>):void;
            public SetVertices($inVertices: System.Collections.Generic.List$1<UnityEngine.Vector3>):void;
            public SetVertices($inVertices: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number):void;
            public SetVertices($inVertices: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags):void;
            public SetVertices($inVertices: System.Array$1<UnityEngine.Vector3>):void;
            public SetVertices($inVertices: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number):void;
            public SetVertices($inVertices: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags):void;
            public GetNormals($normals: System.Collections.Generic.List$1<UnityEngine.Vector3>):void;
            public SetNormals($inNormals: System.Collections.Generic.List$1<UnityEngine.Vector3>):void;
            public SetNormals($inNormals: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number):void;
            public SetNormals($inNormals: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags):void;
            public SetNormals($inNormals: System.Array$1<UnityEngine.Vector3>):void;
            public SetNormals($inNormals: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number):void;
            public SetNormals($inNormals: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags):void;
            public GetTangents($tangents: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
            public SetTangents($inTangents: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
            public SetTangents($inTangents: System.Collections.Generic.List$1<UnityEngine.Vector4>, $start: number, $length: number):void;
            public SetTangents($inTangents: System.Collections.Generic.List$1<UnityEngine.Vector4>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags):void;
            public SetTangents($inTangents: System.Array$1<UnityEngine.Vector4>):void;
            public SetTangents($inTangents: System.Array$1<UnityEngine.Vector4>, $start: number, $length: number):void;
            public SetTangents($inTangents: System.Array$1<UnityEngine.Vector4>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags):void;
            public GetColors($colors: System.Collections.Generic.List$1<UnityEngine.Color>):void;
            public SetColors($inColors: System.Collections.Generic.List$1<UnityEngine.Color>):void;
            public SetColors($inColors: System.Collections.Generic.List$1<UnityEngine.Color>, $start: number, $length: number):void;
            public SetColors($inColors: System.Collections.Generic.List$1<UnityEngine.Color>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags):void;
            public SetColors($inColors: System.Array$1<UnityEngine.Color>):void;
            public SetColors($inColors: System.Array$1<UnityEngine.Color>, $start: number, $length: number):void;
            public SetColors($inColors: System.Array$1<UnityEngine.Color>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags):void;
            public GetColors($colors: System.Collections.Generic.List$1<UnityEngine.Color32>):void;
            public SetColors($inColors: System.Collections.Generic.List$1<UnityEngine.Color32>):void;
            public SetColors($inColors: System.Collections.Generic.List$1<UnityEngine.Color32>, $start: number, $length: number):void;
            public SetColors($inColors: System.Collections.Generic.List$1<UnityEngine.Color32>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags):void;
            public SetColors($inColors: System.Array$1<UnityEngine.Color32>):void;
            public SetColors($inColors: System.Array$1<UnityEngine.Color32>, $start: number, $length: number):void;
            public SetColors($inColors: System.Array$1<UnityEngine.Color32>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags):void;
            public SetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector2>):void;
            public SetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector3>):void;
            public SetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
            public SetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector2>, $start: number, $length: number):void;
            public SetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector2>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags):void;
            public SetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number):void;
            public SetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags):void;
            public SetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector4>, $start: number, $length: number):void;
            public SetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector4>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags):void;
            public SetUVs($channel: number, $uvs: System.Array$1<UnityEngine.Vector2>):void;
            public SetUVs($channel: number, $uvs: System.Array$1<UnityEngine.Vector3>):void;
            public SetUVs($channel: number, $uvs: System.Array$1<UnityEngine.Vector4>):void;
            public SetUVs($channel: number, $uvs: System.Array$1<UnityEngine.Vector2>, $start: number, $length: number):void;
            public SetUVs($channel: number, $uvs: System.Array$1<UnityEngine.Vector2>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags):void;
            public SetUVs($channel: number, $uvs: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number):void;
            public SetUVs($channel: number, $uvs: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags):void;
            public SetUVs($channel: number, $uvs: System.Array$1<UnityEngine.Vector4>, $start: number, $length: number):void;
            public SetUVs($channel: number, $uvs: System.Array$1<UnityEngine.Vector4>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags):void;
            public GetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector2>):void;
            public GetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector3>):void;
            public GetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
            public GetVertexAttributes():System.Array$1<UnityEngine.Rendering.VertexAttributeDescriptor>;
            public GetVertexAttributes($attributes: System.Array$1<UnityEngine.Rendering.VertexAttributeDescriptor>):number;
            public GetVertexAttributes($attributes: System.Collections.Generic.List$1<UnityEngine.Rendering.VertexAttributeDescriptor>):number;
            public SetVertexBufferParams($vertexCount: number, ...attributes: UnityEngine.Rendering.VertexAttributeDescriptor[]):void;
            public SetVertexBufferParams($vertexCount: number, $attributes: Unity.Collections.NativeArray$1<UnityEngine.Rendering.VertexAttributeDescriptor>):void;
            public static AcquireReadOnlyMeshData($mesh: UnityEngine.Mesh):UnityEngine.Mesh.MeshDataArray;
            public static AcquireReadOnlyMeshData($meshes: System.Array$1<UnityEngine.Mesh>):UnityEngine.Mesh.MeshDataArray;
            public static AcquireReadOnlyMeshData($meshes: System.Collections.Generic.List$1<UnityEngine.Mesh>):UnityEngine.Mesh.MeshDataArray;
            public static AllocateWritableMeshData($meshCount: number):UnityEngine.Mesh.MeshDataArray;
            public static ApplyAndDisposeWritableMeshData($data: UnityEngine.Mesh.MeshDataArray, $mesh: UnityEngine.Mesh, $flags?: UnityEngine.Rendering.MeshUpdateFlags):void;
            public static ApplyAndDisposeWritableMeshData($data: UnityEngine.Mesh.MeshDataArray, $meshes: System.Array$1<UnityEngine.Mesh>, $flags?: UnityEngine.Rendering.MeshUpdateFlags):void;
            public static ApplyAndDisposeWritableMeshData($data: UnityEngine.Mesh.MeshDataArray, $meshes: System.Collections.Generic.List$1<UnityEngine.Mesh>, $flags?: UnityEngine.Rendering.MeshUpdateFlags):void;
            public GetTriangles($submesh: number):System.Array$1<number>;
            public GetTriangles($submesh: number, $applyBaseVertex: boolean):System.Array$1<number>;
            public GetTriangles($triangles: System.Collections.Generic.List$1<number>, $submesh: number):void;
            public GetTriangles($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $applyBaseVertex: boolean):void;
            public GetTriangles($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $applyBaseVertex?: boolean):void;
            public GetIndices($submesh: number):System.Array$1<number>;
            public GetIndices($submesh: number, $applyBaseVertex: boolean):System.Array$1<number>;
            public GetIndices($indices: System.Collections.Generic.List$1<number>, $submesh: number):void;
            public GetIndices($indices: System.Collections.Generic.List$1<number>, $submesh: number, $applyBaseVertex: boolean):void;
            public GetIndices($indices: System.Collections.Generic.List$1<number>, $submesh: number, $applyBaseVertex?: boolean):void;
            public GetIndexStart($submesh: number):number;
            public GetIndexCount($submesh: number):number;
            public GetBaseVertex($submesh: number):number;
            public SetTriangles($triangles: System.Array$1<number>, $submesh: number):void;
            public SetTriangles($triangles: System.Array$1<number>, $submesh: number, $calculateBounds: boolean):void;
            public SetTriangles($triangles: System.Array$1<number>, $submesh: number, $calculateBounds: boolean, $baseVertex: number):void;
            public SetTriangles($triangles: System.Array$1<number>, $trianglesStart: number, $trianglesLength: number, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
            public SetTriangles($triangles: System.Array$1<number>, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
            public SetTriangles($triangles: System.Array$1<number>, $trianglesStart: number, $trianglesLength: number, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
            public SetTriangles($triangles: System.Collections.Generic.List$1<number>, $submesh: number):void;
            public SetTriangles($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $calculateBounds: boolean):void;
            public SetTriangles($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $calculateBounds: boolean, $baseVertex: number):void;
            public SetTriangles($triangles: System.Collections.Generic.List$1<number>, $trianglesStart: number, $trianglesLength: number, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
            public SetTriangles($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
            public SetTriangles($triangles: System.Collections.Generic.List$1<number>, $trianglesStart: number, $trianglesLength: number, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
            public SetIndices($indices: System.Array$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number):void;
            public SetIndices($indices: System.Array$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds: boolean):void;
            public SetIndices($indices: System.Array$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds: boolean, $baseVertex: number):void;
            public SetIndices($indices: System.Array$1<number>, $indicesStart: number, $indicesLength: number, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
            public SetIndices($indices: System.Array$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
            public SetIndices($indices: System.Array$1<number>, $indicesStart: number, $indicesLength: number, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
            public SetIndices($indices: System.Collections.Generic.List$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
            public SetIndices($indices: System.Collections.Generic.List$1<number>, $indicesStart: number, $indicesLength: number, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
            public SetIndices($indices: System.Collections.Generic.List$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
            public SetIndices($indices: System.Collections.Generic.List$1<number>, $indicesStart: number, $indicesLength: number, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
            public SetSubMeshes($desc: System.Array$1<UnityEngine.Rendering.SubMeshDescriptor>, $start: number, $count: number, $flags?: UnityEngine.Rendering.MeshUpdateFlags):void;
            public SetSubMeshes($desc: System.Array$1<UnityEngine.Rendering.SubMeshDescriptor>, $flags?: UnityEngine.Rendering.MeshUpdateFlags):void;
            public SetSubMeshes($desc: System.Collections.Generic.List$1<UnityEngine.Rendering.SubMeshDescriptor>, $start: number, $count: number, $flags?: UnityEngine.Rendering.MeshUpdateFlags):void;
            public SetSubMeshes($desc: System.Collections.Generic.List$1<UnityEngine.Rendering.SubMeshDescriptor>, $flags?: UnityEngine.Rendering.MeshUpdateFlags):void;
            public GetBindposes($bindposes: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>):void;
            public GetBoneWeights($boneWeights: System.Collections.Generic.List$1<UnityEngine.BoneWeight>):void;
            public Clear($keepVertexLayout: boolean):void;
            public Clear():void;
            public RecalculateBounds():void;
            public RecalculateNormals():void;
            public RecalculateTangents():void;
            public RecalculateBounds($flags: UnityEngine.Rendering.MeshUpdateFlags):void;
            public RecalculateNormals($flags: UnityEngine.Rendering.MeshUpdateFlags):void;
            public RecalculateTangents($flags: UnityEngine.Rendering.MeshUpdateFlags):void;
            public RecalculateUVDistributionMetric($uvSetIndex: number, $uvAreaThreshold?: number):void;
            public RecalculateUVDistributionMetrics($uvAreaThreshold?: number):void;
            public MarkDynamic():void;
            public UploadMeshData($markNoLongerReadable: boolean):void;
            public Optimize():void;
            public OptimizeIndexBuffers():void;
            public OptimizeReorderVertexBuffer():void;
            public GetTopology($submesh: number):UnityEngine.MeshTopology;
            public CombineMeshes($combine: System.Array$1<UnityEngine.CombineInstance>, $mergeSubMeshes: boolean, $useMatrices: boolean, $hasLightmapData: boolean):void;
            public CombineMeshes($combine: System.Array$1<UnityEngine.CombineInstance>, $mergeSubMeshes: boolean, $useMatrices: boolean):void;
            public CombineMeshes($combine: System.Array$1<UnityEngine.CombineInstance>, $mergeSubMeshes: boolean):void;
            public CombineMeshes($combine: System.Array$1<UnityEngine.CombineInstance>):void;
            public constructor();
        }
        export class BeforeRenderOrderAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public get order(): number;
            public constructor($order: number);
            public constructor();
        }
        export class BillboardAsset extends UnityEngine.Object{ 
            public get width(): number;
            public set width(value: number);
            public get height(): number;
            public set height(value: number);
            public get bottom(): number;
            public set bottom(value: number);
            public get imageCount(): number;
            public get vertexCount(): number;
            public get indexCount(): number;
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public GetImageTexCoords($imageTexCoords: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
            public GetImageTexCoords():System.Array$1<UnityEngine.Vector4>;
            public SetImageTexCoords($imageTexCoords: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
            public SetImageTexCoords($imageTexCoords: System.Array$1<UnityEngine.Vector4>):void;
            public GetVertices($vertices: System.Collections.Generic.List$1<UnityEngine.Vector2>):void;
            public GetVertices():System.Array$1<UnityEngine.Vector2>;
            public SetVertices($vertices: System.Collections.Generic.List$1<UnityEngine.Vector2>):void;
            public SetVertices($vertices: System.Array$1<UnityEngine.Vector2>):void;
            public GetIndices($indices: System.Collections.Generic.List$1<number>):void;
            public GetIndices():System.Array$1<number>;
            public SetIndices($indices: System.Collections.Generic.List$1<number>):void;
            public SetIndices($indices: System.Array$1<number>):void;
            public constructor();
        }
        export class BillboardRenderer extends UnityEngine.Renderer{ 
            public get billboard(): UnityEngine.BillboardAsset;
            public set billboard(value: UnityEngine.BillboardAsset);
            public constructor();
        }
        export class CustomRenderTextureManager extends System.Object{ 
            public static add_textureLoaded($value: System.Action$1<UnityEngine.CustomRenderTexture>):void;
            public static remove_textureLoaded($value: System.Action$1<UnityEngine.CustomRenderTexture>):void;
            public static add_textureUnloaded($value: System.Action$1<UnityEngine.CustomRenderTexture>):void;
            public static remove_textureUnloaded($value: System.Action$1<UnityEngine.CustomRenderTexture>):void;
            public static GetAllCustomRenderTextures($currentCustomRenderTextures: System.Collections.Generic.List$1<UnityEngine.CustomRenderTexture>):void;
            public static add_updateTriggered($value: System.Action$2<UnityEngine.CustomRenderTexture, number>):void;
            public static remove_updateTriggered($value: System.Action$2<UnityEngine.CustomRenderTexture, number>):void;
            public static add_initializeTriggered($value: System.Action$1<UnityEngine.CustomRenderTexture>):void;
            public static remove_initializeTriggered($value: System.Action$1<UnityEngine.CustomRenderTexture>):void;
        }
        export class CustomRenderTexture extends UnityEngine.RenderTexture{ 
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public get initializationMaterial(): UnityEngine.Material;
            public set initializationMaterial(value: UnityEngine.Material);
            public get initializationTexture(): UnityEngine.Texture;
            public set initializationTexture(value: UnityEngine.Texture);
            public get initializationSource(): UnityEngine.CustomRenderTextureInitializationSource;
            public set initializationSource(value: UnityEngine.CustomRenderTextureInitializationSource);
            public get initializationColor(): UnityEngine.Color;
            public set initializationColor(value: UnityEngine.Color);
            public get updateMode(): UnityEngine.CustomRenderTextureUpdateMode;
            public set updateMode(value: UnityEngine.CustomRenderTextureUpdateMode);
            public get initializationMode(): UnityEngine.CustomRenderTextureUpdateMode;
            public set initializationMode(value: UnityEngine.CustomRenderTextureUpdateMode);
            public get updateZoneSpace(): UnityEngine.CustomRenderTextureUpdateZoneSpace;
            public set updateZoneSpace(value: UnityEngine.CustomRenderTextureUpdateZoneSpace);
            public get shaderPass(): number;
            public set shaderPass(value: number);
            public get cubemapFaceMask(): number;
            public set cubemapFaceMask(value: number);
            public get doubleBuffered(): boolean;
            public set doubleBuffered(value: boolean);
            public get wrapUpdateZones(): boolean;
            public set wrapUpdateZones(value: boolean);
            public get updatePeriod(): number;
            public set updatePeriod(value: number);
            public Update($count: number):void;
            public Update():void;
            public Initialize():void;
            public ClearUpdateZones():void;
            public GetUpdateZones($updateZones: System.Collections.Generic.List$1<UnityEngine.CustomRenderTextureUpdateZone>):void;
            public GetDoubleBufferRenderTexture():UnityEngine.RenderTexture;
            public EnsureDoubleBufferConsistency():void;
            public SetUpdateZones($updateZones: System.Array$1<UnityEngine.CustomRenderTextureUpdateZone>):void;
            public constructor($width: number, $height: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite);
            public constructor($width: number, $height: number, $format: UnityEngine.RenderTextureFormat);
            public constructor($width: number, $height: number);
            public constructor($width: number, $height: number, $defaultFormat: UnityEngine.Experimental.Rendering.DefaultFormat);
            public constructor($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat);
            public constructor($desc: UnityEngine.RenderTextureDescriptor);
            public constructor($textureToCopy: UnityEngine.RenderTexture);
            public constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat);
            public constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat);
            public constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number);
            public constructor($width: number, $height: number, $depth: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite);
            public constructor($width: number, $height: number, $depth: number, $format: UnityEngine.RenderTextureFormat);
            public constructor($width: number, $height: number, $depth: number);
            public constructor($width: number, $height: number, $depth: number, $format: UnityEngine.RenderTextureFormat, $mipCount: number);
            public constructor();
        }
        export class Display extends System.Object{ 
            public static displays: System.Array$1<UnityEngine.Display>;
            public get renderingWidth(): number;
            public get renderingHeight(): number;
            public get systemWidth(): number;
            public get systemHeight(): number;
            public get colorBuffer(): UnityEngine.RenderBuffer;
            public get depthBuffer(): UnityEngine.RenderBuffer;
            public get active(): boolean;
            public get requiresBlitToBackbuffer(): boolean;
            public get requiresSrgbBlitToBackbuffer(): boolean;
            public static get main(): UnityEngine.Display;
            public Activate():void;
            public Activate($width: number, $height: number, $refreshRate: number):void;
            public SetParams($width: number, $height: number, $x: number, $y: number):void;
            public SetRenderingResolution($w: number, $h: number):void;
            public static RelativeMouseAt($inputMouseCoordinates: UnityEngine.Vector3):UnityEngine.Vector3;
            public static add_onDisplaysUpdated($value: UnityEngine.Display.DisplaysUpdatedDelegate):void;
            public static remove_onDisplaysUpdated($value: UnityEngine.Display.DisplaysUpdatedDelegate):void;
        }
        export enum FullScreenMode{ ExclusiveFullScreen = 0, FullScreenWindow = 1, MaximizedWindow = 2, Windowed = 3 }
        export class SleepTimeout extends System.Object{ 
            public static NeverSleep: number;
            public static SystemSetting: number;
            public constructor();
        }
        export class Screen extends System.Object{ 
            public static get width(): number;
            public static get height(): number;
            public static get dpi(): number;
            public static get currentResolution(): UnityEngine.Resolution;
            public static get resolutions(): System.Array$1<UnityEngine.Resolution>;
            public static get fullScreen(): boolean;
            public static set fullScreen(value: boolean);
            public static get fullScreenMode(): UnityEngine.FullScreenMode;
            public static set fullScreenMode(value: UnityEngine.FullScreenMode);
            public static get safeArea(): UnityEngine.Rect;
            public static get cutouts(): System.Array$1<UnityEngine.Rect>;
            public static get autorotateToPortrait(): boolean;
            public static set autorotateToPortrait(value: boolean);
            public static get autorotateToPortraitUpsideDown(): boolean;
            public static set autorotateToPortraitUpsideDown(value: boolean);
            public static get autorotateToLandscapeLeft(): boolean;
            public static set autorotateToLandscapeLeft(value: boolean);
            public static get autorotateToLandscapeRight(): boolean;
            public static set autorotateToLandscapeRight(value: boolean);
            public static get orientation(): UnityEngine.ScreenOrientation;
            public static set orientation(value: UnityEngine.ScreenOrientation);
            public static get sleepTimeout(): number;
            public static set sleepTimeout(value: number);
            public static get brightness(): number;
            public static set brightness(value: number);
            public static SetResolution($width: number, $height: number, $fullscreenMode: UnityEngine.FullScreenMode, $preferredRefreshRate: number):void;
            public static SetResolution($width: number, $height: number, $fullscreenMode: UnityEngine.FullScreenMode):void;
            public static SetResolution($width: number, $height: number, $fullscreen: boolean, $preferredRefreshRate: number):void;
            public static SetResolution($width: number, $height: number, $fullscreen: boolean):void;
            public constructor();
        }
        export enum ScreenOrientation{ Unknown = 0, Portrait = 1, PortraitUpsideDown = 2, LandscapeLeft = 3, LandscapeRight = 4, AutoRotation = 5, Landscape = 3 }
        export enum ComputeBufferMode{ Immutable = 0, Dynamic = 1, Circular = 2, StreamOut = 3, SubUpdates = 4 }
        export class Graphics extends System.Object{ 
            public static get activeColorGamut(): UnityEngine.ColorGamut;
            public static get activeTier(): UnityEngine.Rendering.GraphicsTier;
            public static set activeTier(value: UnityEngine.Rendering.GraphicsTier);
            public static get preserveFramebufferAlpha(): boolean;
            public static get minOpenGLESVersion(): UnityEngine.Rendering.OpenGLESVersion;
            public static get activeColorBuffer(): UnityEngine.RenderBuffer;
            public static get activeDepthBuffer(): UnityEngine.RenderBuffer;
            public static ClearRandomWriteTargets():void;
            public static ExecuteCommandBuffer($buffer: UnityEngine.Rendering.CommandBuffer):void;
            public static ExecuteCommandBufferAsync($buffer: UnityEngine.Rendering.CommandBuffer, $queueType: UnityEngine.Rendering.ComputeQueueType):void;
            public static SetRenderTarget($rt: UnityEngine.RenderTexture, $mipLevel: number, $face: UnityEngine.CubemapFace, $depthSlice: number):void;
            public static SetRenderTarget($colorBuffer: UnityEngine.RenderBuffer, $depthBuffer: UnityEngine.RenderBuffer, $mipLevel: number, $face: UnityEngine.CubemapFace, $depthSlice: number):void;
            public static SetRenderTarget($colorBuffers: System.Array$1<UnityEngine.RenderBuffer>, $depthBuffer: UnityEngine.RenderBuffer):void;
            public static SetRenderTarget($setup: UnityEngine.RenderTargetSetup):void;
            public static SetRandomWriteTarget($index: number, $uav: UnityEngine.RenderTexture):void;
            public static SetRandomWriteTarget($index: number, $uav: UnityEngine.ComputeBuffer, $preserveCounterValue: boolean):void;
            public static SetRandomWriteTarget($index: number, $uav: UnityEngine.GraphicsBuffer, $preserveCounterValue: boolean):void;
            public static CopyTexture($src: UnityEngine.Texture, $dst: UnityEngine.Texture):void;
            public static CopyTexture($src: UnityEngine.Texture, $srcElement: number, $dst: UnityEngine.Texture, $dstElement: number):void;
            public static CopyTexture($src: UnityEngine.Texture, $srcElement: number, $srcMip: number, $dst: UnityEngine.Texture, $dstElement: number, $dstMip: number):void;
            public static CopyTexture($src: UnityEngine.Texture, $srcElement: number, $srcMip: number, $srcX: number, $srcY: number, $srcWidth: number, $srcHeight: number, $dst: UnityEngine.Texture, $dstElement: number, $dstMip: number, $dstX: number, $dstY: number):void;
            public static ConvertTexture($src: UnityEngine.Texture, $dst: UnityEngine.Texture):boolean;
            public static ConvertTexture($src: UnityEngine.Texture, $srcElement: number, $dst: UnityEngine.Texture, $dstElement: number):boolean;
            public static CreateAsyncGraphicsFence($stage: UnityEngine.Rendering.SynchronisationStage):UnityEngine.Rendering.GraphicsFence;
            public static CreateAsyncGraphicsFence():UnityEngine.Rendering.GraphicsFence;
            public static CreateGraphicsFence($fenceType: UnityEngine.Rendering.GraphicsFenceType, $stage: UnityEngine.Rendering.SynchronisationStageFlags):UnityEngine.Rendering.GraphicsFence;
            public static WaitOnAsyncGraphicsFence($fence: UnityEngine.Rendering.GraphicsFence):void;
            public static WaitOnAsyncGraphicsFence($fence: UnityEngine.Rendering.GraphicsFence, $stage: UnityEngine.Rendering.SynchronisationStage):void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $color: UnityEngine.Color, $mat: UnityEngine.Material, $pass: number):void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: UnityEngine.Material, $pass: number):void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: UnityEngine.Material, $pass: number):void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $mat: UnityEngine.Material, $pass: number):void;
            public static DrawMeshNow($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $materialIndex: number):void;
            public static DrawMeshNow($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $materialIndex: number):void;
            public static DrawMeshNow($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion):void;
            public static DrawMeshNow($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean, $useLightProbes: boolean):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform, $useLightProbes: boolean):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean, $useLightProbes: boolean):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume):void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume):void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume):void;
            public static DrawMeshInstancedProcedural($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $count: number, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number, $camera?: UnityEngine.Camera, $lightProbeUsage?: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume?: UnityEngine.LightProbeProxyVolume):void;
            public static DrawMeshInstancedIndirect($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume):void;
            public static DrawMeshInstancedIndirect($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume):void;
            public static DrawProceduralNow($topology: UnityEngine.MeshTopology, $vertexCount: number, $instanceCount?: number):void;
            public static DrawProceduralNow($topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $indexCount: number, $instanceCount?: number):void;
            public static DrawProceduralIndirectNow($topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset?: number):void;
            public static DrawProceduralIndirectNow($topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset?: number):void;
            public static DrawProceduralIndirectNow($topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset?: number):void;
            public static DrawProceduralIndirectNow($topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset?: number):void;
            public static DrawProcedural($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $vertexCount: number, $instanceCount?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number):void;
            public static DrawProcedural($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $indexCount: number, $instanceCount?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number):void;
            public static DrawProceduralIndirect($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number):void;
            public static DrawProceduralIndirect($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number):void;
            public static Blit($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture):void;
            public static Blit($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $sourceDepthSlice: number, $destDepthSlice: number):void;
            public static Blit($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2):void;
            public static Blit($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2, $sourceDepthSlice: number, $destDepthSlice: number):void;
            public static Blit($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $mat: UnityEngine.Material, $pass: number):void;
            public static Blit($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $mat: UnityEngine.Material, $pass: number, $destDepthSlice: number):void;
            public static Blit($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $mat: UnityEngine.Material):void;
            public static Blit($source: UnityEngine.Texture, $mat: UnityEngine.Material, $pass: number):void;
            public static Blit($source: UnityEngine.Texture, $mat: UnityEngine.Material, $pass: number, $destDepthSlice: number):void;
            public static Blit($source: UnityEngine.Texture, $mat: UnityEngine.Material):void;
            public static BlitMultiTap($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $mat: UnityEngine.Material, ...offsets: UnityEngine.Vector2[]):void;
            public static BlitMultiTap($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $mat: UnityEngine.Material, $destDepthSlice: number, ...offsets: UnityEngine.Vector2[]):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform, $useLightProbes: boolean):void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage):void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>):void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number):void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock):void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode):void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean):void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number):void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera):void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage):void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>):void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock):void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode):void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean):void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number):void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera):void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage):void;
            public static DrawMeshInstancedIndirect($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset?: number, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number, $camera?: UnityEngine.Camera, $lightProbeUsage?: UnityEngine.Rendering.LightProbeUsage):void;
            public static DrawMeshInstancedIndirect($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset?: number, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number, $camera?: UnityEngine.Camera, $lightProbeUsage?: UnityEngine.Rendering.LightProbeUsage):void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $color: UnityEngine.Color, $mat: UnityEngine.Material):void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $color: UnityEngine.Color):void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: UnityEngine.Material):void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number):void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: UnityEngine.Material):void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number):void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $mat: UnityEngine.Material):void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture):void;
            public static SetRenderTarget($rt: UnityEngine.RenderTexture):void;
            public static SetRenderTarget($rt: UnityEngine.RenderTexture, $mipLevel: number):void;
            public static SetRenderTarget($rt: UnityEngine.RenderTexture, $mipLevel: number, $face: UnityEngine.CubemapFace):void;
            public static SetRenderTarget($colorBuffer: UnityEngine.RenderBuffer, $depthBuffer: UnityEngine.RenderBuffer):void;
            public static SetRenderTarget($colorBuffer: UnityEngine.RenderBuffer, $depthBuffer: UnityEngine.RenderBuffer, $mipLevel: number):void;
            public static SetRenderTarget($colorBuffer: UnityEngine.RenderBuffer, $depthBuffer: UnityEngine.RenderBuffer, $mipLevel: number, $face: UnityEngine.CubemapFace):void;
            public static SetRandomWriteTarget($index: number, $uav: UnityEngine.ComputeBuffer):void;
            public static SetRandomWriteTarget($index: number, $uav: UnityEngine.GraphicsBuffer):void;
            public constructor();
        }
        export enum ColorGamut{ sRGB = 0, Rec709 = 1, Rec2020 = 2, DisplayP3 = 3, HDR10 = 4, DolbyHDR = 5 }
        export enum CubemapFace{ Unknown = -1, PositiveX = 0, NegativeX = 1, PositiveY = 2, NegativeY = 3, PositiveZ = 4, NegativeZ = 5 }
        export class RenderTargetSetup extends System.ValueType{ 
            public color: System.Array$1<UnityEngine.RenderBuffer>;
            public depth: UnityEngine.RenderBuffer;
            public mipLevel: number;
            public cubemapFace: UnityEngine.CubemapFace;
            public depthSlice: number;
            public colorLoad: System.Array$1<UnityEngine.Rendering.RenderBufferLoadAction>;
            public colorStore: System.Array$1<UnityEngine.Rendering.RenderBufferStoreAction>;
            public depthLoad: UnityEngine.Rendering.RenderBufferLoadAction;
            public depthStore: UnityEngine.Rendering.RenderBufferStoreAction;
            public constructor($color: System.Array$1<UnityEngine.RenderBuffer>, $depth: UnityEngine.RenderBuffer, $mip: number, $face: UnityEngine.CubemapFace, $colorLoad: System.Array$1<UnityEngine.Rendering.RenderBufferLoadAction>, $colorStore: System.Array$1<UnityEngine.Rendering.RenderBufferStoreAction>, $depthLoad: UnityEngine.Rendering.RenderBufferLoadAction, $depthStore: UnityEngine.Rendering.RenderBufferStoreAction);
            public constructor($color: UnityEngine.RenderBuffer, $depth: UnityEngine.RenderBuffer);
            public constructor($color: UnityEngine.RenderBuffer, $depth: UnityEngine.RenderBuffer, $mipLevel: number);
            public constructor($color: UnityEngine.RenderBuffer, $depth: UnityEngine.RenderBuffer, $mipLevel: number, $face: UnityEngine.CubemapFace);
            public constructor($color: UnityEngine.RenderBuffer, $depth: UnityEngine.RenderBuffer, $mipLevel: number, $face: UnityEngine.CubemapFace, $depthSlice: number);
            public constructor($color: System.Array$1<UnityEngine.RenderBuffer>, $depth: UnityEngine.RenderBuffer);
            public constructor($color: System.Array$1<UnityEngine.RenderBuffer>, $depth: UnityEngine.RenderBuffer, $mipLevel: number);
            public constructor($color: System.Array$1<UnityEngine.RenderBuffer>, $depth: UnityEngine.RenderBuffer, $mip: number, $face: UnityEngine.CubemapFace);
            public constructor();
        }
        export class ComputeBuffer extends System.Object implements System.IDisposable{ 
            public get count(): number;
            public get stride(): number;
            public set name(value: string);
            public Dispose():void;
            public Release():void;
            public IsValid():boolean;
            public SetData($data: System.Array):void;
            public SetData($data: System.Array, $managedBufferStartIndex: number, $computeBufferStartIndex: number, $count: number):void;
            public GetData($data: System.Array):void;
            public GetData($data: System.Array, $managedBufferStartIndex: number, $computeBufferStartIndex: number, $count: number):void;
            public SetCounterValue($counterValue: number):void;
            public static CopyCount($src: UnityEngine.ComputeBuffer, $dst: UnityEngine.ComputeBuffer, $dstOffsetBytes: number):void;
            public GetNativeBufferPtr():System.IntPtr;
            public constructor($count: number, $stride: number);
            public constructor($count: number, $stride: number, $type: UnityEngine.ComputeBufferType);
            public constructor($count: number, $stride: number, $type: UnityEngine.ComputeBufferType, $usage: UnityEngine.ComputeBufferMode);
            public constructor();
        }
        export class GraphicsBuffer extends System.Object implements System.IDisposable{ 
            public get count(): number;
            public get stride(): number;
            public Dispose():void;
            public Release():void;
            public IsValid():boolean;
            public SetData($data: System.Array):void;
            public SetData($data: System.Array, $managedBufferStartIndex: number, $graphicsBufferStartIndex: number, $count: number):void;
            public GetData($data: System.Array):void;
            public GetData($data: System.Array, $managedBufferStartIndex: number, $computeBufferStartIndex: number, $count: number):void;
            public GetNativeBufferPtr():System.IntPtr;
            public SetCounterValue($counterValue: number):void;
            public static CopyCount($src: UnityEngine.ComputeBuffer, $dst: UnityEngine.ComputeBuffer, $dstOffsetBytes: number):void;
            public static CopyCount($src: UnityEngine.GraphicsBuffer, $dst: UnityEngine.ComputeBuffer, $dstOffsetBytes: number):void;
            public static CopyCount($src: UnityEngine.ComputeBuffer, $dst: UnityEngine.GraphicsBuffer, $dstOffsetBytes: number):void;
            public static CopyCount($src: UnityEngine.GraphicsBuffer, $dst: UnityEngine.GraphicsBuffer, $dstOffsetBytes: number):void;
            public constructor($target: UnityEngine.GraphicsBuffer.Target, $count: number, $stride: number);
            public constructor();
        }
        export class MaterialPropertyBlock extends System.Object{ 
            public get isEmpty(): boolean;
            public Clear():void;
            public SetInt($name: string, $value: number):void;
            public SetInt($nameID: number, $value: number):void;
            public SetFloat($name: string, $value: number):void;
            public SetFloat($nameID: number, $value: number):void;
            public SetInteger($name: string, $value: number):void;
            public SetInteger($nameID: number, $value: number):void;
            public SetVector($name: string, $value: UnityEngine.Vector4):void;
            public SetVector($nameID: number, $value: UnityEngine.Vector4):void;
            public SetColor($name: string, $value: UnityEngine.Color):void;
            public SetColor($nameID: number, $value: UnityEngine.Color):void;
            public SetMatrix($name: string, $value: UnityEngine.Matrix4x4):void;
            public SetMatrix($nameID: number, $value: UnityEngine.Matrix4x4):void;
            public SetBuffer($name: string, $value: UnityEngine.ComputeBuffer):void;
            public SetBuffer($nameID: number, $value: UnityEngine.ComputeBuffer):void;
            public SetBuffer($name: string, $value: UnityEngine.GraphicsBuffer):void;
            public SetBuffer($nameID: number, $value: UnityEngine.GraphicsBuffer):void;
            public SetTexture($name: string, $value: UnityEngine.Texture):void;
            public SetTexture($nameID: number, $value: UnityEngine.Texture):void;
            public SetTexture($name: string, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement):void;
            public SetTexture($nameID: number, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement):void;
            public SetConstantBuffer($name: string, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number):void;
            public SetConstantBuffer($nameID: number, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number):void;
            public SetConstantBuffer($name: string, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number):void;
            public SetConstantBuffer($nameID: number, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number):void;
            public SetFloatArray($name: string, $values: System.Collections.Generic.List$1<number>):void;
            public SetFloatArray($nameID: number, $values: System.Collections.Generic.List$1<number>):void;
            public SetFloatArray($name: string, $values: System.Array$1<number>):void;
            public SetFloatArray($nameID: number, $values: System.Array$1<number>):void;
            public SetVectorArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
            public SetVectorArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
            public SetVectorArray($name: string, $values: System.Array$1<UnityEngine.Vector4>):void;
            public SetVectorArray($nameID: number, $values: System.Array$1<UnityEngine.Vector4>):void;
            public SetMatrixArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>):void;
            public SetMatrixArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>):void;
            public SetMatrixArray($name: string, $values: System.Array$1<UnityEngine.Matrix4x4>):void;
            public SetMatrixArray($nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>):void;
            public HasProperty($name: string):boolean;
            public HasProperty($nameID: number):boolean;
            public HasInt($name: string):boolean;
            public HasInt($nameID: number):boolean;
            public HasFloat($name: string):boolean;
            public HasFloat($nameID: number):boolean;
            public HasInteger($name: string):boolean;
            public HasInteger($nameID: number):boolean;
            public HasTexture($name: string):boolean;
            public HasTexture($nameID: number):boolean;
            public HasMatrix($name: string):boolean;
            public HasMatrix($nameID: number):boolean;
            public HasVector($name: string):boolean;
            public HasVector($nameID: number):boolean;
            public HasColor($name: string):boolean;
            public HasColor($nameID: number):boolean;
            public HasBuffer($name: string):boolean;
            public HasBuffer($nameID: number):boolean;
            public HasConstantBuffer($name: string):boolean;
            public HasConstantBuffer($nameID: number):boolean;
            public GetFloat($name: string):number;
            public GetFloat($nameID: number):number;
            public GetInt($name: string):number;
            public GetInt($nameID: number):number;
            public GetInteger($name: string):number;
            public GetInteger($nameID: number):number;
            public GetVector($name: string):UnityEngine.Vector4;
            public GetVector($nameID: number):UnityEngine.Vector4;
            public GetColor($name: string):UnityEngine.Color;
            public GetColor($nameID: number):UnityEngine.Color;
            public GetMatrix($name: string):UnityEngine.Matrix4x4;
            public GetMatrix($nameID: number):UnityEngine.Matrix4x4;
            public GetTexture($name: string):UnityEngine.Texture;
            public GetTexture($nameID: number):UnityEngine.Texture;
            public GetFloatArray($name: string):System.Array$1<number>;
            public GetFloatArray($nameID: number):System.Array$1<number>;
            public GetVectorArray($name: string):System.Array$1<UnityEngine.Vector4>;
            public GetVectorArray($nameID: number):System.Array$1<UnityEngine.Vector4>;
            public GetMatrixArray($name: string):System.Array$1<UnityEngine.Matrix4x4>;
            public GetMatrixArray($nameID: number):System.Array$1<UnityEngine.Matrix4x4>;
            public GetFloatArray($name: string, $values: System.Collections.Generic.List$1<number>):void;
            public GetFloatArray($nameID: number, $values: System.Collections.Generic.List$1<number>):void;
            public GetVectorArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
            public GetVectorArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
            public GetMatrixArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>):void;
            public GetMatrixArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>):void;
            public CopySHCoefficientArraysFrom($lightProbes: System.Collections.Generic.List$1<UnityEngine.Rendering.SphericalHarmonicsL2>):void;
            public CopySHCoefficientArraysFrom($lightProbes: System.Array$1<UnityEngine.Rendering.SphericalHarmonicsL2>):void;
            public CopySHCoefficientArraysFrom($lightProbes: System.Collections.Generic.List$1<UnityEngine.Rendering.SphericalHarmonicsL2>, $sourceStart: number, $destStart: number, $count: number):void;
            public CopySHCoefficientArraysFrom($lightProbes: System.Array$1<UnityEngine.Rendering.SphericalHarmonicsL2>, $sourceStart: number, $destStart: number, $count: number):void;
            public CopyProbeOcclusionArrayFrom($occlusionProbes: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
            public CopyProbeOcclusionArrayFrom($occlusionProbes: System.Array$1<UnityEngine.Vector4>):void;
            public CopyProbeOcclusionArrayFrom($occlusionProbes: System.Collections.Generic.List$1<UnityEngine.Vector4>, $sourceStart: number, $destStart: number, $count: number):void;
            public CopyProbeOcclusionArrayFrom($occlusionProbes: System.Array$1<UnityEngine.Vector4>, $sourceStart: number, $destStart: number, $count: number):void;
            public constructor();
        }
        export class LightProbeProxyVolume extends UnityEngine.Behaviour{ 
            public static get isFeatureSupported(): boolean;
            public get boundsGlobal(): UnityEngine.Bounds;
            public get sizeCustom(): UnityEngine.Vector3;
            public set sizeCustom(value: UnityEngine.Vector3);
            public get originCustom(): UnityEngine.Vector3;
            public set originCustom(value: UnityEngine.Vector3);
            public get probeDensity(): number;
            public set probeDensity(value: number);
            public get gridResolutionX(): number;
            public set gridResolutionX(value: number);
            public get gridResolutionY(): number;
            public set gridResolutionY(value: number);
            public get gridResolutionZ(): number;
            public set gridResolutionZ(value: number);
            public get boundingBoxMode(): UnityEngine.LightProbeProxyVolume.BoundingBoxMode;
            public set boundingBoxMode(value: UnityEngine.LightProbeProxyVolume.BoundingBoxMode);
            public get resolutionMode(): UnityEngine.LightProbeProxyVolume.ResolutionMode;
            public set resolutionMode(value: UnityEngine.LightProbeProxyVolume.ResolutionMode);
            public get probePositionMode(): UnityEngine.LightProbeProxyVolume.ProbePositionMode;
            public set probePositionMode(value: UnityEngine.LightProbeProxyVolume.ProbePositionMode);
            public get refreshMode(): UnityEngine.LightProbeProxyVolume.RefreshMode;
            public set refreshMode(value: UnityEngine.LightProbeProxyVolume.RefreshMode);
            public get qualityMode(): UnityEngine.LightProbeProxyVolume.QualityMode;
            public set qualityMode(value: UnityEngine.LightProbeProxyVolume.QualityMode);
            public get dataFormat(): UnityEngine.LightProbeProxyVolume.DataFormat;
            public set dataFormat(value: UnityEngine.LightProbeProxyVolume.DataFormat);
            public Update():void;
            public constructor();
        }
        export enum MeshTopology{ Triangles = 0, Quads = 2, Lines = 3, LineStrip = 4, Points = 5 }
        export class GL extends System.Object{ 
            public static TRIANGLES: number;
            public static TRIANGLE_STRIP: number;
            public static QUADS: number;
            public static LINES: number;
            public static LINE_STRIP: number;
            public static get wireframe(): boolean;
            public static set wireframe(value: boolean);
            public static get sRGBWrite(): boolean;
            public static set sRGBWrite(value: boolean);
            public static get invertCulling(): boolean;
            public static set invertCulling(value: boolean);
            public static get modelview(): UnityEngine.Matrix4x4;
            public static set modelview(value: UnityEngine.Matrix4x4);
            public static Vertex3($x: number, $y: number, $z: number):void;
            public static Vertex($v: UnityEngine.Vector3):void;
            public static TexCoord3($x: number, $y: number, $z: number):void;
            public static TexCoord($v: UnityEngine.Vector3):void;
            public static TexCoord2($x: number, $y: number):void;
            public static MultiTexCoord3($unit: number, $x: number, $y: number, $z: number):void;
            public static MultiTexCoord($unit: number, $v: UnityEngine.Vector3):void;
            public static MultiTexCoord2($unit: number, $x: number, $y: number):void;
            public static Color($c: UnityEngine.Color):void;
            public static Flush():void;
            public static RenderTargetBarrier():void;
            public static MultMatrix($m: UnityEngine.Matrix4x4):void;
            public static PushMatrix():void;
            public static PopMatrix():void;
            public static LoadIdentity():void;
            public static LoadOrtho():void;
            public static LoadPixelMatrix():void;
            public static LoadProjectionMatrix($mat: UnityEngine.Matrix4x4):void;
            public static InvalidateState():void;
            public static GetGPUProjectionMatrix($proj: UnityEngine.Matrix4x4, $renderIntoTexture: boolean):UnityEngine.Matrix4x4;
            public static LoadPixelMatrix($left: number, $right: number, $bottom: number, $top: number):void;
            public static IssuePluginEvent($callback: System.IntPtr, $eventID: number):void;
            public static Begin($mode: number):void;
            public static End():void;
            public static Clear($clearDepth: boolean, $clearColor: boolean, $backgroundColor: UnityEngine.Color, $depth: number):void;
            public static Clear($clearDepth: boolean, $clearColor: boolean, $backgroundColor: UnityEngine.Color):void;
            public static Viewport($pixelRect: UnityEngine.Rect):void;
            public static ClearWithSkybox($clearDepth: boolean, $camera: UnityEngine.Camera):void;
            public constructor();
        }
        export class ScalableBufferManager extends System.Object{ 
            public static get widthScaleFactor(): number;
            public static get heightScaleFactor(): number;
            public static ResizeBuffers($widthScale: number, $heightScale: number):void;
        }
        export class FrameTiming extends System.ValueType{ 
            public cpuTimePresentCalled: bigint;
            public cpuFrameTime: number;
            public cpuTimeFrameComplete: bigint;
            public gpuFrameTime: number;
            public heightScale: number;
            public widthScale: number;
            public syncInterval: number;
        }
        export class FrameTimingManager extends System.Object{ 
            public static CaptureFrameTimings():void;
            public static GetLatestTimings($numFrames: number, $timings: System.Array$1<UnityEngine.FrameTiming>):number;
            public static GetVSyncsPerSecond():number;
            public static GetGpuTimerFrequency():bigint;
            public static GetCpuTimerFrequency():bigint;
        }
        export class LightmapData extends System.Object{ 
            public get lightmapColor(): UnityEngine.Texture2D;
            public set lightmapColor(value: UnityEngine.Texture2D);
            public get lightmapDir(): UnityEngine.Texture2D;
            public set lightmapDir(value: UnityEngine.Texture2D);
            public get shadowMask(): UnityEngine.Texture2D;
            public set shadowMask(value: UnityEngine.Texture2D);
            public constructor();
        }
        export class Texture2D extends UnityEngine.Texture{ 
            public get format(): UnityEngine.TextureFormat;
            public static get whiteTexture(): UnityEngine.Texture2D;
            public static get blackTexture(): UnityEngine.Texture2D;
            public static get redTexture(): UnityEngine.Texture2D;
            public static get grayTexture(): UnityEngine.Texture2D;
            public static get linearGrayTexture(): UnityEngine.Texture2D;
            public static get normalTexture(): UnityEngine.Texture2D;
            public get isReadable(): boolean;
            public get vtOnly(): boolean;
            public get streamingMipmaps(): boolean;
            public get streamingMipmapsPriority(): number;
            public get requestedMipmapLevel(): number;
            public set requestedMipmapLevel(value: number);
            public get minimumMipmapLevel(): number;
            public set minimumMipmapLevel(value: number);
            public get calculatedMipmapLevel(): number;
            public get desiredMipmapLevel(): number;
            public get loadingMipmapLevel(): number;
            public get loadedMipmapLevel(): number;
            public Compress($highQuality: boolean):void;
            public ClearRequestedMipmapLevel():void;
            public IsRequestedMipmapLevelLoaded():boolean;
            public ClearMinimumMipmapLevel():void;
            public UpdateExternalTexture($nativeTex: System.IntPtr):void;
            public GetRawTextureData():System.Array$1<number>;
            public GetPixels($x: number, $y: number, $blockWidth: number, $blockHeight: number, $miplevel: number):System.Array$1<UnityEngine.Color>;
            public GetPixels($x: number, $y: number, $blockWidth: number, $blockHeight: number):System.Array$1<UnityEngine.Color>;
            public GetPixels32($miplevel: number):System.Array$1<UnityEngine.Color32>;
            public GetPixels32():System.Array$1<UnityEngine.Color32>;
            public PackTextures($textures: System.Array$1<UnityEngine.Texture2D>, $padding: number, $maximumAtlasSize: number, $makeNoLongerReadable: boolean):System.Array$1<UnityEngine.Rect>;
            public PackTextures($textures: System.Array$1<UnityEngine.Texture2D>, $padding: number, $maximumAtlasSize: number):System.Array$1<UnityEngine.Rect>;
            public PackTextures($textures: System.Array$1<UnityEngine.Texture2D>, $padding: number):System.Array$1<UnityEngine.Rect>;
            public static CreateExternalTexture($width: number, $height: number, $format: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean, $nativeTex: System.IntPtr):UnityEngine.Texture2D;
            public SetPixel($x: number, $y: number, $color: UnityEngine.Color):void;
            public SetPixel($x: number, $y: number, $color: UnityEngine.Color, $mipLevel: number):void;
            public SetPixels($x: number, $y: number, $blockWidth: number, $blockHeight: number, $colors: System.Array$1<UnityEngine.Color>, $miplevel: number):void;
            public SetPixels($x: number, $y: number, $blockWidth: number, $blockHeight: number, $colors: System.Array$1<UnityEngine.Color>):void;
            public SetPixels($colors: System.Array$1<UnityEngine.Color>, $miplevel: number):void;
            public SetPixels($colors: System.Array$1<UnityEngine.Color>):void;
            public GetPixel($x: number, $y: number):UnityEngine.Color;
            public GetPixel($x: number, $y: number, $mipLevel: number):UnityEngine.Color;
            public GetPixelBilinear($u: number, $v: number):UnityEngine.Color;
            public GetPixelBilinear($u: number, $v: number, $mipLevel: number):UnityEngine.Color;
            public LoadRawTextureData($data: System.IntPtr, $size: number):void;
            public LoadRawTextureData($data: System.Array$1<number>):void;
            public Apply($updateMipmaps: boolean, $makeNoLongerReadable: boolean):void;
            public Apply($updateMipmaps: boolean):void;
            public Apply():void;
            public Resize($width: number, $height: number):boolean;
            public Resize($width: number, $height: number, $format: UnityEngine.TextureFormat, $hasMipMap: boolean):boolean;
            public Resize($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $hasMipMap: boolean):boolean;
            public ReadPixels($source: UnityEngine.Rect, $destX: number, $destY: number, $recalculateMipMaps: boolean):void;
            public ReadPixels($source: UnityEngine.Rect, $destX: number, $destY: number):void;
            public static GenerateAtlas($sizes: System.Array$1<UnityEngine.Vector2>, $padding: number, $atlasSize: number, $results: System.Collections.Generic.List$1<UnityEngine.Rect>):boolean;
            public SetPixels32($colors: System.Array$1<UnityEngine.Color32>, $miplevel: number):void;
            public SetPixels32($colors: System.Array$1<UnityEngine.Color32>):void;
            public SetPixels32($x: number, $y: number, $blockWidth: number, $blockHeight: number, $colors: System.Array$1<UnityEngine.Color32>, $miplevel: number):void;
            public SetPixels32($x: number, $y: number, $blockWidth: number, $blockHeight: number, $colors: System.Array$1<UnityEngine.Color32>):void;
            public GetPixels($miplevel: number):System.Array$1<UnityEngine.Color>;
            public GetPixels():System.Array$1<UnityEngine.Color>;
            public constructor($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            public constructor($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            public constructor($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            public constructor($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean);
            public constructor($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean);
            public constructor($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean);
            public constructor($width: number, $height: number);
            public constructor();
        }
        interface Texture2D {
            EncodeToTGA():System.Array$1<number>;
            EncodeToPNG():System.Array$1<number>;
            EncodeToJPG($quality: number):System.Array$1<number>;
            EncodeToJPG():System.Array$1<number>;
            EncodeToEXR($flags: UnityEngine.Texture2D.EXRFlags):System.Array$1<number>;
            EncodeToEXR():System.Array$1<number>;
            LoadImage($data: System.Array$1<number>, $markNonReadable: boolean):boolean;
            LoadImage($data: System.Array$1<number>):boolean;
        }
        export class LightmapSettings extends UnityEngine.Object{ 
            public static get lightmaps(): System.Array$1<UnityEngine.LightmapData>;
            public static set lightmaps(value: System.Array$1<UnityEngine.LightmapData>);
            public static get lightmapsMode(): UnityEngine.LightmapsMode;
            public static set lightmapsMode(value: UnityEngine.LightmapsMode);
            public static get lightProbes(): UnityEngine.LightProbes;
            public static set lightProbes(value: UnityEngine.LightProbes);
        }
        export class LightProbes extends UnityEngine.Object{ 
            public get positions(): System.Array$1<UnityEngine.Vector3>;
            public get bakedProbes(): System.Array$1<UnityEngine.Rendering.SphericalHarmonicsL2>;
            public set bakedProbes(value: System.Array$1<UnityEngine.Rendering.SphericalHarmonicsL2>);
            public get count(): number;
            public get cellCount(): number;
            public static add_tetrahedralizationCompleted($value: System.Action):void;
            public static remove_tetrahedralizationCompleted($value: System.Action):void;
            public static add_needsRetetrahedralization($value: System.Action):void;
            public static remove_needsRetetrahedralization($value: System.Action):void;
            public static Tetrahedralize():void;
            public static TetrahedralizeAsync():void;
            public static GetInterpolatedProbe($position: UnityEngine.Vector3, $renderer: UnityEngine.Renderer, $probe: $Ref<UnityEngine.Rendering.SphericalHarmonicsL2>):void;
            public static CalculateInterpolatedLightAndOcclusionProbes($positions: System.Array$1<UnityEngine.Vector3>, $lightProbes: System.Array$1<UnityEngine.Rendering.SphericalHarmonicsL2>, $occlusionProbes: System.Array$1<UnityEngine.Vector4>):void;
            public static CalculateInterpolatedLightAndOcclusionProbes($positions: System.Collections.Generic.List$1<UnityEngine.Vector3>, $lightProbes: System.Collections.Generic.List$1<UnityEngine.Rendering.SphericalHarmonicsL2>, $occlusionProbes: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
        }
        export enum LightmapsModeLegacy{ Single = 0, Dual = 1, Directional = 2 }
        export enum ColorSpace{ Uninitialized = -1, Gamma = 0, Linear = 1 }
        export enum D3DHDRDisplayBitDepth{ D3DHDRDisplayBitDepth10 = 0, D3DHDRDisplayBitDepth16 = 1 }
        export class HDROutputSettings extends System.Object{ 
            public static displays: System.Array$1<UnityEngine.HDROutputSettings>;
            public static get main(): UnityEngine.HDROutputSettings;
            public get active(): boolean;
            public get available(): boolean;
            public get automaticHDRTonemapping(): boolean;
            public set automaticHDRTonemapping(value: boolean);
            public get displayColorGamut(): UnityEngine.ColorGamut;
            public get format(): UnityEngine.RenderTextureFormat;
            public get graphicsFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public get paperWhiteNits(): number;
            public set paperWhiteNits(value: number);
            public get maxFullFrameToneMapLuminance(): number;
            public get maxToneMapLuminance(): number;
            public get minToneMapLuminance(): number;
            public get HDRModeChangeRequested(): boolean;
            public RequestHDRModeChange($enabled: boolean):void;
        }
        export enum RenderTextureFormat{ ARGB32 = 0, Depth = 1, ARGBHalf = 2, Shadowmap = 3, RGB565 = 4, ARGB4444 = 5, ARGB1555 = 6, Default = 7, ARGB2101010 = 8, DefaultHDR = 9, ARGB64 = 10, ARGBFloat = 11, RGFloat = 12, RGHalf = 13, RFloat = 14, RHalf = 15, R8 = 16, ARGBInt = 17, RGInt = 18, RInt = 19, BGRA32 = 20, RGB111110Float = 22, RG32 = 23, RGBAUShort = 24, RG16 = 25, BGRA10101010_XR = 26, BGR101010_XR = 27, R16 = 28 }
        export class QualitySettings extends UnityEngine.Object{ 
            public static get pixelLightCount(): number;
            public static set pixelLightCount(value: number);
            public static get shadows(): UnityEngine.ShadowQuality;
            public static set shadows(value: UnityEngine.ShadowQuality);
            public static get shadowProjection(): UnityEngine.ShadowProjection;
            public static set shadowProjection(value: UnityEngine.ShadowProjection);
            public static get shadowCascades(): number;
            public static set shadowCascades(value: number);
            public static get shadowDistance(): number;
            public static set shadowDistance(value: number);
            public static get shadowResolution(): UnityEngine.ShadowResolution;
            public static set shadowResolution(value: UnityEngine.ShadowResolution);
            public static get shadowmaskMode(): UnityEngine.ShadowmaskMode;
            public static set shadowmaskMode(value: UnityEngine.ShadowmaskMode);
            public static get shadowNearPlaneOffset(): number;
            public static set shadowNearPlaneOffset(value: number);
            public static get shadowCascade2Split(): number;
            public static set shadowCascade2Split(value: number);
            public static get shadowCascade4Split(): UnityEngine.Vector3;
            public static set shadowCascade4Split(value: UnityEngine.Vector3);
            public static get lodBias(): number;
            public static set lodBias(value: number);
            public static get anisotropicFiltering(): UnityEngine.AnisotropicFiltering;
            public static set anisotropicFiltering(value: UnityEngine.AnisotropicFiltering);
            public static get masterTextureLimit(): number;
            public static set masterTextureLimit(value: number);
            public static get maximumLODLevel(): number;
            public static set maximumLODLevel(value: number);
            public static get particleRaycastBudget(): number;
            public static set particleRaycastBudget(value: number);
            public static get softParticles(): boolean;
            public static set softParticles(value: boolean);
            public static get softVegetation(): boolean;
            public static set softVegetation(value: boolean);
            public static get vSyncCount(): number;
            public static set vSyncCount(value: number);
            public static get antiAliasing(): number;
            public static set antiAliasing(value: number);
            public static get asyncUploadTimeSlice(): number;
            public static set asyncUploadTimeSlice(value: number);
            public static get asyncUploadBufferSize(): number;
            public static set asyncUploadBufferSize(value: number);
            public static get asyncUploadPersistentBuffer(): boolean;
            public static set asyncUploadPersistentBuffer(value: boolean);
            public static get realtimeReflectionProbes(): boolean;
            public static set realtimeReflectionProbes(value: boolean);
            public static get billboardsFaceCameraPosition(): boolean;
            public static set billboardsFaceCameraPosition(value: boolean);
            public static get resolutionScalingFixedDPIFactor(): number;
            public static set resolutionScalingFixedDPIFactor(value: number);
            public static get renderPipeline(): UnityEngine.Rendering.RenderPipelineAsset;
            public static set renderPipeline(value: UnityEngine.Rendering.RenderPipelineAsset);
            public static get skinWeights(): UnityEngine.SkinWeights;
            public static set skinWeights(value: UnityEngine.SkinWeights);
            public static get streamingMipmapsActive(): boolean;
            public static set streamingMipmapsActive(value: boolean);
            public static get streamingMipmapsMemoryBudget(): number;
            public static set streamingMipmapsMemoryBudget(value: number);
            public static get streamingMipmapsMaxLevelReduction(): number;
            public static set streamingMipmapsMaxLevelReduction(value: number);
            public static get streamingMipmapsAddAllCameras(): boolean;
            public static set streamingMipmapsAddAllCameras(value: boolean);
            public static get streamingMipmapsMaxFileIORequests(): number;
            public static set streamingMipmapsMaxFileIORequests(value: number);
            public static get maxQueuedFrames(): number;
            public static set maxQueuedFrames(value: number);
            public static get names(): System.Array$1<string>;
            public static get desiredColorSpace(): UnityEngine.ColorSpace;
            public static get activeColorSpace(): UnityEngine.ColorSpace;
            public static IncreaseLevel($applyExpensiveChanges: boolean):void;
            public static DecreaseLevel($applyExpensiveChanges: boolean):void;
            public static SetQualityLevel($index: number):void;
            public static IncreaseLevel():void;
            public static DecreaseLevel():void;
            public static SetLODSettings($lodBias: number, $maximumLODLevel: number, $setDirty?: boolean):void;
            public static GetRenderPipelineAssetAt($index: number):UnityEngine.Rendering.RenderPipelineAsset;
            public static GetQualityLevel():number;
            public static SetQualityLevel($index: number, $applyExpensiveChanges: boolean):void;
        }
        export enum QualityLevel{ Fastest = 0, Fast = 1, Simple = 2, Good = 3, Beautiful = 4, Fantastic = 5 }
        export enum ShadowQuality{ Disable = 0, HardOnly = 1, All = 2 }
        export enum ShadowProjection{ CloseFit = 0, StableFit = 1 }
        export enum ShadowResolution{ Low = 0, Medium = 1, High = 2, VeryHigh = 3 }
        export enum ShadowmaskMode{ Shadowmask = 0, DistanceShadowmask = 1 }
        export enum AnisotropicFiltering{ Disable = 0, Enable = 1, ForceEnable = 2 }
        export enum BlendWeights{ OneBone = 1, TwoBones = 2, FourBones = 4 }
        export enum SkinWeights{ OneBone = 1, TwoBones = 2, FourBones = 4, Unlimited = 255 }
        export class RendererExtensions extends System.Object{ 
            public static UpdateGIMaterials($renderer: UnityEngine.Renderer):void;
        }
        export class ImageEffectTransformsToLDR extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class ImageEffectAllowedInSceneView extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class ImageEffectOpaque extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class ImageEffectAfterScale extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class ImageEffectUsesCommandBuffer extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class BoneWeight1 extends System.ValueType implements System.IEquatable$1<UnityEngine.BoneWeight1>{ 
            public get weight(): number;
            public set weight(value: number);
            public get boneIndex(): number;
            public set boneIndex(value: number);
            public Equals($other: any):boolean;
            public Equals($other: UnityEngine.BoneWeight1):boolean;
            public static op_Equality($lhs: UnityEngine.BoneWeight1, $rhs: UnityEngine.BoneWeight1):boolean;
            public static op_Inequality($lhs: UnityEngine.BoneWeight1, $rhs: UnityEngine.BoneWeight1):boolean;
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
        }
        export class BoneWeight extends System.ValueType implements System.IEquatable$1<UnityEngine.BoneWeight>{ 
            public get weight0(): number;
            public set weight0(value: number);
            public get weight1(): number;
            public set weight1(value: number);
            public get weight2(): number;
            public set weight2(value: number);
            public get weight3(): number;
            public set weight3(value: number);
            public get boneIndex0(): number;
            public set boneIndex0(value: number);
            public get boneIndex1(): number;
            public set boneIndex1(value: number);
            public get boneIndex2(): number;
            public set boneIndex2(value: number);
            public get boneIndex3(): number;
            public set boneIndex3(value: number);
            public Equals($other: any):boolean;
            public Equals($other: UnityEngine.BoneWeight):boolean;
            public static op_Equality($lhs: UnityEngine.BoneWeight, $rhs: UnityEngine.BoneWeight):boolean;
            public static op_Inequality($lhs: UnityEngine.BoneWeight, $rhs: UnityEngine.BoneWeight):boolean;
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
        }
        export class CombineInstance extends System.ValueType{ 
            public get mesh(): UnityEngine.Mesh;
            public set mesh(value: UnityEngine.Mesh);
            public get subMeshIndex(): number;
            public set subMeshIndex(value: number);
            public get transform(): UnityEngine.Matrix4x4;
            public set transform(value: UnityEngine.Matrix4x4);
            public get lightmapScaleOffset(): UnityEngine.Vector4;
            public set lightmapScaleOffset(value: UnityEngine.Vector4);
            public get realtimeLightmapScaleOffset(): UnityEngine.Vector4;
            public set realtimeLightmapScaleOffset(value: UnityEngine.Vector4);
        }
        export enum MotionVectorGenerationMode{ Camera = 0, Object = 1, ForceNoMotion = 2 }
        export class Projector extends UnityEngine.Behaviour{ 
            public get nearClipPlane(): number;
            public set nearClipPlane(value: number);
            public get farClipPlane(): number;
            public set farClipPlane(value: number);
            public get fieldOfView(): number;
            public set fieldOfView(value: number);
            public get aspectRatio(): number;
            public set aspectRatio(value: number);
            public get orthographic(): boolean;
            public set orthographic(value: boolean);
            public get orthographicSize(): number;
            public set orthographicSize(value: number);
            public get ignoreLayers(): number;
            public set ignoreLayers(value: number);
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public constructor();
        }
        export enum TexGenMode{ None = 0, SphereMap = 1, Object = 2, EyeLinear = 3, CubeReflect = 4, CubeNormal = 5 }
        export class TrailRenderer extends UnityEngine.Renderer{ 
            public get time(): number;
            public set time(value: number);
            public get startWidth(): number;
            public set startWidth(value: number);
            public get endWidth(): number;
            public set endWidth(value: number);
            public get widthMultiplier(): number;
            public set widthMultiplier(value: number);
            public get autodestruct(): boolean;
            public set autodestruct(value: boolean);
            public get emitting(): boolean;
            public set emitting(value: boolean);
            public get numCornerVertices(): number;
            public set numCornerVertices(value: number);
            public get numCapVertices(): number;
            public set numCapVertices(value: number);
            public get minVertexDistance(): number;
            public set minVertexDistance(value: number);
            public get startColor(): UnityEngine.Color;
            public set startColor(value: UnityEngine.Color);
            public get endColor(): UnityEngine.Color;
            public set endColor(value: UnityEngine.Color);
            public get positionCount(): number;
            public get shadowBias(): number;
            public set shadowBias(value: number);
            public get generateLightingData(): boolean;
            public set generateLightingData(value: boolean);
            public get textureMode(): UnityEngine.LineTextureMode;
            public set textureMode(value: UnityEngine.LineTextureMode);
            public get alignment(): UnityEngine.LineAlignment;
            public set alignment(value: UnityEngine.LineAlignment);
            public get widthCurve(): UnityEngine.AnimationCurve;
            public set widthCurve(value: UnityEngine.AnimationCurve);
            public get colorGradient(): UnityEngine.Gradient;
            public set colorGradient(value: UnityEngine.Gradient);
            public SetPosition($index: number, $position: UnityEngine.Vector3):void;
            public GetPosition($index: number):UnityEngine.Vector3;
            public Clear():void;
            public BakeMesh($mesh: UnityEngine.Mesh, $useTransform?: boolean):void;
            public BakeMesh($mesh: UnityEngine.Mesh, $camera: UnityEngine.Camera, $useTransform?: boolean):void;
            public GetPositions($positions: System.Array$1<UnityEngine.Vector3>):number;
            public SetPositions($positions: System.Array$1<UnityEngine.Vector3>):void;
            public AddPosition($position: UnityEngine.Vector3):void;
            public AddPositions($positions: System.Array$1<UnityEngine.Vector3>):void;
            public SetPositions($positions: Unity.Collections.NativeArray$1<UnityEngine.Vector3>):void;
            public SetPositions($positions: Unity.Collections.NativeSlice$1<UnityEngine.Vector3>):void;
            public GetPositions($positions: Unity.Collections.NativeArray$1<UnityEngine.Vector3>):number;
            public GetPositions($positions: Unity.Collections.NativeSlice$1<UnityEngine.Vector3>):number;
            public AddPositions($positions: Unity.Collections.NativeArray$1<UnityEngine.Vector3>):void;
            public AddPositions($positions: Unity.Collections.NativeSlice$1<UnityEngine.Vector3>):void;
            public constructor();
        }
        export enum LineTextureMode{ Stretch = 0, Tile = 1, DistributePerSegment = 2, RepeatPerSegment = 3 }
        export enum LineAlignment{ View = 0, Local = 1, TransformZ = 1 }
        export class Gradient extends System.Object implements System.IEquatable$1<UnityEngine.Gradient>{ 
            public get colorKeys(): System.Array$1<UnityEngine.GradientColorKey>;
            public set colorKeys(value: System.Array$1<UnityEngine.GradientColorKey>);
            public get alphaKeys(): System.Array$1<UnityEngine.GradientAlphaKey>;
            public set alphaKeys(value: System.Array$1<UnityEngine.GradientAlphaKey>);
            public get mode(): UnityEngine.GradientMode;
            public set mode(value: UnityEngine.GradientMode);
            public Evaluate($time: number):UnityEngine.Color;
            public SetKeys($colorKeys: System.Array$1<UnityEngine.GradientColorKey>, $alphaKeys: System.Array$1<UnityEngine.GradientAlphaKey>):void;
            public Equals($o: any):boolean;
            public Equals($other: UnityEngine.Gradient):boolean;
            public constructor();
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
        }
        export class LineRenderer extends UnityEngine.Renderer{ 
            public get startWidth(): number;
            public set startWidth(value: number);
            public get endWidth(): number;
            public set endWidth(value: number);
            public get widthMultiplier(): number;
            public set widthMultiplier(value: number);
            public get numCornerVertices(): number;
            public set numCornerVertices(value: number);
            public get numCapVertices(): number;
            public set numCapVertices(value: number);
            public get useWorldSpace(): boolean;
            public set useWorldSpace(value: boolean);
            public get loop(): boolean;
            public set loop(value: boolean);
            public get startColor(): UnityEngine.Color;
            public set startColor(value: UnityEngine.Color);
            public get endColor(): UnityEngine.Color;
            public set endColor(value: UnityEngine.Color);
            public get positionCount(): number;
            public set positionCount(value: number);
            public get shadowBias(): number;
            public set shadowBias(value: number);
            public get generateLightingData(): boolean;
            public set generateLightingData(value: boolean);
            public get textureMode(): UnityEngine.LineTextureMode;
            public set textureMode(value: UnityEngine.LineTextureMode);
            public get alignment(): UnityEngine.LineAlignment;
            public set alignment(value: UnityEngine.LineAlignment);
            public get widthCurve(): UnityEngine.AnimationCurve;
            public set widthCurve(value: UnityEngine.AnimationCurve);
            public get colorGradient(): UnityEngine.Gradient;
            public set colorGradient(value: UnityEngine.Gradient);
            public SetPosition($index: number, $position: UnityEngine.Vector3):void;
            public GetPosition($index: number):UnityEngine.Vector3;
            public Simplify($tolerance: number):void;
            public BakeMesh($mesh: UnityEngine.Mesh, $useTransform?: boolean):void;
            public BakeMesh($mesh: UnityEngine.Mesh, $camera: UnityEngine.Camera, $useTransform?: boolean):void;
            public GetPositions($positions: System.Array$1<UnityEngine.Vector3>):number;
            public SetPositions($positions: System.Array$1<UnityEngine.Vector3>):void;
            public SetPositions($positions: Unity.Collections.NativeArray$1<UnityEngine.Vector3>):void;
            public SetPositions($positions: Unity.Collections.NativeSlice$1<UnityEngine.Vector3>):void;
            public GetPositions($positions: Unity.Collections.NativeArray$1<UnityEngine.Vector3>):number;
            public GetPositions($positions: Unity.Collections.NativeSlice$1<UnityEngine.Vector3>):number;
            public constructor();
        }
        export class RenderSettings extends UnityEngine.Object{ 
            public static get fog(): boolean;
            public static set fog(value: boolean);
            public static get fogStartDistance(): number;
            public static set fogStartDistance(value: number);
            public static get fogEndDistance(): number;
            public static set fogEndDistance(value: number);
            public static get fogMode(): UnityEngine.FogMode;
            public static set fogMode(value: UnityEngine.FogMode);
            public static get fogColor(): UnityEngine.Color;
            public static set fogColor(value: UnityEngine.Color);
            public static get fogDensity(): number;
            public static set fogDensity(value: number);
            public static get ambientMode(): UnityEngine.Rendering.AmbientMode;
            public static set ambientMode(value: UnityEngine.Rendering.AmbientMode);
            public static get ambientSkyColor(): UnityEngine.Color;
            public static set ambientSkyColor(value: UnityEngine.Color);
            public static get ambientEquatorColor(): UnityEngine.Color;
            public static set ambientEquatorColor(value: UnityEngine.Color);
            public static get ambientGroundColor(): UnityEngine.Color;
            public static set ambientGroundColor(value: UnityEngine.Color);
            public static get ambientIntensity(): number;
            public static set ambientIntensity(value: number);
            public static get ambientLight(): UnityEngine.Color;
            public static set ambientLight(value: UnityEngine.Color);
            public static get subtractiveShadowColor(): UnityEngine.Color;
            public static set subtractiveShadowColor(value: UnityEngine.Color);
            public static get skybox(): UnityEngine.Material;
            public static set skybox(value: UnityEngine.Material);
            public static get sun(): UnityEngine.Light;
            public static set sun(value: UnityEngine.Light);
            public static get ambientProbe(): UnityEngine.Rendering.SphericalHarmonicsL2;
            public static set ambientProbe(value: UnityEngine.Rendering.SphericalHarmonicsL2);
            public static get customReflection(): UnityEngine.Cubemap;
            public static set customReflection(value: UnityEngine.Cubemap);
            public static get reflectionIntensity(): number;
            public static set reflectionIntensity(value: number);
            public static get reflectionBounces(): number;
            public static set reflectionBounces(value: number);
            public static get defaultReflectionMode(): UnityEngine.Rendering.DefaultReflectionMode;
            public static set defaultReflectionMode(value: UnityEngine.Rendering.DefaultReflectionMode);
            public static get defaultReflectionResolution(): number;
            public static set defaultReflectionResolution(value: number);
            public static get haloStrength(): number;
            public static set haloStrength(value: number);
            public static get flareStrength(): number;
            public static set flareStrength(value: number);
            public static get flareFadeSpeed(): number;
            public static set flareFadeSpeed(value: number);
        }
        export enum FogMode{ Linear = 1, Exponential = 2, ExponentialSquared = 3 }
        export class Light extends UnityEngine.Behaviour{ 
            public get type(): UnityEngine.LightType;
            public set type(value: UnityEngine.LightType);
            public get shape(): UnityEngine.LightShape;
            public set shape(value: UnityEngine.LightShape);
            public get spotAngle(): number;
            public set spotAngle(value: number);
            public get innerSpotAngle(): number;
            public set innerSpotAngle(value: number);
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public get colorTemperature(): number;
            public set colorTemperature(value: number);
            public get useColorTemperature(): boolean;
            public set useColorTemperature(value: boolean);
            public get intensity(): number;
            public set intensity(value: number);
            public get bounceIntensity(): number;
            public set bounceIntensity(value: number);
            public get useBoundingSphereOverride(): boolean;
            public set useBoundingSphereOverride(value: boolean);
            public get boundingSphereOverride(): UnityEngine.Vector4;
            public set boundingSphereOverride(value: UnityEngine.Vector4);
            public get useViewFrustumForShadowCasterCull(): boolean;
            public set useViewFrustumForShadowCasterCull(value: boolean);
            public get shadowCustomResolution(): number;
            public set shadowCustomResolution(value: number);
            public get shadowBias(): number;
            public set shadowBias(value: number);
            public get shadowNormalBias(): number;
            public set shadowNormalBias(value: number);
            public get shadowNearPlane(): number;
            public set shadowNearPlane(value: number);
            public get useShadowMatrixOverride(): boolean;
            public set useShadowMatrixOverride(value: boolean);
            public get shadowMatrixOverride(): UnityEngine.Matrix4x4;
            public set shadowMatrixOverride(value: UnityEngine.Matrix4x4);
            public get range(): number;
            public set range(value: number);
            public get flare(): UnityEngine.Flare;
            public set flare(value: UnityEngine.Flare);
            public get bakingOutput(): UnityEngine.LightBakingOutput;
            public set bakingOutput(value: UnityEngine.LightBakingOutput);
            public get cullingMask(): number;
            public set cullingMask(value: number);
            public get renderingLayerMask(): number;
            public set renderingLayerMask(value: number);
            public get lightShadowCasterMode(): UnityEngine.LightShadowCasterMode;
            public set lightShadowCasterMode(value: UnityEngine.LightShadowCasterMode);
            public get shadows(): UnityEngine.LightShadows;
            public set shadows(value: UnityEngine.LightShadows);
            public get shadowStrength(): number;
            public set shadowStrength(value: number);
            public get shadowResolution(): UnityEngine.Rendering.LightShadowResolution;
            public set shadowResolution(value: UnityEngine.Rendering.LightShadowResolution);
            public get layerShadowCullDistances(): System.Array$1<number>;
            public set layerShadowCullDistances(value: System.Array$1<number>);
            public get cookieSize(): number;
            public set cookieSize(value: number);
            public get cookie(): UnityEngine.Texture;
            public set cookie(value: UnityEngine.Texture);
            public get renderMode(): UnityEngine.LightRenderMode;
            public set renderMode(value: UnityEngine.LightRenderMode);
            public get commandBufferCount(): number;
            public Reset():void;
            public AddCommandBuffer($evt: UnityEngine.Rendering.LightEvent, $buffer: UnityEngine.Rendering.CommandBuffer):void;
            public AddCommandBuffer($evt: UnityEngine.Rendering.LightEvent, $buffer: UnityEngine.Rendering.CommandBuffer, $shadowPassMask: UnityEngine.Rendering.ShadowMapPass):void;
            public AddCommandBufferAsync($evt: UnityEngine.Rendering.LightEvent, $buffer: UnityEngine.Rendering.CommandBuffer, $queueType: UnityEngine.Rendering.ComputeQueueType):void;
            public AddCommandBufferAsync($evt: UnityEngine.Rendering.LightEvent, $buffer: UnityEngine.Rendering.CommandBuffer, $shadowPassMask: UnityEngine.Rendering.ShadowMapPass, $queueType: UnityEngine.Rendering.ComputeQueueType):void;
            public RemoveCommandBuffer($evt: UnityEngine.Rendering.LightEvent, $buffer: UnityEngine.Rendering.CommandBuffer):void;
            public RemoveCommandBuffers($evt: UnityEngine.Rendering.LightEvent):void;
            public RemoveAllCommandBuffers():void;
            public GetCommandBuffers($evt: UnityEngine.Rendering.LightEvent):System.Array$1<UnityEngine.Rendering.CommandBuffer>;
            public static GetLights($type: UnityEngine.LightType, $layer: number):System.Array$1<UnityEngine.Light>;
            public constructor();
        }
        export enum MaterialGlobalIlluminationFlags{ None = 0, RealtimeEmissive = 1, BakedEmissive = 2, EmissiveIsBlack = 4, AnyEmissive = 3 }
        export class OcclusionPortal extends UnityEngine.Component{ 
            public get open(): boolean;
            public set open(value: boolean);
            public constructor();
        }
        export class OcclusionArea extends UnityEngine.Component{ 
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            public get size(): UnityEngine.Vector3;
            public set size(value: UnityEngine.Vector3);
            public constructor();
        }
        export class Flare extends UnityEngine.Object{ 
            public constructor();
        }
        export class LensFlare extends UnityEngine.Behaviour{ 
            public get brightness(): number;
            public set brightness(value: number);
            public get fadeSpeed(): number;
            public set fadeSpeed(value: number);
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public get flare(): UnityEngine.Flare;
            public set flare(value: UnityEngine.Flare);
            public constructor();
        }
        export class LightBakingOutput extends System.ValueType{ 
            public probeOcclusionLightIndex: number;
            public occlusionMaskChannel: number;
            public lightmapBakeType: UnityEngine.LightmapBakeType;
            public mixedLightingMode: UnityEngine.MixedLightingMode;
            public isBaked: boolean;
        }
        export enum LightmapBakeType{ Realtime = 4, Baked = 2, Mixed = 1 }
        export enum LightShadowCasterMode{ Default = 0, NonLightmappedOnly = 1, Everything = 2 }
        export enum LightType{ Spot = 0, Directional = 1, Point = 2, Area = 3, Rectangle = 3, Disc = 4 }
        export enum LightShape{ Cone = 0, Pyramid = 1, Box = 2 }
        export enum LightShadows{ None = 0, Hard = 1, Soft = 2 }
        export enum LightRenderMode{ Auto = 0, ForcePixel = 1, ForceVertex = 2 }
        export enum LightmappingMode{ Realtime = 4, Baked = 2, Mixed = 1 }
        export class Skybox extends UnityEngine.Behaviour{ 
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public constructor();
        }
        export class MeshFilter extends UnityEngine.Component{ 
            public get sharedMesh(): UnityEngine.Mesh;
            public set sharedMesh(value: UnityEngine.Mesh);
            public get mesh(): UnityEngine.Mesh;
            public set mesh(value: UnityEngine.Mesh);
            public constructor();
        }
        export enum ComputeBufferType{ Default = 0, Raw = 1, Append = 2, Counter = 4, Constant = 8, Structured = 16, DrawIndirect = 256, IndirectArguments = 256, GPUMemory = 512 }
        export enum ReceiveGI{ Lightmaps = 1, LightProbes = 2 }
        export enum ShadowObjectsFilter{ AllObjects = 0, DynamicOnly = 1, StaticOnly = 2 }
        export enum SkinQuality{ Auto = 0, Bone1 = 1, Bone2 = 2, Bone4 = 4 }
        export enum FilterMode{ Point = 0, Bilinear = 1, Trilinear = 2 }
        export enum TextureWrapMode{ Repeat = 0, Clamp = 1, Mirror = 2, MirrorOnce = 3 }
        export enum NPOTSupport{ None = 0, Restricted = 1, Full = 2 }
        export enum TextureFormat{ Alpha8 = 1, ARGB4444 = 2, RGB24 = 3, RGBA32 = 4, ARGB32 = 5, RGB565 = 7, R16 = 9, DXT1 = 10, DXT5 = 12, RGBA4444 = 13, BGRA32 = 14, RHalf = 15, RGHalf = 16, RGBAHalf = 17, RFloat = 18, RGFloat = 19, RGBAFloat = 20, YUY2 = 21, RGB9e5Float = 22, BC4 = 26, BC5 = 27, BC6H = 24, BC7 = 25, DXT1Crunched = 28, DXT5Crunched = 29, PVRTC_RGB2 = 30, PVRTC_RGBA2 = 31, PVRTC_RGB4 = 32, PVRTC_RGBA4 = 33, ETC_RGB4 = 34, ATC_RGB4 = -127, ATC_RGBA8 = -127, EAC_R = 41, EAC_R_SIGNED = 42, EAC_RG = 43, EAC_RG_SIGNED = 44, ETC2_RGB = 45, ETC2_RGBA1 = 46, ETC2_RGBA8 = 47, ASTC_4x4 = 48, ASTC_5x5 = 49, ASTC_6x6 = 50, ASTC_8x8 = 51, ASTC_10x10 = 52, ASTC_12x12 = 53, ETC_RGB4_3DS = 60, ETC_RGBA8_3DS = 61, RG16 = 62, R8 = 63, ETC_RGB4Crunched = 64, ETC2_RGBA8Crunched = 65, ASTC_HDR_4x4 = 66, ASTC_HDR_5x5 = 67, ASTC_HDR_6x6 = 68, ASTC_HDR_8x8 = 69, ASTC_HDR_10x10 = 70, ASTC_HDR_12x12 = 71, RG32 = 72, RGB48 = 73, RGBA64 = 74, ASTC_RGB_4x4 = 48, ASTC_RGB_5x5 = 49, ASTC_RGB_6x6 = 50, ASTC_RGB_8x8 = 51, ASTC_RGB_10x10 = 52, ASTC_RGB_12x12 = 53, ASTC_RGBA_4x4 = 54, ASTC_RGBA_5x5 = 55, ASTC_RGBA_6x6 = 56, ASTC_RGBA_8x8 = 57, ASTC_RGBA_10x10 = 58, ASTC_RGBA_12x12 = 59, PVRTC_2BPP_RGB = -127, PVRTC_2BPP_RGBA = -127, PVRTC_4BPP_RGB = -127, PVRTC_4BPP_RGBA = -127 }
        export enum VRTextureUsage{ None = 0, OneEye = 1, TwoEyes = 2, DeviceSpecific = 3 }
        export enum RenderTextureCreationFlags{ MipMap = 1, AutoGenerateMips = 2, SRGB = 4, EyeTexture = 8, EnableRandomWrite = 16, CreatedFromScript = 32, AllowVerticalFlip = 128, NoResolvedColorSurface = 256, DynamicallyScalable = 1024, BindMS = 2048 }
        export enum RenderTextureReadWrite{ Default = 0, Linear = 1, sRGB = 2 }
        export enum RenderTextureMemoryless{ None = 0, Color = 1, Depth = 2, MSAA = 4 }
        export enum HDRDisplaySupportFlags{ None = 0, Supported = 1, RuntimeSwitchable = 2, AutomaticTonemapping = 4 }
        export enum CustomRenderTextureInitializationSource{ TextureAndColor = 0, Material = 1 }
        export enum CustomRenderTextureUpdateMode{ OnLoad = 0, Realtime = 1, OnDemand = 2 }
        export enum CustomRenderTextureUpdateZoneSpace{ Normalized = 0, Pixel = 1 }
        export class SkinnedMeshRenderer extends UnityEngine.Renderer{ 
            public get quality(): UnityEngine.SkinQuality;
            public set quality(value: UnityEngine.SkinQuality);
            public get updateWhenOffscreen(): boolean;
            public set updateWhenOffscreen(value: boolean);
            public get forceMatrixRecalculationPerRender(): boolean;
            public set forceMatrixRecalculationPerRender(value: boolean);
            public get rootBone(): UnityEngine.Transform;
            public set rootBone(value: UnityEngine.Transform);
            public get bones(): System.Array$1<UnityEngine.Transform>;
            public set bones(value: System.Array$1<UnityEngine.Transform>);
            public get sharedMesh(): UnityEngine.Mesh;
            public set sharedMesh(value: UnityEngine.Mesh);
            public get skinnedMotionVectors(): boolean;
            public set skinnedMotionVectors(value: boolean);
            public get localBounds(): UnityEngine.Bounds;
            public set localBounds(value: UnityEngine.Bounds);
            public GetBlendShapeWeight($index: number):number;
            public SetBlendShapeWeight($index: number, $value: number):void;
            public BakeMesh($mesh: UnityEngine.Mesh):void;
            public BakeMesh($mesh: UnityEngine.Mesh, $useScale: boolean):void;
            public constructor();
        }
        export class LightProbeGroup extends UnityEngine.Behaviour{ 
            public constructor();
        }
        export class LineUtility extends System.Object{ 
            public static Simplify($points: System.Collections.Generic.List$1<UnityEngine.Vector3>, $tolerance: number, $pointsToKeep: System.Collections.Generic.List$1<number>):void;
            public static Simplify($points: System.Collections.Generic.List$1<UnityEngine.Vector3>, $tolerance: number, $simplifiedPoints: System.Collections.Generic.List$1<UnityEngine.Vector3>):void;
            public static Simplify($points: System.Collections.Generic.List$1<UnityEngine.Vector2>, $tolerance: number, $pointsToKeep: System.Collections.Generic.List$1<number>):void;
            public static Simplify($points: System.Collections.Generic.List$1<UnityEngine.Vector2>, $tolerance: number, $simplifiedPoints: System.Collections.Generic.List$1<UnityEngine.Vector2>):void;
            public constructor();
        }
        export enum LODFadeMode{ None = 0, CrossFade = 1, SpeedTree = 2 }
        export class LOD extends System.ValueType{ 
            public screenRelativeTransitionHeight: number;
            public fadeTransitionWidth: number;
            public renderers: System.Array$1<UnityEngine.Renderer>;
            public constructor($screenRelativeTransitionHeight: number, $renderers: System.Array$1<UnityEngine.Renderer>);
            public constructor();
        }
        export class LODGroup extends UnityEngine.Component{ 
            public get localReferencePoint(): UnityEngine.Vector3;
            public set localReferencePoint(value: UnityEngine.Vector3);
            public get size(): number;
            public set size(value: number);
            public get lodCount(): number;
            public get fadeMode(): UnityEngine.LODFadeMode;
            public set fadeMode(value: UnityEngine.LODFadeMode);
            public get animateCrossFading(): boolean;
            public set animateCrossFading(value: boolean);
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public static get crossFadeAnimationDuration(): number;
            public static set crossFadeAnimationDuration(value: number);
            public RecalculateBounds():void;
            public GetLODs():System.Array$1<UnityEngine.LOD>;
            public SetLODs($lods: System.Array$1<UnityEngine.LOD>):void;
            public ForceLOD($index: number):void;
            public constructor();
        }
        export class Texture3D extends UnityEngine.Texture{ 
            public get depth(): number;
            public get format(): UnityEngine.TextureFormat;
            public get isReadable(): boolean;
            public UpdateExternalTexture($nativeTex: System.IntPtr):void;
            public GetPixels($miplevel: number):System.Array$1<UnityEngine.Color>;
            public GetPixels():System.Array$1<UnityEngine.Color>;
            public GetPixels32($miplevel: number):System.Array$1<UnityEngine.Color32>;
            public GetPixels32():System.Array$1<UnityEngine.Color32>;
            public SetPixels($colors: System.Array$1<UnityEngine.Color>, $miplevel: number):void;
            public SetPixels($colors: System.Array$1<UnityEngine.Color>):void;
            public SetPixels32($colors: System.Array$1<UnityEngine.Color32>, $miplevel: number):void;
            public SetPixels32($colors: System.Array$1<UnityEngine.Color32>):void;
            public static CreateExternalTexture($width: number, $height: number, $depth: number, $format: UnityEngine.TextureFormat, $mipChain: boolean, $nativeTex: System.IntPtr):UnityEngine.Texture3D;
            public Apply($updateMipmaps: boolean, $makeNoLongerReadable: boolean):void;
            public Apply($updateMipmaps: boolean):void;
            public Apply():void;
            public SetPixel($x: number, $y: number, $z: number, $color: UnityEngine.Color):void;
            public SetPixel($x: number, $y: number, $z: number, $color: UnityEngine.Color, $mipLevel: number):void;
            public GetPixel($x: number, $y: number, $z: number):UnityEngine.Color;
            public GetPixel($x: number, $y: number, $z: number, $mipLevel: number):UnityEngine.Color;
            public GetPixelBilinear($u: number, $v: number, $w: number):UnityEngine.Color;
            public GetPixelBilinear($u: number, $v: number, $w: number, $mipLevel: number):UnityEngine.Color;
            public constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            public constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            public constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number);
            public constructor($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number);
            public constructor($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $nativeTex: System.IntPtr);
            public constructor($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean);
            public constructor($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $nativeTex: System.IntPtr);
            public constructor();
        }
        export class Texture2DArray extends UnityEngine.Texture{ 
            public static get allSlices(): number;
            public get depth(): number;
            public get format(): UnityEngine.TextureFormat;
            public get isReadable(): boolean;
            public GetPixels($arrayElement: number, $miplevel: number):System.Array$1<UnityEngine.Color>;
            public GetPixels($arrayElement: number):System.Array$1<UnityEngine.Color>;
            public GetPixels32($arrayElement: number, $miplevel: number):System.Array$1<UnityEngine.Color32>;
            public GetPixels32($arrayElement: number):System.Array$1<UnityEngine.Color32>;
            public SetPixels($colors: System.Array$1<UnityEngine.Color>, $arrayElement: number, $miplevel: number):void;
            public SetPixels($colors: System.Array$1<UnityEngine.Color>, $arrayElement: number):void;
            public SetPixels32($colors: System.Array$1<UnityEngine.Color32>, $arrayElement: number, $miplevel: number):void;
            public SetPixels32($colors: System.Array$1<UnityEngine.Color32>, $arrayElement: number):void;
            public Apply($updateMipmaps: boolean, $makeNoLongerReadable: boolean):void;
            public Apply($updateMipmaps: boolean):void;
            public Apply():void;
            public constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            public constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            public constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number);
            public constructor($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean);
            public constructor($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean);
            public constructor($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean);
            public constructor();
        }
        export class CubemapArray extends UnityEngine.Texture{ 
            public get cubemapCount(): number;
            public get format(): UnityEngine.TextureFormat;
            public get isReadable(): boolean;
            public GetPixels($face: UnityEngine.CubemapFace, $arrayElement: number, $miplevel: number):System.Array$1<UnityEngine.Color>;
            public GetPixels($face: UnityEngine.CubemapFace, $arrayElement: number):System.Array$1<UnityEngine.Color>;
            public GetPixels32($face: UnityEngine.CubemapFace, $arrayElement: number, $miplevel: number):System.Array$1<UnityEngine.Color32>;
            public GetPixels32($face: UnityEngine.CubemapFace, $arrayElement: number):System.Array$1<UnityEngine.Color32>;
            public SetPixels($colors: System.Array$1<UnityEngine.Color>, $face: UnityEngine.CubemapFace, $arrayElement: number, $miplevel: number):void;
            public SetPixels($colors: System.Array$1<UnityEngine.Color>, $face: UnityEngine.CubemapFace, $arrayElement: number):void;
            public SetPixels32($colors: System.Array$1<UnityEngine.Color32>, $face: UnityEngine.CubemapFace, $arrayElement: number, $miplevel: number):void;
            public SetPixels32($colors: System.Array$1<UnityEngine.Color32>, $face: UnityEngine.CubemapFace, $arrayElement: number):void;
            public Apply($updateMipmaps: boolean, $makeNoLongerReadable: boolean):void;
            public Apply($updateMipmaps: boolean):void;
            public Apply():void;
            public constructor($width: number, $cubemapCount: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            public constructor($width: number, $cubemapCount: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            public constructor($width: number, $cubemapCount: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number);
            public constructor($width: number, $cubemapCount: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean);
            public constructor($width: number, $cubemapCount: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean);
            public constructor($width: number, $cubemapCount: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean);
            public constructor();
        }
        export class SparseTexture extends UnityEngine.Texture{ 
            public get tileWidth(): number;
            public get tileHeight(): number;
            public get isCreated(): boolean;
            public UpdateTile($tileX: number, $tileY: number, $miplevel: number, $data: System.Array$1<UnityEngine.Color32>):void;
            public UpdateTileRaw($tileX: number, $tileY: number, $miplevel: number, $data: System.Array$1<number>):void;
            public UnloadTile($tileX: number, $tileY: number, $miplevel: number):void;
            public constructor($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $mipCount: number);
            public constructor($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number);
            public constructor($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number);
            public constructor($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean);
            public constructor();
        }
        export class RenderTextureDescriptor extends System.ValueType{ 
            public get width(): number;
            public set width(value: number);
            public get height(): number;
            public set height(value: number);
            public get msaaSamples(): number;
            public set msaaSamples(value: number);
            public get volumeDepth(): number;
            public set volumeDepth(value: number);
            public get mipCount(): number;
            public set mipCount(value: number);
            public get graphicsFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public set graphicsFormat(value: UnityEngine.Experimental.Rendering.GraphicsFormat);
            public get stencilFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public set stencilFormat(value: UnityEngine.Experimental.Rendering.GraphicsFormat);
            public get colorFormat(): UnityEngine.RenderTextureFormat;
            public set colorFormat(value: UnityEngine.RenderTextureFormat);
            public get sRGB(): boolean;
            public set sRGB(value: boolean);
            public get depthBufferBits(): number;
            public set depthBufferBits(value: number);
            public get dimension(): UnityEngine.Rendering.TextureDimension;
            public set dimension(value: UnityEngine.Rendering.TextureDimension);
            public get shadowSamplingMode(): UnityEngine.Rendering.ShadowSamplingMode;
            public set shadowSamplingMode(value: UnityEngine.Rendering.ShadowSamplingMode);
            public get vrUsage(): UnityEngine.VRTextureUsage;
            public set vrUsage(value: UnityEngine.VRTextureUsage);
            public get flags(): UnityEngine.RenderTextureCreationFlags;
            public get memoryless(): UnityEngine.RenderTextureMemoryless;
            public set memoryless(value: UnityEngine.RenderTextureMemoryless);
            public get useMipMap(): boolean;
            public set useMipMap(value: boolean);
            public get autoGenerateMips(): boolean;
            public set autoGenerateMips(value: boolean);
            public get enableRandomWrite(): boolean;
            public set enableRandomWrite(value: boolean);
            public get bindMS(): boolean;
            public set bindMS(value: boolean);
            public get useDynamicScale(): boolean;
            public set useDynamicScale(value: boolean);
            public constructor($width: number, $height: number);
            public constructor($width: number, $height: number, $colorFormat: UnityEngine.RenderTextureFormat);
            public constructor($width: number, $height: number, $colorFormat: UnityEngine.RenderTextureFormat, $depthBufferBits: number);
            public constructor($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthBufferBits: number);
            public constructor($width: number, $height: number, $colorFormat: UnityEngine.RenderTextureFormat, $depthBufferBits: number, $mipCount: number);
            public constructor($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthBufferBits: number, $mipCount: number);
            public constructor();
        }
        export class CustomRenderTextureUpdateZone extends System.ValueType{ 
            public updateZoneCenter: UnityEngine.Vector3;
            public updateZoneSize: UnityEngine.Vector3;
            public rotation: number;
            public passIndex: number;
            public needSwap: boolean;
        }
        export enum FullScreenMovieControlMode{ Full = 0, Minimal = 1, CancelOnInput = 2, Hidden = 3 }
        export enum FullScreenMovieScalingMode{ None = 0, AspectFit = 1, AspectFill = 2, Fill = 3 }
        export enum AndroidActivityIndicatorStyle{ DontShow = -1, Large = 0, InversedLarge = 1, Small = 2, InversedSmall = 3 }
        export class HashUtilities extends System.Object{ 
            public static AppendHash($inHash: $Ref<UnityEngine.Hash128>, $outHash: $Ref<UnityEngine.Hash128>):void;
            public static QuantisedMatrixHash($value: $Ref<UnityEngine.Matrix4x4>, $hash: $Ref<UnityEngine.Hash128>):void;
            public static QuantisedVectorHash($value: $Ref<UnityEngine.Vector3>, $hash: $Ref<UnityEngine.Hash128>):void;
            public static ComputeHash128($value: System.Array$1<number>, $hash: $Ref<UnityEngine.Hash128>):void;
        }
        export class HashUnsafeUtilities extends System.Object{ 
        }
        export enum CursorMode{ Auto = 0, ForceSoftware = 1 }
        export enum CursorLockMode{ None = 0, Locked = 1, Confined = 2 }
        export class Cursor extends System.Object{ 
            public static get visible(): boolean;
            public static set visible(value: boolean);
            public static get lockState(): UnityEngine.CursorLockMode;
            public static set lockState(value: UnityEngine.CursorLockMode);
            public static SetCursor($texture: UnityEngine.Texture2D, $hotspot: UnityEngine.Vector2, $cursorMode: UnityEngine.CursorMode):void;
            public constructor();
        }
        export enum KeyCode{ None = 0, Backspace = 8, Delete = 127, Tab = 9, Clear = 12, Return = 13, Pause = 19, Escape = 27, Space = 32, Keypad0 = 256, Keypad1 = 257, Keypad2 = 258, Keypad3 = 259, Keypad4 = 260, Keypad5 = 261, Keypad6 = 262, Keypad7 = 263, Keypad8 = 264, Keypad9 = 265, KeypadPeriod = 266, KeypadDivide = 267, KeypadMultiply = 268, KeypadMinus = 269, KeypadPlus = 270, KeypadEnter = 271, KeypadEquals = 272, UpArrow = 273, DownArrow = 274, RightArrow = 275, LeftArrow = 276, Insert = 277, Home = 278, End = 279, PageUp = 280, PageDown = 281, F1 = 282, F2 = 283, F3 = 284, F4 = 285, F5 = 286, F6 = 287, F7 = 288, F8 = 289, F9 = 290, F10 = 291, F11 = 292, F12 = 293, F13 = 294, F14 = 295, F15 = 296, Alpha0 = 48, Alpha1 = 49, Alpha2 = 50, Alpha3 = 51, Alpha4 = 52, Alpha5 = 53, Alpha6 = 54, Alpha7 = 55, Alpha8 = 56, Alpha9 = 57, Exclaim = 33, DoubleQuote = 34, Hash = 35, Dollar = 36, Percent = 37, Ampersand = 38, Quote = 39, LeftParen = 40, RightParen = 41, Asterisk = 42, Plus = 43, Comma = 44, Minus = 45, Period = 46, Slash = 47, Colon = 58, Semicolon = 59, Less = 60, Equals = 61, Greater = 62, Question = 63, At = 64, LeftBracket = 91, Backslash = 92, RightBracket = 93, Caret = 94, Underscore = 95, BackQuote = 96, A = 97, B = 98, C = 99, D = 100, E = 101, F = 102, G = 103, H = 104, I = 105, J = 106, K = 107, L = 108, M = 109, N = 110, O = 111, P = 112, Q = 113, R = 114, S = 115, T = 116, U = 117, V = 118, W = 119, X = 120, Y = 121, Z = 122, LeftCurlyBracket = 123, Pipe = 124, RightCurlyBracket = 125, Tilde = 126, Numlock = 300, CapsLock = 301, ScrollLock = 302, RightShift = 303, LeftShift = 304, RightControl = 305, LeftControl = 306, RightAlt = 307, LeftAlt = 308, LeftCommand = 310, LeftApple = 310, LeftWindows = 311, RightCommand = 309, RightApple = 309, RightWindows = 312, AltGr = 313, Help = 315, Print = 316, SysReq = 317, Break = 318, Menu = 319, Mouse0 = 323, Mouse1 = 324, Mouse2 = 325, Mouse3 = 326, Mouse4 = 327, Mouse5 = 328, Mouse6 = 329, JoystickButton0 = 330, JoystickButton1 = 331, JoystickButton2 = 332, JoystickButton3 = 333, JoystickButton4 = 334, JoystickButton5 = 335, JoystickButton6 = 336, JoystickButton7 = 337, JoystickButton8 = 338, JoystickButton9 = 339, JoystickButton10 = 340, JoystickButton11 = 341, JoystickButton12 = 342, JoystickButton13 = 343, JoystickButton14 = 344, JoystickButton15 = 345, JoystickButton16 = 346, JoystickButton17 = 347, JoystickButton18 = 348, JoystickButton19 = 349, Joystick1Button0 = 350, Joystick1Button1 = 351, Joystick1Button2 = 352, Joystick1Button3 = 353, Joystick1Button4 = 354, Joystick1Button5 = 355, Joystick1Button6 = 356, Joystick1Button7 = 357, Joystick1Button8 = 358, Joystick1Button9 = 359, Joystick1Button10 = 360, Joystick1Button11 = 361, Joystick1Button12 = 362, Joystick1Button13 = 363, Joystick1Button14 = 364, Joystick1Button15 = 365, Joystick1Button16 = 366, Joystick1Button17 = 367, Joystick1Button18 = 368, Joystick1Button19 = 369, Joystick2Button0 = 370, Joystick2Button1 = 371, Joystick2Button2 = 372, Joystick2Button3 = 373, Joystick2Button4 = 374, Joystick2Button5 = 375, Joystick2Button6 = 376, Joystick2Button7 = 377, Joystick2Button8 = 378, Joystick2Button9 = 379, Joystick2Button10 = 380, Joystick2Button11 = 381, Joystick2Button12 = 382, Joystick2Button13 = 383, Joystick2Button14 = 384, Joystick2Button15 = 385, Joystick2Button16 = 386, Joystick2Button17 = 387, Joystick2Button18 = 388, Joystick2Button19 = 389, Joystick3Button0 = 390, Joystick3Button1 = 391, Joystick3Button2 = 392, Joystick3Button3 = 393, Joystick3Button4 = 394, Joystick3Button5 = 395, Joystick3Button6 = 396, Joystick3Button7 = 397, Joystick3Button8 = 398, Joystick3Button9 = 399, Joystick3Button10 = 400, Joystick3Button11 = 401, Joystick3Button12 = 402, Joystick3Button13 = 403, Joystick3Button14 = 404, Joystick3Button15 = 405, Joystick3Button16 = 406, Joystick3Button17 = 407, Joystick3Button18 = 408, Joystick3Button19 = 409, Joystick4Button0 = 410, Joystick4Button1 = 411, Joystick4Button2 = 412, Joystick4Button3 = 413, Joystick4Button4 = 414, Joystick4Button5 = 415, Joystick4Button6 = 416, Joystick4Button7 = 417, Joystick4Button8 = 418, Joystick4Button9 = 419, Joystick4Button10 = 420, Joystick4Button11 = 421, Joystick4Button12 = 422, Joystick4Button13 = 423, Joystick4Button14 = 424, Joystick4Button15 = 425, Joystick4Button16 = 426, Joystick4Button17 = 427, Joystick4Button18 = 428, Joystick4Button19 = 429, Joystick5Button0 = 430, Joystick5Button1 = 431, Joystick5Button2 = 432, Joystick5Button3 = 433, Joystick5Button4 = 434, Joystick5Button5 = 435, Joystick5Button6 = 436, Joystick5Button7 = 437, Joystick5Button8 = 438, Joystick5Button9 = 439, Joystick5Button10 = 440, Joystick5Button11 = 441, Joystick5Button12 = 442, Joystick5Button13 = 443, Joystick5Button14 = 444, Joystick5Button15 = 445, Joystick5Button16 = 446, Joystick5Button17 = 447, Joystick5Button18 = 448, Joystick5Button19 = 449, Joystick6Button0 = 450, Joystick6Button1 = 451, Joystick6Button2 = 452, Joystick6Button3 = 453, Joystick6Button4 = 454, Joystick6Button5 = 455, Joystick6Button6 = 456, Joystick6Button7 = 457, Joystick6Button8 = 458, Joystick6Button9 = 459, Joystick6Button10 = 460, Joystick6Button11 = 461, Joystick6Button12 = 462, Joystick6Button13 = 463, Joystick6Button14 = 464, Joystick6Button15 = 465, Joystick6Button16 = 466, Joystick6Button17 = 467, Joystick6Button18 = 468, Joystick6Button19 = 469, Joystick7Button0 = 470, Joystick7Button1 = 471, Joystick7Button2 = 472, Joystick7Button3 = 473, Joystick7Button4 = 474, Joystick7Button5 = 475, Joystick7Button6 = 476, Joystick7Button7 = 477, Joystick7Button8 = 478, Joystick7Button9 = 479, Joystick7Button10 = 480, Joystick7Button11 = 481, Joystick7Button12 = 482, Joystick7Button13 = 483, Joystick7Button14 = 484, Joystick7Button15 = 485, Joystick7Button16 = 486, Joystick7Button17 = 487, Joystick7Button18 = 488, Joystick7Button19 = 489, Joystick8Button0 = 490, Joystick8Button1 = 491, Joystick8Button2 = 492, Joystick8Button3 = 493, Joystick8Button4 = 494, Joystick8Button5 = 495, Joystick8Button6 = 496, Joystick8Button7 = 497, Joystick8Button8 = 498, Joystick8Button9 = 499, Joystick8Button10 = 500, Joystick8Button11 = 501, Joystick8Button12 = 502, Joystick8Button13 = 503, Joystick8Button14 = 504, Joystick8Button15 = 505, Joystick8Button16 = 506, Joystick8Button17 = 507, Joystick8Button18 = 508, Joystick8Button19 = 509 }
        export enum iPhoneScreenOrientation{ Unknown = 0, Portrait = 1, PortraitUpsideDown = 2, LandscapeLeft = 3, LandscapeRight = 4, AutoRotation = 5, Landscape = 6 }
        export enum iPhoneNetworkReachability{ NotReachable = 0, ReachableViaCarrierDataNetwork = 1, ReachableViaWiFiNetwork = 2 }
        export enum iPhoneGeneration{ Unknown = 0, iPhone = 1, iPhone3G = 2, iPhone3GS = 3, iPodTouch1Gen = 4, iPodTouch2Gen = 5, iPodTouch3Gen = 6, iPad1Gen = 7, iPhone4 = 8, iPodTouch4Gen = 9, iPad2Gen = 10, iPhone4S = 11, iPad3Gen = 12, iPhone5 = 13, iPodTouch5Gen = 14, iPadMini1Gen = 15, iPad4Gen = 16, iPhone5C = 17, iPhone5S = 18, iPhoneUnknown = 19, iPadUnknown = 20, iPodTouchUnknown = 21 }
        export enum iPhoneTouchPhase{ Began = 0, Moved = 1, Stationary = 2, Ended = 3, Canceled = 4 }
        export enum iPhoneMovieControlMode{ Full = 0, Minimal = 1, CancelOnTouch = 2, Hidden = 3, VolumeOnly = 4 }
        export enum iPhoneMovieScalingMode{ None = 0, AspectFit = 1, AspectFill = 2, Fill = 3 }
        export enum iPhoneKeyboardType{ Default = 0, ASCIICapable = 1, NumbersAndPunctuation = 2, URL = 3, NumberPad = 4, PhonePad = 5, NamePhonePad = 6, EmailAddress = 7 }
        export enum iPhoneOrientation{ Unknown = 0, Portrait = 1, PortraitUpsideDown = 2, LandscapeLeft = 3, LandscapeRight = 4, FaceUp = 5, FaceDown = 6 }
        export enum iOSActivityIndicatorStyle{ DontShow = 0, WhiteLarge = 1, White = 2, Gray = 3 }
        export enum CalendarIdentifier{ GregorianCalendar = 0, BuddhistCalendar = 1, ChineseCalendar = 2, HebrewCalendar = 3, IslamicCalendar = 4, IslamicCivilCalendar = 5, JapaneseCalendar = 6, RepublicOfChinaCalendar = 7, PersianCalendar = 8, IndianCalendar = 9, ISO8601Calendar = 10 }
        export enum CalendarUnit{ Era = 0, Year = 1, Month = 2, Day = 3, Hour = 4, Minute = 5, Second = 6, Week = 7, Weekday = 8, WeekdayOrdinal = 9, Quarter = 10 }
        export enum RemoteNotificationType{ None = 0, Badge = 1, Sound = 2, Alert = 3 }
        export class Logger extends System.Object implements UnityEngine.ILogger, UnityEngine.ILogHandler{ 
            public get logHandler(): UnityEngine.ILogHandler;
            public set logHandler(value: UnityEngine.ILogHandler);
            public get logEnabled(): boolean;
            public set logEnabled(value: boolean);
            public get filterLogType(): UnityEngine.LogType;
            public set filterLogType(value: UnityEngine.LogType);
            public IsLogTypeAllowed($logType: UnityEngine.LogType):boolean;
            public Log($logType: UnityEngine.LogType, $message: any):void;
            public Log($logType: UnityEngine.LogType, $message: any, $context: UnityEngine.Object):void;
            public Log($logType: UnityEngine.LogType, $tag: string, $message: any):void;
            public Log($logType: UnityEngine.LogType, $tag: string, $message: any, $context: UnityEngine.Object):void;
            public Log($message: any):void;
            public Log($tag: string, $message: any):void;
            public Log($tag: string, $message: any, $context: UnityEngine.Object):void;
            public LogWarning($tag: string, $message: any):void;
            public LogWarning($tag: string, $message: any, $context: UnityEngine.Object):void;
            public LogError($tag: string, $message: any):void;
            public LogError($tag: string, $message: any, $context: UnityEngine.Object):void;
            public LogException($exception: System.Exception):void;
            public LogException($exception: System.Exception, $context: UnityEngine.Object):void;
            public LogFormat($logType: UnityEngine.LogType, $format: string, ...args: any[]):void;
            public LogFormat($logType: UnityEngine.LogType, $context: UnityEngine.Object, $format: string, ...args: any[]):void;
            public constructor($logHandler: UnityEngine.ILogHandler);
            public IsLogTypeAllowed($logType: UnityEngine.LogType):boolean;
            public Log($logType: UnityEngine.LogType, $message: any):void;
            public Log($logType: UnityEngine.LogType, $message: any, $context: UnityEngine.Object):void;
            public Log($logType: UnityEngine.LogType, $tag: string, $message: any):void;
            public Log($logType: UnityEngine.LogType, $tag: string, $message: any, $context: UnityEngine.Object):void;
            public Log($message: any):void;
            public Log($tag: string, $message: any):void;
            public Log($tag: string, $message: any, $context: UnityEngine.Object):void;
            public LogWarning($tag: string, $message: any):void;
            public LogWarning($tag: string, $message: any, $context: UnityEngine.Object):void;
            public LogError($tag: string, $message: any):void;
            public LogError($tag: string, $message: any, $context: UnityEngine.Object):void;
            public LogFormat($logType: UnityEngine.LogType, $format: string, ...args: any[]):void;
            public LogException($exception: System.Exception):void;
            public LogFormat($logType: UnityEngine.LogType, $context: UnityEngine.Object, $format: string, ...args: any[]):void;
            public LogException($exception: System.Exception, $context: UnityEngine.Object):void;
            public LogFormat($logType: UnityEngine.LogType, $context: UnityEngine.Object, $format: string, ...args: any[]):void;
            public LogException($exception: System.Exception, $context: UnityEngine.Object):void;
            public LogFormat($logType: UnityEngine.LogType, $context: UnityEngine.Object, $format: string, ...args: any[]):void;
            public LogException($exception: System.Exception, $context: UnityEngine.Object):void;
            public constructor();
        }
        export class ColorUtility extends System.Object{ 
            public static TryParseHtmlString($htmlString: string, $color: $Ref<UnityEngine.Color>):boolean;
            public static ToHtmlStringRGB($color: UnityEngine.Color):string;
            public static ToHtmlStringRGBA($color: UnityEngine.Color):string;
            public constructor();
        }
        export class GradientColorKey extends System.ValueType{ 
            public color: UnityEngine.Color;
            public time: number;
            public constructor($col: UnityEngine.Color, $time: number);
            public constructor();
        }
        export class GradientAlphaKey extends System.ValueType{ 
            public alpha: number;
            public time: number;
            public constructor($alpha: number, $time: number);
            public constructor();
        }
        export enum GradientMode{ Blend = 0, Fixed = 1 }
        export class FrustumPlanes extends System.ValueType{ 
            public left: number;
            public right: number;
            public bottom: number;
            public top: number;
            public zNear: number;
            public zFar: number;
        }
        export class Mathf extends System.ValueType{ 
            public static PI: number;
            public static Infinity: number;
            public static NegativeInfinity: number;
            public static Deg2Rad: number;
            public static Rad2Deg: number;
            public static Epsilon: number;
            public static ClosestPowerOfTwo($value: number):number;
            public static IsPowerOfTwo($value: number):boolean;
            public static NextPowerOfTwo($value: number):number;
            public static GammaToLinearSpace($value: number):number;
            public static LinearToGammaSpace($value: number):number;
            public static CorrelatedColorTemperatureToRGB($kelvin: number):UnityEngine.Color;
            public static FloatToHalf($val: number):number;
            public static HalfToFloat($val: number):number;
            public static PerlinNoise($x: number, $y: number):number;
            public static Sin($f: number):number;
            public static Cos($f: number):number;
            public static Tan($f: number):number;
            public static Asin($f: number):number;
            public static Acos($f: number):number;
            public static Atan($f: number):number;
            public static Atan2($y: number, $x: number):number;
            public static Sqrt($f: number):number;
            public static Abs($f: number):number;
            public static Abs($value: number):number;
            public static Min($a: number, $b: number):number;
            public static Min(...values: number[]):number;
            public static Min($a: number, $b: number):number;
            public static Min(...values: number[]):number;
            public static Max($a: number, $b: number):number;
            public static Max(...values: number[]):number;
            public static Max($a: number, $b: number):number;
            public static Max(...values: number[]):number;
            public static Pow($f: number, $p: number):number;
            public static Exp($power: number):number;
            public static Log($f: number, $p: number):number;
            public static Log($f: number):number;
            public static Log10($f: number):number;
            public static Ceil($f: number):number;
            public static Floor($f: number):number;
            public static Round($f: number):number;
            public static CeilToInt($f: number):number;
            public static FloorToInt($f: number):number;
            public static RoundToInt($f: number):number;
            public static Sign($f: number):number;
            public static Clamp($value: number, $min: number, $max: number):number;
            public static Clamp($value: number, $min: number, $max: number):number;
            public static Clamp01($value: number):number;
            public static Lerp($a: number, $b: number, $t: number):number;
            public static LerpUnclamped($a: number, $b: number, $t: number):number;
            public static LerpAngle($a: number, $b: number, $t: number):number;
            public static MoveTowards($current: number, $target: number, $maxDelta: number):number;
            public static MoveTowardsAngle($current: number, $target: number, $maxDelta: number):number;
            public static SmoothStep($from: number, $to: number, $t: number):number;
            public static Gamma($value: number, $absmax: number, $gamma: number):number;
            public static Approximately($a: number, $b: number):boolean;
            public static SmoothDamp($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number, $maxSpeed: number):number;
            public static SmoothDamp($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number):number;
            public static SmoothDamp($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number, $maxSpeed: number, $deltaTime: number):number;
            public static SmoothDampAngle($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number, $maxSpeed: number):number;
            public static SmoothDampAngle($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number):number;
            public static SmoothDampAngle($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number, $maxSpeed: number, $deltaTime: number):number;
            public static Repeat($t: number, $length: number):number;
            public static PingPong($t: number, $length: number):number;
            public static InverseLerp($a: number, $b: number, $value: number):number;
            public static DeltaAngle($current: number, $target: number):number;
        }
        export enum RPCMode{  }
        export enum ConnectionTesterStatus{  }
        export enum NetworkConnectionError{  }
        export enum NetworkDisconnection{  }
        export enum MasterServerEvent{  }
        export enum NetworkStateSynchronization{  }
        export enum NetworkPeerType{  }
        export enum NetworkLogLevel{  }
        export class Ping extends System.Object{ 
            public get isDone(): boolean;
            public get time(): number;
            public get ip(): string;
            public DestroyPing():void;
            public constructor($address: string);
            public constructor();
        }
        export class PlayerPrefsException extends System.Exception implements System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable{ 
            public constructor($error: string);
            public constructor();
        }
        export class PlayerPrefs extends System.Object{ 
            public static SetInt($key: string, $value: number):void;
            public static GetInt($key: string, $defaultValue: number):number;
            public static GetInt($key: string):number;
            public static SetFloat($key: string, $value: number):void;
            public static GetFloat($key: string, $defaultValue: number):number;
            public static GetFloat($key: string):number;
            public static SetString($key: string, $value: string):void;
            public static GetString($key: string, $defaultValue: string):string;
            public static GetString($key: string):string;
            public static HasKey($key: string):boolean;
            public static DeleteKey($key: string):void;
            public static DeleteAll():void;
            public static Save():void;
            public constructor();
        }
        export class PropertyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public get order(): number;
            public set order(value: number);
        }
        export class ContextMenuItemAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute{ 
            public name: string;
            public function: string;
            public constructor($name: string, $function: string);
            public constructor();
        }
        export class InspectorNameAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute{ 
            public displayName: string;
            public constructor($displayName: string);
            public constructor();
        }
        export class TooltipAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute{ 
            public tooltip: string;
            public constructor($tooltip: string);
            public constructor();
        }
        export class SpaceAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute{ 
            public height: number;
            public constructor();
            public constructor($height: number);
        }
        export class HeaderAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute{ 
            public header: string;
            public constructor($header: string);
            public constructor();
        }
        export class RangeAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute{ 
            public min: number;
            public max: number;
            public constructor($min: number, $max: number);
            public constructor();
        }
        export class MinAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute{ 
            public min: number;
            public constructor($min: number);
            public constructor();
        }
        export class MultilineAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute{ 
            public lines: number;
            public constructor();
            public constructor($lines: number);
        }
        export class TextAreaAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute{ 
            public minLines: number;
            public maxLines: number;
            public constructor();
            public constructor($minLines: number, $maxLines: number);
        }
        export class ColorUsageAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute{ 
            public showAlpha: boolean;
            public hdr: boolean;
            public constructor($showAlpha: boolean);
            public constructor($showAlpha: boolean, $hdr: boolean);
            public constructor();
        }
        export class GradientUsageAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute{ 
            public hdr: boolean;
            public colorSpace: UnityEngine.ColorSpace;
            public constructor($hdr: boolean);
            public constructor($hdr: boolean, $colorSpace: UnityEngine.ColorSpace);
            public constructor();
        }
        export class DelayedAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class NonReorderableAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class Random extends System.Object{ 
            public static get state(): UnityEngine.Random.State;
            public static set state(value: UnityEngine.Random.State);
            public static get value(): number;
            public static get insideUnitSphere(): UnityEngine.Vector3;
            public static get insideUnitCircle(): UnityEngine.Vector2;
            public static get onUnitSphere(): UnityEngine.Vector3;
            public static get rotation(): UnityEngine.Quaternion;
            public static get rotationUniform(): UnityEngine.Quaternion;
            public static InitState($seed: number):void;
            public static Range($minInclusive: number, $maxInclusive: number):number;
            public static Range($minInclusive: number, $maxExclusive: number):number;
            public static ColorHSV():UnityEngine.Color;
            public static ColorHSV($hueMin: number, $hueMax: number):UnityEngine.Color;
            public static ColorHSV($hueMin: number, $hueMax: number, $saturationMin: number, $saturationMax: number):UnityEngine.Color;
            public static ColorHSV($hueMin: number, $hueMax: number, $saturationMin: number, $saturationMax: number, $valueMin: number, $valueMax: number):UnityEngine.Color;
            public static ColorHSV($hueMin: number, $hueMax: number, $saturationMin: number, $saturationMax: number, $valueMin: number, $valueMax: number, $alphaMin: number, $alphaMax: number):UnityEngine.Color;
        }
        export class ResourcesAPI extends System.Object{ 
            public static get overrideAPI(): UnityEngine.ResourcesAPI;
            public static set overrideAPI(value: UnityEngine.ResourcesAPI);
        }
        export class Resources extends System.Object{ 
            public static FindObjectsOfTypeAll($type: System.Type):System.Array$1<UnityEngine.Object>;
            public static Load($path: string):UnityEngine.Object;
            public static Load($path: string, $systemTypeInstance: System.Type):UnityEngine.Object;
            public static LoadAsync($path: string):UnityEngine.ResourceRequest;
            public static LoadAsync($path: string, $type: System.Type):UnityEngine.ResourceRequest;
            public static LoadAll($path: string, $systemTypeInstance: System.Type):System.Array$1<UnityEngine.Object>;
            public static LoadAll($path: string):System.Array$1<UnityEngine.Object>;
            public static GetBuiltinResource($type: System.Type, $path: string):UnityEngine.Object;
            public static UnloadAsset($assetToUnload: UnityEngine.Object):void;
            public static UnloadUnusedAssets():UnityEngine.AsyncOperation;
            public static InstanceIDToObject($instanceID: number):UnityEngine.Object;
            public static InstanceIDToObjectList($instanceIDs: Unity.Collections.NativeArray$1<number>, $objects: System.Collections.Generic.List$1<UnityEngine.Object>):void;
            public constructor();
        }
        export class DisallowMultipleComponent extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class RequireComponent extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public m_Type0: System.Type;
            public m_Type1: System.Type;
            public m_Type2: System.Type;
            public constructor($requiredComponent: System.Type);
            public constructor($requiredComponent: System.Type, $requiredComponent2: System.Type);
            public constructor($requiredComponent: System.Type, $requiredComponent2: System.Type, $requiredComponent3: System.Type);
            public constructor();
        }
        export class AddComponentMenu extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public get componentMenu(): string;
            public get componentOrder(): number;
            public constructor($menuName: string);
            public constructor($menuName: string, $order: number);
            public constructor();
        }
        export class CreateAssetMenuAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public get menuName(): string;
            public set menuName(value: string);
            public get fileName(): string;
            public set fileName(value: string);
            public get order(): number;
            public set order(value: number);
            public constructor();
        }
        export class ContextMenu extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public menuItem: string;
            public validate: boolean;
            public priority: number;
            public constructor($itemName: string);
            public constructor($itemName: string, $isValidateFunction: boolean);
            public constructor($itemName: string, $isValidateFunction: boolean, $priority: number);
            public constructor();
        }
        export class ExecuteInEditMode extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class ExecuteAlways extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class HideInInspector extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class HelpURLAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public get URL(): string;
            public constructor($url: string);
            public constructor();
        }
        export class DefaultExecutionOrder extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public get order(): number;
            public constructor($order: number);
            public constructor();
        }
        export class AssemblyIsEditorAssembly extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
        }
        export class ExcludeFromPresetAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class CustomYieldInstruction extends System.Object implements System.Collections.IEnumerator{ 
            public get keepWaiting(): boolean;
            public get Current(): any;
            public MoveNext():boolean;
            public Reset():void;
        }
        export class ExcludeFromObjectFactoryAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class LayerMask extends System.ValueType{ 
            public get value(): number;
            public set value(value: number);
            public static op_Implicit($mask: UnityEngine.LayerMask):number;
            public static op_Implicit($intVal: number):UnityEngine.LayerMask;
            public static LayerToName($layer: number):string;
            public static NameToLayer($layerName: string):number;
            public static GetMask(...layerNames: string[]):number;
        }
        interface LayerMask {
            Inverse():UnityEngine.LayerMask;
            AddToMask(...layerNames: string[]):UnityEngine.LayerMask;
            RemoveFromMask(...layerNames: string[]):UnityEngine.LayerMask;
            ContainsAnyLayer(...layerNames: string[]):boolean;
            ContainsAllLayers(...layerNames: string[]):boolean;
            MaskToNames():System.Array$1<string>;
            MaskToString():string;
            MaskToString($delimiter: string):string;
        }
        export class RangeInt extends System.ValueType{ 
            public start: number;
            public length: number;
            public get end(): number;
            public constructor($start: number, $length: number);
            public constructor();
        }
        export enum RuntimeInitializeLoadType{ AfterSceneLoad = 0, BeforeSceneLoad = 1, AfterAssembliesLoaded = 2, BeforeSplashScreen = 3, SubsystemRegistration = 4 }
        export class RuntimeInitializeOnLoadMethodAttribute extends UnityEngine.Scripting.PreserveAttribute implements System.Runtime.InteropServices._Attribute{ 
            public get loadType(): UnityEngine.RuntimeInitializeLoadType;
            public constructor();
            public constructor($loadType: UnityEngine.RuntimeInitializeLoadType);
        }
        export class SelectionBaseAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class StackTraceUtility extends System.Object{ 
            public static ExtractStackTrace():string;
            public static ExtractStringFromException($exception: any):string;
        }
        export class UnityException extends System.SystemException implements System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable{ 
            public constructor();
            public constructor($message: string);
            public constructor($message: string, $innerException: System.Exception);
        }
        export class MissingComponentException extends System.SystemException implements System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable{ 
            public constructor();
            public constructor($message: string);
            public constructor($message: string, $innerException: System.Exception);
        }
        export class UnassignedReferenceException extends System.SystemException implements System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable{ 
            public constructor();
            public constructor($message: string);
            public constructor($message: string, $innerException: System.Exception);
        }
        export class MissingReferenceException extends System.SystemException implements System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable{ 
            public constructor();
            public constructor($message: string);
            public constructor($message: string, $innerException: System.Exception);
        }
        export class TextAsset extends UnityEngine.Object{ 
            public get bytes(): System.Array$1<number>;
            public get text(): string;
            public constructor();
            public constructor($text: string);
        }
        export class UnityAPICompatibilityVersionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public get version(): string;
            public constructor($version: string, $checkOnlyUnityVersion: boolean);
            public constructor($version: string, $configurationAssembliesHashes: System.Array$1<string>);
            public constructor();
        }
        export class WaitForEndOfFrame extends UnityEngine.YieldInstruction{ 
            public constructor();
        }
        export class WaitForFixedUpdate extends UnityEngine.YieldInstruction{ 
            public constructor();
        }
        export class WaitForSeconds extends UnityEngine.YieldInstruction{ 
            public constructor($seconds: number);
            public constructor();
        }
        export class WaitForSecondsRealtime extends UnityEngine.CustomYieldInstruction implements System.Collections.IEnumerator{ 
            public get waitTime(): number;
            public set waitTime(value: number);
            public get keepWaiting(): boolean;
            public constructor($time: number);
            public constructor();
        }
        export class WaitUntil extends UnityEngine.CustomYieldInstruction implements System.Collections.IEnumerator{ 
            public get keepWaiting(): boolean;
            public constructor($predicate: System.Func$1<boolean>);
            public constructor();
        }
        export class WaitWhile extends UnityEngine.CustomYieldInstruction implements System.Collections.IEnumerator{ 
            public get keepWaiting(): boolean;
            public constructor($predicate: System.Func$1<boolean>);
            public constructor();
        }
        export class Security extends System.Object{ 
            public constructor();
        }
        export class Types extends System.Object{ 
        }
        export class SerializeField extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class SerializeReference extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class PreferBinarySerialization extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class ComputeShader extends UnityEngine.Object{ 
            public get shaderKeywords(): System.Array$1<string>;
            public set shaderKeywords(value: System.Array$1<string>);
            public FindKernel($name: string):number;
            public HasKernel($name: string):boolean;
            public SetFloat($nameID: number, $val: number):void;
            public SetInt($nameID: number, $val: number):void;
            public SetVector($nameID: number, $val: UnityEngine.Vector4):void;
            public SetMatrix($nameID: number, $val: UnityEngine.Matrix4x4):void;
            public SetVectorArray($nameID: number, $values: System.Array$1<UnityEngine.Vector4>):void;
            public SetMatrixArray($nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>):void;
            public SetTexture($kernelIndex: number, $nameID: number, $texture: UnityEngine.Texture, $mipLevel: number):void;
            public SetTextureFromGlobal($kernelIndex: number, $nameID: number, $globalTextureNameID: number):void;
            public SetBuffer($kernelIndex: number, $nameID: number, $buffer: UnityEngine.ComputeBuffer):void;
            public SetBuffer($kernelIndex: number, $nameID: number, $buffer: UnityEngine.GraphicsBuffer):void;
            public GetKernelThreadGroupSizes($kernelIndex: number, $x: $Ref<number>, $y: $Ref<number>, $z: $Ref<number>):void;
            public Dispatch($kernelIndex: number, $threadGroupsX: number, $threadGroupsY: number, $threadGroupsZ: number):void;
            public EnableKeyword($keyword: string):void;
            public DisableKeyword($keyword: string):void;
            public IsKeywordEnabled($keyword: string):boolean;
            public IsSupported($kernelIndex: number):boolean;
            public SetFloat($name: string, $val: number):void;
            public SetInt($name: string, $val: number):void;
            public SetVector($name: string, $val: UnityEngine.Vector4):void;
            public SetMatrix($name: string, $val: UnityEngine.Matrix4x4):void;
            public SetVectorArray($name: string, $values: System.Array$1<UnityEngine.Vector4>):void;
            public SetMatrixArray($name: string, $values: System.Array$1<UnityEngine.Matrix4x4>):void;
            public SetFloats($name: string, ...values: number[]):void;
            public SetFloats($nameID: number, ...values: number[]):void;
            public SetInts($name: string, ...values: number[]):void;
            public SetInts($nameID: number, ...values: number[]):void;
            public SetBool($name: string, $val: boolean):void;
            public SetBool($nameID: number, $val: boolean):void;
            public SetTexture($kernelIndex: number, $nameID: number, $texture: UnityEngine.Texture):void;
            public SetTexture($kernelIndex: number, $name: string, $texture: UnityEngine.Texture):void;
            public SetTexture($kernelIndex: number, $name: string, $texture: UnityEngine.Texture, $mipLevel: number):void;
            public SetTexture($kernelIndex: number, $nameID: number, $texture: UnityEngine.RenderTexture, $mipLevel: number, $element: UnityEngine.Rendering.RenderTextureSubElement):void;
            public SetTexture($kernelIndex: number, $name: string, $texture: UnityEngine.RenderTexture, $mipLevel: number, $element: UnityEngine.Rendering.RenderTextureSubElement):void;
            public SetTextureFromGlobal($kernelIndex: number, $name: string, $globalTextureName: string):void;
            public SetBuffer($kernelIndex: number, $name: string, $buffer: UnityEngine.ComputeBuffer):void;
            public SetBuffer($kernelIndex: number, $name: string, $buffer: UnityEngine.GraphicsBuffer):void;
            public SetConstantBuffer($nameID: number, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number):void;
            public SetConstantBuffer($name: string, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number):void;
            public SetConstantBuffer($nameID: number, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number):void;
            public SetConstantBuffer($name: string, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number):void;
            public DispatchIndirect($kernelIndex: number, $argsBuffer: UnityEngine.ComputeBuffer, $argsOffset: number):void;
            public DispatchIndirect($kernelIndex: number, $argsBuffer: UnityEngine.ComputeBuffer):void;
            public DispatchIndirect($kernelIndex: number, $argsBuffer: UnityEngine.GraphicsBuffer, $argsOffset: number):void;
            public DispatchIndirect($kernelIndex: number, $argsBuffer: UnityEngine.GraphicsBuffer):void;
        }
        export class ShaderVariantCollection extends UnityEngine.Object{ 
            public get shaderCount(): number;
            public get variantCount(): number;
            public get isWarmedUp(): boolean;
            public Clear():void;
            public WarmUp():void;
            public Add($variant: UnityEngine.ShaderVariantCollection.ShaderVariant):boolean;
            public Remove($variant: UnityEngine.ShaderVariantCollection.ShaderVariant):boolean;
            public Contains($variant: UnityEngine.ShaderVariantCollection.ShaderVariant):boolean;
            public constructor();
        }
        export enum SnapAxis{ None = 0, X = 1, Y = 2, Z = 4, All = 7 }
        export class Snapping extends System.Object{ 
            public static Snap($val: number, $snap: number):number;
            public static Snap($val: UnityEngine.Vector2, $snap: UnityEngine.Vector2):UnityEngine.Vector2;
            public static Snap($val: UnityEngine.Vector3, $snap: UnityEngine.Vector3, $axis?: UnityEngine.SnapAxis):UnityEngine.Vector3;
        }
        export class StaticBatchingUtility extends System.Object{ 
            public static Combine($staticBatchRoot: UnityEngine.GameObject):void;
            public static Combine($gos: System.Array$1<UnityEngine.GameObject>, $staticBatchRoot: UnityEngine.GameObject):void;
            public constructor();
        }
        export enum BatteryStatus{ Unknown = 0, Charging = 1, Discharging = 2, NotCharging = 3, Full = 4 }
        export enum OperatingSystemFamily{ Other = 0, MacOSX = 1, Windows = 2, Linux = 3 }
        export enum DeviceType{ Unknown = 0, Handheld = 1, Console = 2, Desktop = 3 }
        export class SystemInfo extends System.Object{ 
            public static unsupportedIdentifier: string;
            public static get batteryLevel(): number;
            public static get batteryStatus(): UnityEngine.BatteryStatus;
            public static get operatingSystem(): string;
            public static get operatingSystemFamily(): UnityEngine.OperatingSystemFamily;
            public static get processorType(): string;
            public static get processorFrequency(): number;
            public static get processorCount(): number;
            public static get systemMemorySize(): number;
            public static get deviceUniqueIdentifier(): string;
            public static get deviceName(): string;
            public static get deviceModel(): string;
            public static get supportsAccelerometer(): boolean;
            public static get supportsGyroscope(): boolean;
            public static get supportsLocationService(): boolean;
            public static get supportsVibration(): boolean;
            public static get supportsAudio(): boolean;
            public static get deviceType(): UnityEngine.DeviceType;
            public static get graphicsMemorySize(): number;
            public static get graphicsDeviceName(): string;
            public static get graphicsDeviceVendor(): string;
            public static get graphicsDeviceID(): number;
            public static get graphicsDeviceVendorID(): number;
            public static get graphicsDeviceType(): UnityEngine.Rendering.GraphicsDeviceType;
            public static get graphicsUVStartsAtTop(): boolean;
            public static get graphicsDeviceVersion(): string;
            public static get graphicsShaderLevel(): number;
            public static get graphicsMultiThreaded(): boolean;
            public static get renderingThreadingMode(): UnityEngine.Rendering.RenderingThreadingMode;
            public static get hasHiddenSurfaceRemovalOnGPU(): boolean;
            public static get hasDynamicUniformArrayIndexingInFragmentShaders(): boolean;
            public static get supportsShadows(): boolean;
            public static get supportsRawShadowDepthSampling(): boolean;
            public static get supportsMotionVectors(): boolean;
            public static get supports3DTextures(): boolean;
            public static get supportsCompressed3DTextures(): boolean;
            public static get supports2DArrayTextures(): boolean;
            public static get supports3DRenderTextures(): boolean;
            public static get supportsCubemapArrayTextures(): boolean;
            public static get copyTextureSupport(): UnityEngine.Rendering.CopyTextureSupport;
            public static get supportsComputeShaders(): boolean;
            public static get supportsGeometryShaders(): boolean;
            public static get supportsTessellationShaders(): boolean;
            public static get supportsRenderTargetArrayIndexFromVertexShader(): boolean;
            public static get supportsInstancing(): boolean;
            public static get supportsHardwareQuadTopology(): boolean;
            public static get supports32bitsIndexBuffer(): boolean;
            public static get supportsSparseTextures(): boolean;
            public static get supportedRenderTargetCount(): number;
            public static get supportsSeparatedRenderTargetsBlend(): boolean;
            public static get supportedRandomWriteTargetCount(): number;
            public static get supportsMultisampledTextures(): number;
            public static get supportsMultisampled2DArrayTextures(): boolean;
            public static get supportsMultisampleAutoResolve(): boolean;
            public static get supportsTextureWrapMirrorOnce(): number;
            public static get usesReversedZBuffer(): boolean;
            public static get npotSupport(): UnityEngine.NPOTSupport;
            public static get maxTextureSize(): number;
            public static get maxCubemapSize(): number;
            public static get maxComputeBufferInputsVertex(): number;
            public static get maxComputeBufferInputsFragment(): number;
            public static get maxComputeBufferInputsGeometry(): number;
            public static get maxComputeBufferInputsDomain(): number;
            public static get maxComputeBufferInputsHull(): number;
            public static get maxComputeBufferInputsCompute(): number;
            public static get maxComputeWorkGroupSize(): number;
            public static get maxComputeWorkGroupSizeX(): number;
            public static get maxComputeWorkGroupSizeY(): number;
            public static get maxComputeWorkGroupSizeZ(): number;
            public static get supportsAsyncCompute(): boolean;
            public static get supportsGpuRecorder(): boolean;
            public static get supportsGraphicsFence(): boolean;
            public static get supportsAsyncGPUReadback(): boolean;
            public static get supportsRayTracing(): boolean;
            public static get supportsSetConstantBuffer(): boolean;
            public static get constantBufferOffsetAlignment(): number;
            public static get hasMipMaxLevel(): boolean;
            public static get supportsMipStreaming(): boolean;
            public static get usesLoadStoreActions(): boolean;
            public static get hdrDisplaySupportFlags(): UnityEngine.HDRDisplaySupportFlags;
            public static get supportsConservativeRaster(): boolean;
            public static get supportsMultiview(): boolean;
            public static get supportsStoreAndResolveAction(): boolean;
            public static SupportsRenderTextureFormat($format: UnityEngine.RenderTextureFormat):boolean;
            public static SupportsBlendingOnRenderTextureFormat($format: UnityEngine.RenderTextureFormat):boolean;
            public static SupportsRandomWriteOnRenderTextureFormat($format: UnityEngine.RenderTextureFormat):boolean;
            public static SupportsTextureFormat($format: UnityEngine.TextureFormat):boolean;
            public static SupportsVertexAttributeFormat($format: UnityEngine.Rendering.VertexAttributeFormat, $dimension: number):boolean;
            public static IsFormatSupported($format: UnityEngine.Experimental.Rendering.GraphicsFormat, $usage: UnityEngine.Experimental.Rendering.FormatUsage):boolean;
            public static GetCompatibleFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat, $usage: UnityEngine.Experimental.Rendering.FormatUsage):UnityEngine.Experimental.Rendering.GraphicsFormat;
            public static GetGraphicsFormat($format: UnityEngine.Experimental.Rendering.DefaultFormat):UnityEngine.Experimental.Rendering.GraphicsFormat;
            public static GetRenderTextureSupportedMSAASampleCount($desc: UnityEngine.RenderTextureDescriptor):number;
            public constructor();
        }
        export class UnityEventQueueSystem extends System.Object{ 
            public static GenerateEventIdForPayload($eventPayloadName: string):string;
            public static GetGlobalEventQueue():System.IntPtr;
            public constructor();
        }
        export class Pose extends System.ValueType implements System.IEquatable$1<UnityEngine.Pose>{ 
            public position: UnityEngine.Vector3;
            public rotation: UnityEngine.Quaternion;
            public get forward(): UnityEngine.Vector3;
            public get right(): UnityEngine.Vector3;
            public get up(): UnityEngine.Vector3;
            public static get identity(): UnityEngine.Pose;
            public ToString():string;
            public ToString($format: string):string;
            public GetTransformedBy($lhs: UnityEngine.Pose):UnityEngine.Pose;
            public GetTransformedBy($lhs: UnityEngine.Transform):UnityEngine.Pose;
            public Equals($obj: any):boolean;
            public Equals($other: UnityEngine.Pose):boolean;
            public static op_Equality($a: UnityEngine.Pose, $b: UnityEngine.Pose):boolean;
            public static op_Inequality($a: UnityEngine.Pose, $b: UnityEngine.Pose):boolean;
            public constructor($position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion);
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
            public constructor();
        }
        export enum DrivenTransformProperties{ None = 0, All = -1, AnchoredPositionX = 2, AnchoredPositionY = 4, AnchoredPositionZ = 8, Rotation = 16, ScaleX = 32, ScaleY = 64, ScaleZ = 128, AnchorMinX = 256, AnchorMinY = 512, AnchorMaxX = 1024, AnchorMaxY = 2048, SizeDeltaX = 4096, SizeDeltaY = 8192, PivotX = 16384, PivotY = 32768, AnchoredPosition = 6, AnchoredPosition3D = 14, Scale = 224, AnchorMin = 768, AnchorMax = 3072, Anchors = 3840, SizeDelta = 12288, Pivot = 49152 }
        export class DrivenRectTransformTracker extends System.ValueType{ 
            public Add($driver: UnityEngine.Object, $rectTransform: UnityEngine.RectTransform, $drivenProperties: UnityEngine.DrivenTransformProperties):void;
            public Clear():void;
        }
        export class RectTransform extends UnityEngine.Transform implements System.Collections.IEnumerable{ 
            public get rect(): UnityEngine.Rect;
            public get anchorMin(): UnityEngine.Vector2;
            public set anchorMin(value: UnityEngine.Vector2);
            public get anchorMax(): UnityEngine.Vector2;
            public set anchorMax(value: UnityEngine.Vector2);
            public get anchoredPosition(): UnityEngine.Vector2;
            public set anchoredPosition(value: UnityEngine.Vector2);
            public get sizeDelta(): UnityEngine.Vector2;
            public set sizeDelta(value: UnityEngine.Vector2);
            public get pivot(): UnityEngine.Vector2;
            public set pivot(value: UnityEngine.Vector2);
            public get anchoredPosition3D(): UnityEngine.Vector3;
            public set anchoredPosition3D(value: UnityEngine.Vector3);
            public get offsetMin(): UnityEngine.Vector2;
            public set offsetMin(value: UnityEngine.Vector2);
            public get offsetMax(): UnityEngine.Vector2;
            public set offsetMax(value: UnityEngine.Vector2);
            public get drivenByObject(): UnityEngine.Object;
            public static add_reapplyDrivenProperties($value: UnityEngine.RectTransform.ReapplyDrivenProperties):void;
            public static remove_reapplyDrivenProperties($value: UnityEngine.RectTransform.ReapplyDrivenProperties):void;
            public ForceUpdateRectTransforms():void;
            public GetLocalCorners($fourCornersArray: System.Array$1<UnityEngine.Vector3>):void;
            public GetWorldCorners($fourCornersArray: System.Array$1<UnityEngine.Vector3>):void;
            public SetInsetAndSizeFromParentEdge($edge: UnityEngine.RectTransform.Edge, $inset: number, $size: number):void;
            public SetSizeWithCurrentAnchors($axis: UnityEngine.RectTransform.Axis, $size: number):void;
            public constructor();
        }
        interface RectTransform {
            WrappedSetParent($parent: UnityEngine.Transform):void;
            DOJump($endValue: UnityEngine.Vector3, $numJumps: number, $duration: number, $snapping?: boolean):DG.Tweening.Sequence;
            MatchOther($other: UnityEngine.RectTransform):void;
            Height($height?: number):number;
            Width($width?: number):number;
            Top($top?: number):number;
            Bottom($bottom?: number):number;
            Pos($pos: UnityEngine.Vector2):UnityEngine.Vector2;
            Pos($x?: number, $y?: number):UnityEngine.Vector2;
            PosX($x?: number):number;
            PosY($y?: number):number;
            SetLeft($left: number):void;
            SetRight($right: number):void;
            SetTop($top: number):void;
            SetBottom($bottom: number):void;
            AlignTo($dest: UnityEngine.RectTransform, $moveToLast?: boolean):UnityEngine.RectTransform;
            AlignTo($dest: UnityEngine.Transform, $moveToLast?: boolean):UnityEngine.RectTransform;
            switchToRectTransform($to: UnityEngine.RectTransform):UnityEngine.Vector2;
            GetParentCanvas():UnityEngine.Canvas;
            DOAnchorPos($endValue: UnityEngine.Vector2, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            DOAnchorPosX($endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            DOAnchorPosY($endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            DOAnchorPos3D($endValue: UnityEngine.Vector3, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.Options.VectorOptions>;
            DOAnchorPos3DX($endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.Options.VectorOptions>;
            DOAnchorPos3DY($endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.Options.VectorOptions>;
            DOAnchorPos3DZ($endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.Options.VectorOptions>;
            DOAnchorMax($endValue: UnityEngine.Vector2, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            DOAnchorMin($endValue: UnityEngine.Vector2, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            DOPivot($endValue: UnityEngine.Vector2, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            DOPivotX($endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            DOPivotY($endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            DOSizeDelta($endValue: UnityEngine.Vector2, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            DOPunchAnchorPos($punch: UnityEngine.Vector2, $duration: number, $vibrato?: number, $elasticity?: number, $snapping?: boolean):DG.Tweening.Tweener;
            DOShakeAnchorPos($duration: number, $strength?: number, $vibrato?: number, $randomness?: number, $snapping?: boolean, $fadeOut?: boolean):DG.Tweening.Tweener;
            DOShakeAnchorPos($duration: number, $strength: UnityEngine.Vector2, $vibrato?: number, $randomness?: number, $snapping?: boolean, $fadeOut?: boolean):DG.Tweening.Tweener;
            DOJumpAnchorPos($endValue: UnityEngine.Vector2, $jumpPower: number, $numJumps: number, $duration: number, $snapping?: boolean):DG.Tweening.Sequence;
            DOShapeCircle($center: UnityEngine.Vector2, $endValueDegrees: number, $duration: number, $relativeCenter?: boolean, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.CircleOptions>;
        }
        export enum SpriteDrawMode{ Simple = 0, Sliced = 1, Tiled = 2 }
        export enum SpriteTileMode{ Continuous = 0, Adaptive = 1 }
        export enum SpriteMaskInteraction{ None = 0, VisibleInsideMask = 1, VisibleOutsideMask = 2 }
        export class SpriteRenderer extends UnityEngine.Renderer{ 
            public get sprite(): UnityEngine.Sprite;
            public set sprite(value: UnityEngine.Sprite);
            public get drawMode(): UnityEngine.SpriteDrawMode;
            public set drawMode(value: UnityEngine.SpriteDrawMode);
            public get size(): UnityEngine.Vector2;
            public set size(value: UnityEngine.Vector2);
            public get adaptiveModeThreshold(): number;
            public set adaptiveModeThreshold(value: number);
            public get tileMode(): UnityEngine.SpriteTileMode;
            public set tileMode(value: UnityEngine.SpriteTileMode);
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public get maskInteraction(): UnityEngine.SpriteMaskInteraction;
            public set maskInteraction(value: UnityEngine.SpriteMaskInteraction);
            public get flipX(): boolean;
            public set flipX(value: boolean);
            public get flipY(): boolean;
            public set flipY(value: boolean);
            public get spriteSortPoint(): UnityEngine.SpriteSortPoint;
            public set spriteSortPoint(value: UnityEngine.SpriteSortPoint);
            public constructor();
        }
        interface SpriteRenderer {
            DOColor($endValue: UnityEngine.Color, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions>;
            DOFade($endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions>;
            DOGradientColor($gradient: UnityEngine.Gradient, $duration: number):DG.Tweening.Sequence;
            DOBlendableColor($endValue: UnityEngine.Color, $duration: number):DG.Tweening.Tweener;
        }
        export class Sprite extends UnityEngine.Object{ 
            public get bounds(): UnityEngine.Bounds;
            public get rect(): UnityEngine.Rect;
            public get border(): UnityEngine.Vector4;
            public get texture(): UnityEngine.Texture2D;
            public get pixelsPerUnit(): number;
            public get spriteAtlasTextureScale(): number;
            public get associatedAlphaSplitTexture(): UnityEngine.Texture2D;
            public get pivot(): UnityEngine.Vector2;
            public get packed(): boolean;
            public get packingMode(): UnityEngine.SpritePackingMode;
            public get packingRotation(): UnityEngine.SpritePackingRotation;
            public get textureRect(): UnityEngine.Rect;
            public get textureRectOffset(): UnityEngine.Vector2;
            public get vertices(): System.Array$1<UnityEngine.Vector2>;
            public get triangles(): System.Array$1<number>;
            public get uv(): System.Array$1<UnityEngine.Vector2>;
            public GetPhysicsShapeCount():number;
            public GetPhysicsShapePointCount($shapeIdx: number):number;
            public GetPhysicsShape($shapeIdx: number, $physicsShape: System.Collections.Generic.List$1<UnityEngine.Vector2>):number;
            public OverridePhysicsShape($physicsShapes: System.Collections.Generic.IList$1<System.Array$1<UnityEngine.Vector2>>):void;
            public OverrideGeometry($vertices: System.Array$1<UnityEngine.Vector2>, $triangles: System.Array$1<number>):void;
            public static Create($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number, $extrude: number, $meshType: UnityEngine.SpriteMeshType, $border: UnityEngine.Vector4, $generateFallbackPhysicsShape: boolean):UnityEngine.Sprite;
            public static Create($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number, $extrude: number, $meshType: UnityEngine.SpriteMeshType, $border: UnityEngine.Vector4):UnityEngine.Sprite;
            public static Create($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number, $extrude: number, $meshType: UnityEngine.SpriteMeshType):UnityEngine.Sprite;
            public static Create($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number, $extrude: number):UnityEngine.Sprite;
            public static Create($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number):UnityEngine.Sprite;
            public static Create($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2):UnityEngine.Sprite;
        }
        export enum SpriteSortPoint{ Center = 0, Pivot = 1 }
        export enum SpriteMeshType{ FullRect = 0, Tight = 1 }
        export enum SpriteAlignment{ Center = 0, TopLeft = 1, TopCenter = 2, TopRight = 3, LeftCenter = 4, RightCenter = 5, BottomLeft = 6, BottomCenter = 7, BottomRight = 8, Custom = 9 }
        export enum SpritePackingMode{ Tight = 0, Rectangle = 1 }
        export enum SpritePackingRotation{ None = 0, FlipHorizontal = 1, FlipVertical = 2, Rotate180 = 3, Any = 15 }
        export class SecondarySpriteTexture extends System.ValueType{ 
            public name: string;
            public texture: UnityEngine.Texture2D;
        }
        export class Social extends System.Object{ 
            public static get Active(): UnityEngine.SocialPlatforms.ISocialPlatform;
            public static set Active(value: UnityEngine.SocialPlatforms.ISocialPlatform);
            public static get localUser(): UnityEngine.SocialPlatforms.ILocalUser;
            public static LoadUsers($userIDs: System.Array$1<string>, $callback: System.Action$1<System.Array$1<UnityEngine.SocialPlatforms.IUserProfile>>):void;
            public static ReportProgress($achievementID: string, $progress: number, $callback: System.Action$1<boolean>):void;
            public static LoadAchievementDescriptions($callback: System.Action$1<System.Array$1<UnityEngine.SocialPlatforms.IAchievementDescription>>):void;
            public static LoadAchievements($callback: System.Action$1<System.Array$1<UnityEngine.SocialPlatforms.IAchievement>>):void;
            public static ReportScore($score: bigint, $board: string, $callback: System.Action$1<boolean>):void;
            public static LoadScores($leaderboardID: string, $callback: System.Action$1<System.Array$1<UnityEngine.SocialPlatforms.IScore>>):void;
            public static CreateLeaderboard():UnityEngine.SocialPlatforms.ILeaderboard;
            public static CreateAchievement():UnityEngine.SocialPlatforms.IAchievement;
            public static ShowAchievementsUI():void;
            public static ShowLeaderboardUI():void;
        }
        export class Grid extends UnityEngine.GridLayout{ 
            public get cellSize(): UnityEngine.Vector3;
            public set cellSize(value: UnityEngine.Vector3);
            public get cellGap(): UnityEngine.Vector3;
            public set cellGap(value: UnityEngine.Vector3);
            public get cellLayout(): UnityEngine.GridLayout.CellLayout;
            public set cellLayout(value: UnityEngine.GridLayout.CellLayout);
            public get cellSwizzle(): UnityEngine.GridLayout.CellSwizzle;
            public set cellSwizzle(value: UnityEngine.GridLayout.CellSwizzle);
            public GetCellCenterLocal($position: UnityEngine.Vector3Int):UnityEngine.Vector3;
            public GetCellCenterWorld($position: UnityEngine.Vector3Int):UnityEngine.Vector3;
            public static Swizzle($swizzle: UnityEngine.GridLayout.CellSwizzle, $position: UnityEngine.Vector3):UnityEngine.Vector3;
            public static InverseSwizzle($swizzle: UnityEngine.GridLayout.CellSwizzle, $position: UnityEngine.Vector3):UnityEngine.Vector3;
            public constructor();
        }
        export class GridLayout extends UnityEngine.Behaviour{ 
            public get cellSize(): UnityEngine.Vector3;
            public get cellGap(): UnityEngine.Vector3;
            public get cellLayout(): UnityEngine.GridLayout.CellLayout;
            public get cellSwizzle(): UnityEngine.GridLayout.CellSwizzle;
            public GetBoundsLocal($cellPosition: UnityEngine.Vector3Int):UnityEngine.Bounds;
            public GetBoundsLocal($origin: UnityEngine.Vector3, $size: UnityEngine.Vector3):UnityEngine.Bounds;
            public CellToLocal($cellPosition: UnityEngine.Vector3Int):UnityEngine.Vector3;
            public LocalToCell($localPosition: UnityEngine.Vector3):UnityEngine.Vector3Int;
            public CellToLocalInterpolated($cellPosition: UnityEngine.Vector3):UnityEngine.Vector3;
            public LocalToCellInterpolated($localPosition: UnityEngine.Vector3):UnityEngine.Vector3;
            public CellToWorld($cellPosition: UnityEngine.Vector3Int):UnityEngine.Vector3;
            public WorldToCell($worldPosition: UnityEngine.Vector3):UnityEngine.Vector3Int;
            public LocalToWorld($localPosition: UnityEngine.Vector3):UnityEngine.Vector3;
            public WorldToLocal($worldPosition: UnityEngine.Vector3):UnityEngine.Vector3;
            public GetLayoutCellCenter():UnityEngine.Vector3;
            public constructor();
        }
        export enum EventType{ MouseDown = 0, MouseUp = 1, MouseMove = 2, MouseDrag = 3, KeyDown = 4, KeyUp = 5, ScrollWheel = 6, Repaint = 7, Layout = 8, DragUpdated = 9, DragPerform = 10, DragExited = 15, Ignore = 11, Used = 12, ValidateCommand = 13, ExecuteCommand = 14, ContextClick = 16, MouseEnterWindow = 20, MouseLeaveWindow = 21, TouchDown = 30, TouchUp = 31, TouchMove = 32, TouchEnter = 33, TouchLeave = 34, TouchStationary = 35, mouseDown = 0, mouseUp = 1, mouseMove = 2, mouseDrag = 3, keyDown = 4, keyUp = 5, scrollWheel = 6, repaint = 7, layout = 8, dragUpdated = 9, dragPerform = 10, ignore = 11, used = 12 }
        export enum PointerType{ Mouse = 0, Touch = 1, Pen = 2 }
        export enum EventModifiers{ None = 0, Shift = 1, Control = 2, Alt = 4, Command = 8, Numeric = 16, CapsLock = 32, FunctionKey = 64 }
        export class GUI extends System.Object{ 
            public static get color(): UnityEngine.Color;
            public static set color(value: UnityEngine.Color);
            public static get backgroundColor(): UnityEngine.Color;
            public static set backgroundColor(value: UnityEngine.Color);
            public static get contentColor(): UnityEngine.Color;
            public static set contentColor(value: UnityEngine.Color);
            public static get changed(): boolean;
            public static set changed(value: boolean);
            public static get enabled(): boolean;
            public static set enabled(value: boolean);
            public static get depth(): number;
            public static set depth(value: number);
            public static get skin(): UnityEngine.GUISkin;
            public static set skin(value: UnityEngine.GUISkin);
            public static get matrix(): UnityEngine.Matrix4x4;
            public static set matrix(value: UnityEngine.Matrix4x4);
            public static get tooltip(): string;
            public static set tooltip(value: string);
            public static SetNextControlName($name: string):void;
            public static GetNameOfFocusedControl():string;
            public static FocusControl($name: string):void;
            public static DragWindow($position: UnityEngine.Rect):void;
            public static BringWindowToFront($windowID: number):void;
            public static BringWindowToBack($windowID: number):void;
            public static FocusWindow($windowID: number):void;
            public static UnfocusWindow():void;
            public static Label($position: UnityEngine.Rect, $text: string):void;
            public static Label($position: UnityEngine.Rect, $image: UnityEngine.Texture):void;
            public static Label($position: UnityEngine.Rect, $content: UnityEngine.GUIContent):void;
            public static Label($position: UnityEngine.Rect, $text: string, $style: UnityEngine.GUIStyle):void;
            public static Label($position: UnityEngine.Rect, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle):void;
            public static Label($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle):void;
            public static DrawTexture($position: UnityEngine.Rect, $image: UnityEngine.Texture):void;
            public static DrawTexture($position: UnityEngine.Rect, $image: UnityEngine.Texture, $scaleMode: UnityEngine.ScaleMode):void;
            public static DrawTexture($position: UnityEngine.Rect, $image: UnityEngine.Texture, $scaleMode: UnityEngine.ScaleMode, $alphaBlend: boolean):void;
            public static DrawTexture($position: UnityEngine.Rect, $image: UnityEngine.Texture, $scaleMode: UnityEngine.ScaleMode, $alphaBlend: boolean, $imageAspect: number):void;
            public static DrawTexture($position: UnityEngine.Rect, $image: UnityEngine.Texture, $scaleMode: UnityEngine.ScaleMode, $alphaBlend: boolean, $imageAspect: number, $color: UnityEngine.Color, $borderWidth: number, $borderRadius: number):void;
            public static DrawTexture($position: UnityEngine.Rect, $image: UnityEngine.Texture, $scaleMode: UnityEngine.ScaleMode, $alphaBlend: boolean, $imageAspect: number, $color: UnityEngine.Color, $borderWidths: UnityEngine.Vector4, $borderRadius: number):void;
            public static DrawTexture($position: UnityEngine.Rect, $image: UnityEngine.Texture, $scaleMode: UnityEngine.ScaleMode, $alphaBlend: boolean, $imageAspect: number, $color: UnityEngine.Color, $borderWidths: UnityEngine.Vector4, $borderRadiuses: UnityEngine.Vector4):void;
            public static DrawTextureWithTexCoords($position: UnityEngine.Rect, $image: UnityEngine.Texture, $texCoords: UnityEngine.Rect):void;
            public static DrawTextureWithTexCoords($position: UnityEngine.Rect, $image: UnityEngine.Texture, $texCoords: UnityEngine.Rect, $alphaBlend: boolean):void;
            public static Box($position: UnityEngine.Rect, $text: string):void;
            public static Box($position: UnityEngine.Rect, $image: UnityEngine.Texture):void;
            public static Box($position: UnityEngine.Rect, $content: UnityEngine.GUIContent):void;
            public static Box($position: UnityEngine.Rect, $text: string, $style: UnityEngine.GUIStyle):void;
            public static Box($position: UnityEngine.Rect, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle):void;
            public static Box($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle):void;
            public static Button($position: UnityEngine.Rect, $text: string):boolean;
            public static Button($position: UnityEngine.Rect, $image: UnityEngine.Texture):boolean;
            public static Button($position: UnityEngine.Rect, $content: UnityEngine.GUIContent):boolean;
            public static Button($position: UnityEngine.Rect, $text: string, $style: UnityEngine.GUIStyle):boolean;
            public static Button($position: UnityEngine.Rect, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle):boolean;
            public static Button($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle):boolean;
            public static RepeatButton($position: UnityEngine.Rect, $text: string):boolean;
            public static RepeatButton($position: UnityEngine.Rect, $image: UnityEngine.Texture):boolean;
            public static RepeatButton($position: UnityEngine.Rect, $content: UnityEngine.GUIContent):boolean;
            public static RepeatButton($position: UnityEngine.Rect, $text: string, $style: UnityEngine.GUIStyle):boolean;
            public static RepeatButton($position: UnityEngine.Rect, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle):boolean;
            public static RepeatButton($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle):boolean;
            public static TextField($position: UnityEngine.Rect, $text: string):string;
            public static TextField($position: UnityEngine.Rect, $text: string, $maxLength: number):string;
            public static TextField($position: UnityEngine.Rect, $text: string, $style: UnityEngine.GUIStyle):string;
            public static TextField($position: UnityEngine.Rect, $text: string, $maxLength: number, $style: UnityEngine.GUIStyle):string;
            public static PasswordField($position: UnityEngine.Rect, $password: string, $maskChar: number):string;
            public static PasswordField($position: UnityEngine.Rect, $password: string, $maskChar: number, $maxLength: number):string;
            public static PasswordField($position: UnityEngine.Rect, $password: string, $maskChar: number, $style: UnityEngine.GUIStyle):string;
            public static PasswordField($position: UnityEngine.Rect, $password: string, $maskChar: number, $maxLength: number, $style: UnityEngine.GUIStyle):string;
            public static TextArea($position: UnityEngine.Rect, $text: string):string;
            public static TextArea($position: UnityEngine.Rect, $text: string, $maxLength: number):string;
            public static TextArea($position: UnityEngine.Rect, $text: string, $style: UnityEngine.GUIStyle):string;
            public static TextArea($position: UnityEngine.Rect, $text: string, $maxLength: number, $style: UnityEngine.GUIStyle):string;
            public static Toggle($position: UnityEngine.Rect, $value: boolean, $text: string):boolean;
            public static Toggle($position: UnityEngine.Rect, $value: boolean, $image: UnityEngine.Texture):boolean;
            public static Toggle($position: UnityEngine.Rect, $value: boolean, $content: UnityEngine.GUIContent):boolean;
            public static Toggle($position: UnityEngine.Rect, $value: boolean, $text: string, $style: UnityEngine.GUIStyle):boolean;
            public static Toggle($position: UnityEngine.Rect, $value: boolean, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle):boolean;
            public static Toggle($position: UnityEngine.Rect, $value: boolean, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle):boolean;
            public static Toggle($position: UnityEngine.Rect, $id: number, $value: boolean, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle):boolean;
            public static Toolbar($position: UnityEngine.Rect, $selected: number, $texts: System.Array$1<string>):number;
            public static Toolbar($position: UnityEngine.Rect, $selected: number, $images: System.Array$1<UnityEngine.Texture>):number;
            public static Toolbar($position: UnityEngine.Rect, $selected: number, $contents: System.Array$1<UnityEngine.GUIContent>):number;
            public static Toolbar($position: UnityEngine.Rect, $selected: number, $texts: System.Array$1<string>, $style: UnityEngine.GUIStyle):number;
            public static Toolbar($position: UnityEngine.Rect, $selected: number, $images: System.Array$1<UnityEngine.Texture>, $style: UnityEngine.GUIStyle):number;
            public static Toolbar($position: UnityEngine.Rect, $selected: number, $contents: System.Array$1<UnityEngine.GUIContent>, $style: UnityEngine.GUIStyle):number;
            public static Toolbar($position: UnityEngine.Rect, $selected: number, $contents: System.Array$1<UnityEngine.GUIContent>, $style: UnityEngine.GUIStyle, $buttonSize: UnityEngine.GUI.ToolbarButtonSize):number;
            public static SelectionGrid($position: UnityEngine.Rect, $selected: number, $texts: System.Array$1<string>, $xCount: number):number;
            public static SelectionGrid($position: UnityEngine.Rect, $selected: number, $images: System.Array$1<UnityEngine.Texture>, $xCount: number):number;
            public static SelectionGrid($position: UnityEngine.Rect, $selected: number, $content: System.Array$1<UnityEngine.GUIContent>, $xCount: number):number;
            public static SelectionGrid($position: UnityEngine.Rect, $selected: number, $texts: System.Array$1<string>, $xCount: number, $style: UnityEngine.GUIStyle):number;
            public static SelectionGrid($position: UnityEngine.Rect, $selected: number, $images: System.Array$1<UnityEngine.Texture>, $xCount: number, $style: UnityEngine.GUIStyle):number;
            public static SelectionGrid($position: UnityEngine.Rect, $selected: number, $contents: System.Array$1<UnityEngine.GUIContent>, $xCount: number, $style: UnityEngine.GUIStyle):number;
            public static HorizontalSlider($position: UnityEngine.Rect, $value: number, $leftValue: number, $rightValue: number):number;
            public static HorizontalSlider($position: UnityEngine.Rect, $value: number, $leftValue: number, $rightValue: number, $slider: UnityEngine.GUIStyle, $thumb: UnityEngine.GUIStyle):number;
            public static HorizontalSlider($position: UnityEngine.Rect, $value: number, $leftValue: number, $rightValue: number, $slider: UnityEngine.GUIStyle, $thumb: UnityEngine.GUIStyle, $thumbExtent: UnityEngine.GUIStyle):number;
            public static VerticalSlider($position: UnityEngine.Rect, $value: number, $topValue: number, $bottomValue: number):number;
            public static VerticalSlider($position: UnityEngine.Rect, $value: number, $topValue: number, $bottomValue: number, $slider: UnityEngine.GUIStyle, $thumb: UnityEngine.GUIStyle):number;
            public static VerticalSlider($position: UnityEngine.Rect, $value: number, $topValue: number, $bottomValue: number, $slider: UnityEngine.GUIStyle, $thumb: UnityEngine.GUIStyle, $thumbExtent: UnityEngine.GUIStyle):number;
            public static Slider($position: UnityEngine.Rect, $value: number, $size: number, $start: number, $end: number, $slider: UnityEngine.GUIStyle, $thumb: UnityEngine.GUIStyle, $horiz: boolean, $id: number, $thumbExtent?: UnityEngine.GUIStyle):number;
            public static HorizontalScrollbar($position: UnityEngine.Rect, $value: number, $size: number, $leftValue: number, $rightValue: number):number;
            public static HorizontalScrollbar($position: UnityEngine.Rect, $value: number, $size: number, $leftValue: number, $rightValue: number, $style: UnityEngine.GUIStyle):number;
            public static VerticalScrollbar($position: UnityEngine.Rect, $value: number, $size: number, $topValue: number, $bottomValue: number):number;
            public static VerticalScrollbar($position: UnityEngine.Rect, $value: number, $size: number, $topValue: number, $bottomValue: number, $style: UnityEngine.GUIStyle):number;
            public static BeginClip($position: UnityEngine.Rect, $scrollOffset: UnityEngine.Vector2, $renderOffset: UnityEngine.Vector2, $resetOffset: boolean):void;
            public static BeginGroup($position: UnityEngine.Rect):void;
            public static BeginGroup($position: UnityEngine.Rect, $text: string):void;
            public static BeginGroup($position: UnityEngine.Rect, $image: UnityEngine.Texture):void;
            public static BeginGroup($position: UnityEngine.Rect, $content: UnityEngine.GUIContent):void;
            public static BeginGroup($position: UnityEngine.Rect, $style: UnityEngine.GUIStyle):void;
            public static BeginGroup($position: UnityEngine.Rect, $text: string, $style: UnityEngine.GUIStyle):void;
            public static BeginGroup($position: UnityEngine.Rect, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle):void;
            public static BeginGroup($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle):void;
            public static EndGroup():void;
            public static BeginClip($position: UnityEngine.Rect):void;
            public static EndClip():void;
            public static BeginScrollView($position: UnityEngine.Rect, $scrollPosition: UnityEngine.Vector2, $viewRect: UnityEngine.Rect):UnityEngine.Vector2;
            public static BeginScrollView($position: UnityEngine.Rect, $scrollPosition: UnityEngine.Vector2, $viewRect: UnityEngine.Rect, $alwaysShowHorizontal: boolean, $alwaysShowVertical: boolean):UnityEngine.Vector2;
            public static BeginScrollView($position: UnityEngine.Rect, $scrollPosition: UnityEngine.Vector2, $viewRect: UnityEngine.Rect, $horizontalScrollbar: UnityEngine.GUIStyle, $verticalScrollbar: UnityEngine.GUIStyle):UnityEngine.Vector2;
            public static BeginScrollView($position: UnityEngine.Rect, $scrollPosition: UnityEngine.Vector2, $viewRect: UnityEngine.Rect, $alwaysShowHorizontal: boolean, $alwaysShowVertical: boolean, $horizontalScrollbar: UnityEngine.GUIStyle, $verticalScrollbar: UnityEngine.GUIStyle):UnityEngine.Vector2;
            public static EndScrollView():void;
            public static EndScrollView($handleScrollWheel: boolean):void;
            public static ScrollTo($position: UnityEngine.Rect):void;
            public static ScrollTowards($position: UnityEngine.Rect, $maxDelta: number):boolean;
            public static Window($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $text: string):UnityEngine.Rect;
            public static Window($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $image: UnityEngine.Texture):UnityEngine.Rect;
            public static Window($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $content: UnityEngine.GUIContent):UnityEngine.Rect;
            public static Window($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $text: string, $style: UnityEngine.GUIStyle):UnityEngine.Rect;
            public static Window($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle):UnityEngine.Rect;
            public static Window($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $title: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle):UnityEngine.Rect;
            public static ModalWindow($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $text: string):UnityEngine.Rect;
            public static ModalWindow($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $image: UnityEngine.Texture):UnityEngine.Rect;
            public static ModalWindow($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $content: UnityEngine.GUIContent):UnityEngine.Rect;
            public static ModalWindow($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $text: string, $style: UnityEngine.GUIStyle):UnityEngine.Rect;
            public static ModalWindow($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle):UnityEngine.Rect;
            public static ModalWindow($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle):UnityEngine.Rect;
            public static DragWindow():void;
            public constructor();
        }
        export class GUISkin extends UnityEngine.ScriptableObject{ 
            public get font(): UnityEngine.Font;
            public set font(value: UnityEngine.Font);
            public get box(): UnityEngine.GUIStyle;
            public set box(value: UnityEngine.GUIStyle);
            public get label(): UnityEngine.GUIStyle;
            public set label(value: UnityEngine.GUIStyle);
            public get textField(): UnityEngine.GUIStyle;
            public set textField(value: UnityEngine.GUIStyle);
            public get textArea(): UnityEngine.GUIStyle;
            public set textArea(value: UnityEngine.GUIStyle);
            public get button(): UnityEngine.GUIStyle;
            public set button(value: UnityEngine.GUIStyle);
            public get toggle(): UnityEngine.GUIStyle;
            public set toggle(value: UnityEngine.GUIStyle);
            public get window(): UnityEngine.GUIStyle;
            public set window(value: UnityEngine.GUIStyle);
            public get horizontalSlider(): UnityEngine.GUIStyle;
            public set horizontalSlider(value: UnityEngine.GUIStyle);
            public get horizontalSliderThumb(): UnityEngine.GUIStyle;
            public set horizontalSliderThumb(value: UnityEngine.GUIStyle);
            public get verticalSlider(): UnityEngine.GUIStyle;
            public set verticalSlider(value: UnityEngine.GUIStyle);
            public get verticalSliderThumb(): UnityEngine.GUIStyle;
            public set verticalSliderThumb(value: UnityEngine.GUIStyle);
            public get horizontalScrollbar(): UnityEngine.GUIStyle;
            public set horizontalScrollbar(value: UnityEngine.GUIStyle);
            public get horizontalScrollbarThumb(): UnityEngine.GUIStyle;
            public set horizontalScrollbarThumb(value: UnityEngine.GUIStyle);
            public get horizontalScrollbarLeftButton(): UnityEngine.GUIStyle;
            public set horizontalScrollbarLeftButton(value: UnityEngine.GUIStyle);
            public get horizontalScrollbarRightButton(): UnityEngine.GUIStyle;
            public set horizontalScrollbarRightButton(value: UnityEngine.GUIStyle);
            public get verticalScrollbar(): UnityEngine.GUIStyle;
            public set verticalScrollbar(value: UnityEngine.GUIStyle);
            public get verticalScrollbarThumb(): UnityEngine.GUIStyle;
            public set verticalScrollbarThumb(value: UnityEngine.GUIStyle);
            public get verticalScrollbarUpButton(): UnityEngine.GUIStyle;
            public set verticalScrollbarUpButton(value: UnityEngine.GUIStyle);
            public get verticalScrollbarDownButton(): UnityEngine.GUIStyle;
            public set verticalScrollbarDownButton(value: UnityEngine.GUIStyle);
            public get scrollView(): UnityEngine.GUIStyle;
            public set scrollView(value: UnityEngine.GUIStyle);
            public get customStyles(): System.Array$1<UnityEngine.GUIStyle>;
            public set customStyles(value: System.Array$1<UnityEngine.GUIStyle>);
            public get settings(): UnityEngine.GUISettings;
            public GetStyle($styleName: string):UnityEngine.GUIStyle;
            public FindStyle($styleName: string):UnityEngine.GUIStyle;
            public GetEnumerator():System.Collections.IEnumerator;
            public constructor();
        }
        export class GUIContent extends System.Object{ 
            public static none: UnityEngine.GUIContent;
            public get text(): string;
            public set text(value: string);
            public get image(): UnityEngine.Texture;
            public set image(value: UnityEngine.Texture);
            public get tooltip(): string;
            public set tooltip(value: string);
            public constructor();
            public constructor($text: string);
            public constructor($image: UnityEngine.Texture);
            public constructor($text: string, $image: UnityEngine.Texture);
            public constructor($text: string, $tooltip: string);
            public constructor($image: UnityEngine.Texture, $tooltip: string);
            public constructor($text: string, $image: UnityEngine.Texture, $tooltip: string);
            public constructor($src: UnityEngine.GUIContent);
        }
        export class GUIStyle extends System.Object{ 
            public get font(): UnityEngine.Font;
            public set font(value: UnityEngine.Font);
            public get imagePosition(): UnityEngine.ImagePosition;
            public set imagePosition(value: UnityEngine.ImagePosition);
            public get alignment(): UnityEngine.TextAnchor;
            public set alignment(value: UnityEngine.TextAnchor);
            public get wordWrap(): boolean;
            public set wordWrap(value: boolean);
            public get clipping(): UnityEngine.TextClipping;
            public set clipping(value: UnityEngine.TextClipping);
            public get contentOffset(): UnityEngine.Vector2;
            public set contentOffset(value: UnityEngine.Vector2);
            public get fixedWidth(): number;
            public set fixedWidth(value: number);
            public get fixedHeight(): number;
            public set fixedHeight(value: number);
            public get stretchWidth(): boolean;
            public set stretchWidth(value: boolean);
            public get stretchHeight(): boolean;
            public set stretchHeight(value: boolean);
            public get fontSize(): number;
            public set fontSize(value: number);
            public get fontStyle(): UnityEngine.FontStyle;
            public set fontStyle(value: UnityEngine.FontStyle);
            public get richText(): boolean;
            public set richText(value: boolean);
            public get name(): string;
            public set name(value: string);
            public get normal(): UnityEngine.GUIStyleState;
            public set normal(value: UnityEngine.GUIStyleState);
            public get hover(): UnityEngine.GUIStyleState;
            public set hover(value: UnityEngine.GUIStyleState);
            public get active(): UnityEngine.GUIStyleState;
            public set active(value: UnityEngine.GUIStyleState);
            public get onNormal(): UnityEngine.GUIStyleState;
            public set onNormal(value: UnityEngine.GUIStyleState);
            public get onHover(): UnityEngine.GUIStyleState;
            public set onHover(value: UnityEngine.GUIStyleState);
            public get onActive(): UnityEngine.GUIStyleState;
            public set onActive(value: UnityEngine.GUIStyleState);
            public get focused(): UnityEngine.GUIStyleState;
            public set focused(value: UnityEngine.GUIStyleState);
            public get onFocused(): UnityEngine.GUIStyleState;
            public set onFocused(value: UnityEngine.GUIStyleState);
            public get border(): UnityEngine.RectOffset;
            public set border(value: UnityEngine.RectOffset);
            public get margin(): UnityEngine.RectOffset;
            public set margin(value: UnityEngine.RectOffset);
            public get padding(): UnityEngine.RectOffset;
            public set padding(value: UnityEngine.RectOffset);
            public get overflow(): UnityEngine.RectOffset;
            public set overflow(value: UnityEngine.RectOffset);
            public get lineHeight(): number;
            public static get none(): UnityEngine.GUIStyle;
            public get isHeightDependantOnWidth(): boolean;
            public Draw($position: UnityEngine.Rect, $isHover: boolean, $isActive: boolean, $on: boolean, $hasKeyboardFocus: boolean):void;
            public Draw($position: UnityEngine.Rect, $text: string, $isHover: boolean, $isActive: boolean, $on: boolean, $hasKeyboardFocus: boolean):void;
            public Draw($position: UnityEngine.Rect, $image: UnityEngine.Texture, $isHover: boolean, $isActive: boolean, $on: boolean, $hasKeyboardFocus: boolean):void;
            public Draw($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $isHover: boolean, $isActive: boolean, $on: boolean, $hasKeyboardFocus: boolean):void;
            public Draw($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $controlID: number):void;
            public Draw($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $controlID: number, $on: boolean):void;
            public Draw($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $controlID: number, $on: boolean, $hover: boolean):void;
            public DrawCursor($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $controlID: number, $character: number):void;
            public DrawWithTextSelection($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $controlID: number, $firstSelectedCharacter: number, $lastSelectedCharacter: number):void;
            public static op_Implicit($str: string):UnityEngine.GUIStyle;
            public GetCursorPixelPosition($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $cursorStringIndex: number):UnityEngine.Vector2;
            public GetCursorStringIndex($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $cursorPixelPosition: UnityEngine.Vector2):number;
            public CalcSize($content: UnityEngine.GUIContent):UnityEngine.Vector2;
            public CalcScreenSize($contentSize: UnityEngine.Vector2):UnityEngine.Vector2;
            public CalcHeight($content: UnityEngine.GUIContent, $width: number):number;
            public CalcMinMaxWidth($content: UnityEngine.GUIContent, $minWidth: $Ref<number>, $maxWidth: $Ref<number>):void;
            public constructor();
            public constructor($other: UnityEngine.GUIStyle);
        }
        interface GUIStyle {
            Margin($left: number, $right: number, $top: number, $bottom: number):UnityEngine.GUIStyle;
            Padding($left: number, $right: number, $top: number, $bottom: number):UnityEngine.GUIStyle;
            Border($left: number, $right: number, $top: number, $bottom: number):UnityEngine.GUIStyle;
            Overflow($left: number, $right: number, $top: number, $bottom: number):UnityEngine.GUIStyle;
            TextAlignment($anchor: UnityEngine.TextAnchor):UnityEngine.GUIStyle;
            RichText($rich: boolean):UnityEngine.GUIStyle;
        }
        export enum ScaleMode{ StretchToFill = 0, ScaleAndCrop = 1, ScaleToFit = 2 }
        export enum FocusType{ Native = 0, Keyboard = 1, Passive = 2 }
        export class GUILayout extends System.Object{ 
            public static Label($image: UnityEngine.Texture, ...options: UnityEngine.GUILayoutOption[]):void;
            public static Label($text: string, ...options: UnityEngine.GUILayoutOption[]):void;
            public static Label($content: UnityEngine.GUIContent, ...options: UnityEngine.GUILayoutOption[]):void;
            public static Label($image: UnityEngine.Texture, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):void;
            public static Label($text: string, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):void;
            public static Label($content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):void;
            public static Box($image: UnityEngine.Texture, ...options: UnityEngine.GUILayoutOption[]):void;
            public static Box($text: string, ...options: UnityEngine.GUILayoutOption[]):void;
            public static Box($content: UnityEngine.GUIContent, ...options: UnityEngine.GUILayoutOption[]):void;
            public static Box($image: UnityEngine.Texture, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):void;
            public static Box($text: string, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):void;
            public static Box($content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):void;
            public static Button($image: UnityEngine.Texture, ...options: UnityEngine.GUILayoutOption[]):boolean;
            public static Button($text: string, ...options: UnityEngine.GUILayoutOption[]):boolean;
            public static Button($content: UnityEngine.GUIContent, ...options: UnityEngine.GUILayoutOption[]):boolean;
            public static Button($image: UnityEngine.Texture, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):boolean;
            public static Button($text: string, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):boolean;
            public static Button($content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):boolean;
            public static RepeatButton($image: UnityEngine.Texture, ...options: UnityEngine.GUILayoutOption[]):boolean;
            public static RepeatButton($text: string, ...options: UnityEngine.GUILayoutOption[]):boolean;
            public static RepeatButton($content: UnityEngine.GUIContent, ...options: UnityEngine.GUILayoutOption[]):boolean;
            public static RepeatButton($image: UnityEngine.Texture, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):boolean;
            public static RepeatButton($text: string, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):boolean;
            public static RepeatButton($content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):boolean;
            public static TextField($text: string, ...options: UnityEngine.GUILayoutOption[]):string;
            public static TextField($text: string, $maxLength: number, ...options: UnityEngine.GUILayoutOption[]):string;
            public static TextField($text: string, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):string;
            public static TextField($text: string, $maxLength: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):string;
            public static PasswordField($password: string, $maskChar: number, ...options: UnityEngine.GUILayoutOption[]):string;
            public static PasswordField($password: string, $maskChar: number, $maxLength: number, ...options: UnityEngine.GUILayoutOption[]):string;
            public static PasswordField($password: string, $maskChar: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):string;
            public static PasswordField($password: string, $maskChar: number, $maxLength: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):string;
            public static TextArea($text: string, ...options: UnityEngine.GUILayoutOption[]):string;
            public static TextArea($text: string, $maxLength: number, ...options: UnityEngine.GUILayoutOption[]):string;
            public static TextArea($text: string, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):string;
            public static TextArea($text: string, $maxLength: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):string;
            public static Toggle($value: boolean, $image: UnityEngine.Texture, ...options: UnityEngine.GUILayoutOption[]):boolean;
            public static Toggle($value: boolean, $text: string, ...options: UnityEngine.GUILayoutOption[]):boolean;
            public static Toggle($value: boolean, $content: UnityEngine.GUIContent, ...options: UnityEngine.GUILayoutOption[]):boolean;
            public static Toggle($value: boolean, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):boolean;
            public static Toggle($value: boolean, $text: string, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):boolean;
            public static Toggle($value: boolean, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):boolean;
            public static Toolbar($selected: number, $texts: System.Array$1<string>, ...options: UnityEngine.GUILayoutOption[]):number;
            public static Toolbar($selected: number, $images: System.Array$1<UnityEngine.Texture>, ...options: UnityEngine.GUILayoutOption[]):number;
            public static Toolbar($selected: number, $contents: System.Array$1<UnityEngine.GUIContent>, ...options: UnityEngine.GUILayoutOption[]):number;
            public static Toolbar($selected: number, $texts: System.Array$1<string>, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):number;
            public static Toolbar($selected: number, $images: System.Array$1<UnityEngine.Texture>, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):number;
            public static Toolbar($selected: number, $texts: System.Array$1<string>, $style: UnityEngine.GUIStyle, $buttonSize: UnityEngine.GUI.ToolbarButtonSize, ...options: UnityEngine.GUILayoutOption[]):number;
            public static Toolbar($selected: number, $images: System.Array$1<UnityEngine.Texture>, $style: UnityEngine.GUIStyle, $buttonSize: UnityEngine.GUI.ToolbarButtonSize, ...options: UnityEngine.GUILayoutOption[]):number;
            public static Toolbar($selected: number, $contents: System.Array$1<UnityEngine.GUIContent>, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):number;
            public static Toolbar($selected: number, $contents: System.Array$1<UnityEngine.GUIContent>, $style: UnityEngine.GUIStyle, $buttonSize: UnityEngine.GUI.ToolbarButtonSize, ...options: UnityEngine.GUILayoutOption[]):number;
            public static Toolbar($selected: number, $contents: System.Array$1<UnityEngine.GUIContent>, $enabled: System.Array$1<boolean>, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):number;
            public static Toolbar($selected: number, $contents: System.Array$1<UnityEngine.GUIContent>, $enabled: System.Array$1<boolean>, $style: UnityEngine.GUIStyle, $buttonSize: UnityEngine.GUI.ToolbarButtonSize, ...options: UnityEngine.GUILayoutOption[]):number;
            public static SelectionGrid($selected: number, $texts: System.Array$1<string>, $xCount: number, ...options: UnityEngine.GUILayoutOption[]):number;
            public static SelectionGrid($selected: number, $images: System.Array$1<UnityEngine.Texture>, $xCount: number, ...options: UnityEngine.GUILayoutOption[]):number;
            public static SelectionGrid($selected: number, $content: System.Array$1<UnityEngine.GUIContent>, $xCount: number, ...options: UnityEngine.GUILayoutOption[]):number;
            public static SelectionGrid($selected: number, $texts: System.Array$1<string>, $xCount: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):number;
            public static SelectionGrid($selected: number, $images: System.Array$1<UnityEngine.Texture>, $xCount: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):number;
            public static SelectionGrid($selected: number, $contents: System.Array$1<UnityEngine.GUIContent>, $xCount: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):number;
            public static HorizontalSlider($value: number, $leftValue: number, $rightValue: number, ...options: UnityEngine.GUILayoutOption[]):number;
            public static HorizontalSlider($value: number, $leftValue: number, $rightValue: number, $slider: UnityEngine.GUIStyle, $thumb: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):number;
            public static VerticalSlider($value: number, $leftValue: number, $rightValue: number, ...options: UnityEngine.GUILayoutOption[]):number;
            public static VerticalSlider($value: number, $leftValue: number, $rightValue: number, $slider: UnityEngine.GUIStyle, $thumb: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):number;
            public static HorizontalScrollbar($value: number, $size: number, $leftValue: number, $rightValue: number, ...options: UnityEngine.GUILayoutOption[]):number;
            public static HorizontalScrollbar($value: number, $size: number, $leftValue: number, $rightValue: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):number;
            public static VerticalScrollbar($value: number, $size: number, $topValue: number, $bottomValue: number, ...options: UnityEngine.GUILayoutOption[]):number;
            public static VerticalScrollbar($value: number, $size: number, $topValue: number, $bottomValue: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):number;
            public static Space($pixels: number):void;
            public static FlexibleSpace():void;
            public static BeginHorizontal(...options: UnityEngine.GUILayoutOption[]):void;
            public static BeginHorizontal($style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):void;
            public static BeginHorizontal($text: string, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):void;
            public static BeginHorizontal($image: UnityEngine.Texture, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):void;
            public static BeginHorizontal($content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):void;
            public static EndHorizontal():void;
            public static BeginVertical(...options: UnityEngine.GUILayoutOption[]):void;
            public static BeginVertical($style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):void;
            public static BeginVertical($text: string, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):void;
            public static BeginVertical($image: UnityEngine.Texture, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):void;
            public static BeginVertical($content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):void;
            public static EndVertical():void;
            public static BeginArea($screenRect: UnityEngine.Rect):void;
            public static BeginArea($screenRect: UnityEngine.Rect, $text: string):void;
            public static BeginArea($screenRect: UnityEngine.Rect, $image: UnityEngine.Texture):void;
            public static BeginArea($screenRect: UnityEngine.Rect, $content: UnityEngine.GUIContent):void;
            public static BeginArea($screenRect: UnityEngine.Rect, $style: UnityEngine.GUIStyle):void;
            public static BeginArea($screenRect: UnityEngine.Rect, $text: string, $style: UnityEngine.GUIStyle):void;
            public static BeginArea($screenRect: UnityEngine.Rect, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle):void;
            public static BeginArea($screenRect: UnityEngine.Rect, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle):void;
            public static EndArea():void;
            public static BeginScrollView($scrollPosition: UnityEngine.Vector2, ...options: UnityEngine.GUILayoutOption[]):UnityEngine.Vector2;
            public static BeginScrollView($scrollPosition: UnityEngine.Vector2, $alwaysShowHorizontal: boolean, $alwaysShowVertical: boolean, ...options: UnityEngine.GUILayoutOption[]):UnityEngine.Vector2;
            public static BeginScrollView($scrollPosition: UnityEngine.Vector2, $horizontalScrollbar: UnityEngine.GUIStyle, $verticalScrollbar: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):UnityEngine.Vector2;
            public static BeginScrollView($scrollPosition: UnityEngine.Vector2, $style: UnityEngine.GUIStyle):UnityEngine.Vector2;
            public static BeginScrollView($scrollPosition: UnityEngine.Vector2, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):UnityEngine.Vector2;
            public static BeginScrollView($scrollPosition: UnityEngine.Vector2, $alwaysShowHorizontal: boolean, $alwaysShowVertical: boolean, $horizontalScrollbar: UnityEngine.GUIStyle, $verticalScrollbar: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):UnityEngine.Vector2;
            public static BeginScrollView($scrollPosition: UnityEngine.Vector2, $alwaysShowHorizontal: boolean, $alwaysShowVertical: boolean, $horizontalScrollbar: UnityEngine.GUIStyle, $verticalScrollbar: UnityEngine.GUIStyle, $background: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):UnityEngine.Vector2;
            public static EndScrollView():void;
            public static Window($id: number, $screenRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $text: string, ...options: UnityEngine.GUILayoutOption[]):UnityEngine.Rect;
            public static Window($id: number, $screenRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $image: UnityEngine.Texture, ...options: UnityEngine.GUILayoutOption[]):UnityEngine.Rect;
            public static Window($id: number, $screenRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $content: UnityEngine.GUIContent, ...options: UnityEngine.GUILayoutOption[]):UnityEngine.Rect;
            public static Window($id: number, $screenRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $text: string, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):UnityEngine.Rect;
            public static Window($id: number, $screenRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):UnityEngine.Rect;
            public static Window($id: number, $screenRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):UnityEngine.Rect;
            public static Width($width: number):UnityEngine.GUILayoutOption;
            public static MinWidth($minWidth: number):UnityEngine.GUILayoutOption;
            public static MaxWidth($maxWidth: number):UnityEngine.GUILayoutOption;
            public static Height($height: number):UnityEngine.GUILayoutOption;
            public static MinHeight($minHeight: number):UnityEngine.GUILayoutOption;
            public static MaxHeight($maxHeight: number):UnityEngine.GUILayoutOption;
            public static ExpandWidth($expand: boolean):UnityEngine.GUILayoutOption;
            public static ExpandHeight($expand: boolean):UnityEngine.GUILayoutOption;
            public constructor();
        }
        export class GUILayoutOption extends System.Object{ 
        }
        export class GUILayoutUtility extends System.Object{ 
            public static GetRect($content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle):UnityEngine.Rect;
            public static GetRect($content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):UnityEngine.Rect;
            public static GetRect($width: number, $height: number):UnityEngine.Rect;
            public static GetRect($width: number, $height: number, $style: UnityEngine.GUIStyle):UnityEngine.Rect;
            public static GetRect($width: number, $height: number, ...options: UnityEngine.GUILayoutOption[]):UnityEngine.Rect;
            public static GetRect($width: number, $height: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):UnityEngine.Rect;
            public static GetRect($minWidth: number, $maxWidth: number, $minHeight: number, $maxHeight: number):UnityEngine.Rect;
            public static GetRect($minWidth: number, $maxWidth: number, $minHeight: number, $maxHeight: number, $style: UnityEngine.GUIStyle):UnityEngine.Rect;
            public static GetRect($minWidth: number, $maxWidth: number, $minHeight: number, $maxHeight: number, ...options: UnityEngine.GUILayoutOption[]):UnityEngine.Rect;
            public static GetRect($minWidth: number, $maxWidth: number, $minHeight: number, $maxHeight: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):UnityEngine.Rect;
            public static GetLastRect():UnityEngine.Rect;
            public static GetAspectRect($aspect: number):UnityEngine.Rect;
            public static GetAspectRect($aspect: number, $style: UnityEngine.GUIStyle):UnityEngine.Rect;
            public static GetAspectRect($aspect: number, ...options: UnityEngine.GUILayoutOption[]):UnityEngine.Rect;
            public static GetAspectRect($aspect: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]):UnityEngine.Rect;
            public constructor();
        }
        export class GUISettings extends System.Object{ 
            public get doubleClickSelectsWord(): boolean;
            public set doubleClickSelectsWord(value: boolean);
            public get tripleClickSelectsLine(): boolean;
            public set tripleClickSelectsLine(value: boolean);
            public get cursorColor(): UnityEngine.Color;
            public set cursorColor(value: UnityEngine.Color);
            public get cursorFlashSpeed(): number;
            public set cursorFlashSpeed(value: number);
            public get selectionColor(): UnityEngine.Color;
            public set selectionColor(value: UnityEngine.Color);
            public constructor();
        }
        export class Font extends UnityEngine.Object{ 
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public get fontNames(): System.Array$1<string>;
            public set fontNames(value: System.Array$1<string>);
            public get dynamic(): boolean;
            public get ascent(): number;
            public get fontSize(): number;
            public get characterInfo(): System.Array$1<UnityEngine.CharacterInfo>;
            public set characterInfo(value: System.Array$1<UnityEngine.CharacterInfo>);
            public get lineHeight(): number;
            public static add_textureRebuilt($value: System.Action$1<UnityEngine.Font>):void;
            public static remove_textureRebuilt($value: System.Action$1<UnityEngine.Font>):void;
            public static CreateDynamicFontFromOSFont($fontname: string, $size: number):UnityEngine.Font;
            public static CreateDynamicFontFromOSFont($fontnames: System.Array$1<string>, $size: number):UnityEngine.Font;
            public static GetMaxVertsForString($str: string):number;
            public HasCharacter($c: number):boolean;
            public static GetOSInstalledFontNames():System.Array$1<string>;
            public static GetPathsToOSFonts():System.Array$1<string>;
            public GetCharacterInfo($ch: number, $info: $Ref<UnityEngine.CharacterInfo>, $size: number, $style: UnityEngine.FontStyle):boolean;
            public GetCharacterInfo($ch: number, $info: $Ref<UnityEngine.CharacterInfo>, $size: number):boolean;
            public GetCharacterInfo($ch: number, $info: $Ref<UnityEngine.CharacterInfo>):boolean;
            public RequestCharactersInTexture($characters: string, $size: number, $style: UnityEngine.FontStyle):void;
            public RequestCharactersInTexture($characters: string, $size: number):void;
            public RequestCharactersInTexture($characters: string):void;
            public constructor();
            public constructor($name: string);
        }
        export class GUIStyleState extends System.Object{ 
            public get background(): UnityEngine.Texture2D;
            public set background(value: UnityEngine.Texture2D);
            public get textColor(): UnityEngine.Color;
            public set textColor(value: UnityEngine.Color);
            public constructor();
        }
        export enum ImagePosition{ ImageLeft = 0, ImageAbove = 1, ImageOnly = 2, TextOnly = 3 }
        export enum TextAnchor{ UpperLeft = 0, UpperCenter = 1, UpperRight = 2, MiddleLeft = 3, MiddleCenter = 4, MiddleRight = 5, LowerLeft = 6, LowerCenter = 7, LowerRight = 8 }
        export enum TextClipping{ Overflow = 0, Clip = 1 }
        export enum FontStyle{ Normal = 0, Bold = 1, Italic = 2, BoldAndItalic = 3 }
        export class GUITargetAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
            public constructor($displayIndex: number);
            public constructor($displayIndex: number, $displayIndex1: number);
            public constructor($displayIndex: number, $displayIndex1: number, ...displayIndexList: number[]);
        }
        export class GUIUtility extends System.Object{ 
            public static get hasModalWindow(): boolean;
            public static get systemCopyBuffer(): string;
            public static set systemCopyBuffer(value: string);
            public static get hotControl(): number;
            public static set hotControl(value: number);
            public static get keyboardControl(): number;
            public static set keyboardControl(value: number);
            public static GetControlID($hint: number, $focusType: UnityEngine.FocusType, $rect: UnityEngine.Rect):number;
            public static AlignRectToDevice($rect: UnityEngine.Rect, $widthInPixels: $Ref<number>, $heightInPixels: $Ref<number>):UnityEngine.Rect;
            public static GetControlID($focus: UnityEngine.FocusType):number;
            public static GetControlID($contents: UnityEngine.GUIContent, $focus: UnityEngine.FocusType):number;
            public static GetControlID($focus: UnityEngine.FocusType, $position: UnityEngine.Rect):number;
            public static GetControlID($contents: UnityEngine.GUIContent, $focus: UnityEngine.FocusType, $position: UnityEngine.Rect):number;
            public static GetControlID($hint: number, $focus: UnityEngine.FocusType):number;
            public static GetStateObject($t: System.Type, $controlID: number):any;
            public static QueryStateObject($t: System.Type, $controlID: number):any;
            public static ExitGUI():void;
            public static GUIToScreenPoint($guiPoint: UnityEngine.Vector2):UnityEngine.Vector2;
            public static GUIToScreenRect($guiRect: UnityEngine.Rect):UnityEngine.Rect;
            public static ScreenToGUIPoint($screenPoint: UnityEngine.Vector2):UnityEngine.Vector2;
            public static ScreenToGUIRect($screenRect: UnityEngine.Rect):UnityEngine.Rect;
            public static RotateAroundPivot($angle: number, $pivotPoint: UnityEngine.Vector2):void;
            public static ScaleAroundPivot($scale: UnityEngine.Vector2, $pivotPoint: UnityEngine.Vector2):void;
            public static AlignRectToDevice($rect: UnityEngine.Rect):UnityEngine.Rect;
            public constructor();
        }
        export class ExitGUIException extends System.Exception implements System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable{ 
            public constructor();
        }
        export class TextEditor extends System.Object{ 
        }
        export class ImageConversion extends System.Object{ 
            public static get EnableLegacyPngGammaRuntimeLoadBehavior(): boolean;
            public static set EnableLegacyPngGammaRuntimeLoadBehavior(value: boolean);
            public static EncodeToTGA($tex: UnityEngine.Texture2D):System.Array$1<number>;
            public static EncodeToPNG($tex: UnityEngine.Texture2D):System.Array$1<number>;
            public static EncodeToJPG($tex: UnityEngine.Texture2D, $quality: number):System.Array$1<number>;
            public static EncodeToJPG($tex: UnityEngine.Texture2D):System.Array$1<number>;
            public static EncodeToEXR($tex: UnityEngine.Texture2D, $flags: UnityEngine.Texture2D.EXRFlags):System.Array$1<number>;
            public static EncodeToEXR($tex: UnityEngine.Texture2D):System.Array$1<number>;
            public static LoadImage($tex: UnityEngine.Texture2D, $data: System.Array$1<number>, $markNonReadable: boolean):boolean;
            public static LoadImage($tex: UnityEngine.Texture2D, $data: System.Array$1<number>):boolean;
            public static EncodeArrayToTGA($input: System.Array, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $width: number, $height: number, $rowBytes?: number):System.Array$1<number>;
            public static EncodeArrayToPNG($input: System.Array, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $width: number, $height: number, $rowBytes?: number):System.Array$1<number>;
            public static EncodeArrayToJPG($input: System.Array, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $width: number, $height: number, $rowBytes?: number, $quality?: number):System.Array$1<number>;
            public static EncodeArrayToEXR($input: System.Array, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $width: number, $height: number, $rowBytes?: number, $flags?: UnityEngine.Texture2D.EXRFlags):System.Array$1<number>;
        }
        export enum TouchPhase{ Began = 0, Moved = 1, Stationary = 2, Ended = 3, Canceled = 4 }
        export enum IMECompositionMode{ Auto = 0, On = 1, Off = 2 }
        export enum TouchType{ Direct = 0, Indirect = 1, Stylus = 2 }
        export class Touch extends System.ValueType{ 
            public get fingerId(): number;
            public set fingerId(value: number);
            public get position(): UnityEngine.Vector2;
            public set position(value: UnityEngine.Vector2);
            public get rawPosition(): UnityEngine.Vector2;
            public set rawPosition(value: UnityEngine.Vector2);
            public get deltaPosition(): UnityEngine.Vector2;
            public set deltaPosition(value: UnityEngine.Vector2);
            public get deltaTime(): number;
            public set deltaTime(value: number);
            public get tapCount(): number;
            public set tapCount(value: number);
            public get phase(): UnityEngine.TouchPhase;
            public set phase(value: UnityEngine.TouchPhase);
            public get pressure(): number;
            public set pressure(value: number);
            public get maximumPossiblePressure(): number;
            public set maximumPossiblePressure(value: number);
            public get type(): UnityEngine.TouchType;
            public set type(value: UnityEngine.TouchType);
            public get altitudeAngle(): number;
            public set altitudeAngle(value: number);
            public get azimuthAngle(): number;
            public set azimuthAngle(value: number);
            public get radius(): number;
            public set radius(value: number);
            public get radiusVariance(): number;
            public set radiusVariance(value: number);
        }
        export enum DeviceOrientation{ Unknown = 0, Portrait = 1, PortraitUpsideDown = 2, LandscapeLeft = 3, LandscapeRight = 4, FaceUp = 5, FaceDown = 6 }
        export class AccelerationEvent extends System.ValueType{ 
            public get acceleration(): UnityEngine.Vector3;
            public get deltaTime(): number;
        }
        export class Gyroscope extends System.Object{ 
            public get rotationRate(): UnityEngine.Vector3;
            public get rotationRateUnbiased(): UnityEngine.Vector3;
            public get gravity(): UnityEngine.Vector3;
            public get userAcceleration(): UnityEngine.Vector3;
            public get attitude(): UnityEngine.Quaternion;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get updateInterval(): number;
            public set updateInterval(value: number);
        }
        export class LocationInfo extends System.ValueType{ 
            public get latitude(): number;
            public get longitude(): number;
            public get altitude(): number;
            public get horizontalAccuracy(): number;
            public get verticalAccuracy(): number;
            public get timestamp(): number;
        }
        export enum LocationServiceStatus{ Stopped = 0, Initializing = 1, Running = 2, Failed = 3 }
        export class LocationService extends System.Object{ 
            public get isEnabledByUser(): boolean;
            public get status(): UnityEngine.LocationServiceStatus;
            public get lastData(): UnityEngine.LocationInfo;
            public Start($desiredAccuracyInMeters: number, $updateDistanceInMeters: number):void;
            public Start($desiredAccuracyInMeters: number):void;
            public Start():void;
            public Stop():void;
            public constructor();
        }
        export class Compass extends System.Object{ 
            public get magneticHeading(): number;
            public get trueHeading(): number;
            public get headingAccuracy(): number;
            public get rawVector(): UnityEngine.Vector3;
            public get timestamp(): number;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public constructor();
        }
        export class Input extends System.Object{ 
            public static get simulateMouseWithTouches(): boolean;
            public static set simulateMouseWithTouches(value: boolean);
            public static get anyKey(): boolean;
            public static get anyKeyDown(): boolean;
            public static get inputString(): string;
            public static get mousePosition(): UnityEngine.Vector3;
            public static get mouseScrollDelta(): UnityEngine.Vector2;
            public static get imeCompositionMode(): UnityEngine.IMECompositionMode;
            public static set imeCompositionMode(value: UnityEngine.IMECompositionMode);
            public static get compositionString(): string;
            public static get imeIsSelected(): boolean;
            public static get compositionCursorPos(): UnityEngine.Vector2;
            public static set compositionCursorPos(value: UnityEngine.Vector2);
            public static get mousePresent(): boolean;
            public static get touchCount(): number;
            public static get touchPressureSupported(): boolean;
            public static get stylusTouchSupported(): boolean;
            public static get touchSupported(): boolean;
            public static get multiTouchEnabled(): boolean;
            public static set multiTouchEnabled(value: boolean);
            public static get deviceOrientation(): UnityEngine.DeviceOrientation;
            public static get acceleration(): UnityEngine.Vector3;
            public static get compensateSensors(): boolean;
            public static set compensateSensors(value: boolean);
            public static get accelerationEventCount(): number;
            public static get backButtonLeavesApp(): boolean;
            public static set backButtonLeavesApp(value: boolean);
            public static get location(): UnityEngine.LocationService;
            public static get compass(): UnityEngine.Compass;
            public static get gyro(): UnityEngine.Gyroscope;
            public static get touches(): System.Array$1<UnityEngine.Touch>;
            public static get accelerationEvents(): System.Array$1<UnityEngine.AccelerationEvent>;
            public static GetAxis($axisName: string):number;
            public static GetAxisRaw($axisName: string):number;
            public static GetButton($buttonName: string):boolean;
            public static GetButtonDown($buttonName: string):boolean;
            public static GetButtonUp($buttonName: string):boolean;
            public static GetMouseButton($button: number):boolean;
            public static GetMouseButtonDown($button: number):boolean;
            public static GetMouseButtonUp($button: number):boolean;
            public static ResetInputAxes():void;
            public static GetJoystickNames():System.Array$1<string>;
            public static GetTouch($index: number):UnityEngine.Touch;
            public static GetAccelerationEvent($index: number):UnityEngine.AccelerationEvent;
            public static GetKey($key: UnityEngine.KeyCode):boolean;
            public static GetKey($name: string):boolean;
            public static GetKeyUp($key: UnityEngine.KeyCode):boolean;
            public static GetKeyUp($name: string):boolean;
            public static GetKeyDown($key: UnityEngine.KeyCode):boolean;
            public static GetKeyDown($name: string):boolean;
            public constructor();
        }
        export class JsonUtility extends System.Object{ 
            public static ToJson($obj: any):string;
            public static ToJson($obj: any, $prettyPrint: boolean):string;
            public static FromJson($json: string, $type: System.Type):any;
            public static FromJsonOverwrite($json: string, $objectToOverwrite: any):void;
        }
        export class LocalizationAsset extends UnityEngine.Object{ 
            public get localeIsoCode(): string;
            public set localeIsoCode(value: string);
            public get isEditorAsset(): boolean;
            public set isEditorAsset(value: boolean);
            public SetLocalizedString($original: string, $localized: string):void;
            public GetLocalizedString($original: string):string;
            public constructor();
        }
        export enum ParticleSystemEmissionType{ Time = 0, Distance = 1 }
        export enum ParticleSystemCurveMode{ Constant = 0, Curve = 1, TwoCurves = 2, TwoConstants = 3 }
        export enum ParticleSystemEmitterVelocityMode{ Transform = 0, Rigidbody = 1, Custom = 2 }
        export enum ParticleSystemStopAction{ None = 0, Disable = 1, Destroy = 2, Callback = 3 }
        export enum ParticleSystemRingBufferMode{ Disabled = 0, PauseUntilReplaced = 1, LoopUntilReplaced = 2 }
        export enum ParticleSystemCullingMode{ Automatic = 0, PauseAndCatchup = 1, Pause = 2, AlwaysSimulate = 3 }
        export enum ParticleSystemShapeType{ Sphere = 0, SphereShell = 1, Hemisphere = 2, HemisphereShell = 3, Cone = 4, Box = 5, Mesh = 6, ConeShell = 7, ConeVolume = 8, ConeVolumeShell = 9, Circle = 10, CircleEdge = 11, SingleSidedEdge = 12, MeshRenderer = 13, SkinnedMeshRenderer = 14, BoxShell = 15, BoxEdge = 16, Donut = 17, Rectangle = 18, Sprite = 19, SpriteRenderer = 20 }
        export enum ParticleSystemShapeMultiModeValue{ Random = 0, Loop = 1, PingPong = 2, BurstSpread = 3 }
        export enum ParticleSystemMeshShapeType{ Vertex = 0, Edge = 1, Triangle = 2 }
        export class MeshRenderer extends UnityEngine.Renderer{ 
        }
        export enum ParticleSystemShapeTextureChannel{ Red = 0, Green = 1, Blue = 2, Alpha = 3 }
        export enum ParticleSystemCollisionType{ Planes = 0, World = 1 }
        export enum ParticleSystemCollisionMode{ Collision3D = 0, Collision2D = 1 }
        export enum ParticleSystemCollisionQuality{ High = 0, Medium = 1, Low = 2 }
        export enum ParticleSystemOverlapAction{ Ignore = 0, Kill = 1, Callback = 2 }
        export enum ParticleSystemColliderQueryMode{ Disabled = 0, One = 1, All = 2 }
        export enum ParticleSystemSubEmitterType{ Birth = 0, Collision = 1, Death = 2, Trigger = 3, Manual = 4 }
        export enum ParticleSystemSubEmitterProperties{ InheritNothing = 0, InheritEverything = 31, InheritColor = 1, InheritSize = 2, InheritRotation = 4, InheritLifetime = 8, InheritDuration = 16 }
        export enum ParticleSystemAnimationMode{ Grid = 0, Sprites = 1 }
        export enum ParticleSystemAnimationTimeMode{ Lifetime = 0, Speed = 1, FPS = 2 }
        export enum ParticleSystemAnimationType{ WholeSheet = 0, SingleRow = 1 }
        export enum ParticleSystemAnimationRowMode{ Custom = 0, Random = 1, MeshIndex = 2 }
        export enum ParticleSystemGradientMode{ Color = 0, Gradient = 1, TwoColors = 2, TwoGradients = 3, RandomColor = 4 }
        export enum ParticleSystemInheritVelocityMode{ Initial = 0, Current = 1 }
        export enum ParticleSystemGameObjectFilter{ LayerMask = 0, List = 1, LayerMaskAndList = 2 }
        export class ParticleSystemForceField extends UnityEngine.Component{ 
            public get shape(): UnityEngine.ParticleSystemForceFieldShape;
            public set shape(value: UnityEngine.ParticleSystemForceFieldShape);
            public get startRange(): number;
            public set startRange(value: number);
            public get endRange(): number;
            public set endRange(value: number);
            public get length(): number;
            public set length(value: number);
            public get gravityFocus(): number;
            public set gravityFocus(value: number);
            public get rotationRandomness(): UnityEngine.Vector2;
            public set rotationRandomness(value: UnityEngine.Vector2);
            public get multiplyDragByParticleSize(): boolean;
            public set multiplyDragByParticleSize(value: boolean);
            public get multiplyDragByParticleVelocity(): boolean;
            public set multiplyDragByParticleVelocity(value: boolean);
            public get vectorField(): UnityEngine.Texture3D;
            public set vectorField(value: UnityEngine.Texture3D);
            public get directionX(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set directionX(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get directionY(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set directionY(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get directionZ(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set directionZ(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get gravity(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set gravity(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get rotationSpeed(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set rotationSpeed(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get rotationAttraction(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set rotationAttraction(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get drag(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set drag(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get vectorFieldSpeed(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set vectorFieldSpeed(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get vectorFieldAttraction(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set vectorFieldAttraction(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public constructor();
        }
        export enum ParticleSystemNoiseQuality{ Low = 0, Medium = 1, High = 2 }
        export enum ParticleSystemTrailMode{ PerParticle = 0, Ribbon = 1 }
        export enum ParticleSystemTrailTextureMode{ Stretch = 0, Tile = 1, DistributePerSegment = 2, RepeatPerSegment = 3 }
        export enum ParticleSystemCustomDataMode{ Disabled = 0, Vector = 1, Color = 2 }
        export class ParticlePhysicsExtensions extends System.Object{ 
            public static GetSafeCollisionEventSize($ps: UnityEngine.ParticleSystem):number;
            public static GetCollisionEvents($ps: UnityEngine.ParticleSystem, $go: UnityEngine.GameObject, $collisionEvents: System.Collections.Generic.List$1<UnityEngine.ParticleCollisionEvent>):number;
            public static GetSafeTriggerParticlesSize($ps: UnityEngine.ParticleSystem, $type: UnityEngine.ParticleSystemTriggerEventType):number;
            public static GetTriggerParticles($ps: UnityEngine.ParticleSystem, $type: UnityEngine.ParticleSystemTriggerEventType, $particles: System.Collections.Generic.List$1<UnityEngine.ParticleSystem.Particle>):number;
            public static GetTriggerParticles($ps: UnityEngine.ParticleSystem, $type: UnityEngine.ParticleSystemTriggerEventType, $particles: System.Collections.Generic.List$1<UnityEngine.ParticleSystem.Particle>, $colliderData: $Ref<UnityEngine.ParticleSystem.ColliderData>):number;
            public static SetTriggerParticles($ps: UnityEngine.ParticleSystem, $type: UnityEngine.ParticleSystemTriggerEventType, $particles: System.Collections.Generic.List$1<UnityEngine.ParticleSystem.Particle>, $offset: number, $count: number):void;
            public static SetTriggerParticles($ps: UnityEngine.ParticleSystem, $type: UnityEngine.ParticleSystemTriggerEventType, $particles: System.Collections.Generic.List$1<UnityEngine.ParticleSystem.Particle>):void;
        }
        export class ParticleCollisionEvent extends System.ValueType{ 
            public get intersection(): UnityEngine.Vector3;
            public get normal(): UnityEngine.Vector3;
            public get velocity(): UnityEngine.Vector3;
            public get colliderComponent(): UnityEngine.Component;
        }
        export enum ParticleSystemTriggerEventType{ Inside = 0, Outside = 1, Enter = 2, Exit = 3 }
        export enum ParticleSystemRenderMode{ Billboard = 0, Stretch = 1, HorizontalBillboard = 2, VerticalBillboard = 3, Mesh = 4, None = 5 }
        export enum ParticleSystemSortMode{ None = 0, Distance = 1, OldestInFront = 2, YoungestInFront = 3, Depth = 4 }
        export enum ParticleSystemRenderSpace{ View = 0, World = 1, Local = 2, Facing = 3, Velocity = 4 }
        export enum ParticleSystemVertexStream{ Position = 0, Normal = 1, Tangent = 2, Color = 3, UV = 4, UV2 = 5, UV3 = 6, UV4 = 7, AnimBlend = 8, AnimFrame = 9, Center = 10, VertexID = 11, SizeX = 12, SizeXY = 13, SizeXYZ = 14, Rotation = 15, Rotation3D = 16, RotationSpeed = 17, RotationSpeed3D = 18, Velocity = 19, Speed = 20, AgePercent = 21, InvStartLifetime = 22, StableRandomX = 23, StableRandomXY = 24, StableRandomXYZ = 25, StableRandomXYZW = 26, VaryingRandomX = 27, VaryingRandomXY = 28, VaryingRandomXYZ = 29, VaryingRandomXYZW = 30, Custom1X = 31, Custom1XY = 32, Custom1XYZ = 33, Custom1XYZW = 34, Custom2X = 35, Custom2XY = 36, Custom2XYZ = 37, Custom2XYZW = 38, NoiseSumX = 39, NoiseSumXY = 40, NoiseSumXYZ = 41, NoiseImpulseX = 42, NoiseImpulseXY = 43, NoiseImpulseXYZ = 44, MeshIndex = 45 }
        export enum ParticleSystemForceFieldShape{ Sphere = 0, Hemisphere = 1, Cylinder = 2, Box = 3 }
        export enum ParticleSystemVertexStreams{ Position = 1, Normal = 2, Tangent = 4, Color = 8, UV = 16, UV2BlendAndFrame = 32, CenterAndVertexID = 64, Size = 128, Rotation = 256, Velocity = 512, Lifetime = 1024, Custom1 = 2048, Custom2 = 4096, Random = 8192, None = 0, All = 2147483647 }
        export enum RigidbodyConstraints{ None = 0, FreezePositionX = 2, FreezePositionY = 4, FreezePositionZ = 8, FreezeRotationX = 16, FreezeRotationY = 32, FreezeRotationZ = 64, FreezePosition = 14, FreezeRotation = 112, FreezeAll = 126 }
        export enum ForceMode{ Force = 0, Acceleration = 5, Impulse = 1, VelocityChange = 2 }
        export enum JointProjectionMode{ None = 0, PositionAndRotation = 1, PositionOnly = 2 }
        export enum MeshColliderCookingOptions{ None = 0, InflateConvexMesh = 1, CookForFasterSimulation = 2, EnableMeshCleaning = 4, WeldColocatedVertices = 8, UseFastMidphase = 16 }
        export class WheelFrictionCurve extends System.ValueType{ 
            public get extremumSlip(): number;
            public set extremumSlip(value: number);
            public get extremumValue(): number;
            public set extremumValue(value: number);
            public get asymptoteSlip(): number;
            public set asymptoteSlip(value: number);
            public get asymptoteValue(): number;
            public set asymptoteValue(value: number);
            public get stiffness(): number;
            public set stiffness(value: number);
        }
        export class SoftJointLimit extends System.ValueType{ 
            public get limit(): number;
            public set limit(value: number);
            public get bounciness(): number;
            public set bounciness(value: number);
            public get contactDistance(): number;
            public set contactDistance(value: number);
        }
        export class SoftJointLimitSpring extends System.ValueType{ 
            public get spring(): number;
            public set spring(value: number);
            public get damper(): number;
            public set damper(value: number);
        }
        export class JointDrive extends System.ValueType{ 
            public get positionSpring(): number;
            public set positionSpring(value: number);
            public get positionDamper(): number;
            public set positionDamper(value: number);
            public get maximumForce(): number;
            public set maximumForce(value: number);
        }
        export enum JointDriveMode{ None = 0, Position = 1, Velocity = 2, PositionAndVelocity = 3 }
        export enum RigidbodyInterpolation{ None = 0, Interpolate = 1, Extrapolate = 2 }
        export class JointMotor extends System.ValueType{ 
            public get targetVelocity(): number;
            public set targetVelocity(value: number);
            public get force(): number;
            public set force(value: number);
            public get freeSpin(): boolean;
            public set freeSpin(value: boolean);
        }
        export class JointSpring extends System.ValueType{ 
            public spring: number;
            public damper: number;
            public targetPosition: number;
        }
        export class JointLimits extends System.ValueType{ 
            public get min(): number;
            public set min(value: number);
            public get max(): number;
            public set max(value: number);
            public get bounciness(): number;
            public set bounciness(value: number);
            public get bounceMinVelocity(): number;
            public set bounceMinVelocity(value: number);
            public get contactDistance(): number;
            public set contactDistance(value: number);
        }
        export class ControllerColliderHit extends System.Object{ 
            public get controller(): UnityEngine.CharacterController;
            public get collider(): UnityEngine.Collider;
            public get rigidbody(): UnityEngine.Rigidbody;
            public get gameObject(): UnityEngine.GameObject;
            public get transform(): UnityEngine.Transform;
            public get point(): UnityEngine.Vector3;
            public get normal(): UnityEngine.Vector3;
            public get moveDirection(): UnityEngine.Vector3;
            public get moveLength(): number;
            public constructor();
        }
        export class CharacterController extends UnityEngine.Collider{ 
            public get velocity(): UnityEngine.Vector3;
            public get isGrounded(): boolean;
            public get collisionFlags(): UnityEngine.CollisionFlags;
            public get radius(): number;
            public set radius(value: number);
            public get height(): number;
            public set height(value: number);
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            public get slopeLimit(): number;
            public set slopeLimit(value: number);
            public get stepOffset(): number;
            public set stepOffset(value: number);
            public get skinWidth(): number;
            public set skinWidth(value: number);
            public get minMoveDistance(): number;
            public set minMoveDistance(value: number);
            public get detectCollisions(): boolean;
            public set detectCollisions(value: boolean);
            public get enableOverlapRecovery(): boolean;
            public set enableOverlapRecovery(value: boolean);
            public SimpleMove($speed: UnityEngine.Vector3):boolean;
            public Move($motion: UnityEngine.Vector3):UnityEngine.CollisionFlags;
            public constructor();
        }
        export class Rigidbody extends UnityEngine.Component{ 
            public get velocity(): UnityEngine.Vector3;
            public set velocity(value: UnityEngine.Vector3);
            public get angularVelocity(): UnityEngine.Vector3;
            public set angularVelocity(value: UnityEngine.Vector3);
            public get drag(): number;
            public set drag(value: number);
            public get angularDrag(): number;
            public set angularDrag(value: number);
            public get mass(): number;
            public set mass(value: number);
            public get useGravity(): boolean;
            public set useGravity(value: boolean);
            public get maxDepenetrationVelocity(): number;
            public set maxDepenetrationVelocity(value: number);
            public get isKinematic(): boolean;
            public set isKinematic(value: boolean);
            public get freezeRotation(): boolean;
            public set freezeRotation(value: boolean);
            public get constraints(): UnityEngine.RigidbodyConstraints;
            public set constraints(value: UnityEngine.RigidbodyConstraints);
            public get collisionDetectionMode(): UnityEngine.CollisionDetectionMode;
            public set collisionDetectionMode(value: UnityEngine.CollisionDetectionMode);
            public get centerOfMass(): UnityEngine.Vector3;
            public set centerOfMass(value: UnityEngine.Vector3);
            public get worldCenterOfMass(): UnityEngine.Vector3;
            public get inertiaTensorRotation(): UnityEngine.Quaternion;
            public set inertiaTensorRotation(value: UnityEngine.Quaternion);
            public get inertiaTensor(): UnityEngine.Vector3;
            public set inertiaTensor(value: UnityEngine.Vector3);
            public get detectCollisions(): boolean;
            public set detectCollisions(value: boolean);
            public get position(): UnityEngine.Vector3;
            public set position(value: UnityEngine.Vector3);
            public get rotation(): UnityEngine.Quaternion;
            public set rotation(value: UnityEngine.Quaternion);
            public get interpolation(): UnityEngine.RigidbodyInterpolation;
            public set interpolation(value: UnityEngine.RigidbodyInterpolation);
            public get solverIterations(): number;
            public set solverIterations(value: number);
            public get sleepThreshold(): number;
            public set sleepThreshold(value: number);
            public get maxAngularVelocity(): number;
            public set maxAngularVelocity(value: number);
            public get solverVelocityIterations(): number;
            public set solverVelocityIterations(value: number);
            public SetDensity($density: number):void;
            public MovePosition($position: UnityEngine.Vector3):void;
            public MoveRotation($rot: UnityEngine.Quaternion):void;
            public Sleep():void;
            public IsSleeping():boolean;
            public WakeUp():void;
            public ResetCenterOfMass():void;
            public ResetInertiaTensor():void;
            public GetRelativePointVelocity($relativePoint: UnityEngine.Vector3):UnityEngine.Vector3;
            public GetPointVelocity($worldPoint: UnityEngine.Vector3):UnityEngine.Vector3;
            public AddForce($force: UnityEngine.Vector3, $mode: UnityEngine.ForceMode):void;
            public AddForce($force: UnityEngine.Vector3):void;
            public AddForce($x: number, $y: number, $z: number, $mode: UnityEngine.ForceMode):void;
            public AddForce($x: number, $y: number, $z: number):void;
            public AddRelativeForce($force: UnityEngine.Vector3, $mode: UnityEngine.ForceMode):void;
            public AddRelativeForce($force: UnityEngine.Vector3):void;
            public AddRelativeForce($x: number, $y: number, $z: number, $mode: UnityEngine.ForceMode):void;
            public AddRelativeForce($x: number, $y: number, $z: number):void;
            public AddTorque($torque: UnityEngine.Vector3, $mode: UnityEngine.ForceMode):void;
            public AddTorque($torque: UnityEngine.Vector3):void;
            public AddTorque($x: number, $y: number, $z: number, $mode: UnityEngine.ForceMode):void;
            public AddTorque($x: number, $y: number, $z: number):void;
            public AddRelativeTorque($torque: UnityEngine.Vector3, $mode: UnityEngine.ForceMode):void;
            public AddRelativeTorque($torque: UnityEngine.Vector3):void;
            public AddRelativeTorque($x: number, $y: number, $z: number, $mode: UnityEngine.ForceMode):void;
            public AddRelativeTorque($x: number, $y: number, $z: number):void;
            public AddForceAtPosition($force: UnityEngine.Vector3, $position: UnityEngine.Vector3, $mode: UnityEngine.ForceMode):void;
            public AddForceAtPosition($force: UnityEngine.Vector3, $position: UnityEngine.Vector3):void;
            public AddExplosionForce($explosionForce: number, $explosionPosition: UnityEngine.Vector3, $explosionRadius: number, $upwardsModifier: number, $mode: UnityEngine.ForceMode):void;
            public AddExplosionForce($explosionForce: number, $explosionPosition: UnityEngine.Vector3, $explosionRadius: number, $upwardsModifier: number):void;
            public AddExplosionForce($explosionForce: number, $explosionPosition: UnityEngine.Vector3, $explosionRadius: number):void;
            public ClosestPointOnBounds($position: UnityEngine.Vector3):UnityEngine.Vector3;
            public SweepTest($direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):boolean;
            public SweepTest($direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number):boolean;
            public SweepTest($direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>):boolean;
            public SweepTestAll($direction: UnityEngine.Vector3, $maxDistance: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):System.Array$1<UnityEngine.RaycastHit>;
            public SweepTestAll($direction: UnityEngine.Vector3, $maxDistance: number):System.Array$1<UnityEngine.RaycastHit>;
            public SweepTestAll($direction: UnityEngine.Vector3):System.Array$1<UnityEngine.RaycastHit>;
            public constructor();
        }
        interface Rigidbody {
            DOMove($endValue: UnityEngine.Vector3, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.Options.VectorOptions>;
            DOMoveX($endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.Options.VectorOptions>;
            DOMoveY($endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.Options.VectorOptions>;
            DOMoveZ($endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.Options.VectorOptions>;
            DORotate($endValue: UnityEngine.Vector3, $duration: number, $mode?: DG.Tweening.RotateMode):DG.Tweening.Core.TweenerCore$3<UnityEngine.Quaternion, UnityEngine.Vector3, DG.Tweening.Plugins.Options.QuaternionOptions>;
            DOLookAt($towards: UnityEngine.Vector3, $duration: number, $axisConstraint?: DG.Tweening.AxisConstraint, $up?: System.Nullable$1<UnityEngine.Vector3>):DG.Tweening.Core.TweenerCore$3<UnityEngine.Quaternion, UnityEngine.Vector3, DG.Tweening.Plugins.Options.QuaternionOptions>;
            DOJump($endValue: UnityEngine.Vector3, $jumpPower: number, $numJumps: number, $duration: number, $snapping?: boolean):DG.Tweening.Sequence;
            DOPath($path: System.Array$1<UnityEngine.Vector3>, $duration: number, $pathType?: DG.Tweening.PathType, $pathMode?: DG.Tweening.PathMode, $resolution?: number, $gizmoColor?: System.Nullable$1<UnityEngine.Color>):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions>;
            DOLocalPath($path: System.Array$1<UnityEngine.Vector3>, $duration: number, $pathType?: DG.Tweening.PathType, $pathMode?: DG.Tweening.PathMode, $resolution?: number, $gizmoColor?: System.Nullable$1<UnityEngine.Color>):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions>;
        }
        export enum PhysicMaterialCombine{ Average = 0, Minimum = 2, Multiply = 1, Maximum = 3 }
        export class Collision extends System.Object{ 
            public get relativeVelocity(): UnityEngine.Vector3;
            public get rigidbody(): UnityEngine.Rigidbody;
            public get articulationBody(): UnityEngine.ArticulationBody;
            public get body(): UnityEngine.Component;
            public get collider(): UnityEngine.Collider;
            public get transform(): UnityEngine.Transform;
            public get gameObject(): UnityEngine.GameObject;
            public get contactCount(): number;
            public get contacts(): System.Array$1<UnityEngine.ContactPoint>;
            public get impulse(): UnityEngine.Vector3;
            public GetContact($index: number):UnityEngine.ContactPoint;
            public GetContacts($contacts: System.Array$1<UnityEngine.ContactPoint>):number;
            public GetContacts($contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint>):number;
            public constructor();
        }
        export class ArticulationBody extends UnityEngine.Behaviour{ 
            public get jointType(): UnityEngine.ArticulationJointType;
            public set jointType(value: UnityEngine.ArticulationJointType);
            public get anchorPosition(): UnityEngine.Vector3;
            public set anchorPosition(value: UnityEngine.Vector3);
            public get parentAnchorPosition(): UnityEngine.Vector3;
            public set parentAnchorPosition(value: UnityEngine.Vector3);
            public get anchorRotation(): UnityEngine.Quaternion;
            public set anchorRotation(value: UnityEngine.Quaternion);
            public get parentAnchorRotation(): UnityEngine.Quaternion;
            public set parentAnchorRotation(value: UnityEngine.Quaternion);
            public get isRoot(): boolean;
            public get computeParentAnchor(): boolean;
            public set computeParentAnchor(value: boolean);
            public get linearLockX(): UnityEngine.ArticulationDofLock;
            public set linearLockX(value: UnityEngine.ArticulationDofLock);
            public get linearLockY(): UnityEngine.ArticulationDofLock;
            public set linearLockY(value: UnityEngine.ArticulationDofLock);
            public get linearLockZ(): UnityEngine.ArticulationDofLock;
            public set linearLockZ(value: UnityEngine.ArticulationDofLock);
            public get swingYLock(): UnityEngine.ArticulationDofLock;
            public set swingYLock(value: UnityEngine.ArticulationDofLock);
            public get swingZLock(): UnityEngine.ArticulationDofLock;
            public set swingZLock(value: UnityEngine.ArticulationDofLock);
            public get twistLock(): UnityEngine.ArticulationDofLock;
            public set twistLock(value: UnityEngine.ArticulationDofLock);
            public get xDrive(): UnityEngine.ArticulationDrive;
            public set xDrive(value: UnityEngine.ArticulationDrive);
            public get yDrive(): UnityEngine.ArticulationDrive;
            public set yDrive(value: UnityEngine.ArticulationDrive);
            public get zDrive(): UnityEngine.ArticulationDrive;
            public set zDrive(value: UnityEngine.ArticulationDrive);
            public get immovable(): boolean;
            public set immovable(value: boolean);
            public get useGravity(): boolean;
            public set useGravity(value: boolean);
            public get linearDamping(): number;
            public set linearDamping(value: number);
            public get angularDamping(): number;
            public set angularDamping(value: number);
            public get jointFriction(): number;
            public set jointFriction(value: number);
            public get velocity(): UnityEngine.Vector3;
            public set velocity(value: UnityEngine.Vector3);
            public get angularVelocity(): UnityEngine.Vector3;
            public set angularVelocity(value: UnityEngine.Vector3);
            public get mass(): number;
            public set mass(value: number);
            public get centerOfMass(): UnityEngine.Vector3;
            public set centerOfMass(value: UnityEngine.Vector3);
            public get worldCenterOfMass(): UnityEngine.Vector3;
            public get inertiaTensor(): UnityEngine.Vector3;
            public set inertiaTensor(value: UnityEngine.Vector3);
            public get inertiaTensorRotation(): UnityEngine.Quaternion;
            public set inertiaTensorRotation(value: UnityEngine.Quaternion);
            public get sleepThreshold(): number;
            public set sleepThreshold(value: number);
            public get solverIterations(): number;
            public set solverIterations(value: number);
            public get solverVelocityIterations(): number;
            public set solverVelocityIterations(value: number);
            public get maxAngularVelocity(): number;
            public set maxAngularVelocity(value: number);
            public get maxLinearVelocity(): number;
            public set maxLinearVelocity(value: number);
            public get maxJointVelocity(): number;
            public set maxJointVelocity(value: number);
            public get maxDepenetrationVelocity(): number;
            public set maxDepenetrationVelocity(value: number);
            public get jointPosition(): UnityEngine.ArticulationReducedSpace;
            public set jointPosition(value: UnityEngine.ArticulationReducedSpace);
            public get jointVelocity(): UnityEngine.ArticulationReducedSpace;
            public set jointVelocity(value: UnityEngine.ArticulationReducedSpace);
            public get jointAcceleration(): UnityEngine.ArticulationReducedSpace;
            public set jointAcceleration(value: UnityEngine.ArticulationReducedSpace);
            public get jointForce(): UnityEngine.ArticulationReducedSpace;
            public set jointForce(value: UnityEngine.ArticulationReducedSpace);
            public get dofCount(): number;
            public get index(): number;
            public get collisionDetectionMode(): UnityEngine.CollisionDetectionMode;
            public set collisionDetectionMode(value: UnityEngine.CollisionDetectionMode);
            public AddForce($force: UnityEngine.Vector3):void;
            public AddRelativeForce($force: UnityEngine.Vector3):void;
            public AddTorque($torque: UnityEngine.Vector3):void;
            public AddRelativeTorque($torque: UnityEngine.Vector3):void;
            public AddForceAtPosition($force: UnityEngine.Vector3, $position: UnityEngine.Vector3):void;
            public ResetCenterOfMass():void;
            public ResetInertiaTensor():void;
            public Sleep():void;
            public IsSleeping():boolean;
            public WakeUp():void;
            public TeleportRoot($position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion):void;
            public GetClosestPoint($point: UnityEngine.Vector3):UnityEngine.Vector3;
            public GetRelativePointVelocity($relativePoint: UnityEngine.Vector3):UnityEngine.Vector3;
            public GetPointVelocity($worldPoint: UnityEngine.Vector3):UnityEngine.Vector3;
            public GetDenseJacobian($jacobian: $Ref<UnityEngine.ArticulationJacobian>):number;
            public GetJointPositions($positions: System.Collections.Generic.List$1<number>):number;
            public SetJointPositions($positions: System.Collections.Generic.List$1<number>):void;
            public GetJointVelocities($velocities: System.Collections.Generic.List$1<number>):number;
            public SetJointVelocities($velocities: System.Collections.Generic.List$1<number>):void;
            public GetJointAccelerations($accelerations: System.Collections.Generic.List$1<number>):number;
            public SetJointAccelerations($accelerations: System.Collections.Generic.List$1<number>):void;
            public GetJointForces($forces: System.Collections.Generic.List$1<number>):number;
            public SetJointForces($forces: System.Collections.Generic.List$1<number>):void;
            public GetDriveTargets($targets: System.Collections.Generic.List$1<number>):number;
            public SetDriveTargets($targets: System.Collections.Generic.List$1<number>):void;
            public GetDriveTargetVelocities($targetVelocities: System.Collections.Generic.List$1<number>):number;
            public SetDriveTargetVelocities($targetVelocities: System.Collections.Generic.List$1<number>):void;
            public GetDofStartIndices($dofStartIndices: System.Collections.Generic.List$1<number>):number;
            public SnapAnchorToClosestContact():void;
            public constructor();
        }
        export class ContactPoint extends System.ValueType{ 
            public get point(): UnityEngine.Vector3;
            public get normal(): UnityEngine.Vector3;
            public get thisCollider(): UnityEngine.Collider;
            public get otherCollider(): UnityEngine.Collider;
            public get separation(): number;
        }
        export enum CollisionFlags{ None = 0, Sides = 1, Above = 2, Below = 4, CollidedSides = 1, CollidedAbove = 2, CollidedBelow = 4 }
        export enum QueryTriggerInteraction{ UseGlobal = 0, Ignore = 1, Collide = 2 }
        export enum CollisionDetectionMode{ Discrete = 0, Continuous = 1, ContinuousDynamic = 2, ContinuousSpeculative = 3 }
        export enum ConfigurableJointMotion{ Locked = 0, Limited = 1, Free = 2 }
        export enum RotationDriveMode{ XYAndZ = 0, Slerp = 1 }
        export enum ArticulationJointType{ FixedJoint = 0, PrismaticJoint = 1, RevoluteJoint = 2, SphericalJoint = 3 }
        export enum ArticulationDofLock{ LockedMotion = 0, LimitedMotion = 1, FreeMotion = 2 }
        export class ArticulationDrive extends System.ValueType{ 
            public lowerLimit: number;
            public upperLimit: number;
            public stiffness: number;
            public damping: number;
            public forceLimit: number;
            public target: number;
            public targetVelocity: number;
        }
        export class ArticulationReducedSpace extends System.ValueType{ 
            public dofCount: number;
            public get_Item($i: number):number;
            public set_Item($i: number, $value: number):void;
            public constructor($a: number);
            public constructor($a: number, $b: number);
            public constructor($a: number, $b: number, $c: number);
            public constructor();
        }
        export class ArticulationJacobian extends System.ValueType{ 
            public get rows(): number;
            public set rows(value: number);
            public get columns(): number;
            public set columns(value: number);
            public get elements(): System.Collections.Generic.List$1<number>;
            public set elements(value: System.Collections.Generic.List$1<number>);
            public constructor($rows: number, $cols: number);
            public constructor();
        }
        export class PhysicMaterial extends UnityEngine.Object{ 
            public get bounciness(): number;
            public set bounciness(value: number);
            public get dynamicFriction(): number;
            public set dynamicFriction(value: number);
            public get staticFriction(): number;
            public set staticFriction(value: number);
            public get frictionCombine(): UnityEngine.PhysicMaterialCombine;
            public set frictionCombine(value: UnityEngine.PhysicMaterialCombine);
            public get bounceCombine(): UnityEngine.PhysicMaterialCombine;
            public set bounceCombine(value: UnityEngine.PhysicMaterialCombine);
            public constructor();
            public constructor($name: string);
        }
        export class RaycastHit extends System.ValueType{ 
            public get collider(): UnityEngine.Collider;
            public get point(): UnityEngine.Vector3;
            public set point(value: UnityEngine.Vector3);
            public get normal(): UnityEngine.Vector3;
            public set normal(value: UnityEngine.Vector3);
            public get barycentricCoordinate(): UnityEngine.Vector3;
            public set barycentricCoordinate(value: UnityEngine.Vector3);
            public get distance(): number;
            public set distance(value: number);
            public get triangleIndex(): number;
            public get textureCoord(): UnityEngine.Vector2;
            public get textureCoord2(): UnityEngine.Vector2;
            public get transform(): UnityEngine.Transform;
            public get rigidbody(): UnityEngine.Rigidbody;
            public get articulationBody(): UnityEngine.ArticulationBody;
            public get lightmapCoord(): UnityEngine.Vector2;
        }
        export class MeshCollider extends UnityEngine.Collider{ 
            public get sharedMesh(): UnityEngine.Mesh;
            public set sharedMesh(value: UnityEngine.Mesh);
            public get convex(): boolean;
            public set convex(value: boolean);
            public get cookingOptions(): UnityEngine.MeshColliderCookingOptions;
            public set cookingOptions(value: UnityEngine.MeshColliderCookingOptions);
            public constructor();
        }
        export class BoxCollider extends UnityEngine.Collider{ 
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            public get size(): UnityEngine.Vector3;
            public set size(value: UnityEngine.Vector3);
            public constructor();
        }
        export class ConstantForce extends UnityEngine.Behaviour{ 
            public get force(): UnityEngine.Vector3;
            public set force(value: UnityEngine.Vector3);
            public get relativeForce(): UnityEngine.Vector3;
            public set relativeForce(value: UnityEngine.Vector3);
            public get torque(): UnityEngine.Vector3;
            public set torque(value: UnityEngine.Vector3);
            public get relativeTorque(): UnityEngine.Vector3;
            public set relativeTorque(value: UnityEngine.Vector3);
            public constructor();
        }
        export class Joint extends UnityEngine.Component{ 
            public get connectedBody(): UnityEngine.Rigidbody;
            public set connectedBody(value: UnityEngine.Rigidbody);
            public get connectedArticulationBody(): UnityEngine.ArticulationBody;
            public set connectedArticulationBody(value: UnityEngine.ArticulationBody);
            public get axis(): UnityEngine.Vector3;
            public set axis(value: UnityEngine.Vector3);
            public get anchor(): UnityEngine.Vector3;
            public set anchor(value: UnityEngine.Vector3);
            public get connectedAnchor(): UnityEngine.Vector3;
            public set connectedAnchor(value: UnityEngine.Vector3);
            public get autoConfigureConnectedAnchor(): boolean;
            public set autoConfigureConnectedAnchor(value: boolean);
            public get breakForce(): number;
            public set breakForce(value: number);
            public get breakTorque(): number;
            public set breakTorque(value: number);
            public get enableCollision(): boolean;
            public set enableCollision(value: boolean);
            public get enablePreprocessing(): boolean;
            public set enablePreprocessing(value: boolean);
            public get massScale(): number;
            public set massScale(value: number);
            public get connectedMassScale(): number;
            public set connectedMassScale(value: number);
            public get currentForce(): UnityEngine.Vector3;
            public get currentTorque(): UnityEngine.Vector3;
            public constructor();
        }
        export class HingeJoint extends UnityEngine.Joint{ 
            public get motor(): UnityEngine.JointMotor;
            public set motor(value: UnityEngine.JointMotor);
            public get limits(): UnityEngine.JointLimits;
            public set limits(value: UnityEngine.JointLimits);
            public get spring(): UnityEngine.JointSpring;
            public set spring(value: UnityEngine.JointSpring);
            public get useMotor(): boolean;
            public set useMotor(value: boolean);
            public get useLimits(): boolean;
            public set useLimits(value: boolean);
            public get useSpring(): boolean;
            public set useSpring(value: boolean);
            public get velocity(): number;
            public get angle(): number;
            public constructor();
        }
        export class SpringJoint extends UnityEngine.Joint{ 
            public get spring(): number;
            public set spring(value: number);
            public get damper(): number;
            public set damper(value: number);
            public get minDistance(): number;
            public set minDistance(value: number);
            public get maxDistance(): number;
            public set maxDistance(value: number);
            public get tolerance(): number;
            public set tolerance(value: number);
            public constructor();
        }
        export class FixedJoint extends UnityEngine.Joint{ 
            public constructor();
        }
        export class CharacterJoint extends UnityEngine.Joint{ 
            public get swingAxis(): UnityEngine.Vector3;
            public set swingAxis(value: UnityEngine.Vector3);
            public get twistLimitSpring(): UnityEngine.SoftJointLimitSpring;
            public set twistLimitSpring(value: UnityEngine.SoftJointLimitSpring);
            public get swingLimitSpring(): UnityEngine.SoftJointLimitSpring;
            public set swingLimitSpring(value: UnityEngine.SoftJointLimitSpring);
            public get lowTwistLimit(): UnityEngine.SoftJointLimit;
            public set lowTwistLimit(value: UnityEngine.SoftJointLimit);
            public get highTwistLimit(): UnityEngine.SoftJointLimit;
            public set highTwistLimit(value: UnityEngine.SoftJointLimit);
            public get swing1Limit(): UnityEngine.SoftJointLimit;
            public set swing1Limit(value: UnityEngine.SoftJointLimit);
            public get swing2Limit(): UnityEngine.SoftJointLimit;
            public set swing2Limit(value: UnityEngine.SoftJointLimit);
            public get enableProjection(): boolean;
            public set enableProjection(value: boolean);
            public get projectionDistance(): number;
            public set projectionDistance(value: number);
            public get projectionAngle(): number;
            public set projectionAngle(value: number);
            public constructor();
        }
        export class ConfigurableJoint extends UnityEngine.Joint{ 
            public get secondaryAxis(): UnityEngine.Vector3;
            public set secondaryAxis(value: UnityEngine.Vector3);
            public get xMotion(): UnityEngine.ConfigurableJointMotion;
            public set xMotion(value: UnityEngine.ConfigurableJointMotion);
            public get yMotion(): UnityEngine.ConfigurableJointMotion;
            public set yMotion(value: UnityEngine.ConfigurableJointMotion);
            public get zMotion(): UnityEngine.ConfigurableJointMotion;
            public set zMotion(value: UnityEngine.ConfigurableJointMotion);
            public get angularXMotion(): UnityEngine.ConfigurableJointMotion;
            public set angularXMotion(value: UnityEngine.ConfigurableJointMotion);
            public get angularYMotion(): UnityEngine.ConfigurableJointMotion;
            public set angularYMotion(value: UnityEngine.ConfigurableJointMotion);
            public get angularZMotion(): UnityEngine.ConfigurableJointMotion;
            public set angularZMotion(value: UnityEngine.ConfigurableJointMotion);
            public get linearLimitSpring(): UnityEngine.SoftJointLimitSpring;
            public set linearLimitSpring(value: UnityEngine.SoftJointLimitSpring);
            public get angularXLimitSpring(): UnityEngine.SoftJointLimitSpring;
            public set angularXLimitSpring(value: UnityEngine.SoftJointLimitSpring);
            public get angularYZLimitSpring(): UnityEngine.SoftJointLimitSpring;
            public set angularYZLimitSpring(value: UnityEngine.SoftJointLimitSpring);
            public get linearLimit(): UnityEngine.SoftJointLimit;
            public set linearLimit(value: UnityEngine.SoftJointLimit);
            public get lowAngularXLimit(): UnityEngine.SoftJointLimit;
            public set lowAngularXLimit(value: UnityEngine.SoftJointLimit);
            public get highAngularXLimit(): UnityEngine.SoftJointLimit;
            public set highAngularXLimit(value: UnityEngine.SoftJointLimit);
            public get angularYLimit(): UnityEngine.SoftJointLimit;
            public set angularYLimit(value: UnityEngine.SoftJointLimit);
            public get angularZLimit(): UnityEngine.SoftJointLimit;
            public set angularZLimit(value: UnityEngine.SoftJointLimit);
            public get targetPosition(): UnityEngine.Vector3;
            public set targetPosition(value: UnityEngine.Vector3);
            public get targetVelocity(): UnityEngine.Vector3;
            public set targetVelocity(value: UnityEngine.Vector3);
            public get xDrive(): UnityEngine.JointDrive;
            public set xDrive(value: UnityEngine.JointDrive);
            public get yDrive(): UnityEngine.JointDrive;
            public set yDrive(value: UnityEngine.JointDrive);
            public get zDrive(): UnityEngine.JointDrive;
            public set zDrive(value: UnityEngine.JointDrive);
            public get targetRotation(): UnityEngine.Quaternion;
            public set targetRotation(value: UnityEngine.Quaternion);
            public get targetAngularVelocity(): UnityEngine.Vector3;
            public set targetAngularVelocity(value: UnityEngine.Vector3);
            public get rotationDriveMode(): UnityEngine.RotationDriveMode;
            public set rotationDriveMode(value: UnityEngine.RotationDriveMode);
            public get angularXDrive(): UnityEngine.JointDrive;
            public set angularXDrive(value: UnityEngine.JointDrive);
            public get angularYZDrive(): UnityEngine.JointDrive;
            public set angularYZDrive(value: UnityEngine.JointDrive);
            public get slerpDrive(): UnityEngine.JointDrive;
            public set slerpDrive(value: UnityEngine.JointDrive);
            public get projectionMode(): UnityEngine.JointProjectionMode;
            public set projectionMode(value: UnityEngine.JointProjectionMode);
            public get projectionDistance(): number;
            public set projectionDistance(value: number);
            public get projectionAngle(): number;
            public set projectionAngle(value: number);
            public get configuredInWorldSpace(): boolean;
            public set configuredInWorldSpace(value: boolean);
            public get swapBodies(): boolean;
            public set swapBodies(value: boolean);
            public constructor();
        }
        export class PhysicsScene extends System.ValueType implements System.IEquatable$1<UnityEngine.PhysicsScene>{ 
            public static op_Equality($lhs: UnityEngine.PhysicsScene, $rhs: UnityEngine.PhysicsScene):boolean;
            public static op_Inequality($lhs: UnityEngine.PhysicsScene, $rhs: UnityEngine.PhysicsScene):boolean;
            public Equals($other: any):boolean;
            public Equals($other: UnityEngine.PhysicsScene):boolean;
            public IsValid():boolean;
            public IsEmpty():boolean;
            public Simulate($step: number):void;
            public Raycast($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $maxDistance?: number, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction):boolean;
            public Raycast($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance?: number, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction):boolean;
            public Raycast($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $raycastHits: System.Array$1<UnityEngine.RaycastHit>, $maxDistance?: number, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction):number;
            public CapsuleCast($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance?: number, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction):boolean;
            public CapsuleCast($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance?: number, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction):number;
            public OverlapCapsule($point0: UnityEngine.Vector3, $point1: UnityEngine.Vector3, $radius: number, $results: System.Array$1<UnityEngine.Collider>, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction):number;
            public SphereCast($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance?: number, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction):boolean;
            public SphereCast($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance?: number, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction):number;
            public OverlapSphere($position: UnityEngine.Vector3, $radius: number, $results: System.Array$1<UnityEngine.Collider>, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):number;
            public BoxCast($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $orientation: UnityEngine.Quaternion, $maxDistance?: number, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction):boolean;
            public BoxCast($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>):boolean;
            public OverlapBox($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.Collider>, $orientation: UnityEngine.Quaternion, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction):number;
            public OverlapBox($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.Collider>):number;
            public BoxCast($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $orientation: UnityEngine.Quaternion, $maxDistance?: number, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction):number;
            public BoxCast($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>):number;
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
        }
        export class PhysicsSceneExtensions extends System.Object{ 
            public static GetPhysicsScene($scene: UnityEngine.SceneManagement.Scene):UnityEngine.PhysicsScene;
        }
        export class Physics extends System.Object{ 
            public static IgnoreRaycastLayer: number;
            public static DefaultRaycastLayers: number;
            public static AllLayers: number;
            public static get gravity(): UnityEngine.Vector3;
            public static set gravity(value: UnityEngine.Vector3);
            public static get defaultContactOffset(): number;
            public static set defaultContactOffset(value: number);
            public static get sleepThreshold(): number;
            public static set sleepThreshold(value: number);
            public static get queriesHitTriggers(): boolean;
            public static set queriesHitTriggers(value: boolean);
            public static get queriesHitBackfaces(): boolean;
            public static set queriesHitBackfaces(value: boolean);
            public static get bounceThreshold(): number;
            public static set bounceThreshold(value: number);
            public static get defaultMaxDepenetrationVelocity(): number;
            public static set defaultMaxDepenetrationVelocity(value: number);
            public static get defaultSolverIterations(): number;
            public static set defaultSolverIterations(value: number);
            public static get defaultSolverVelocityIterations(): number;
            public static set defaultSolverVelocityIterations(value: number);
            public static get defaultMaxAngularSpeed(): number;
            public static set defaultMaxAngularSpeed(value: number);
            public static get defaultPhysicsScene(): UnityEngine.PhysicsScene;
            public static get autoSimulation(): boolean;
            public static set autoSimulation(value: boolean);
            public static get autoSyncTransforms(): boolean;
            public static set autoSyncTransforms(value: boolean);
            public static get reuseCollisionCallbacks(): boolean;
            public static set reuseCollisionCallbacks(value: boolean);
            public static get interCollisionDistance(): number;
            public static set interCollisionDistance(value: number);
            public static get interCollisionStiffness(): number;
            public static set interCollisionStiffness(value: number);
            public static get interCollisionSettingsToggle(): boolean;
            public static set interCollisionSettingsToggle(value: boolean);
            public static get clothGravity(): UnityEngine.Vector3;
            public static set clothGravity(value: UnityEngine.Vector3);
            public static IgnoreCollision($collider1: UnityEngine.Collider, $collider2: UnityEngine.Collider, $ignore: boolean):void;
            public static IgnoreCollision($collider1: UnityEngine.Collider, $collider2: UnityEngine.Collider):void;
            public static IgnoreLayerCollision($layer1: number, $layer2: number, $ignore: boolean):void;
            public static IgnoreLayerCollision($layer1: number, $layer2: number):void;
            public static GetIgnoreLayerCollision($layer1: number, $layer2: number):boolean;
            public static GetIgnoreCollision($collider1: UnityEngine.Collider, $collider2: UnityEngine.Collider):boolean;
            public static Raycast($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):boolean;
            public static Raycast($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $maxDistance: number, $layerMask: number):boolean;
            public static Raycast($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $maxDistance: number):boolean;
            public static Raycast($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3):boolean;
            public static Raycast($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):boolean;
            public static Raycast($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number):boolean;
            public static Raycast($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number):boolean;
            public static Raycast($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>):boolean;
            public static Raycast($ray: UnityEngine.Ray, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):boolean;
            public static Raycast($ray: UnityEngine.Ray, $maxDistance: number, $layerMask: number):boolean;
            public static Raycast($ray: UnityEngine.Ray, $maxDistance: number):boolean;
            public static Raycast($ray: UnityEngine.Ray):boolean;
            public static Raycast($ray: UnityEngine.Ray, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):boolean;
            public static Raycast($ray: UnityEngine.Ray, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number):boolean;
            public static Raycast($ray: UnityEngine.Ray, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number):boolean;
            public static Raycast($ray: UnityEngine.Ray, $hitInfo: $Ref<UnityEngine.RaycastHit>):boolean;
            public static Linecast($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):boolean;
            public static Linecast($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $layerMask: number):boolean;
            public static Linecast($start: UnityEngine.Vector3, $end: UnityEngine.Vector3):boolean;
            public static Linecast($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):boolean;
            public static Linecast($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $layerMask: number):boolean;
            public static Linecast($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>):boolean;
            public static CapsuleCast($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):boolean;
            public static CapsuleCast($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $maxDistance: number, $layerMask: number):boolean;
            public static CapsuleCast($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $maxDistance: number):boolean;
            public static CapsuleCast($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3):boolean;
            public static CapsuleCast($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):boolean;
            public static CapsuleCast($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number):boolean;
            public static CapsuleCast($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number):boolean;
            public static CapsuleCast($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>):boolean;
            public static SphereCast($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):boolean;
            public static SphereCast($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number):boolean;
            public static SphereCast($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number):boolean;
            public static SphereCast($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>):boolean;
            public static SphereCast($ray: UnityEngine.Ray, $radius: number, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):boolean;
            public static SphereCast($ray: UnityEngine.Ray, $radius: number, $maxDistance: number, $layerMask: number):boolean;
            public static SphereCast($ray: UnityEngine.Ray, $radius: number, $maxDistance: number):boolean;
            public static SphereCast($ray: UnityEngine.Ray, $radius: number):boolean;
            public static SphereCast($ray: UnityEngine.Ray, $radius: number, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):boolean;
            public static SphereCast($ray: UnityEngine.Ray, $radius: number, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number):boolean;
            public static SphereCast($ray: UnityEngine.Ray, $radius: number, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number):boolean;
            public static SphereCast($ray: UnityEngine.Ray, $radius: number, $hitInfo: $Ref<UnityEngine.RaycastHit>):boolean;
            public static BoxCast($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):boolean;
            public static BoxCast($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $maxDistance: number, $layerMask: number):boolean;
            public static BoxCast($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $maxDistance: number):boolean;
            public static BoxCast($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion):boolean;
            public static BoxCast($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3):boolean;
            public static BoxCast($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $orientation: UnityEngine.Quaternion, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):boolean;
            public static BoxCast($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $orientation: UnityEngine.Quaternion, $maxDistance: number, $layerMask: number):boolean;
            public static BoxCast($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $orientation: UnityEngine.Quaternion, $maxDistance: number):boolean;
            public static BoxCast($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $orientation: UnityEngine.Quaternion):boolean;
            public static BoxCast($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>):boolean;
            public static RaycastAll($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):System.Array$1<UnityEngine.RaycastHit>;
            public static RaycastAll($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $maxDistance: number, $layerMask: number):System.Array$1<UnityEngine.RaycastHit>;
            public static RaycastAll($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $maxDistance: number):System.Array$1<UnityEngine.RaycastHit>;
            public static RaycastAll($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3):System.Array$1<UnityEngine.RaycastHit>;
            public static RaycastAll($ray: UnityEngine.Ray, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):System.Array$1<UnityEngine.RaycastHit>;
            public static RaycastAll($ray: UnityEngine.Ray, $maxDistance: number, $layerMask: number):System.Array$1<UnityEngine.RaycastHit>;
            public static RaycastAll($ray: UnityEngine.Ray, $maxDistance: number):System.Array$1<UnityEngine.RaycastHit>;
            public static RaycastAll($ray: UnityEngine.Ray):System.Array$1<UnityEngine.RaycastHit>;
            public static RaycastNonAlloc($ray: UnityEngine.Ray, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):number;
            public static RaycastNonAlloc($ray: UnityEngine.Ray, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number):number;
            public static RaycastNonAlloc($ray: UnityEngine.Ray, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number):number;
            public static RaycastNonAlloc($ray: UnityEngine.Ray, $results: System.Array$1<UnityEngine.RaycastHit>):number;
            public static RaycastNonAlloc($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):number;
            public static RaycastNonAlloc($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number):number;
            public static RaycastNonAlloc($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number):number;
            public static RaycastNonAlloc($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>):number;
            public static CapsuleCastAll($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):System.Array$1<UnityEngine.RaycastHit>;
            public static CapsuleCastAll($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $maxDistance: number, $layerMask: number):System.Array$1<UnityEngine.RaycastHit>;
            public static CapsuleCastAll($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $maxDistance: number):System.Array$1<UnityEngine.RaycastHit>;
            public static CapsuleCastAll($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3):System.Array$1<UnityEngine.RaycastHit>;
            public static SphereCastAll($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):System.Array$1<UnityEngine.RaycastHit>;
            public static SphereCastAll($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $maxDistance: number, $layerMask: number):System.Array$1<UnityEngine.RaycastHit>;
            public static SphereCastAll($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $maxDistance: number):System.Array$1<UnityEngine.RaycastHit>;
            public static SphereCastAll($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3):System.Array$1<UnityEngine.RaycastHit>;
            public static SphereCastAll($ray: UnityEngine.Ray, $radius: number, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):System.Array$1<UnityEngine.RaycastHit>;
            public static SphereCastAll($ray: UnityEngine.Ray, $radius: number, $maxDistance: number, $layerMask: number):System.Array$1<UnityEngine.RaycastHit>;
            public static SphereCastAll($ray: UnityEngine.Ray, $radius: number, $maxDistance: number):System.Array$1<UnityEngine.RaycastHit>;
            public static SphereCastAll($ray: UnityEngine.Ray, $radius: number):System.Array$1<UnityEngine.RaycastHit>;
            public static OverlapCapsule($point0: UnityEngine.Vector3, $point1: UnityEngine.Vector3, $radius: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):System.Array$1<UnityEngine.Collider>;
            public static OverlapCapsule($point0: UnityEngine.Vector3, $point1: UnityEngine.Vector3, $radius: number, $layerMask: number):System.Array$1<UnityEngine.Collider>;
            public static OverlapCapsule($point0: UnityEngine.Vector3, $point1: UnityEngine.Vector3, $radius: number):System.Array$1<UnityEngine.Collider>;
            public static OverlapSphere($position: UnityEngine.Vector3, $radius: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):System.Array$1<UnityEngine.Collider>;
            public static OverlapSphere($position: UnityEngine.Vector3, $radius: number, $layerMask: number):System.Array$1<UnityEngine.Collider>;
            public static OverlapSphere($position: UnityEngine.Vector3, $radius: number):System.Array$1<UnityEngine.Collider>;
            public static Simulate($step: number):void;
            public static SyncTransforms():void;
            public static ComputePenetration($colliderA: UnityEngine.Collider, $positionA: UnityEngine.Vector3, $rotationA: UnityEngine.Quaternion, $colliderB: UnityEngine.Collider, $positionB: UnityEngine.Vector3, $rotationB: UnityEngine.Quaternion, $direction: $Ref<UnityEngine.Vector3>, $distance: $Ref<number>):boolean;
            public static ClosestPoint($point: UnityEngine.Vector3, $collider: UnityEngine.Collider, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion):UnityEngine.Vector3;
            public static OverlapSphereNonAlloc($position: UnityEngine.Vector3, $radius: number, $results: System.Array$1<UnityEngine.Collider>, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):number;
            public static OverlapSphereNonAlloc($position: UnityEngine.Vector3, $radius: number, $results: System.Array$1<UnityEngine.Collider>, $layerMask: number):number;
            public static OverlapSphereNonAlloc($position: UnityEngine.Vector3, $radius: number, $results: System.Array$1<UnityEngine.Collider>):number;
            public static CheckSphere($position: UnityEngine.Vector3, $radius: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):boolean;
            public static CheckSphere($position: UnityEngine.Vector3, $radius: number, $layerMask: number):boolean;
            public static CheckSphere($position: UnityEngine.Vector3, $radius: number):boolean;
            public static CapsuleCastNonAlloc($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):number;
            public static CapsuleCastNonAlloc($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number):number;
            public static CapsuleCastNonAlloc($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number):number;
            public static CapsuleCastNonAlloc($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>):number;
            public static SphereCastNonAlloc($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):number;
            public static SphereCastNonAlloc($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number):number;
            public static SphereCastNonAlloc($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number):number;
            public static SphereCastNonAlloc($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>):number;
            public static SphereCastNonAlloc($ray: UnityEngine.Ray, $radius: number, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):number;
            public static SphereCastNonAlloc($ray: UnityEngine.Ray, $radius: number, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number):number;
            public static SphereCastNonAlloc($ray: UnityEngine.Ray, $radius: number, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number):number;
            public static SphereCastNonAlloc($ray: UnityEngine.Ray, $radius: number, $results: System.Array$1<UnityEngine.RaycastHit>):number;
            public static CheckCapsule($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $radius: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):boolean;
            public static CheckCapsule($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $radius: number, $layerMask: number):boolean;
            public static CheckCapsule($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $radius: number):boolean;
            public static CheckBox($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $layermask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):boolean;
            public static CheckBox($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $layerMask: number):boolean;
            public static CheckBox($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion):boolean;
            public static CheckBox($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3):boolean;
            public static OverlapBox($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):System.Array$1<UnityEngine.Collider>;
            public static OverlapBox($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $layerMask: number):System.Array$1<UnityEngine.Collider>;
            public static OverlapBox($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion):System.Array$1<UnityEngine.Collider>;
            public static OverlapBox($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3):System.Array$1<UnityEngine.Collider>;
            public static OverlapBoxNonAlloc($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.Collider>, $orientation: UnityEngine.Quaternion, $mask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):number;
            public static OverlapBoxNonAlloc($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.Collider>, $orientation: UnityEngine.Quaternion, $mask: number):number;
            public static OverlapBoxNonAlloc($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.Collider>, $orientation: UnityEngine.Quaternion):number;
            public static OverlapBoxNonAlloc($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.Collider>):number;
            public static BoxCastNonAlloc($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $orientation: UnityEngine.Quaternion, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):number;
            public static BoxCastNonAlloc($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $orientation: UnityEngine.Quaternion):number;
            public static BoxCastNonAlloc($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $orientation: UnityEngine.Quaternion, $maxDistance: number):number;
            public static BoxCastNonAlloc($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $orientation: UnityEngine.Quaternion, $maxDistance: number, $layerMask: number):number;
            public static BoxCastNonAlloc($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>):number;
            public static BoxCastAll($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):System.Array$1<UnityEngine.RaycastHit>;
            public static BoxCastAll($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $maxDistance: number, $layerMask: number):System.Array$1<UnityEngine.RaycastHit>;
            public static BoxCastAll($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $maxDistance: number):System.Array$1<UnityEngine.RaycastHit>;
            public static BoxCastAll($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion):System.Array$1<UnityEngine.RaycastHit>;
            public static BoxCastAll($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3):System.Array$1<UnityEngine.RaycastHit>;
            public static OverlapCapsuleNonAlloc($point0: UnityEngine.Vector3, $point1: UnityEngine.Vector3, $radius: number, $results: System.Array$1<UnityEngine.Collider>, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction):number;
            public static OverlapCapsuleNonAlloc($point0: UnityEngine.Vector3, $point1: UnityEngine.Vector3, $radius: number, $results: System.Array$1<UnityEngine.Collider>, $layerMask: number):number;
            public static OverlapCapsuleNonAlloc($point0: UnityEngine.Vector3, $point1: UnityEngine.Vector3, $radius: number, $results: System.Array$1<UnityEngine.Collider>):number;
            public static RebuildBroadphaseRegions($worldBounds: UnityEngine.Bounds, $subdivisions: number):void;
            public static BakeMesh($meshID: number, $convex: boolean):void;
            public constructor();
        }
        export class RaycastCommand extends System.ValueType{ 
            public get from(): UnityEngine.Vector3;
            public set from(value: UnityEngine.Vector3);
            public get direction(): UnityEngine.Vector3;
            public set direction(value: UnityEngine.Vector3);
            public get distance(): number;
            public set distance(value: number);
            public get layerMask(): number;
            public set layerMask(value: number);
            public get maxHits(): number;
            public set maxHits(value: number);
            public static ScheduleBatch($commands: Unity.Collections.NativeArray$1<UnityEngine.RaycastCommand>, $results: Unity.Collections.NativeArray$1<UnityEngine.RaycastHit>, $minCommandsPerJob: number, $dependsOn?: Unity.Jobs.JobHandle):Unity.Jobs.JobHandle;
            public constructor($from: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $distance?: number, $layerMask?: number, $maxHits?: number);
            public constructor();
        }
        export class SpherecastCommand extends System.ValueType{ 
            public get origin(): UnityEngine.Vector3;
            public set origin(value: UnityEngine.Vector3);
            public get radius(): number;
            public set radius(value: number);
            public get direction(): UnityEngine.Vector3;
            public set direction(value: UnityEngine.Vector3);
            public get distance(): number;
            public set distance(value: number);
            public get layerMask(): number;
            public set layerMask(value: number);
            public static ScheduleBatch($commands: Unity.Collections.NativeArray$1<UnityEngine.SpherecastCommand>, $results: Unity.Collections.NativeArray$1<UnityEngine.RaycastHit>, $minCommandsPerJob: number, $dependsOn?: Unity.Jobs.JobHandle):Unity.Jobs.JobHandle;
            public constructor($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $distance?: number, $layerMask?: number);
            public constructor();
        }
        export class CapsulecastCommand extends System.ValueType{ 
            public get point1(): UnityEngine.Vector3;
            public set point1(value: UnityEngine.Vector3);
            public get point2(): UnityEngine.Vector3;
            public set point2(value: UnityEngine.Vector3);
            public get radius(): number;
            public set radius(value: number);
            public get direction(): UnityEngine.Vector3;
            public set direction(value: UnityEngine.Vector3);
            public get distance(): number;
            public set distance(value: number);
            public get layerMask(): number;
            public set layerMask(value: number);
            public static ScheduleBatch($commands: Unity.Collections.NativeArray$1<UnityEngine.CapsulecastCommand>, $results: Unity.Collections.NativeArray$1<UnityEngine.RaycastHit>, $minCommandsPerJob: number, $dependsOn?: Unity.Jobs.JobHandle):Unity.Jobs.JobHandle;
            public constructor($p1: UnityEngine.Vector3, $p2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $distance?: number, $layerMask?: number);
            public constructor();
        }
        export class BoxcastCommand extends System.ValueType{ 
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            public get halfExtents(): UnityEngine.Vector3;
            public set halfExtents(value: UnityEngine.Vector3);
            public get orientation(): UnityEngine.Quaternion;
            public set orientation(value: UnityEngine.Quaternion);
            public get direction(): UnityEngine.Vector3;
            public set direction(value: UnityEngine.Vector3);
            public get distance(): number;
            public set distance(value: number);
            public get layerMask(): number;
            public set layerMask(value: number);
            public static ScheduleBatch($commands: Unity.Collections.NativeArray$1<UnityEngine.BoxcastCommand>, $results: Unity.Collections.NativeArray$1<UnityEngine.RaycastHit>, $minCommandsPerJob: number, $dependsOn?: Unity.Jobs.JobHandle):Unity.Jobs.JobHandle;
            public constructor($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $direction: UnityEngine.Vector3, $distance?: number, $layerMask?: number);
            public constructor();
        }
        export class PhysicsScene2D extends System.ValueType implements System.IEquatable$1<UnityEngine.PhysicsScene2D>{ 
            public static op_Equality($lhs: UnityEngine.PhysicsScene2D, $rhs: UnityEngine.PhysicsScene2D):boolean;
            public static op_Inequality($lhs: UnityEngine.PhysicsScene2D, $rhs: UnityEngine.PhysicsScene2D):boolean;
            public Equals($other: any):boolean;
            public Equals($other: UnityEngine.PhysicsScene2D):boolean;
            public IsValid():boolean;
            public IsEmpty():boolean;
            public Simulate($step: number):boolean;
            public Linecast($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $layerMask?: number):UnityEngine.RaycastHit2D;
            public Linecast($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D):UnityEngine.RaycastHit2D;
            public Linecast($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $layerMask?: number):number;
            public Linecast($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public Linecast($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>):number;
            public Raycast($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $layerMask?: number):UnityEngine.RaycastHit2D;
            public Raycast($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D):UnityEngine.RaycastHit2D;
            public Raycast($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $results: System.Array$1<UnityEngine.RaycastHit2D>, $layerMask?: number):number;
            public Raycast($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public Raycast($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>):number;
            public CircleCast($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask?: number):UnityEngine.RaycastHit2D;
            public CircleCast($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D):UnityEngine.RaycastHit2D;
            public CircleCast($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $results: System.Array$1<UnityEngine.RaycastHit2D>, $layerMask?: number):number;
            public CircleCast($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public CircleCast($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>):number;
            public BoxCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask?: number):UnityEngine.RaycastHit2D;
            public BoxCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D):UnityEngine.RaycastHit2D;
            public BoxCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $results: System.Array$1<UnityEngine.RaycastHit2D>, $layerMask?: number):number;
            public BoxCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public BoxCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>):number;
            public CapsuleCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask?: number):UnityEngine.RaycastHit2D;
            public CapsuleCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D):UnityEngine.RaycastHit2D;
            public CapsuleCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $results: System.Array$1<UnityEngine.RaycastHit2D>, $layerMask?: number):number;
            public CapsuleCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public CapsuleCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>):number;
            public GetRayIntersection($ray: UnityEngine.Ray, $distance: number, $layerMask?: number):UnityEngine.RaycastHit2D;
            public GetRayIntersection($ray: UnityEngine.Ray, $distance: number, $results: System.Array$1<UnityEngine.RaycastHit2D>, $layerMask?: number):number;
            public OverlapPoint($point: UnityEngine.Vector2, $layerMask?: number):UnityEngine.Collider2D;
            public OverlapPoint($point: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D):UnityEngine.Collider2D;
            public OverlapPoint($point: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask?: number):number;
            public OverlapPoint($point: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>):number;
            public OverlapPoint($point: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public OverlapCircle($point: UnityEngine.Vector2, $radius: number, $layerMask?: number):UnityEngine.Collider2D;
            public OverlapCircle($point: UnityEngine.Vector2, $radius: number, $contactFilter: UnityEngine.ContactFilter2D):UnityEngine.Collider2D;
            public OverlapCircle($point: UnityEngine.Vector2, $radius: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask?: number):number;
            public OverlapCircle($point: UnityEngine.Vector2, $radius: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>):number;
            public OverlapCircle($point: UnityEngine.Vector2, $radius: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public OverlapBox($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $layerMask?: number):UnityEngine.Collider2D;
            public OverlapBox($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $contactFilter: UnityEngine.ContactFilter2D):UnityEngine.Collider2D;
            public OverlapBox($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask?: number):number;
            public OverlapBox($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>):number;
            public OverlapBox($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public OverlapArea($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $layerMask?: number):UnityEngine.Collider2D;
            public OverlapArea($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D):UnityEngine.Collider2D;
            public OverlapArea($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask?: number):number;
            public OverlapArea($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>):number;
            public OverlapArea($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public OverlapCapsule($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $layerMask?: number):UnityEngine.Collider2D;
            public OverlapCapsule($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $contactFilter: UnityEngine.ContactFilter2D):UnityEngine.Collider2D;
            public OverlapCapsule($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask?: number):number;
            public OverlapCapsule($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>):number;
            public OverlapCapsule($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public static OverlapCollider($collider: UnityEngine.Collider2D, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask?: number):number;
            public static OverlapCollider($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>):number;
            public static OverlapCollider($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
        }
        export class RaycastHit2D extends System.ValueType{ 
            public get centroid(): UnityEngine.Vector2;
            public set centroid(value: UnityEngine.Vector2);
            public get point(): UnityEngine.Vector2;
            public set point(value: UnityEngine.Vector2);
            public get normal(): UnityEngine.Vector2;
            public set normal(value: UnityEngine.Vector2);
            public get distance(): number;
            public set distance(value: number);
            public get fraction(): number;
            public set fraction(value: number);
            public get collider(): UnityEngine.Collider2D;
            public get rigidbody(): UnityEngine.Rigidbody2D;
            public get transform(): UnityEngine.Transform;
            public static op_Implicit($hit: UnityEngine.RaycastHit2D):boolean;
            public CompareTo($other: UnityEngine.RaycastHit2D):number;
        }
        export class ContactFilter2D extends System.ValueType{ 
            public useTriggers: boolean;
            public useLayerMask: boolean;
            public useDepth: boolean;
            public useOutsideDepth: boolean;
            public useNormalAngle: boolean;
            public useOutsideNormalAngle: boolean;
            public layerMask: UnityEngine.LayerMask;
            public minDepth: number;
            public maxDepth: number;
            public minNormalAngle: number;
            public maxNormalAngle: number;
            public static NormalAngleUpperLimit: number;
            public get isFiltering(): boolean;
            public NoFilter():UnityEngine.ContactFilter2D;
            public ClearLayerMask():void;
            public SetLayerMask($layerMask: UnityEngine.LayerMask):void;
            public ClearDepth():void;
            public SetDepth($minDepth: number, $maxDepth: number):void;
            public ClearNormalAngle():void;
            public SetNormalAngle($minNormalAngle: number, $maxNormalAngle: number):void;
            public IsFilteringTrigger($collider: UnityEngine.Collider2D):boolean;
            public IsFilteringLayerMask($obj: UnityEngine.GameObject):boolean;
            public IsFilteringDepth($obj: UnityEngine.GameObject):boolean;
            public IsFilteringNormalAngle($normal: UnityEngine.Vector2):boolean;
            public IsFilteringNormalAngle($angle: number):boolean;
        }
        export enum CapsuleDirection2D{ Vertical = 0, Horizontal = 1 }
        export class Collider2D extends UnityEngine.Behaviour{ 
            public get density(): number;
            public set density(value: number);
            public get isTrigger(): boolean;
            public set isTrigger(value: boolean);
            public get usedByEffector(): boolean;
            public set usedByEffector(value: boolean);
            public get usedByComposite(): boolean;
            public set usedByComposite(value: boolean);
            public get composite(): UnityEngine.CompositeCollider2D;
            public get offset(): UnityEngine.Vector2;
            public set offset(value: UnityEngine.Vector2);
            public get attachedRigidbody(): UnityEngine.Rigidbody2D;
            public get shapeCount(): number;
            public get bounds(): UnityEngine.Bounds;
            public get sharedMaterial(): UnityEngine.PhysicsMaterial2D;
            public set sharedMaterial(value: UnityEngine.PhysicsMaterial2D);
            public get friction(): number;
            public get bounciness(): number;
            public CreateMesh($useBodyPosition: boolean, $useBodyRotation: boolean):UnityEngine.Mesh;
            public GetShapeHash():number;
            public IsTouching($collider: UnityEngine.Collider2D):boolean;
            public IsTouching($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D):boolean;
            public IsTouching($contactFilter: UnityEngine.ContactFilter2D):boolean;
            public IsTouchingLayers():boolean;
            public IsTouchingLayers($layerMask: number):boolean;
            public OverlapPoint($point: UnityEngine.Vector2):boolean;
            public Distance($collider: UnityEngine.Collider2D):UnityEngine.ColliderDistance2D;
            public OverlapCollider($contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>):number;
            public OverlapCollider($contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public GetContacts($contacts: System.Array$1<UnityEngine.ContactPoint2D>):number;
            public GetContacts($contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint2D>):number;
            public GetContacts($contactFilter: UnityEngine.ContactFilter2D, $contacts: System.Array$1<UnityEngine.ContactPoint2D>):number;
            public GetContacts($contactFilter: UnityEngine.ContactFilter2D, $contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint2D>):number;
            public GetContacts($colliders: System.Array$1<UnityEngine.Collider2D>):number;
            public GetContacts($colliders: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public GetContacts($contactFilter: UnityEngine.ContactFilter2D, $colliders: System.Array$1<UnityEngine.Collider2D>):number;
            public GetContacts($contactFilter: UnityEngine.ContactFilter2D, $colliders: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public Cast($direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public Cast($direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number):number;
            public Cast($direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $ignoreSiblingColliders: boolean):number;
            public Cast($direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public Cast($direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number):number;
            public Cast($direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $ignoreSiblingColliders: boolean):number;
            public Cast($direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>, $distance?: number, $ignoreSiblingColliders?: boolean):number;
            public Raycast($direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public Raycast($direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number):number;
            public Raycast($direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number):number;
            public Raycast($direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number, $minDepth: number):number;
            public Raycast($direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number):number;
            public Raycast($direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public Raycast($direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number):number;
            public Raycast($direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>, $distance?: number):number;
            public ClosestPoint($position: UnityEngine.Vector2):UnityEngine.Vector2;
            public constructor();
        }
        export class PhysicsSceneExtensions2D extends System.Object{ 
            public static GetPhysicsScene2D($scene: UnityEngine.SceneManagement.Scene):UnityEngine.PhysicsScene2D;
        }
        export class Physics2D extends System.Object{ 
            public static IgnoreRaycastLayer: number;
            public static DefaultRaycastLayers: number;
            public static AllLayers: number;
            public static get defaultPhysicsScene(): UnityEngine.PhysicsScene2D;
            public static get velocityIterations(): number;
            public static set velocityIterations(value: number);
            public static get positionIterations(): number;
            public static set positionIterations(value: number);
            public static get gravity(): UnityEngine.Vector2;
            public static set gravity(value: UnityEngine.Vector2);
            public static get queriesHitTriggers(): boolean;
            public static set queriesHitTriggers(value: boolean);
            public static get queriesStartInColliders(): boolean;
            public static set queriesStartInColliders(value: boolean);
            public static get callbacksOnDisable(): boolean;
            public static set callbacksOnDisable(value: boolean);
            public static get reuseCollisionCallbacks(): boolean;
            public static set reuseCollisionCallbacks(value: boolean);
            public static get autoSyncTransforms(): boolean;
            public static set autoSyncTransforms(value: boolean);
            public static get simulationMode(): UnityEngine.SimulationMode2D;
            public static set simulationMode(value: UnityEngine.SimulationMode2D);
            public static get jobOptions(): UnityEngine.PhysicsJobOptions2D;
            public static set jobOptions(value: UnityEngine.PhysicsJobOptions2D);
            public static get velocityThreshold(): number;
            public static set velocityThreshold(value: number);
            public static get maxLinearCorrection(): number;
            public static set maxLinearCorrection(value: number);
            public static get maxAngularCorrection(): number;
            public static set maxAngularCorrection(value: number);
            public static get maxTranslationSpeed(): number;
            public static set maxTranslationSpeed(value: number);
            public static get maxRotationSpeed(): number;
            public static set maxRotationSpeed(value: number);
            public static get defaultContactOffset(): number;
            public static set defaultContactOffset(value: number);
            public static get baumgarteScale(): number;
            public static set baumgarteScale(value: number);
            public static get baumgarteTOIScale(): number;
            public static set baumgarteTOIScale(value: number);
            public static get timeToSleep(): number;
            public static set timeToSleep(value: number);
            public static get linearSleepTolerance(): number;
            public static set linearSleepTolerance(value: number);
            public static get angularSleepTolerance(): number;
            public static set angularSleepTolerance(value: number);
            public static get alwaysShowColliders(): boolean;
            public static set alwaysShowColliders(value: boolean);
            public static get showColliderSleep(): boolean;
            public static set showColliderSleep(value: boolean);
            public static get showColliderContacts(): boolean;
            public static set showColliderContacts(value: boolean);
            public static get showColliderAABB(): boolean;
            public static set showColliderAABB(value: boolean);
            public static get contactArrowScale(): number;
            public static set contactArrowScale(value: number);
            public static get colliderAwakeColor(): UnityEngine.Color;
            public static set colliderAwakeColor(value: UnityEngine.Color);
            public static get colliderAsleepColor(): UnityEngine.Color;
            public static set colliderAsleepColor(value: UnityEngine.Color);
            public static get colliderContactColor(): UnityEngine.Color;
            public static set colliderContactColor(value: UnityEngine.Color);
            public static get colliderAABBColor(): UnityEngine.Color;
            public static set colliderAABBColor(value: UnityEngine.Color);
            public static Simulate($step: number):boolean;
            public static SyncTransforms():void;
            public static IgnoreCollision($collider1: UnityEngine.Collider2D, $collider2: UnityEngine.Collider2D):void;
            public static IgnoreCollision($collider1: UnityEngine.Collider2D, $collider2: UnityEngine.Collider2D, $ignore: boolean):void;
            public static GetIgnoreCollision($collider1: UnityEngine.Collider2D, $collider2: UnityEngine.Collider2D):boolean;
            public static IgnoreLayerCollision($layer1: number, $layer2: number):void;
            public static IgnoreLayerCollision($layer1: number, $layer2: number, $ignore: boolean):void;
            public static GetIgnoreLayerCollision($layer1: number, $layer2: number):boolean;
            public static SetLayerCollisionMask($layer: number, $layerMask: number):void;
            public static GetLayerCollisionMask($layer: number):number;
            public static IsTouching($collider1: UnityEngine.Collider2D, $collider2: UnityEngine.Collider2D):boolean;
            public static IsTouching($collider1: UnityEngine.Collider2D, $collider2: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D):boolean;
            public static IsTouching($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D):boolean;
            public static IsTouchingLayers($collider: UnityEngine.Collider2D):boolean;
            public static IsTouchingLayers($collider: UnityEngine.Collider2D, $layerMask: number):boolean;
            public static Distance($colliderA: UnityEngine.Collider2D, $colliderB: UnityEngine.Collider2D):UnityEngine.ColliderDistance2D;
            public static ClosestPoint($position: UnityEngine.Vector2, $collider: UnityEngine.Collider2D):UnityEngine.Vector2;
            public static ClosestPoint($position: UnityEngine.Vector2, $rigidbody: UnityEngine.Rigidbody2D):UnityEngine.Vector2;
            public static Linecast($start: UnityEngine.Vector2, $end: UnityEngine.Vector2):UnityEngine.RaycastHit2D;
            public static Linecast($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $layerMask: number):UnityEngine.RaycastHit2D;
            public static Linecast($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $layerMask: number, $minDepth: number):UnityEngine.RaycastHit2D;
            public static Linecast($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $layerMask: number, $minDepth: number, $maxDepth: number):UnityEngine.RaycastHit2D;
            public static Linecast($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public static Linecast($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>):number;
            public static LinecastAll($start: UnityEngine.Vector2, $end: UnityEngine.Vector2):System.Array$1<UnityEngine.RaycastHit2D>;
            public static LinecastAll($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $layerMask: number):System.Array$1<UnityEngine.RaycastHit2D>;
            public static LinecastAll($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $layerMask: number, $minDepth: number):System.Array$1<UnityEngine.RaycastHit2D>;
            public static LinecastAll($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $layerMask: number, $minDepth: number, $maxDepth: number):System.Array$1<UnityEngine.RaycastHit2D>;
            public static LinecastNonAlloc($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public static LinecastNonAlloc($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $layerMask: number):number;
            public static LinecastNonAlloc($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $layerMask: number, $minDepth: number):number;
            public static LinecastNonAlloc($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $layerMask: number, $minDepth: number, $maxDepth: number):number;
            public static Raycast($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2):UnityEngine.RaycastHit2D;
            public static Raycast($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number):UnityEngine.RaycastHit2D;
            public static Raycast($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number):UnityEngine.RaycastHit2D;
            public static Raycast($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number):UnityEngine.RaycastHit2D;
            public static Raycast($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number):UnityEngine.RaycastHit2D;
            public static Raycast($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public static Raycast($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number):number;
            public static Raycast($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>, $distance?: number):number;
            public static RaycastNonAlloc($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public static RaycastNonAlloc($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number):number;
            public static RaycastNonAlloc($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number):number;
            public static RaycastNonAlloc($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number, $minDepth: number):number;
            public static RaycastNonAlloc($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number):number;
            public static RaycastAll($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2):System.Array$1<UnityEngine.RaycastHit2D>;
            public static RaycastAll($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number):System.Array$1<UnityEngine.RaycastHit2D>;
            public static RaycastAll($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number):System.Array$1<UnityEngine.RaycastHit2D>;
            public static RaycastAll($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number):System.Array$1<UnityEngine.RaycastHit2D>;
            public static RaycastAll($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number):System.Array$1<UnityEngine.RaycastHit2D>;
            public static CircleCast($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2):UnityEngine.RaycastHit2D;
            public static CircleCast($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number):UnityEngine.RaycastHit2D;
            public static CircleCast($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number):UnityEngine.RaycastHit2D;
            public static CircleCast($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number):UnityEngine.RaycastHit2D;
            public static CircleCast($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number):UnityEngine.RaycastHit2D;
            public static CircleCast($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public static CircleCast($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number):number;
            public static CircleCast($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>, $distance?: number):number;
            public static CircleCastAll($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2):System.Array$1<UnityEngine.RaycastHit2D>;
            public static CircleCastAll($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number):System.Array$1<UnityEngine.RaycastHit2D>;
            public static CircleCastAll($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number):System.Array$1<UnityEngine.RaycastHit2D>;
            public static CircleCastAll($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number):System.Array$1<UnityEngine.RaycastHit2D>;
            public static CircleCastAll($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number):System.Array$1<UnityEngine.RaycastHit2D>;
            public static CircleCastNonAlloc($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public static CircleCastNonAlloc($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number):number;
            public static CircleCastNonAlloc($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number):number;
            public static CircleCastNonAlloc($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number, $minDepth: number):number;
            public static CircleCastNonAlloc($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number):number;
            public static BoxCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2):UnityEngine.RaycastHit2D;
            public static BoxCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number):UnityEngine.RaycastHit2D;
            public static BoxCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number):UnityEngine.RaycastHit2D;
            public static BoxCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number):UnityEngine.RaycastHit2D;
            public static BoxCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number):UnityEngine.RaycastHit2D;
            public static BoxCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public static BoxCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number):number;
            public static BoxCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>, $distance?: number):number;
            public static BoxCastAll($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2):System.Array$1<UnityEngine.RaycastHit2D>;
            public static BoxCastAll($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number):System.Array$1<UnityEngine.RaycastHit2D>;
            public static BoxCastAll($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number):System.Array$1<UnityEngine.RaycastHit2D>;
            public static BoxCastAll($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number):System.Array$1<UnityEngine.RaycastHit2D>;
            public static BoxCastAll($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number):System.Array$1<UnityEngine.RaycastHit2D>;
            public static BoxCastNonAlloc($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public static BoxCastNonAlloc($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number):number;
            public static BoxCastNonAlloc($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number):number;
            public static BoxCastNonAlloc($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number, $minDepth: number):number;
            public static BoxCastNonAlloc($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number):number;
            public static CapsuleCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2):UnityEngine.RaycastHit2D;
            public static CapsuleCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number):UnityEngine.RaycastHit2D;
            public static CapsuleCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number):UnityEngine.RaycastHit2D;
            public static CapsuleCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number):UnityEngine.RaycastHit2D;
            public static CapsuleCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number):UnityEngine.RaycastHit2D;
            public static CapsuleCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public static CapsuleCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number):number;
            public static CapsuleCast($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>, $distance?: number):number;
            public static CapsuleCastAll($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2):System.Array$1<UnityEngine.RaycastHit2D>;
            public static CapsuleCastAll($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number):System.Array$1<UnityEngine.RaycastHit2D>;
            public static CapsuleCastAll($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number):System.Array$1<UnityEngine.RaycastHit2D>;
            public static CapsuleCastAll($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number):System.Array$1<UnityEngine.RaycastHit2D>;
            public static CapsuleCastAll($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number):System.Array$1<UnityEngine.RaycastHit2D>;
            public static CapsuleCastNonAlloc($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public static CapsuleCastNonAlloc($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number):number;
            public static CapsuleCastNonAlloc($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number):number;
            public static CapsuleCastNonAlloc($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number, $minDepth: number):number;
            public static CapsuleCastNonAlloc($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number):number;
            public static GetRayIntersection($ray: UnityEngine.Ray):UnityEngine.RaycastHit2D;
            public static GetRayIntersection($ray: UnityEngine.Ray, $distance: number):UnityEngine.RaycastHit2D;
            public static GetRayIntersection($ray: UnityEngine.Ray, $distance: number, $layerMask: number):UnityEngine.RaycastHit2D;
            public static GetRayIntersectionAll($ray: UnityEngine.Ray):System.Array$1<UnityEngine.RaycastHit2D>;
            public static GetRayIntersectionAll($ray: UnityEngine.Ray, $distance: number):System.Array$1<UnityEngine.RaycastHit2D>;
            public static GetRayIntersectionAll($ray: UnityEngine.Ray, $distance: number, $layerMask: number):System.Array$1<UnityEngine.RaycastHit2D>;
            public static GetRayIntersectionNonAlloc($ray: UnityEngine.Ray, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public static GetRayIntersectionNonAlloc($ray: UnityEngine.Ray, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number):number;
            public static GetRayIntersectionNonAlloc($ray: UnityEngine.Ray, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number):number;
            public static OverlapPoint($point: UnityEngine.Vector2):UnityEngine.Collider2D;
            public static OverlapPoint($point: UnityEngine.Vector2, $layerMask: number):UnityEngine.Collider2D;
            public static OverlapPoint($point: UnityEngine.Vector2, $layerMask: number, $minDepth: number):UnityEngine.Collider2D;
            public static OverlapPoint($point: UnityEngine.Vector2, $layerMask: number, $minDepth: number, $maxDepth: number):UnityEngine.Collider2D;
            public static OverlapPoint($point: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>):number;
            public static OverlapPoint($point: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public static OverlapPointAll($point: UnityEngine.Vector2):System.Array$1<UnityEngine.Collider2D>;
            public static OverlapPointAll($point: UnityEngine.Vector2, $layerMask: number):System.Array$1<UnityEngine.Collider2D>;
            public static OverlapPointAll($point: UnityEngine.Vector2, $layerMask: number, $minDepth: number):System.Array$1<UnityEngine.Collider2D>;
            public static OverlapPointAll($point: UnityEngine.Vector2, $layerMask: number, $minDepth: number, $maxDepth: number):System.Array$1<UnityEngine.Collider2D>;
            public static OverlapPointNonAlloc($point: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.Collider2D>):number;
            public static OverlapPointNonAlloc($point: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number):number;
            public static OverlapPointNonAlloc($point: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number, $minDepth: number):number;
            public static OverlapPointNonAlloc($point: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number, $minDepth: number, $maxDepth: number):number;
            public static OverlapCircle($point: UnityEngine.Vector2, $radius: number):UnityEngine.Collider2D;
            public static OverlapCircle($point: UnityEngine.Vector2, $radius: number, $layerMask: number):UnityEngine.Collider2D;
            public static OverlapCircle($point: UnityEngine.Vector2, $radius: number, $layerMask: number, $minDepth: number):UnityEngine.Collider2D;
            public static OverlapCircle($point: UnityEngine.Vector2, $radius: number, $layerMask: number, $minDepth: number, $maxDepth: number):UnityEngine.Collider2D;
            public static OverlapCircle($point: UnityEngine.Vector2, $radius: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>):number;
            public static OverlapCircle($point: UnityEngine.Vector2, $radius: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public static OverlapCircleAll($point: UnityEngine.Vector2, $radius: number):System.Array$1<UnityEngine.Collider2D>;
            public static OverlapCircleAll($point: UnityEngine.Vector2, $radius: number, $layerMask: number):System.Array$1<UnityEngine.Collider2D>;
            public static OverlapCircleAll($point: UnityEngine.Vector2, $radius: number, $layerMask: number, $minDepth: number):System.Array$1<UnityEngine.Collider2D>;
            public static OverlapCircleAll($point: UnityEngine.Vector2, $radius: number, $layerMask: number, $minDepth: number, $maxDepth: number):System.Array$1<UnityEngine.Collider2D>;
            public static OverlapCircleNonAlloc($point: UnityEngine.Vector2, $radius: number, $results: System.Array$1<UnityEngine.Collider2D>):number;
            public static OverlapCircleNonAlloc($point: UnityEngine.Vector2, $radius: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number):number;
            public static OverlapCircleNonAlloc($point: UnityEngine.Vector2, $radius: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number, $minDepth: number):number;
            public static OverlapCircleNonAlloc($point: UnityEngine.Vector2, $radius: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number, $minDepth: number, $maxDepth: number):number;
            public static OverlapBox($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number):UnityEngine.Collider2D;
            public static OverlapBox($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $layerMask: number):UnityEngine.Collider2D;
            public static OverlapBox($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $layerMask: number, $minDepth: number):UnityEngine.Collider2D;
            public static OverlapBox($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $layerMask: number, $minDepth: number, $maxDepth: number):UnityEngine.Collider2D;
            public static OverlapBox($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>):number;
            public static OverlapBox($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public static OverlapBoxAll($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number):System.Array$1<UnityEngine.Collider2D>;
            public static OverlapBoxAll($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $layerMask: number):System.Array$1<UnityEngine.Collider2D>;
            public static OverlapBoxAll($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $layerMask: number, $minDepth: number):System.Array$1<UnityEngine.Collider2D>;
            public static OverlapBoxAll($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $layerMask: number, $minDepth: number, $maxDepth: number):System.Array$1<UnityEngine.Collider2D>;
            public static OverlapBoxNonAlloc($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $results: System.Array$1<UnityEngine.Collider2D>):number;
            public static OverlapBoxNonAlloc($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number):number;
            public static OverlapBoxNonAlloc($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number, $minDepth: number):number;
            public static OverlapBoxNonAlloc($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number, $minDepth: number, $maxDepth: number):number;
            public static OverlapArea($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2):UnityEngine.Collider2D;
            public static OverlapArea($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $layerMask: number):UnityEngine.Collider2D;
            public static OverlapArea($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $layerMask: number, $minDepth: number):UnityEngine.Collider2D;
            public static OverlapArea($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $layerMask: number, $minDepth: number, $maxDepth: number):UnityEngine.Collider2D;
            public static OverlapArea($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>):number;
            public static OverlapArea($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public static OverlapAreaAll($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2):System.Array$1<UnityEngine.Collider2D>;
            public static OverlapAreaAll($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $layerMask: number):System.Array$1<UnityEngine.Collider2D>;
            public static OverlapAreaAll($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $layerMask: number, $minDepth: number):System.Array$1<UnityEngine.Collider2D>;
            public static OverlapAreaAll($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $layerMask: number, $minDepth: number, $maxDepth: number):System.Array$1<UnityEngine.Collider2D>;
            public static OverlapAreaNonAlloc($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.Collider2D>):number;
            public static OverlapAreaNonAlloc($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number):number;
            public static OverlapAreaNonAlloc($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number, $minDepth: number):number;
            public static OverlapAreaNonAlloc($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number, $minDepth: number, $maxDepth: number):number;
            public static OverlapCapsule($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number):UnityEngine.Collider2D;
            public static OverlapCapsule($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $layerMask: number):UnityEngine.Collider2D;
            public static OverlapCapsule($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $layerMask: number, $minDepth: number):UnityEngine.Collider2D;
            public static OverlapCapsule($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $layerMask: number, $minDepth: number, $maxDepth: number):UnityEngine.Collider2D;
            public static OverlapCapsule($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>):number;
            public static OverlapCapsule($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public static OverlapCapsuleAll($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number):System.Array$1<UnityEngine.Collider2D>;
            public static OverlapCapsuleAll($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $layerMask: number):System.Array$1<UnityEngine.Collider2D>;
            public static OverlapCapsuleAll($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $layerMask: number, $minDepth: number):System.Array$1<UnityEngine.Collider2D>;
            public static OverlapCapsuleAll($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $layerMask: number, $minDepth: number, $maxDepth: number):System.Array$1<UnityEngine.Collider2D>;
            public static OverlapCapsuleNonAlloc($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $results: System.Array$1<UnityEngine.Collider2D>):number;
            public static OverlapCapsuleNonAlloc($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number):number;
            public static OverlapCapsuleNonAlloc($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number, $minDepth: number):number;
            public static OverlapCapsuleNonAlloc($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number, $minDepth: number, $maxDepth: number):number;
            public static OverlapCollider($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>):number;
            public static OverlapCollider($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public static GetContacts($collider1: UnityEngine.Collider2D, $collider2: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D, $contacts: System.Array$1<UnityEngine.ContactPoint2D>):number;
            public static GetContacts($collider: UnityEngine.Collider2D, $contacts: System.Array$1<UnityEngine.ContactPoint2D>):number;
            public static GetContacts($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D, $contacts: System.Array$1<UnityEngine.ContactPoint2D>):number;
            public static GetContacts($collider: UnityEngine.Collider2D, $colliders: System.Array$1<UnityEngine.Collider2D>):number;
            public static GetContacts($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D, $colliders: System.Array$1<UnityEngine.Collider2D>):number;
            public static GetContacts($rigidbody: UnityEngine.Rigidbody2D, $contacts: System.Array$1<UnityEngine.ContactPoint2D>):number;
            public static GetContacts($rigidbody: UnityEngine.Rigidbody2D, $contactFilter: UnityEngine.ContactFilter2D, $contacts: System.Array$1<UnityEngine.ContactPoint2D>):number;
            public static GetContacts($rigidbody: UnityEngine.Rigidbody2D, $colliders: System.Array$1<UnityEngine.Collider2D>):number;
            public static GetContacts($rigidbody: UnityEngine.Rigidbody2D, $contactFilter: UnityEngine.ContactFilter2D, $colliders: System.Array$1<UnityEngine.Collider2D>):number;
            public static GetContacts($collider1: UnityEngine.Collider2D, $collider2: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D, $contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint2D>):number;
            public static GetContacts($collider: UnityEngine.Collider2D, $contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint2D>):number;
            public static GetContacts($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D, $contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint2D>):number;
            public static GetContacts($collider: UnityEngine.Collider2D, $colliders: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public static GetContacts($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D, $colliders: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public static GetContacts($rigidbody: UnityEngine.Rigidbody2D, $contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint2D>):number;
            public static GetContacts($rigidbody: UnityEngine.Rigidbody2D, $contactFilter: UnityEngine.ContactFilter2D, $contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint2D>):number;
            public static GetContacts($rigidbody: UnityEngine.Rigidbody2D, $colliders: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public static GetContacts($rigidbody: UnityEngine.Rigidbody2D, $contactFilter: UnityEngine.ContactFilter2D, $colliders: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public constructor();
        }
        export enum SimulationMode2D{ FixedUpdate = 0, Update = 1, Script = 2 }
        export class PhysicsJobOptions2D extends System.ValueType{ 
            public get useMultithreading(): boolean;
            public set useMultithreading(value: boolean);
            public get useConsistencySorting(): boolean;
            public set useConsistencySorting(value: boolean);
            public get interpolationPosesPerJob(): number;
            public set interpolationPosesPerJob(value: number);
            public get newContactsPerJob(): number;
            public set newContactsPerJob(value: number);
            public get collideContactsPerJob(): number;
            public set collideContactsPerJob(value: number);
            public get clearFlagsPerJob(): number;
            public set clearFlagsPerJob(value: number);
            public get clearBodyForcesPerJob(): number;
            public set clearBodyForcesPerJob(value: number);
            public get syncDiscreteFixturesPerJob(): number;
            public set syncDiscreteFixturesPerJob(value: number);
            public get syncContinuousFixturesPerJob(): number;
            public set syncContinuousFixturesPerJob(value: number);
            public get findNearestContactsPerJob(): number;
            public set findNearestContactsPerJob(value: number);
            public get updateTriggerContactsPerJob(): number;
            public set updateTriggerContactsPerJob(value: number);
            public get islandSolverCostThreshold(): number;
            public set islandSolverCostThreshold(value: number);
            public get islandSolverBodyCostScale(): number;
            public set islandSolverBodyCostScale(value: number);
            public get islandSolverContactCostScale(): number;
            public set islandSolverContactCostScale(value: number);
            public get islandSolverJointCostScale(): number;
            public set islandSolverJointCostScale(value: number);
            public get islandSolverBodiesPerJob(): number;
            public set islandSolverBodiesPerJob(value: number);
            public get islandSolverContactsPerJob(): number;
            public set islandSolverContactsPerJob(value: number);
        }
        export class ColliderDistance2D extends System.ValueType{ 
            public get pointA(): UnityEngine.Vector2;
            public set pointA(value: UnityEngine.Vector2);
            public get pointB(): UnityEngine.Vector2;
            public set pointB(value: UnityEngine.Vector2);
            public get normal(): UnityEngine.Vector2;
            public get distance(): number;
            public set distance(value: number);
            public get isOverlapped(): boolean;
            public get isValid(): boolean;
            public set isValid(value: boolean);
        }
        export class Rigidbody2D extends UnityEngine.Component{ 
            public get position(): UnityEngine.Vector2;
            public set position(value: UnityEngine.Vector2);
            public get rotation(): number;
            public set rotation(value: number);
            public get velocity(): UnityEngine.Vector2;
            public set velocity(value: UnityEngine.Vector2);
            public get angularVelocity(): number;
            public set angularVelocity(value: number);
            public get useAutoMass(): boolean;
            public set useAutoMass(value: boolean);
            public get mass(): number;
            public set mass(value: number);
            public get sharedMaterial(): UnityEngine.PhysicsMaterial2D;
            public set sharedMaterial(value: UnityEngine.PhysicsMaterial2D);
            public get centerOfMass(): UnityEngine.Vector2;
            public set centerOfMass(value: UnityEngine.Vector2);
            public get worldCenterOfMass(): UnityEngine.Vector2;
            public get inertia(): number;
            public set inertia(value: number);
            public get drag(): number;
            public set drag(value: number);
            public get angularDrag(): number;
            public set angularDrag(value: number);
            public get gravityScale(): number;
            public set gravityScale(value: number);
            public get bodyType(): UnityEngine.RigidbodyType2D;
            public set bodyType(value: UnityEngine.RigidbodyType2D);
            public get useFullKinematicContacts(): boolean;
            public set useFullKinematicContacts(value: boolean);
            public get isKinematic(): boolean;
            public set isKinematic(value: boolean);
            public get freezeRotation(): boolean;
            public set freezeRotation(value: boolean);
            public get constraints(): UnityEngine.RigidbodyConstraints2D;
            public set constraints(value: UnityEngine.RigidbodyConstraints2D);
            public get simulated(): boolean;
            public set simulated(value: boolean);
            public get interpolation(): UnityEngine.RigidbodyInterpolation2D;
            public set interpolation(value: UnityEngine.RigidbodyInterpolation2D);
            public get sleepMode(): UnityEngine.RigidbodySleepMode2D;
            public set sleepMode(value: UnityEngine.RigidbodySleepMode2D);
            public get collisionDetectionMode(): UnityEngine.CollisionDetectionMode2D;
            public set collisionDetectionMode(value: UnityEngine.CollisionDetectionMode2D);
            public get attachedColliderCount(): number;
            public SetRotation($angle: number):void;
            public SetRotation($rotation: UnityEngine.Quaternion):void;
            public MovePosition($position: UnityEngine.Vector2):void;
            public MoveRotation($angle: number):void;
            public MoveRotation($rotation: UnityEngine.Quaternion):void;
            public IsSleeping():boolean;
            public IsAwake():boolean;
            public Sleep():void;
            public WakeUp():void;
            public IsTouching($collider: UnityEngine.Collider2D):boolean;
            public IsTouching($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D):boolean;
            public IsTouching($contactFilter: UnityEngine.ContactFilter2D):boolean;
            public IsTouchingLayers():boolean;
            public IsTouchingLayers($layerMask: number):boolean;
            public OverlapPoint($point: UnityEngine.Vector2):boolean;
            public Distance($collider: UnityEngine.Collider2D):UnityEngine.ColliderDistance2D;
            public ClosestPoint($position: UnityEngine.Vector2):UnityEngine.Vector2;
            public AddForce($force: UnityEngine.Vector2):void;
            public AddForce($force: UnityEngine.Vector2, $mode: UnityEngine.ForceMode2D):void;
            public AddRelativeForce($relativeForce: UnityEngine.Vector2):void;
            public AddRelativeForce($relativeForce: UnityEngine.Vector2, $mode: UnityEngine.ForceMode2D):void;
            public AddForceAtPosition($force: UnityEngine.Vector2, $position: UnityEngine.Vector2):void;
            public AddForceAtPosition($force: UnityEngine.Vector2, $position: UnityEngine.Vector2, $mode: UnityEngine.ForceMode2D):void;
            public AddTorque($torque: number):void;
            public AddTorque($torque: number, $mode: UnityEngine.ForceMode2D):void;
            public GetPoint($point: UnityEngine.Vector2):UnityEngine.Vector2;
            public GetRelativePoint($relativePoint: UnityEngine.Vector2):UnityEngine.Vector2;
            public GetVector($vector: UnityEngine.Vector2):UnityEngine.Vector2;
            public GetRelativeVector($relativeVector: UnityEngine.Vector2):UnityEngine.Vector2;
            public GetPointVelocity($point: UnityEngine.Vector2):UnityEngine.Vector2;
            public GetRelativePointVelocity($relativePoint: UnityEngine.Vector2):UnityEngine.Vector2;
            public OverlapCollider($contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>):number;
            public OverlapCollider($contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public GetContacts($contacts: System.Array$1<UnityEngine.ContactPoint2D>):number;
            public GetContacts($contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint2D>):number;
            public GetContacts($contactFilter: UnityEngine.ContactFilter2D, $contacts: System.Array$1<UnityEngine.ContactPoint2D>):number;
            public GetContacts($contactFilter: UnityEngine.ContactFilter2D, $contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint2D>):number;
            public GetContacts($colliders: System.Array$1<UnityEngine.Collider2D>):number;
            public GetContacts($colliders: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public GetContacts($contactFilter: UnityEngine.ContactFilter2D, $colliders: System.Array$1<UnityEngine.Collider2D>):number;
            public GetContacts($contactFilter: UnityEngine.ContactFilter2D, $colliders: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public GetAttachedColliders($results: System.Array$1<UnityEngine.Collider2D>):number;
            public GetAttachedColliders($results: System.Collections.Generic.List$1<UnityEngine.Collider2D>):number;
            public Cast($direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public Cast($direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number):number;
            public Cast($direction: UnityEngine.Vector2, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>, $distance?: number):number;
            public Cast($direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>):number;
            public Cast($direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number):number;
            public Cast($direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>, $distance: number):number;
            public constructor();
        }
        interface Rigidbody2D {
            DOMove($endValue: UnityEngine.Vector2, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            DOMoveX($endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            DOMoveY($endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            DORotate($endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<number, number, DG.Tweening.Plugins.Options.FloatOptions>;
            DOJump($endValue: UnityEngine.Vector2, $jumpPower: number, $numJumps: number, $duration: number, $snapping?: boolean):DG.Tweening.Sequence;
            DOPath($path: System.Array$1<UnityEngine.Vector2>, $duration: number, $pathType?: DG.Tweening.PathType, $pathMode?: DG.Tweening.PathMode, $resolution?: number, $gizmoColor?: System.Nullable$1<UnityEngine.Color>):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions>;
            DOLocalPath($path: System.Array$1<UnityEngine.Vector2>, $duration: number, $pathType?: DG.Tweening.PathType, $pathMode?: DG.Tweening.PathMode, $resolution?: number, $gizmoColor?: System.Nullable$1<UnityEngine.Color>):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions>;
        }
        export class ContactPoint2D extends System.ValueType{ 
            public get point(): UnityEngine.Vector2;
            public get normal(): UnityEngine.Vector2;
            public get separation(): number;
            public get normalImpulse(): number;
            public get tangentImpulse(): number;
            public get relativeVelocity(): UnityEngine.Vector2;
            public get collider(): UnityEngine.Collider2D;
            public get otherCollider(): UnityEngine.Collider2D;
            public get rigidbody(): UnityEngine.Rigidbody2D;
            public get otherRigidbody(): UnityEngine.Rigidbody2D;
            public get enabled(): boolean;
        }
        export enum RigidbodyConstraints2D{ None = 0, FreezePositionX = 1, FreezePositionY = 2, FreezeRotation = 4, FreezePosition = 3, FreezeAll = 7 }
        export enum RigidbodyInterpolation2D{ None = 0, Interpolate = 1, Extrapolate = 2 }
        export enum RigidbodySleepMode2D{ NeverSleep = 0, StartAwake = 1, StartAsleep = 2 }
        export enum CollisionDetectionMode2D{ None = 0, Discrete = 0, Continuous = 1 }
        export enum RigidbodyType2D{ Dynamic = 0, Kinematic = 1, Static = 2 }
        export enum ForceMode2D{ Force = 0, Impulse = 1 }
        export enum JointLimitState2D{ Inactive = 0, LowerLimit = 1, UpperLimit = 2, EqualLimits = 3 }
        export enum EffectorSelection2D{ Rigidbody = 0, Collider = 1 }
        export enum EffectorForceMode2D{ Constant = 0, InverseLinear = 1, InverseSquared = 2 }
        export class Collision2D extends System.Object{ 
            public get collider(): UnityEngine.Collider2D;
            public get otherCollider(): UnityEngine.Collider2D;
            public get rigidbody(): UnityEngine.Rigidbody2D;
            public get otherRigidbody(): UnityEngine.Rigidbody2D;
            public get transform(): UnityEngine.Transform;
            public get gameObject(): UnityEngine.GameObject;
            public get relativeVelocity(): UnityEngine.Vector2;
            public get enabled(): boolean;
            public get contacts(): System.Array$1<UnityEngine.ContactPoint2D>;
            public get contactCount(): number;
            public GetContact($index: number):UnityEngine.ContactPoint2D;
            public GetContacts($contacts: System.Array$1<UnityEngine.ContactPoint2D>):number;
            public GetContacts($contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint2D>):number;
            public constructor();
        }
        export class JointAngleLimits2D extends System.ValueType{ 
            public get min(): number;
            public set min(value: number);
            public get max(): number;
            public set max(value: number);
        }
        export class JointTranslationLimits2D extends System.ValueType{ 
            public get min(): number;
            public set min(value: number);
            public get max(): number;
            public set max(value: number);
        }
        export class JointMotor2D extends System.ValueType{ 
            public get motorSpeed(): number;
            public set motorSpeed(value: number);
            public get maxMotorTorque(): number;
            public set maxMotorTorque(value: number);
        }
        export class JointSuspension2D extends System.ValueType{ 
            public get dampingRatio(): number;
            public set dampingRatio(value: number);
            public get frequency(): number;
            public set frequency(value: number);
            public get angle(): number;
            public set angle(value: number);
        }
        export class PhysicsMaterial2D extends UnityEngine.Object{ 
            public get bounciness(): number;
            public set bounciness(value: number);
            public get friction(): number;
            public set friction(value: number);
            public constructor();
            public constructor($name: string);
        }
        export class CompositeCollider2D extends UnityEngine.Collider2D{ 
            public get geometryType(): UnityEngine.CompositeCollider2D.GeometryType;
            public set geometryType(value: UnityEngine.CompositeCollider2D.GeometryType);
            public get generationType(): UnityEngine.CompositeCollider2D.GenerationType;
            public set generationType(value: UnityEngine.CompositeCollider2D.GenerationType);
            public get vertexDistance(): number;
            public set vertexDistance(value: number);
            public get edgeRadius(): number;
            public set edgeRadius(value: number);
            public get offsetDistance(): number;
            public set offsetDistance(value: number);
            public get pathCount(): number;
            public get pointCount(): number;
            public GenerateGeometry():void;
            public GetPathPointCount($index: number):number;
            public GetPath($index: number, $points: System.Array$1<UnityEngine.Vector2>):number;
            public GetPath($index: number, $points: System.Collections.Generic.List$1<UnityEngine.Vector2>):number;
            public constructor();
            public GetPath():null;
        }
        export class CircleCollider2D extends UnityEngine.Collider2D{ 
            public get radius(): number;
            public set radius(value: number);
            public constructor();
        }
        export class CapsuleCollider2D extends UnityEngine.Collider2D{ 
            public get size(): UnityEngine.Vector2;
            public set size(value: UnityEngine.Vector2);
            public get direction(): UnityEngine.CapsuleDirection2D;
            public set direction(value: UnityEngine.CapsuleDirection2D);
            public constructor();
        }
        export class EdgeCollider2D extends UnityEngine.Collider2D{ 
            public get edgeRadius(): number;
            public set edgeRadius(value: number);
            public get edgeCount(): number;
            public get pointCount(): number;
            public get points(): System.Array$1<UnityEngine.Vector2>;
            public set points(value: System.Array$1<UnityEngine.Vector2>);
            public get useAdjacentStartPoint(): boolean;
            public set useAdjacentStartPoint(value: boolean);
            public get useAdjacentEndPoint(): boolean;
            public set useAdjacentEndPoint(value: boolean);
            public get adjacentStartPoint(): UnityEngine.Vector2;
            public set adjacentStartPoint(value: UnityEngine.Vector2);
            public get adjacentEndPoint(): UnityEngine.Vector2;
            public set adjacentEndPoint(value: UnityEngine.Vector2);
            public Reset():void;
            public GetPoints($points: System.Collections.Generic.List$1<UnityEngine.Vector2>):number;
            public SetPoints($points: System.Collections.Generic.List$1<UnityEngine.Vector2>):boolean;
            public constructor();
        }
        export class BoxCollider2D extends UnityEngine.Collider2D{ 
            public get size(): UnityEngine.Vector2;
            public set size(value: UnityEngine.Vector2);
            public get edgeRadius(): number;
            public set edgeRadius(value: number);
            public get autoTiling(): boolean;
            public set autoTiling(value: boolean);
            public constructor();
        }
        export class PolygonCollider2D extends UnityEngine.Collider2D{ 
            public get autoTiling(): boolean;
            public set autoTiling(value: boolean);
            public get points(): System.Array$1<UnityEngine.Vector2>;
            public set points(value: System.Array$1<UnityEngine.Vector2>);
            public get pathCount(): number;
            public set pathCount(value: number);
            public GetTotalPointCount():number;
            public GetPath($index: number):System.Array$1<UnityEngine.Vector2>;
            public SetPath($index: number, $points: System.Array$1<UnityEngine.Vector2>):void;
            public GetPath($index: number, $points: System.Collections.Generic.List$1<UnityEngine.Vector2>):number;
            public SetPath($index: number, $points: System.Collections.Generic.List$1<UnityEngine.Vector2>):void;
            public CreatePrimitive($sides: number):void;
            public CreatePrimitive($sides: number, $scale: UnityEngine.Vector2):void;
            public CreatePrimitive($sides: number, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2):void;
            public constructor();
            public GetPath():null;
        }
        export class Joint2D extends UnityEngine.Behaviour{ 
            public get attachedRigidbody(): UnityEngine.Rigidbody2D;
            public get connectedBody(): UnityEngine.Rigidbody2D;
            public set connectedBody(value: UnityEngine.Rigidbody2D);
            public get enableCollision(): boolean;
            public set enableCollision(value: boolean);
            public get breakForce(): number;
            public set breakForce(value: number);
            public get breakTorque(): number;
            public set breakTorque(value: number);
            public get reactionForce(): UnityEngine.Vector2;
            public get reactionTorque(): number;
            public GetReactionForce($timeStep: number):UnityEngine.Vector2;
            public GetReactionTorque($timeStep: number):number;
            public constructor();
        }
        export class AnchoredJoint2D extends UnityEngine.Joint2D{ 
            public get anchor(): UnityEngine.Vector2;
            public set anchor(value: UnityEngine.Vector2);
            public get connectedAnchor(): UnityEngine.Vector2;
            public set connectedAnchor(value: UnityEngine.Vector2);
            public get autoConfigureConnectedAnchor(): boolean;
            public set autoConfigureConnectedAnchor(value: boolean);
            public constructor();
        }
        export class SpringJoint2D extends UnityEngine.AnchoredJoint2D{ 
            public get autoConfigureDistance(): boolean;
            public set autoConfigureDistance(value: boolean);
            public get distance(): number;
            public set distance(value: number);
            public get dampingRatio(): number;
            public set dampingRatio(value: number);
            public get frequency(): number;
            public set frequency(value: number);
            public constructor();
        }
        export class DistanceJoint2D extends UnityEngine.AnchoredJoint2D{ 
            public get autoConfigureDistance(): boolean;
            public set autoConfigureDistance(value: boolean);
            public get distance(): number;
            public set distance(value: number);
            public get maxDistanceOnly(): boolean;
            public set maxDistanceOnly(value: boolean);
            public constructor();
        }
        export class FrictionJoint2D extends UnityEngine.AnchoredJoint2D{ 
            public get maxForce(): number;
            public set maxForce(value: number);
            public get maxTorque(): number;
            public set maxTorque(value: number);
            public constructor();
        }
        export class HingeJoint2D extends UnityEngine.AnchoredJoint2D{ 
            public get useMotor(): boolean;
            public set useMotor(value: boolean);
            public get useLimits(): boolean;
            public set useLimits(value: boolean);
            public get motor(): UnityEngine.JointMotor2D;
            public set motor(value: UnityEngine.JointMotor2D);
            public get limits(): UnityEngine.JointAngleLimits2D;
            public set limits(value: UnityEngine.JointAngleLimits2D);
            public get limitState(): UnityEngine.JointLimitState2D;
            public get referenceAngle(): number;
            public get jointAngle(): number;
            public get jointSpeed(): number;
            public GetMotorTorque($timeStep: number):number;
            public constructor();
        }
        export class RelativeJoint2D extends UnityEngine.Joint2D{ 
            public get maxForce(): number;
            public set maxForce(value: number);
            public get maxTorque(): number;
            public set maxTorque(value: number);
            public get correctionScale(): number;
            public set correctionScale(value: number);
            public get autoConfigureOffset(): boolean;
            public set autoConfigureOffset(value: boolean);
            public get linearOffset(): UnityEngine.Vector2;
            public set linearOffset(value: UnityEngine.Vector2);
            public get angularOffset(): number;
            public set angularOffset(value: number);
            public get target(): UnityEngine.Vector2;
            public constructor();
        }
        export class SliderJoint2D extends UnityEngine.AnchoredJoint2D{ 
            public get autoConfigureAngle(): boolean;
            public set autoConfigureAngle(value: boolean);
            public get angle(): number;
            public set angle(value: number);
            public get useMotor(): boolean;
            public set useMotor(value: boolean);
            public get useLimits(): boolean;
            public set useLimits(value: boolean);
            public get motor(): UnityEngine.JointMotor2D;
            public set motor(value: UnityEngine.JointMotor2D);
            public get limits(): UnityEngine.JointTranslationLimits2D;
            public set limits(value: UnityEngine.JointTranslationLimits2D);
            public get limitState(): UnityEngine.JointLimitState2D;
            public get referenceAngle(): number;
            public get jointTranslation(): number;
            public get jointSpeed(): number;
            public GetMotorForce($timeStep: number):number;
            public constructor();
        }
        export class TargetJoint2D extends UnityEngine.Joint2D{ 
            public get anchor(): UnityEngine.Vector2;
            public set anchor(value: UnityEngine.Vector2);
            public get target(): UnityEngine.Vector2;
            public set target(value: UnityEngine.Vector2);
            public get autoConfigureTarget(): boolean;
            public set autoConfigureTarget(value: boolean);
            public get maxForce(): number;
            public set maxForce(value: number);
            public get dampingRatio(): number;
            public set dampingRatio(value: number);
            public get frequency(): number;
            public set frequency(value: number);
            public constructor();
        }
        export class FixedJoint2D extends UnityEngine.AnchoredJoint2D{ 
            public get dampingRatio(): number;
            public set dampingRatio(value: number);
            public get frequency(): number;
            public set frequency(value: number);
            public get referenceAngle(): number;
            public constructor();
        }
        export class WheelJoint2D extends UnityEngine.AnchoredJoint2D{ 
            public get suspension(): UnityEngine.JointSuspension2D;
            public set suspension(value: UnityEngine.JointSuspension2D);
            public get useMotor(): boolean;
            public set useMotor(value: boolean);
            public get motor(): UnityEngine.JointMotor2D;
            public set motor(value: UnityEngine.JointMotor2D);
            public get jointTranslation(): number;
            public get jointLinearSpeed(): number;
            public get jointSpeed(): number;
            public get jointAngle(): number;
            public GetMotorTorque($timeStep: number):number;
            public constructor();
        }
        export class Effector2D extends UnityEngine.Behaviour{ 
            public get useColliderMask(): boolean;
            public set useColliderMask(value: boolean);
            public get colliderMask(): number;
            public set colliderMask(value: number);
            public constructor();
        }
        export class AreaEffector2D extends UnityEngine.Effector2D{ 
            public get forceAngle(): number;
            public set forceAngle(value: number);
            public get useGlobalAngle(): boolean;
            public set useGlobalAngle(value: boolean);
            public get forceMagnitude(): number;
            public set forceMagnitude(value: number);
            public get forceVariation(): number;
            public set forceVariation(value: number);
            public get drag(): number;
            public set drag(value: number);
            public get angularDrag(): number;
            public set angularDrag(value: number);
            public get forceTarget(): UnityEngine.EffectorSelection2D;
            public set forceTarget(value: UnityEngine.EffectorSelection2D);
            public constructor();
        }
        export class BuoyancyEffector2D extends UnityEngine.Effector2D{ 
            public get surfaceLevel(): number;
            public set surfaceLevel(value: number);
            public get density(): number;
            public set density(value: number);
            public get linearDrag(): number;
            public set linearDrag(value: number);
            public get angularDrag(): number;
            public set angularDrag(value: number);
            public get flowAngle(): number;
            public set flowAngle(value: number);
            public get flowMagnitude(): number;
            public set flowMagnitude(value: number);
            public get flowVariation(): number;
            public set flowVariation(value: number);
            public constructor();
        }
        export class PointEffector2D extends UnityEngine.Effector2D{ 
            public get forceMagnitude(): number;
            public set forceMagnitude(value: number);
            public get forceVariation(): number;
            public set forceVariation(value: number);
            public get distanceScale(): number;
            public set distanceScale(value: number);
            public get drag(): number;
            public set drag(value: number);
            public get angularDrag(): number;
            public set angularDrag(value: number);
            public get forceSource(): UnityEngine.EffectorSelection2D;
            public set forceSource(value: UnityEngine.EffectorSelection2D);
            public get forceTarget(): UnityEngine.EffectorSelection2D;
            public set forceTarget(value: UnityEngine.EffectorSelection2D);
            public get forceMode(): UnityEngine.EffectorForceMode2D;
            public set forceMode(value: UnityEngine.EffectorForceMode2D);
            public constructor();
        }
        export class PlatformEffector2D extends UnityEngine.Effector2D{ 
            public get useOneWay(): boolean;
            public set useOneWay(value: boolean);
            public get useOneWayGrouping(): boolean;
            public set useOneWayGrouping(value: boolean);
            public get useSideFriction(): boolean;
            public set useSideFriction(value: boolean);
            public get useSideBounce(): boolean;
            public set useSideBounce(value: boolean);
            public get surfaceArc(): number;
            public set surfaceArc(value: number);
            public get sideArc(): number;
            public set sideArc(value: number);
            public get rotationalOffset(): number;
            public set rotationalOffset(value: number);
            public constructor();
        }
        export class SurfaceEffector2D extends UnityEngine.Effector2D{ 
            public get speed(): number;
            public set speed(value: number);
            public get speedVariation(): number;
            public set speedVariation(value: number);
            public get forceScale(): number;
            public set forceScale(value: number);
            public get useContactForce(): boolean;
            public set useContactForce(value: boolean);
            public get useFriction(): boolean;
            public set useFriction(value: boolean);
            public get useBounce(): boolean;
            public set useBounce(value: boolean);
            public constructor();
        }
        export class PhysicsUpdateBehaviour2D extends UnityEngine.Behaviour{ 
            public constructor();
        }
        export class ConstantForce2D extends UnityEngine.PhysicsUpdateBehaviour2D{ 
            public get force(): UnityEngine.Vector2;
            public set force(value: UnityEngine.Vector2);
            public get relativeForce(): UnityEngine.Vector2;
            public set relativeForce(value: UnityEngine.Vector2);
            public get torque(): number;
            public set torque(value: number);
            public constructor();
        }
        export class ScreenCapture extends System.Object{ 
            public static CaptureScreenshot($filename: string):void;
            public static CaptureScreenshot($filename: string, $superSize: number):void;
            public static CaptureScreenshot($filename: string, $stereoCaptureMode: UnityEngine.ScreenCapture.StereoScreenCaptureMode):void;
            public static CaptureScreenshotAsTexture():UnityEngine.Texture2D;
            public static CaptureScreenshotAsTexture($superSize: number):UnityEngine.Texture2D;
            public static CaptureScreenshotAsTexture($stereoCaptureMode: UnityEngine.ScreenCapture.StereoScreenCaptureMode):UnityEngine.Texture2D;
            public static CaptureScreenshotIntoRenderTexture($renderTexture: UnityEngine.RenderTexture):void;
        }
        export class SpriteMask extends UnityEngine.Renderer{ 
            public get frontSortingLayerID(): number;
            public set frontSortingLayerID(value: number);
            public get frontSortingOrder(): number;
            public set frontSortingOrder(value: number);
            public get backSortingLayerID(): number;
            public set backSortingLayerID(value: number);
            public get backSortingOrder(): number;
            public set backSortingOrder(value: number);
            public get alphaCutoff(): number;
            public set alphaCutoff(value: number);
            public get sprite(): UnityEngine.Sprite;
            public set sprite(value: UnityEngine.Sprite);
            public get isCustomRangeActive(): boolean;
            public set isCustomRangeActive(value: boolean);
            public get spriteSortPoint(): UnityEngine.SpriteSortPoint;
            public set spriteSortPoint(value: UnityEngine.SpriteSortPoint);
            public constructor();
        }
        export class StreamingController extends UnityEngine.Behaviour{ 
            public get streamingMipmapBias(): number;
            public set streamingMipmapBias(value: number);
            public SetPreloading($timeoutSeconds?: number, $activateCameraOnTimeout?: boolean, $disableCameraCuttingFrom?: UnityEngine.Camera):void;
            public CancelPreloading():void;
            public IsPreloading():boolean;
            public constructor();
        }
        export enum ProceduralProcessorUsage{ Unsupported = 0, One = 1, Half = 2, All = 3 }
        export enum ProceduralCacheSize{ Tiny = 0, Medium = 1, Heavy = 2, NoLimit = 3, None = 4 }
        export enum ProceduralLoadingBehavior{ DoNothing = 0, Generate = 1, BakeAndKeep = 2, BakeAndDiscard = 3, Cache = 4, DoNothingAndCache = 5 }
        export enum ProceduralPropertyType{ Boolean = 0, Float = 1, Vector2 = 2, Vector3 = 3, Vector4 = 4, Color3 = 5, Color4 = 6, Enum = 7, Texture = 8, String = 9 }
        export enum ProceduralOutputType{ Unknown = 0, Diffuse = 1, Normal = 2, Height = 3, Emissive = 4, Specular = 5, Opacity = 6, Smoothness = 7, AmbientOcclusion = 8, DetailMask = 9, Metallic = 10, Roughness = 11 }
        export class IntegratedSubsystem extends System.Object implements UnityEngine.ISubsystem{ 
            public get running(): boolean;
            public Start():void;
            public Stop():void;
            public Destroy():void;
            public constructor();
        }
        export interface ISubsystem{ 
            running: boolean;
            Start():void;
            Stop():void;
            Destroy():void;
        }
        export class IntegratedSubsystemDescriptor extends System.Object implements UnityEngine.ISubsystemDescriptorImpl, UnityEngine.ISubsystemDescriptor{ 
            public get id(): string;
            public Create():UnityEngine.ISubsystem;
        }
        export interface ISubsystemDescriptorImpl extends UnityEngine.ISubsystemDescriptor{ 
            id: string;
            Create():UnityEngine.ISubsystem;
        }
        export interface ISubsystemDescriptor{ 
            id: string;
            Create():UnityEngine.ISubsystem;
        }
        export class Subsystem extends System.Object implements UnityEngine.ISubsystem{ 
            public get running(): boolean;
            public Start():void;
            public Stop():void;
            public Destroy():void;
        }
        export class SubsystemDescriptor extends System.Object implements UnityEngine.ISubsystemDescriptor{ 
            public get id(): string;
            public set id(value: string);
            public get subsystemImplementationType(): System.Type;
            public set subsystemImplementationType(value: System.Type);
            public Create():UnityEngine.ISubsystem;
        }
        export class SubsystemManager extends System.Object{ 
            public static GetAllSubsystemDescriptors($descriptors: System.Collections.Generic.List$1<UnityEngine.ISubsystemDescriptor>):void;
            public static add_beforeReloadSubsystems($value: System.Action):void;
            public static remove_beforeReloadSubsystems($value: System.Action):void;
            public static add_afterReloadSubsystems($value: System.Action):void;
            public static remove_afterReloadSubsystems($value: System.Action):void;
            public static add_reloadSubsytemsStarted($value: System.Action):void;
            public static remove_reloadSubsytemsStarted($value: System.Action):void;
            public static add_reloadSubsytemsCompleted($value: System.Action):void;
            public static remove_reloadSubsytemsCompleted($value: System.Action):void;
        }
        export enum TerrainChangedFlags{ Heightmap = 1, TreeInstances = 2, DelayedHeightmapUpdate = 4, FlushEverythingImmediately = 8, RemoveDirtyDetailsImmediately = 16, HeightmapResolution = 32, Holes = 64, DelayedHolesUpdate = 128, WillBeDestroyed = 256 }
        export enum TerrainRenderFlags{ heightmap = 1, trees = 2, details = 4, all = 7, Heightmap = 1, Trees = 2, Details = 4, All = 7 }
        export class Terrain extends UnityEngine.Behaviour{ 
            public get terrainData(): UnityEngine.TerrainData;
            public set terrainData(value: UnityEngine.TerrainData);
            public get treeDistance(): number;
            public set treeDistance(value: number);
            public get treeBillboardDistance(): number;
            public set treeBillboardDistance(value: number);
            public get treeCrossFadeLength(): number;
            public set treeCrossFadeLength(value: number);
            public get treeMaximumFullLODCount(): number;
            public set treeMaximumFullLODCount(value: number);
            public get detailObjectDistance(): number;
            public set detailObjectDistance(value: number);
            public get detailObjectDensity(): number;
            public set detailObjectDensity(value: number);
            public get heightmapPixelError(): number;
            public set heightmapPixelError(value: number);
            public get heightmapMaximumLOD(): number;
            public set heightmapMaximumLOD(value: number);
            public get basemapDistance(): number;
            public set basemapDistance(value: number);
            public get lightmapIndex(): number;
            public set lightmapIndex(value: number);
            public get realtimeLightmapIndex(): number;
            public set realtimeLightmapIndex(value: number);
            public get lightmapScaleOffset(): UnityEngine.Vector4;
            public set lightmapScaleOffset(value: UnityEngine.Vector4);
            public get realtimeLightmapScaleOffset(): UnityEngine.Vector4;
            public set realtimeLightmapScaleOffset(value: UnityEngine.Vector4);
            public get freeUnusedRenderingResources(): boolean;
            public set freeUnusedRenderingResources(value: boolean);
            public get shadowCastingMode(): UnityEngine.Rendering.ShadowCastingMode;
            public set shadowCastingMode(value: UnityEngine.Rendering.ShadowCastingMode);
            public get reflectionProbeUsage(): UnityEngine.Rendering.ReflectionProbeUsage;
            public set reflectionProbeUsage(value: UnityEngine.Rendering.ReflectionProbeUsage);
            public get materialTemplate(): UnityEngine.Material;
            public set materialTemplate(value: UnityEngine.Material);
            public get drawHeightmap(): boolean;
            public set drawHeightmap(value: boolean);
            public get allowAutoConnect(): boolean;
            public set allowAutoConnect(value: boolean);
            public get groupingID(): number;
            public set groupingID(value: number);
            public get drawInstanced(): boolean;
            public set drawInstanced(value: boolean);
            public get normalmapTexture(): UnityEngine.RenderTexture;
            public get drawTreesAndFoliage(): boolean;
            public set drawTreesAndFoliage(value: boolean);
            public get patchBoundsMultiplier(): UnityEngine.Vector3;
            public set patchBoundsMultiplier(value: UnityEngine.Vector3);
            public get treeLODBiasMultiplier(): number;
            public set treeLODBiasMultiplier(value: number);
            public get collectDetailPatches(): boolean;
            public set collectDetailPatches(value: boolean);
            public get editorRenderFlags(): UnityEngine.TerrainRenderFlags;
            public set editorRenderFlags(value: UnityEngine.TerrainRenderFlags);
            public get preserveTreePrototypeLayers(): boolean;
            public set preserveTreePrototypeLayers(value: boolean);
            public static get heightmapFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public static get heightmapTextureFormat(): UnityEngine.TextureFormat;
            public static get heightmapRenderTextureFormat(): UnityEngine.RenderTextureFormat;
            public static get normalmapFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public static get normalmapTextureFormat(): UnityEngine.TextureFormat;
            public static get normalmapRenderTextureFormat(): UnityEngine.RenderTextureFormat;
            public static get holesFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public static get holesRenderTextureFormat(): UnityEngine.RenderTextureFormat;
            public static get compressedHolesFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public static get compressedHolesTextureFormat(): UnityEngine.TextureFormat;
            public static get activeTerrain(): UnityEngine.Terrain;
            public static get activeTerrains(): System.Array$1<UnityEngine.Terrain>;
            public get leftNeighbor(): UnityEngine.Terrain;
            public get rightNeighbor(): UnityEngine.Terrain;
            public get topNeighbor(): UnityEngine.Terrain;
            public get bottomNeighbor(): UnityEngine.Terrain;
            public get renderingLayerMask(): number;
            public set renderingLayerMask(value: number);
            public GetClosestReflectionProbes($result: System.Collections.Generic.List$1<UnityEngine.Rendering.ReflectionProbeBlendInfo>):void;
            public SampleHeight($worldPosition: UnityEngine.Vector3):number;
            public AddTreeInstance($instance: UnityEngine.TreeInstance):void;
            public SetNeighbors($left: UnityEngine.Terrain, $top: UnityEngine.Terrain, $right: UnityEngine.Terrain, $bottom: UnityEngine.Terrain):void;
            public GetPosition():UnityEngine.Vector3;
            public Flush():void;
            public SetSplatMaterialPropertyBlock($properties: UnityEngine.MaterialPropertyBlock):void;
            public GetSplatMaterialPropertyBlock($dest: UnityEngine.MaterialPropertyBlock):void;
            public static SetConnectivityDirty():void;
            public static CreateTerrainGameObject($assignTerrain: UnityEngine.TerrainData):UnityEngine.GameObject;
            public constructor();
        }
        interface Terrain {
            UpdateGIMaterials():void;
            UpdateGIMaterials($x: number, $y: number, $width: number, $height: number):void;
        }
        export class TerrainData extends UnityEngine.Object{ 
        }
        export class TreeInstance extends System.ValueType{ 
            public position: UnityEngine.Vector3;
            public widthScale: number;
            public heightScale: number;
            public rotation: number;
            public color: UnityEngine.Color32;
            public lightmapColor: UnityEngine.Color32;
            public prototypeIndex: number;
        }
        export class TerrainExtensions extends System.Object{ 
            public static UpdateGIMaterials($terrain: UnityEngine.Terrain):void;
            public static UpdateGIMaterials($terrain: UnityEngine.Terrain, $x: number, $y: number, $width: number, $height: number):void;
        }
        export class Tree extends UnityEngine.Component{ 
            public get data(): UnityEngine.ScriptableObject;
            public set data(value: UnityEngine.ScriptableObject);
            public get hasSpeedTreeWind(): boolean;
            public constructor();
        }
        export class TreePrototype extends System.Object{ 
            public get prefab(): UnityEngine.GameObject;
            public set prefab(value: UnityEngine.GameObject);
            public get bendFactor(): number;
            public set bendFactor(value: number);
            public get navMeshLod(): number;
            public set navMeshLod(value: number);
            public constructor();
            public constructor($other: UnityEngine.TreePrototype);
        }
        export enum DetailRenderMode{ GrassBillboard = 0, VertexLit = 1, Grass = 2 }
        export class DetailPrototype extends System.Object{ 
            public get prototype(): UnityEngine.GameObject;
            public set prototype(value: UnityEngine.GameObject);
            public get prototypeTexture(): UnityEngine.Texture2D;
            public set prototypeTexture(value: UnityEngine.Texture2D);
            public get minWidth(): number;
            public set minWidth(value: number);
            public get maxWidth(): number;
            public set maxWidth(value: number);
            public get minHeight(): number;
            public set minHeight(value: number);
            public get maxHeight(): number;
            public set maxHeight(value: number);
            public get noiseSpread(): number;
            public set noiseSpread(value: number);
            public get holeEdgePadding(): number;
            public set holeEdgePadding(value: number);
            public get healthyColor(): UnityEngine.Color;
            public set healthyColor(value: UnityEngine.Color);
            public get dryColor(): UnityEngine.Color;
            public set dryColor(value: UnityEngine.Color);
            public get renderMode(): UnityEngine.DetailRenderMode;
            public set renderMode(value: UnityEngine.DetailRenderMode);
            public get usePrototypeMesh(): boolean;
            public set usePrototypeMesh(value: boolean);
            public Validate():boolean;
            public Validate($errorMessage: $Ref<string>):boolean;
            public constructor();
            public constructor($other: UnityEngine.DetailPrototype);
        }
        export class SplatPrototype extends System.Object{ 
            public get texture(): UnityEngine.Texture2D;
            public set texture(value: UnityEngine.Texture2D);
            public get normalMap(): UnityEngine.Texture2D;
            public set normalMap(value: UnityEngine.Texture2D);
            public get tileSize(): UnityEngine.Vector2;
            public set tileSize(value: UnityEngine.Vector2);
            public get tileOffset(): UnityEngine.Vector2;
            public set tileOffset(value: UnityEngine.Vector2);
            public get specular(): UnityEngine.Color;
            public set specular(value: UnityEngine.Color);
            public get metallic(): number;
            public set metallic(value: number);
            public get smoothness(): number;
            public set smoothness(value: number);
            public constructor();
        }
        export class PatchExtents extends System.ValueType{ 
            public get min(): number;
            public set min(value: number);
            public get max(): number;
            public set max(value: number);
        }
        export enum TerrainHeightmapSyncControl{ None = 0, HeightOnly = 1, HeightAndLod = 2 }
        export class TerrainLayer extends UnityEngine.Object{ 
            public get diffuseTexture(): UnityEngine.Texture2D;
            public set diffuseTexture(value: UnityEngine.Texture2D);
            public get normalMapTexture(): UnityEngine.Texture2D;
            public set normalMapTexture(value: UnityEngine.Texture2D);
            public get maskMapTexture(): UnityEngine.Texture2D;
            public set maskMapTexture(value: UnityEngine.Texture2D);
            public get tileSize(): UnityEngine.Vector2;
            public set tileSize(value: UnityEngine.Vector2);
            public get tileOffset(): UnityEngine.Vector2;
            public set tileOffset(value: UnityEngine.Vector2);
            public get specular(): UnityEngine.Color;
            public set specular(value: UnityEngine.Color);
            public get metallic(): number;
            public set metallic(value: number);
            public get smoothness(): number;
            public set smoothness(value: number);
            public get normalScale(): number;
            public set normalScale(value: number);
            public get diffuseRemapMin(): UnityEngine.Vector4;
            public set diffuseRemapMin(value: UnityEngine.Vector4);
            public get diffuseRemapMax(): UnityEngine.Vector4;
            public set diffuseRemapMax(value: UnityEngine.Vector4);
            public get maskMapRemapMin(): UnityEngine.Vector4;
            public set maskMapRemapMin(value: UnityEngine.Vector4);
            public get maskMapRemapMax(): UnityEngine.Vector4;
            public set maskMapRemapMax(value: UnityEngine.Vector4);
            public constructor();
        }
        export class TerrainCollider extends UnityEngine.Collider{ 
            public get terrainData(): UnityEngine.TerrainData;
            public set terrainData(value: UnityEngine.TerrainData);
            public constructor();
        }
        export class TextGenerationSettings extends System.ValueType{ 
            public font: UnityEngine.Font;
            public color: UnityEngine.Color;
            public fontSize: number;
            public lineSpacing: number;
            public richText: boolean;
            public scaleFactor: number;
            public fontStyle: UnityEngine.FontStyle;
            public textAnchor: UnityEngine.TextAnchor;
            public alignByGeometry: boolean;
            public resizeTextForBestFit: boolean;
            public resizeTextMinSize: number;
            public resizeTextMaxSize: number;
            public updateBounds: boolean;
            public verticalOverflow: UnityEngine.VerticalWrapMode;
            public horizontalOverflow: UnityEngine.HorizontalWrapMode;
            public generationExtents: UnityEngine.Vector2;
            public pivot: UnityEngine.Vector2;
            public generateOutOfBounds: boolean;
            public Equals($other: UnityEngine.TextGenerationSettings):boolean;
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
        }
        export enum VerticalWrapMode{ Truncate = 0, Overflow = 1 }
        export enum HorizontalWrapMode{ Wrap = 0, Overflow = 1 }
        export class TextGenerator extends System.Object implements System.IDisposable{ 
            public get characterCountVisible(): number;
            public get verts(): System.Collections.Generic.IList$1<UnityEngine.UIVertex>;
            public get characters(): System.Collections.Generic.IList$1<UnityEngine.UICharInfo>;
            public get lines(): System.Collections.Generic.IList$1<UnityEngine.UILineInfo>;
            public get rectExtents(): UnityEngine.Rect;
            public get vertexCount(): number;
            public get characterCount(): number;
            public get lineCount(): number;
            public get fontSizeUsedForBestFit(): number;
            public Invalidate():void;
            public GetCharacters($characters: System.Collections.Generic.List$1<UnityEngine.UICharInfo>):void;
            public GetLines($lines: System.Collections.Generic.List$1<UnityEngine.UILineInfo>):void;
            public GetVertices($vertices: System.Collections.Generic.List$1<UnityEngine.UIVertex>):void;
            public GetPreferredWidth($str: string, $settings: UnityEngine.TextGenerationSettings):number;
            public GetPreferredHeight($str: string, $settings: UnityEngine.TextGenerationSettings):number;
            public PopulateWithErrors($str: string, $settings: UnityEngine.TextGenerationSettings, $context: UnityEngine.GameObject):boolean;
            public Populate($str: string, $settings: UnityEngine.TextGenerationSettings):boolean;
            public GetVerticesArray():System.Array$1<UnityEngine.UIVertex>;
            public GetCharactersArray():System.Array$1<UnityEngine.UICharInfo>;
            public GetLinesArray():System.Array$1<UnityEngine.UILineInfo>;
            public constructor();
            public constructor($initialCapacity: number);
        }
        export class UICharInfo extends System.ValueType{ 
            public cursorPos: UnityEngine.Vector2;
            public charWidth: number;
        }
        export class UILineInfo extends System.ValueType{ 
            public startCharIdx: number;
            public height: number;
            public topY: number;
            public leading: number;
        }
        export class UIVertex extends System.ValueType{ 
            public position: UnityEngine.Vector3;
            public normal: UnityEngine.Vector3;
            public tangent: UnityEngine.Vector4;
            public color: UnityEngine.Color32;
            public uv0: UnityEngine.Vector4;
            public uv1: UnityEngine.Vector4;
            public uv2: UnityEngine.Vector4;
            public uv3: UnityEngine.Vector4;
            public static simpleVert: UnityEngine.UIVertex;
        }
        export enum TextAlignment{ Left = 0, Center = 1, Right = 2 }
        export class TextMesh extends UnityEngine.Component{ 
            public get text(): string;
            public set text(value: string);
            public get font(): UnityEngine.Font;
            public set font(value: UnityEngine.Font);
            public get fontSize(): number;
            public set fontSize(value: number);
            public get fontStyle(): UnityEngine.FontStyle;
            public set fontStyle(value: UnityEngine.FontStyle);
            public get offsetZ(): number;
            public set offsetZ(value: number);
            public get alignment(): UnityEngine.TextAlignment;
            public set alignment(value: UnityEngine.TextAlignment);
            public get anchor(): UnityEngine.TextAnchor;
            public set anchor(value: UnityEngine.TextAnchor);
            public get characterSize(): number;
            public set characterSize(value: number);
            public get lineSpacing(): number;
            public set lineSpacing(value: number);
            public get tabSize(): number;
            public set tabSize(value: number);
            public get richText(): boolean;
            public set richText(value: boolean);
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public constructor();
        }
        export class CharacterInfo extends System.ValueType{ 
            public index: number;
            public size: number;
            public style: UnityEngine.FontStyle;
            public get advance(): number;
            public set advance(value: number);
            public get glyphWidth(): number;
            public set glyphWidth(value: number);
            public get glyphHeight(): number;
            public set glyphHeight(value: number);
            public get bearing(): number;
            public set bearing(value: number);
            public get minY(): number;
            public set minY(value: number);
            public get maxY(): number;
            public set maxY(value: number);
            public get minX(): number;
            public set minX(value: number);
            public get maxX(): number;
            public set maxX(value: number);
            public get uvBottomLeft(): UnityEngine.Vector2;
            public set uvBottomLeft(value: UnityEngine.Vector2);
            public get uvBottomRight(): UnityEngine.Vector2;
            public set uvBottomRight(value: UnityEngine.Vector2);
            public get uvTopRight(): UnityEngine.Vector2;
            public set uvTopRight(value: UnityEngine.Vector2);
            public get uvTopLeft(): UnityEngine.Vector2;
            public set uvTopLeft(value: UnityEngine.Vector2);
        }
        export class CustomGridBrushAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public get hideAssetInstances(): boolean;
            public get hideDefaultInstance(): boolean;
            public get defaultBrush(): boolean;
            public get defaultName(): string;
            public constructor();
            public constructor($hideAssetInstances: boolean, $hideDefaultInstance: boolean, $defaultBrush: boolean, $defaultName: string);
        }
        export class GridBrushBase extends UnityEngine.ScriptableObject{ 
            public Paint($gridLayout: UnityEngine.GridLayout, $brushTarget: UnityEngine.GameObject, $position: UnityEngine.Vector3Int):void;
            public Erase($gridLayout: UnityEngine.GridLayout, $brushTarget: UnityEngine.GameObject, $position: UnityEngine.Vector3Int):void;
            public BoxFill($gridLayout: UnityEngine.GridLayout, $brushTarget: UnityEngine.GameObject, $position: UnityEngine.BoundsInt):void;
            public BoxErase($gridLayout: UnityEngine.GridLayout, $brushTarget: UnityEngine.GameObject, $position: UnityEngine.BoundsInt):void;
            public Select($gridLayout: UnityEngine.GridLayout, $brushTarget: UnityEngine.GameObject, $position: UnityEngine.BoundsInt):void;
            public FloodFill($gridLayout: UnityEngine.GridLayout, $brushTarget: UnityEngine.GameObject, $position: UnityEngine.Vector3Int):void;
            public Rotate($direction: UnityEngine.GridBrushBase.RotationDirection, $layout: UnityEngine.GridLayout.CellLayout):void;
            public Flip($flip: UnityEngine.GridBrushBase.FlipAxis, $layout: UnityEngine.GridLayout.CellLayout):void;
            public Pick($gridLayout: UnityEngine.GridLayout, $brushTarget: UnityEngine.GameObject, $position: UnityEngine.BoundsInt, $pivot: UnityEngine.Vector3Int):void;
            public Move($gridLayout: UnityEngine.GridLayout, $brushTarget: UnityEngine.GameObject, $from: UnityEngine.BoundsInt, $to: UnityEngine.BoundsInt):void;
            public MoveStart($gridLayout: UnityEngine.GridLayout, $brushTarget: UnityEngine.GameObject, $position: UnityEngine.BoundsInt):void;
            public MoveEnd($gridLayout: UnityEngine.GridLayout, $brushTarget: UnityEngine.GameObject, $position: UnityEngine.BoundsInt):void;
            public ChangeZPosition($change: number):void;
            public ResetZPosition():void;
        }
        export class CanvasGroup extends UnityEngine.Behaviour implements UnityEngine.ICanvasRaycastFilter{ 
            public get alpha(): number;
            public set alpha(value: number);
            public get interactable(): boolean;
            public set interactable(value: boolean);
            public get blocksRaycasts(): boolean;
            public set blocksRaycasts(value: boolean);
            public get ignoreParentGroups(): boolean;
            public set ignoreParentGroups(value: boolean);
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public constructor();
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
        }
        interface CanvasGroup {
            DOFade($endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<number, number, DG.Tweening.Plugins.Options.FloatOptions>;
        }
        export class CanvasRenderer extends UnityEngine.Component{ 
            public get hasPopInstruction(): boolean;
            public set hasPopInstruction(value: boolean);
            public get materialCount(): number;
            public set materialCount(value: number);
            public get popMaterialCount(): number;
            public set popMaterialCount(value: number);
            public get absoluteDepth(): number;
            public get hasMoved(): boolean;
            public get cullTransparentMesh(): boolean;
            public set cullTransparentMesh(value: boolean);
            public get hasRectClipping(): boolean;
            public get relativeDepth(): number;
            public get cull(): boolean;
            public set cull(value: boolean);
            public get clippingSoftness(): UnityEngine.Vector2;
            public set clippingSoftness(value: UnityEngine.Vector2);
            public SetColor($color: UnityEngine.Color):void;
            public GetColor():UnityEngine.Color;
            public EnableRectClipping($rect: UnityEngine.Rect):void;
            public DisableRectClipping():void;
            public SetMaterial($material: UnityEngine.Material, $index: number):void;
            public GetMaterial($index: number):UnityEngine.Material;
            public SetPopMaterial($material: UnityEngine.Material, $index: number):void;
            public GetPopMaterial($index: number):UnityEngine.Material;
            public SetTexture($texture: UnityEngine.Texture):void;
            public SetAlphaTexture($texture: UnityEngine.Texture):void;
            public SetMesh($mesh: UnityEngine.Mesh):void;
            public Clear():void;
            public GetAlpha():number;
            public SetAlpha($alpha: number):void;
            public GetInheritedAlpha():number;
            public SetMaterial($material: UnityEngine.Material, $texture: UnityEngine.Texture):void;
            public GetMaterial():UnityEngine.Material;
            public static SplitUIVertexStreams($verts: System.Collections.Generic.List$1<UnityEngine.UIVertex>, $positions: System.Collections.Generic.List$1<UnityEngine.Vector3>, $colors: System.Collections.Generic.List$1<UnityEngine.Color32>, $uv0S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv1S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $normals: System.Collections.Generic.List$1<UnityEngine.Vector3>, $tangents: System.Collections.Generic.List$1<UnityEngine.Vector4>, $indices: System.Collections.Generic.List$1<number>):void;
            public static SplitUIVertexStreams($verts: System.Collections.Generic.List$1<UnityEngine.UIVertex>, $positions: System.Collections.Generic.List$1<UnityEngine.Vector3>, $colors: System.Collections.Generic.List$1<UnityEngine.Color32>, $uv0S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv1S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv2S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv3S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $normals: System.Collections.Generic.List$1<UnityEngine.Vector3>, $tangents: System.Collections.Generic.List$1<UnityEngine.Vector4>, $indices: System.Collections.Generic.List$1<number>):void;
            public static CreateUIVertexStream($verts: System.Collections.Generic.List$1<UnityEngine.UIVertex>, $positions: System.Collections.Generic.List$1<UnityEngine.Vector3>, $colors: System.Collections.Generic.List$1<UnityEngine.Color32>, $uv0S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv1S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $normals: System.Collections.Generic.List$1<UnityEngine.Vector3>, $tangents: System.Collections.Generic.List$1<UnityEngine.Vector4>, $indices: System.Collections.Generic.List$1<number>):void;
            public static CreateUIVertexStream($verts: System.Collections.Generic.List$1<UnityEngine.UIVertex>, $positions: System.Collections.Generic.List$1<UnityEngine.Vector3>, $colors: System.Collections.Generic.List$1<UnityEngine.Color32>, $uv0S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv1S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv2S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv3S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $normals: System.Collections.Generic.List$1<UnityEngine.Vector3>, $tangents: System.Collections.Generic.List$1<UnityEngine.Vector4>, $indices: System.Collections.Generic.List$1<number>):void;
            public static AddUIVertexStream($verts: System.Collections.Generic.List$1<UnityEngine.UIVertex>, $positions: System.Collections.Generic.List$1<UnityEngine.Vector3>, $colors: System.Collections.Generic.List$1<UnityEngine.Color32>, $uv0S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv1S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $normals: System.Collections.Generic.List$1<UnityEngine.Vector3>, $tangents: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
            public static AddUIVertexStream($verts: System.Collections.Generic.List$1<UnityEngine.UIVertex>, $positions: System.Collections.Generic.List$1<UnityEngine.Vector3>, $colors: System.Collections.Generic.List$1<UnityEngine.Color32>, $uv0S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv1S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv2S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv3S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $normals: System.Collections.Generic.List$1<UnityEngine.Vector3>, $tangents: System.Collections.Generic.List$1<UnityEngine.Vector4>):void;
            public static add_onRequestRebuild($value: UnityEngine.CanvasRenderer.OnRequestRebuild):void;
            public static remove_onRequestRebuild($value: UnityEngine.CanvasRenderer.OnRequestRebuild):void;
            public constructor();
        }
        export class RectTransformUtility extends System.Object{ 
            public static PixelAdjustPoint($point: UnityEngine.Vector2, $elementTransform: UnityEngine.Transform, $canvas: UnityEngine.Canvas):UnityEngine.Vector2;
            public static PixelAdjustRect($rectTransform: UnityEngine.RectTransform, $canvas: UnityEngine.Canvas):UnityEngine.Rect;
            public static RectangleContainsScreenPoint($rect: UnityEngine.RectTransform, $screenPoint: UnityEngine.Vector2):boolean;
            public static RectangleContainsScreenPoint($rect: UnityEngine.RectTransform, $screenPoint: UnityEngine.Vector2, $cam: UnityEngine.Camera):boolean;
            public static RectangleContainsScreenPoint($rect: UnityEngine.RectTransform, $screenPoint: UnityEngine.Vector2, $cam: UnityEngine.Camera, $offset: UnityEngine.Vector4):boolean;
            public static ScreenPointToWorldPointInRectangle($rect: UnityEngine.RectTransform, $screenPoint: UnityEngine.Vector2, $cam: UnityEngine.Camera, $worldPoint: $Ref<UnityEngine.Vector3>):boolean;
            public static ScreenPointToLocalPointInRectangle($rect: UnityEngine.RectTransform, $screenPoint: UnityEngine.Vector2, $cam: UnityEngine.Camera, $localPoint: $Ref<UnityEngine.Vector2>):boolean;
            public static ScreenPointToRay($cam: UnityEngine.Camera, $screenPos: UnityEngine.Vector2):UnityEngine.Ray;
            public static WorldToScreenPoint($cam: UnityEngine.Camera, $worldPoint: UnityEngine.Vector3):UnityEngine.Vector2;
            public static CalculateRelativeRectTransformBounds($root: UnityEngine.Transform, $child: UnityEngine.Transform):UnityEngine.Bounds;
            public static CalculateRelativeRectTransformBounds($trans: UnityEngine.Transform):UnityEngine.Bounds;
            public static FlipLayoutOnAxis($rect: UnityEngine.RectTransform, $axis: number, $keepPositioning: boolean, $recursive: boolean):void;
            public static FlipLayoutAxes($rect: UnityEngine.RectTransform, $keepPositioning: boolean, $recursive: boolean):void;
        }
        export class UISystemProfilerApi extends System.Object{ 
            public static BeginSample($type: UnityEngine.UISystemProfilerApi.SampleType):void;
            public static EndSample($type: UnityEngine.UISystemProfilerApi.SampleType):void;
            public static AddMarker($name: string, $obj: UnityEngine.Object):void;
        }
        export class RemoteSettings extends System.Object{ 
            public static add_Updated($value: UnityEngine.RemoteSettings.UpdatedEventHandler):void;
            public static remove_Updated($value: UnityEngine.RemoteSettings.UpdatedEventHandler):void;
            public static add_BeforeFetchFromServer($value: System.Action):void;
            public static remove_BeforeFetchFromServer($value: System.Action):void;
            public static add_Completed($value: System.Action$3<boolean, boolean, number>):void;
            public static remove_Completed($value: System.Action$3<boolean, boolean, number>):void;
            public static ForceUpdate():void;
            public static WasLastUpdatedFromServer():boolean;
            public static GetInt($key: string):number;
            public static GetInt($key: string, $defaultValue: number):number;
            public static GetLong($key: string):bigint;
            public static GetLong($key: string, $defaultValue: bigint):bigint;
            public static GetFloat($key: string):number;
            public static GetFloat($key: string, $defaultValue: number):number;
            public static GetString($key: string):string;
            public static GetString($key: string, $defaultValue: string):string;
            public static GetBool($key: string):boolean;
            public static GetBool($key: string, $defaultValue: boolean):boolean;
            public static HasKey($key: string):boolean;
            public static GetCount():number;
            public static GetKeys():System.Array$1<string>;
            public static GetObject($type: System.Type, $key?: string):any;
            public static GetObject($key: string, $defaultValue: any):any;
            public static GetDictionary($key?: string):System.Collections.Generic.IDictionary$2<string, any>;
        }
        export class RemoteConfigSettings extends System.Object implements System.IDisposable{ 
            public add_Updated($value: System.Action$1<boolean>):void;
            public remove_Updated($value: System.Action$1<boolean>):void;
            public Dispose():void;
            public static QueueConfig($name: string, $param: any, $ver?: number, $prefix?: string):boolean;
            public static SendDeviceInfoInConfigRequest():boolean;
            public static AddSessionTag($tag: string):void;
            public ForceUpdate():void;
            public WasLastUpdatedFromServer():boolean;
            public GetInt($key: string):number;
            public GetInt($key: string, $defaultValue: number):number;
            public GetLong($key: string):bigint;
            public GetLong($key: string, $defaultValue: bigint):bigint;
            public GetFloat($key: string):number;
            public GetFloat($key: string, $defaultValue: number):number;
            public GetString($key: string):string;
            public GetString($key: string, $defaultValue: string):string;
            public GetBool($key: string):boolean;
            public GetBool($key: string, $defaultValue: boolean):boolean;
            public HasKey($key: string):boolean;
            public GetCount():number;
            public GetKeys():System.Array$1<string>;
            public GetObject($type: System.Type, $key?: string):any;
            public GetObject($key: string, $defaultValue: any):any;
            public GetDictionary($key?: string):System.Collections.Generic.IDictionary$2<string, any>;
            public constructor($configKey: string);
            public constructor();
        }
        export class WWWForm extends System.Object{ 
            public get headers(): System.Collections.Generic.Dictionary$2<string, string>;
            public get data(): System.Array$1<number>;
            public AddField($fieldName: string, $value: string):void;
            public AddField($fieldName: string, $value: string, $e: System.Text.Encoding):void;
            public AddField($fieldName: string, $i: number):void;
            public AddBinaryData($fieldName: string, $contents: System.Array$1<number>):void;
            public AddBinaryData($fieldName: string, $contents: System.Array$1<number>, $fileName: string):void;
            public AddBinaryData($fieldName: string, $contents: System.Array$1<number>, $fileName: string, $mimeType: string):void;
            public constructor();
        }
        export class WWWAudioExtensions extends System.Object{ 
        }
        export class WWW extends UnityEngine.CustomYieldInstruction implements System.Collections.IEnumerator, System.IDisposable{ 
        }
        interface WWW {
            GetAudioClip():UnityEngine.AudioClip;
            GetAudioClip($threeD: boolean):UnityEngine.AudioClip;
            GetAudioClip($threeD: boolean, $stream: boolean):UnityEngine.AudioClip;
            GetAudioClip($threeD: boolean, $stream: boolean, $audioType: UnityEngine.AudioType):UnityEngine.AudioClip;
            GetAudioClipCompressed():UnityEngine.AudioClip;
            GetAudioClipCompressed($threeD: boolean):UnityEngine.AudioClip;
            GetAudioClipCompressed($threeD: boolean, $audioType: UnityEngine.AudioType):UnityEngine.AudioClip;
            GetMovieTexture():UnityEngine.MovieTexture;
        }
        export class MovieTexture extends UnityEngine.Texture{ 
        }
        export class WheelHit extends System.ValueType{ 
            public get collider(): UnityEngine.Collider;
            public set collider(value: UnityEngine.Collider);
            public get point(): UnityEngine.Vector3;
            public set point(value: UnityEngine.Vector3);
            public get normal(): UnityEngine.Vector3;
            public set normal(value: UnityEngine.Vector3);
            public get forwardDir(): UnityEngine.Vector3;
            public set forwardDir(value: UnityEngine.Vector3);
            public get sidewaysDir(): UnityEngine.Vector3;
            public set sidewaysDir(value: UnityEngine.Vector3);
            public get force(): number;
            public set force(value: number);
            public get forwardSlip(): number;
            public set forwardSlip(value: number);
            public get sidewaysSlip(): number;
            public set sidewaysSlip(value: number);
        }
        export class WheelCollider extends UnityEngine.Collider{ 
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            public get radius(): number;
            public set radius(value: number);
            public get suspensionDistance(): number;
            public set suspensionDistance(value: number);
            public get suspensionSpring(): UnityEngine.JointSpring;
            public set suspensionSpring(value: UnityEngine.JointSpring);
            public get suspensionExpansionLimited(): boolean;
            public set suspensionExpansionLimited(value: boolean);
            public get forceAppPointDistance(): number;
            public set forceAppPointDistance(value: number);
            public get mass(): number;
            public set mass(value: number);
            public get wheelDampingRate(): number;
            public set wheelDampingRate(value: number);
            public get forwardFriction(): UnityEngine.WheelFrictionCurve;
            public set forwardFriction(value: UnityEngine.WheelFrictionCurve);
            public get sidewaysFriction(): UnityEngine.WheelFrictionCurve;
            public set sidewaysFriction(value: UnityEngine.WheelFrictionCurve);
            public get motorTorque(): number;
            public set motorTorque(value: number);
            public get brakeTorque(): number;
            public set brakeTorque(value: number);
            public get steerAngle(): number;
            public set steerAngle(value: number);
            public get isGrounded(): boolean;
            public get rpm(): number;
            public get sprungMass(): number;
            public set sprungMass(value: number);
            public ResetSprungMasses():void;
            public ConfigureVehicleSubsteps($speedThreshold: number, $stepsBelowThreshold: number, $stepsAboveThreshold: number):void;
            public GetWorldPose($pos: $Ref<UnityEngine.Vector3>, $quat: $Ref<UnityEngine.Quaternion>):void;
            public GetGroundHit($hit: $Ref<UnityEngine.WheelHit>):boolean;
            public constructor();
        }
        export enum WindZoneMode{ Directional = 0, Spherical = 1 }
        export class WindZone extends UnityEngine.Component{ 
            public get mode(): UnityEngine.WindZoneMode;
            public set mode(value: UnityEngine.WindZoneMode);
            public get radius(): number;
            public set radius(value: number);
            public get windMain(): number;
            public set windMain(value: number);
            public get windTurbulence(): number;
            public set windTurbulence(value: number);
            public get windPulseMagnitude(): number;
            public set windPulseMagnitude(value: number);
            public get windPulseFrequency(): number;
            public set windPulseFrequency(value: number);
            public constructor();
        }
        export class AssetReferenceUIRestriction extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public ValidateAsset($obj: UnityEngine.Object):boolean;
            public ValidateAsset($path: string):boolean;
            public constructor();
        }
        export class AssetReferenceUILabelRestriction extends UnityEngine.AssetReferenceUIRestriction implements System.Runtime.InteropServices._Attribute{ 
            public m_AllowedLabels: System.Array$1<string>;
            public m_CachedToString: string;
            public constructor(...allowedLabels: string[]);
            public constructor();
        }
        export class InputManagerEntry extends System.Object{ 
            public name: string;
            public desc: string;
            public btnNegative: string;
            public btnPositive: string;
            public altBtnNegative: string;
            public altBtnPositive: string;
            public gravity: number;
            public deadZone: number;
            public sensitivity: number;
            public snap: boolean;
            public invert: boolean;
            public kind: UnityEngine.InputManagerEntry.Kind;
            public axis: UnityEngine.InputManagerEntry.Axis;
            public joystick: UnityEngine.InputManagerEntry.Joy;
            public constructor();
        }
        export class InputRegistering extends System.Object{ 
            public static RegisterInputs($entries: System.Collections.Generic.List$1<UnityEngine.InputManagerEntry>):void;
        }
    }
    export namespace System {
        export class Object{ 
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
            public GetHashCode():number;
            public GetType():System.Type;
            public ToString():string;
            public static ReferenceEquals($objA: any, $objB: any):boolean;
            public constructor();
        }
        interface Object {
            ToGreen(...extra: any[]):string;
            ToYellow(...extra: any[]):string;
            ToWhite(...extra: any[]):string;
            ToBlue(...extra: any[]):string;
            ToRed(...extra: any[]):string;
            ToBold(...extra: any[]):string;
            Env():Puerts.JsEnv;
            AsString():string;
            ToStringAdvanced():string;
        }
        export class Void extends System.ValueType{ 
        }
        export class ValueType extends System.Object{ 
        }
        export interface IEquatable$1<T>{ 
        }
        export interface IFormattable{ 
        }
        export class Single extends System.ValueType implements System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>, System.IFormattable{ 
        }
        interface Single {
            eq($b: number, $epsilon?: number):boolean;
            Difference($a: number, $b: number):number;
        }
        export interface IComparable{ 
        }
        export interface IComparable$1<T>{ 
        }
        export interface IConvertible{ 
        }
        export class Boolean extends System.ValueType implements System.IComparable, System.IComparable$1<boolean>, System.IConvertible, System.IEquatable$1<boolean>{ 
        }
        export class Int32 extends System.ValueType implements System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>, System.IFormattable{ 
        }
        export class String extends System.Object implements System.ICloneable, System.Collections.IEnumerable, System.IComparable, System.IComparable$1<string>, System.IConvertible, System.IEquatable$1<string>, System.Collections.Generic.IEnumerable$1<number>{ 
        }
        interface String {
            GetFullPath():string;
            AssetPathNormal():string;
            PathCombine(...names: string[]):string;
            RenamePath($newName: string):void;
            IsNotNullOrEmpty():boolean;
            IsNullOrEmpty():boolean;
            IsNullOrWhiteSpace():boolean;
            _TagKey():string;
            ToPadSides($totalWidth?: number, $paddingChar?: number):string;
            ToCapitalStr():string;
            GetBytes():System.Array$1<number>;
            Md5():string;
            PadBoth($length: number, $chars?: string):string;
            Color($color: UnityEngine.Color):string;
            md5():string;
            JsPath($ext?: string, $fullpath?: boolean):string;
            JsFullPath():string;
            RemoveAssets():string;
            GetGUID():string;
            FullPath():string;
            dataPathRoot():string;
            M_PregReplace($rule: System.Array$1<string>, $to: string):string;
            M_PregReplace($rule: string, $to: string):string;
            M_PregReplace($rule: System.Array$1<string>, $to: System.Array$1<string>):string;
            Dirname($create?: boolean):string;
            FileExtension():string;
            ResourcePath():string;
            CreateDirFromFilePath($isFile?: boolean):string;
            M_VarName($toCaptical?: boolean):string;
            SplitCamelCase():string;
            CapitalizeFirst():string;
            CapLength($max: number):string;
            GetCapitals():string;
            FormatError():string;
            GetStringWithinOuter($from: number, $to: number):string;
            GetStringWithinInner($from: number, $to: number):string;
            ReplaceWithin($startChar: number, $endChar: number, $Process: System.Func$2<string, string>):string;
        }
        export interface ICloneable{ 
        }
        export class Char extends System.ValueType implements System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>{ 
        }
        export class Enum extends System.ValueType implements System.IComparable, System.IConvertible, System.IFormattable{ 
        }
        interface Enum {
            GetFullName():string;
        }
        export class Exception extends System.Object implements System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable{ 
        }
        export class Array extends System.Object implements System.ICloneable, System.Collections.IEnumerable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Collections.ICollection{ 
            public get LongLength(): bigint;
            public get IsFixedSize(): boolean;
            public get IsReadOnly(): boolean;
            public get IsSynchronized(): boolean;
            public get SyncRoot(): any;
            public get Length(): number;
            public get Rank(): number;
            public static CreateInstance($elementType: System.Type, ...lengths: bigint[]):System.Array;
            public CopyTo($array: System.Array, $index: number):void;
            public Clone():any;
            public static BinarySearch($array: System.Array, $value: any):number;
            public static Copy($sourceArray: System.Array, $destinationArray: System.Array, $length: bigint):void;
            public static Copy($sourceArray: System.Array, $sourceIndex: bigint, $destinationArray: System.Array, $destinationIndex: bigint, $length: bigint):void;
            public CopyTo($array: System.Array, $index: bigint):void;
            public GetLongLength($dimension: number):bigint;
            public GetValue($index: bigint):any;
            public GetValue($index1: bigint, $index2: bigint):any;
            public GetValue($index1: bigint, $index2: bigint, $index3: bigint):any;
            public GetValue(...indices: bigint[]):any;
            public static BinarySearch($array: System.Array, $index: number, $length: number, $value: any):number;
            public static BinarySearch($array: System.Array, $value: any, $comparer: System.Collections.IComparer):number;
            public static BinarySearch($array: System.Array, $index: number, $length: number, $value: any, $comparer: System.Collections.IComparer):number;
            public static IndexOf($array: System.Array, $value: any):number;
            public static IndexOf($array: System.Array, $value: any, $startIndex: number):number;
            public static IndexOf($array: System.Array, $value: any, $startIndex: number, $count: number):number;
            public static LastIndexOf($array: System.Array, $value: any):number;
            public static LastIndexOf($array: System.Array, $value: any, $startIndex: number):number;
            public static LastIndexOf($array: System.Array, $value: any, $startIndex: number, $count: number):number;
            public static Reverse($array: System.Array):void;
            public static Reverse($array: System.Array, $index: number, $length: number):void;
            public SetValue($value: any, $index: bigint):void;
            public SetValue($value: any, $index1: bigint, $index2: bigint):void;
            public SetValue($value: any, $index1: bigint, $index2: bigint, $index3: bigint):void;
            public SetValue($value: any, ...indices: bigint[]):void;
            public static Sort($array: System.Array):void;
            public static Sort($array: System.Array, $index: number, $length: number):void;
            public static Sort($array: System.Array, $comparer: System.Collections.IComparer):void;
            public static Sort($array: System.Array, $index: number, $length: number, $comparer: System.Collections.IComparer):void;
            public static Sort($keys: System.Array, $items: System.Array):void;
            public static Sort($keys: System.Array, $items: System.Array, $comparer: System.Collections.IComparer):void;
            public static Sort($keys: System.Array, $items: System.Array, $index: number, $length: number):void;
            public static Sort($keys: System.Array, $items: System.Array, $index: number, $length: number, $comparer: System.Collections.IComparer):void;
            public GetEnumerator():System.Collections.IEnumerator;
            public GetLength($dimension: number):number;
            public GetLowerBound($dimension: number):number;
            public GetValue(...indices: number[]):any;
            public SetValue($value: any, ...indices: number[]):void;
            public GetUpperBound($dimension: number):number;
            public GetValue($index: number):any;
            public GetValue($index1: number, $index2: number):any;
            public GetValue($index1: number, $index2: number, $index3: number):any;
            public SetValue($value: any, $index: number):void;
            public SetValue($value: any, $index1: number, $index2: number):void;
            public SetValue($value: any, $index1: number, $index2: number, $index3: number):void;
            public static CreateInstance($elementType: System.Type, $length: number):System.Array;
            public static CreateInstance($elementType: System.Type, $length1: number, $length2: number):System.Array;
            public static CreateInstance($elementType: System.Type, $length1: number, $length2: number, $length3: number):System.Array;
            public static CreateInstance($elementType: System.Type, ...lengths: number[]):System.Array;
            public static CreateInstance($elementType: System.Type, $lengths: System.Array$1<number>, $lowerBounds: System.Array$1<number>):System.Array;
            public static Clear($array: System.Array, $index: number, $length: number):void;
            public static Copy($sourceArray: System.Array, $destinationArray: System.Array, $length: number):void;
            public static Copy($sourceArray: System.Array, $sourceIndex: number, $destinationArray: System.Array, $destinationIndex: number, $length: number):void;
            public static ConstrainedCopy($sourceArray: System.Array, $sourceIndex: number, $destinationArray: System.Array, $destinationIndex: number, $length: number):void;
            public Initialize():void;
        }
        interface Array {
            Resize($newSize: number):System.Array;
        }
        export class Type extends System.Reflection.MemberInfo implements System.Reflection.IReflect, System.Runtime.InteropServices._Type, System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._MemberInfo{ 
            public static FilterAttribute: System.Reflection.MemberFilter;
            public static FilterName: System.Reflection.MemberFilter;
            public static FilterNameIgnoreCase: System.Reflection.MemberFilter;
            public static Missing: any;
            public static Delimiter: number;
            public static EmptyTypes: System.Array$1<System.Type>;
            public get MemberType(): System.Reflection.MemberTypes;
            public get DeclaringType(): System.Type;
            public get DeclaringMethod(): System.Reflection.MethodBase;
            public get ReflectedType(): System.Type;
            public get StructLayoutAttribute(): System.Runtime.InteropServices.StructLayoutAttribute;
            public get GUID(): System.Guid;
            public static get DefaultBinder(): System.Reflection.Binder;
            public get Module(): System.Reflection.Module;
            public get Assembly(): System.Reflection.Assembly;
            public get TypeHandle(): System.RuntimeTypeHandle;
            public get FullName(): string;
            public get Namespace(): string;
            public get AssemblyQualifiedName(): string;
            public get BaseType(): System.Type;
            public get TypeInitializer(): System.Reflection.ConstructorInfo;
            public get IsNested(): boolean;
            public get Attributes(): System.Reflection.TypeAttributes;
            public get GenericParameterAttributes(): System.Reflection.GenericParameterAttributes;
            public get IsVisible(): boolean;
            public get IsNotPublic(): boolean;
            public get IsPublic(): boolean;
            public get IsNestedPublic(): boolean;
            public get IsNestedPrivate(): boolean;
            public get IsNestedFamily(): boolean;
            public get IsNestedAssembly(): boolean;
            public get IsNestedFamANDAssem(): boolean;
            public get IsNestedFamORAssem(): boolean;
            public get IsAutoLayout(): boolean;
            public get IsLayoutSequential(): boolean;
            public get IsExplicitLayout(): boolean;
            public get IsClass(): boolean;
            public get IsInterface(): boolean;
            public get IsValueType(): boolean;
            public get IsAbstract(): boolean;
            public get IsSealed(): boolean;
            public get IsEnum(): boolean;
            public get IsSpecialName(): boolean;
            public get IsImport(): boolean;
            public get IsSerializable(): boolean;
            public get IsAnsiClass(): boolean;
            public get IsUnicodeClass(): boolean;
            public get IsAutoClass(): boolean;
            public get IsArray(): boolean;
            public get IsGenericType(): boolean;
            public get IsGenericTypeDefinition(): boolean;
            public get IsConstructedGenericType(): boolean;
            public get IsGenericParameter(): boolean;
            public get GenericParameterPosition(): number;
            public get ContainsGenericParameters(): boolean;
            public get IsByRef(): boolean;
            public get IsPointer(): boolean;
            public get IsPrimitive(): boolean;
            public get IsCOMObject(): boolean;
            public get HasElementType(): boolean;
            public get IsContextful(): boolean;
            public get IsMarshalByRef(): boolean;
            public get GenericTypeArguments(): System.Array$1<System.Type>;
            public get IsSecurityCritical(): boolean;
            public get IsSecuritySafeCritical(): boolean;
            public get IsSecurityTransparent(): boolean;
            public get UnderlyingSystemType(): System.Type;
            public static GetType($typeName: string, $assemblyResolver: System.Func$2<System.Reflection.AssemblyName, System.Reflection.Assembly>, $typeResolver: System.Func$4<System.Reflection.Assembly, string, boolean, System.Type>):System.Type;
            public static GetType($typeName: string, $assemblyResolver: System.Func$2<System.Reflection.AssemblyName, System.Reflection.Assembly>, $typeResolver: System.Func$4<System.Reflection.Assembly, string, boolean, System.Type>, $throwOnError: boolean):System.Type;
            public static GetType($typeName: string, $assemblyResolver: System.Func$2<System.Reflection.AssemblyName, System.Reflection.Assembly>, $typeResolver: System.Func$4<System.Reflection.Assembly, string, boolean, System.Type>, $throwOnError: boolean, $ignoreCase: boolean):System.Type;
            public MakePointerType():System.Type;
            public MakeByRefType():System.Type;
            public MakeArrayType():System.Type;
            public MakeArrayType($rank: number):System.Type;
            public static GetTypeFromProgID($progID: string):System.Type;
            public static GetTypeFromProgID($progID: string, $throwOnError: boolean):System.Type;
            public static GetTypeFromProgID($progID: string, $server: string):System.Type;
            public static GetTypeFromProgID($progID: string, $server: string, $throwOnError: boolean):System.Type;
            public static GetTypeFromCLSID($clsid: System.Guid):System.Type;
            public static GetTypeFromCLSID($clsid: System.Guid, $throwOnError: boolean):System.Type;
            public static GetTypeFromCLSID($clsid: System.Guid, $server: string):System.Type;
            public static GetTypeFromCLSID($clsid: System.Guid, $server: string, $throwOnError: boolean):System.Type;
            public static GetTypeCode($type: System.Type):System.TypeCode;
            public InvokeMember($name: string, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $target: any, $args: System.Array$1<any>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>, $culture: System.Globalization.CultureInfo, $namedParameters: System.Array$1<string>):any;
            public InvokeMember($name: string, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $target: any, $args: System.Array$1<any>, $culture: System.Globalization.CultureInfo):any;
            public InvokeMember($name: string, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $target: any, $args: System.Array$1<any>):any;
            public static GetTypeHandle($o: any):System.RuntimeTypeHandle;
            public GetArrayRank():number;
            public GetConstructor($bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $callConvention: System.Reflection.CallingConventions, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>):System.Reflection.ConstructorInfo;
            public GetConstructor($bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>):System.Reflection.ConstructorInfo;
            public GetConstructor($types: System.Array$1<System.Type>):System.Reflection.ConstructorInfo;
            public GetConstructors():System.Array$1<System.Reflection.ConstructorInfo>;
            public GetConstructors($bindingAttr: System.Reflection.BindingFlags):System.Array$1<System.Reflection.ConstructorInfo>;
            public GetMethod($name: string, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $callConvention: System.Reflection.CallingConventions, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>):System.Reflection.MethodInfo;
            public GetMethod($name: string, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>):System.Reflection.MethodInfo;
            public GetMethod($name: string, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>):System.Reflection.MethodInfo;
            public GetMethod($name: string, $types: System.Array$1<System.Type>):System.Reflection.MethodInfo;
            public GetMethod($name: string, $bindingAttr: System.Reflection.BindingFlags):System.Reflection.MethodInfo;
            public GetMethod($name: string):System.Reflection.MethodInfo;
            public GetMethods():System.Array$1<System.Reflection.MethodInfo>;
            public GetMethods($bindingAttr: System.Reflection.BindingFlags):System.Array$1<System.Reflection.MethodInfo>;
            public GetField($name: string, $bindingAttr: System.Reflection.BindingFlags):System.Reflection.FieldInfo;
            public GetField($name: string):System.Reflection.FieldInfo;
            public GetFields():System.Array$1<System.Reflection.FieldInfo>;
            public GetFields($bindingAttr: System.Reflection.BindingFlags):System.Array$1<System.Reflection.FieldInfo>;
            public GetInterface($name: string):System.Type;
            public GetInterface($name: string, $ignoreCase: boolean):System.Type;
            public GetInterfaces():System.Array$1<System.Type>;
            public FindInterfaces($filter: System.Reflection.TypeFilter, $filterCriteria: any):System.Array$1<System.Type>;
            public GetEvent($name: string):System.Reflection.EventInfo;
            public GetEvent($name: string, $bindingAttr: System.Reflection.BindingFlags):System.Reflection.EventInfo;
            public GetEvents():System.Array$1<System.Reflection.EventInfo>;
            public GetEvents($bindingAttr: System.Reflection.BindingFlags):System.Array$1<System.Reflection.EventInfo>;
            public GetProperty($name: string, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $returnType: System.Type, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>):System.Reflection.PropertyInfo;
            public GetProperty($name: string, $returnType: System.Type, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>):System.Reflection.PropertyInfo;
            public GetProperty($name: string, $bindingAttr: System.Reflection.BindingFlags):System.Reflection.PropertyInfo;
            public GetProperty($name: string, $returnType: System.Type, $types: System.Array$1<System.Type>):System.Reflection.PropertyInfo;
            public GetProperty($name: string, $types: System.Array$1<System.Type>):System.Reflection.PropertyInfo;
            public GetProperty($name: string, $returnType: System.Type):System.Reflection.PropertyInfo;
            public GetProperty($name: string):System.Reflection.PropertyInfo;
            public GetProperties($bindingAttr: System.Reflection.BindingFlags):System.Array$1<System.Reflection.PropertyInfo>;
            public GetProperties():System.Array$1<System.Reflection.PropertyInfo>;
            public GetNestedTypes():System.Array$1<System.Type>;
            public GetNestedTypes($bindingAttr: System.Reflection.BindingFlags):System.Array$1<System.Type>;
            public GetNestedType($name: string):System.Type;
            public GetNestedType($name: string, $bindingAttr: System.Reflection.BindingFlags):System.Type;
            public GetMember($name: string):System.Array$1<System.Reflection.MemberInfo>;
            public GetMember($name: string, $bindingAttr: System.Reflection.BindingFlags):System.Array$1<System.Reflection.MemberInfo>;
            public GetMember($name: string, $type: System.Reflection.MemberTypes, $bindingAttr: System.Reflection.BindingFlags):System.Array$1<System.Reflection.MemberInfo>;
            public GetMembers():System.Array$1<System.Reflection.MemberInfo>;
            public GetMembers($bindingAttr: System.Reflection.BindingFlags):System.Array$1<System.Reflection.MemberInfo>;
            public GetDefaultMembers():System.Array$1<System.Reflection.MemberInfo>;
            public FindMembers($memberType: System.Reflection.MemberTypes, $bindingAttr: System.Reflection.BindingFlags, $filter: System.Reflection.MemberFilter, $filterCriteria: any):System.Array$1<System.Reflection.MemberInfo>;
            public GetGenericParameterConstraints():System.Array$1<System.Type>;
            public MakeGenericType(...typeArguments: System.Type[]):System.Type;
            public GetElementType():System.Type;
            public GetGenericArguments():System.Array$1<System.Type>;
            public GetGenericTypeDefinition():System.Type;
            public GetEnumNames():System.Array$1<string>;
            public GetEnumValues():System.Array;
            public GetEnumUnderlyingType():System.Type;
            public IsEnumDefined($value: any):boolean;
            public GetEnumName($value: any):string;
            public IsSubclassOf($c: System.Type):boolean;
            public IsInstanceOfType($o: any):boolean;
            public IsAssignableFrom($c: System.Type):boolean;
            public IsEquivalentTo($other: System.Type):boolean;
            public static GetTypeArray($args: System.Array$1<any>):System.Array$1<System.Type>;
            public Equals($o: any):boolean;
            public Equals($o: System.Type):boolean;
            public static op_Equality($left: System.Type, $right: System.Type):boolean;
            public static op_Inequality($left: System.Type, $right: System.Type):boolean;
            public GetInterfaceMap($interfaceType: System.Type):System.Reflection.InterfaceMapping;
            public GetType():System.Type;
            public static GetType($typeName: string):System.Type;
            public static GetType($typeName: string, $throwOnError: boolean):System.Type;
            public static GetType($typeName: string, $throwOnError: boolean, $ignoreCase: boolean):System.Type;
            public static ReflectionOnlyGetType($typeName: string, $throwIfNotFound: boolean, $ignoreCase: boolean):System.Type;
            public static GetTypeFromHandle($handle: System.RuntimeTypeHandle):System.Type;
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
        }
        interface Type {
            GetDefault():any;
            GetForeignKeyProperty($relationshipProperty: System.Reflection.PropertyInfo, $intermediateType?: System.Type, $inverse?: boolean):System.Reflection.PropertyInfo;
            GetInverseProperty($property: System.Reflection.PropertyInfo):System.Reflection.PropertyInfo;
            GetManyToManyMetaInfo($relationship: System.Reflection.PropertyInfo):SQLiteNetExtensions.Extensions.ManyToManyMetaInfo;
            GetRelationshipProperties():System.Collections.Generic.List$1<System.Reflection.PropertyInfo>;
            GetPrimaryKey():System.Reflection.PropertyInfo;
            GetTableName():string;
            FriendlyName($compileSafe?: boolean):string;
            RTIsAssignableFrom($other: System.Type):boolean;
            RTIsAssignableTo($other: System.Type):boolean;
            RTIsAbstract():boolean;
            RTIsValueType():boolean;
            RTIsArray():boolean;
            RTIsInterface():boolean;
            RTIsSubclassOf($other: System.Type):boolean;
            RTIsGenericParameter():boolean;
            RTIsGenericType():boolean;
            RTMakeGenericType(...typeArgs: System.Type[]):System.Type;
            RTGetGenericArguments():System.Array$1<System.Type>;
            RTGetElementType():System.Type;
            RTIsByRef():boolean;
            CreateObject():any;
            CreateObjectUninitialized():any;
            RTGetDefaultConstructor():System.Reflection.ConstructorInfo;
            RTGetConstructor($paramTypes: System.Array$1<System.Type>):System.Reflection.ConstructorInfo;
            RTGetMethod($name: string):System.Reflection.MethodInfo;
            RTGetMethod($name: string, $paramTypes: System.Array$1<System.Type>, $returnType?: System.Type, $genericArgumentTypes?: System.Array$1<System.Type>):System.Reflection.MethodInfo;
            RTGetField($name: string, $includePrivateBase?: boolean):System.Reflection.FieldInfo;
            RTGetProperty($name: string):System.Reflection.PropertyInfo;
            RTGetFieldOrProp($name: string):System.Reflection.MemberInfo;
            RTGetEvent($name: string):System.Reflection.EventInfo;
            RTGetConstructors():System.Array$1<System.Reflection.ConstructorInfo>;
            RTGetMethods():System.Array$1<System.Reflection.MethodInfo>;
            RTGetFields():System.Array$1<System.Reflection.FieldInfo>;
            RTGetProperties():System.Array$1<System.Reflection.PropertyInfo>;
            RTGetEvents():System.Array$1<System.Reflection.EventInfo>;
            RTGetAllAttributes():System.Array$1<any>;
            RTIsDefined($attributeType: System.Type, $inherited: boolean):boolean;
            RTGetAttribute($attributeType: System.Type, $inherited: boolean):System.Attribute;
            RTGetDelegateTypeParameters():System.Array$1<System.Reflection.ParameterInfo>;
            GetExtensionMethods():System.Array$1<System.Reflection.MethodInfo>;
            IsEnumerableCollection():boolean;
            GetEnumerableElementType():System.Type;
            GetSingleGenericArgument():System.Type;
            GetFirstGenericParameterConstraintType():System.Type;
            CanBeMadeGenericWith($type: System.Type):boolean;
            IsAllowedByGenericArgument($genericArgument: System.Type):boolean;
        }
        export class Int64 extends System.ValueType implements System.IComparable, System.IComparable$1<bigint>, System.IConvertible, System.IEquatable$1<bigint>, System.IFormattable{ 
        }
        export type Converter$2<TInput, TOutput> = (input: TInput) => TOutput;
        export type MulticastDelegate = (...args:any[]) => any;
        var MulticastDelegate: {new (func: (...args:any[]) => any): MulticastDelegate;}
        export class Delegate extends System.Object implements System.ICloneable, System.Runtime.Serialization.ISerializable{ 
            public get Method(): System.Reflection.MethodInfo;
            public get Target(): any;
            public static CreateDelegate($type: System.Type, $firstArgument: any, $method: System.Reflection.MethodInfo, $throwOnBindFailure: boolean):Function;
            public static CreateDelegate($type: System.Type, $firstArgument: any, $method: System.Reflection.MethodInfo):Function;
            public static CreateDelegate($type: System.Type, $method: System.Reflection.MethodInfo, $throwOnBindFailure: boolean):Function;
            public static CreateDelegate($type: System.Type, $method: System.Reflection.MethodInfo):Function;
            public static CreateDelegate($type: System.Type, $target: any, $method: string):Function;
            public static CreateDelegate($type: System.Type, $target: System.Type, $method: string, $ignoreCase: boolean, $throwOnBindFailure: boolean):Function;
            public static CreateDelegate($type: System.Type, $target: System.Type, $method: string):Function;
            public static CreateDelegate($type: System.Type, $target: System.Type, $method: string, $ignoreCase: boolean):Function;
            public static CreateDelegate($type: System.Type, $target: any, $method: string, $ignoreCase: boolean, $throwOnBindFailure: boolean):Function;
            public static CreateDelegate($type: System.Type, $target: any, $method: string, $ignoreCase: boolean):Function;
            public DynamicInvoke(...args: any[]):any;
            public Clone():any;
            public GetObjectData($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext):void;
            public GetInvocationList():System.Array$1<Function>;
            public static Combine($a: Function, $b: Function):Function;
            public static Combine(...delegates: Function[]):Function;
            public static Remove($source: Function, $value: Function):Function;
            public static RemoveAll($source: Function, $value: Function):Function;
            public static op_Equality($d1: Function, $d2: Function):boolean;
            public static op_Inequality($d1: Function, $d2: Function):boolean;
        }
        interface Delegate {
            RTGetDelegateMethodInfo():System.Reflection.MethodInfo;
        }
        export type Action$1<T> = (obj: T) => void;
        export type Comparison$1<T> = (x: T, y: T) => number;
        export type Predicate$1<T> = (obj: T) => boolean;
        export interface IFormatProvider{ 
        }
        export interface IDisposable{ 
        }
        export class Double extends System.ValueType implements System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>, System.IFormattable{ 
        }
        export interface IAsyncResult{ 
        }
        export class UInt64 extends System.ValueType implements System.IComparable, System.IComparable$1<bigint>, System.IConvertible, System.IEquatable$1<bigint>, System.IFormattable{ 
        }
        export type Func$2<T, TResult> = (arg: T) => TResult;
        export type Func$4<T1, T2, T3, TResult> = (arg1: T1, arg2: T2, arg3: T3) => TResult;
        export class Attribute extends System.Object implements System.Runtime.InteropServices._Attribute{ 
        }
        export class Guid extends System.ValueType implements System.IComparable, System.IComparable$1<System.Guid>, System.IEquatable$1<System.Guid>, System.IFormattable{ 
        }
        export enum TypeCode{ Empty = 0, Object = 1, DBNull = 2, Boolean = 3, Char = 4, SByte = 5, Byte = 6, Int16 = 7, UInt16 = 8, Int32 = 9, UInt32 = 10, Int64 = 11, UInt64 = 12, Single = 13, Double = 14, Decimal = 15, DateTime = 16, String = 18 }
        export class RuntimeTypeHandle extends System.ValueType implements System.Runtime.Serialization.ISerializable{ 
        }
        export class UInt32 extends System.ValueType implements System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>, System.IFormattable{ 
        }
        export type AsyncCallback = (ar: System.IAsyncResult) => void;
        var AsyncCallback: {new (func: (ar: System.IAsyncResult) => void): AsyncCallback;}
        export class IntPtr extends System.ValueType implements System.Runtime.Serialization.ISerializable{ 
        }
        export class SByte extends System.ValueType implements System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>, System.IFormattable{ 
        }
        export class Int16 extends System.ValueType implements System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>, System.IFormattable{ 
        }
        export class Byte extends System.ValueType implements System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>, System.IFormattable{ 
        }
        export class MarshalByRefObject extends System.Object{ 
        }
        export class Nullable$1<T> extends System.ValueType{ 
        }
        export type Func$1<TResult> = () => TResult;
        export type Action = () => void;
        var Action: {new (func: () => void): Action;}
        export type Action$2<T1, T2> = (arg1: T1, arg2: T2) => void;
        export class DateTime extends System.ValueType implements System.IComparable, System.IComparable$1<Date>, System.IConvertible, System.IEquatable$1<Date>, System.Runtime.Serialization.ISerializable, System.IFormattable{ 
        }
        export class UInt16 extends System.ValueType implements System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>, System.IFormattable{ 
        }
        export class SystemException extends System.Exception implements System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable{ 
        }
        export type Action$3<T1, T2, T3> = (arg1: T1, arg2: T2, arg3: T3) => void;
        export type Func$3<T1, T2, TResult> = (arg1: T1, arg2: T2) => TResult;
        export class ValueTuple$2<T1, T2> extends System.ValueType implements System.Runtime.CompilerServices.ITuple, System.IComparable, System.IComparable$1<System.ValueTuple$2<T1, T2>>, System.IValueTupleInternal, System.Collections.IStructuralComparable, System.IEquatable$1<System.ValueTuple$2<T1, T2>>, System.Collections.IStructuralEquatable{ 
        }
        export interface IValueTupleInternal extends System.Runtime.CompilerServices.ITuple{ 
        }
        export type Action$4<T1, T2, T3, T4> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => void;
        export type Func$5<T1, T2, T3, T4, TResult> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => TResult;
        export class Uri extends System.Object implements System.Runtime.Serialization.ISerializable{ 
        }
    }
    export namespace System.Collections {
        export interface IEnumerable{ 
        }
        export interface IList extends System.Collections.IEnumerable, System.Collections.ICollection{ 
        }
        export interface ICollection extends System.Collections.IEnumerable{ 
        }
        export interface IStructuralComparable{ 
        }
        export interface IStructuralEquatable{ 
        }
        export interface IComparer{ 
        }
        export interface IEnumerator{ 
        }
        export interface IDictionary extends System.Collections.IEnumerable, System.Collections.ICollection{ 
        }
        export interface IDictionaryEnumerator extends System.Collections.IEnumerator{ 
        }
    }
    export namespace System.Collections.Generic {
        export interface IEnumerable$1<T> extends System.Collections.IEnumerable{ 
        }
        export interface IList$1<T> extends System.Collections.IEnumerable, System.Collections.Generic.ICollection$1<T>, System.Collections.Generic.IEnumerable$1<T>{ 
        }
        export interface ICollection$1<T> extends System.Collections.IEnumerable, System.Collections.Generic.IEnumerable$1<T>{ 
        }
        export interface IReadOnlyCollection$1<T> extends System.Collections.IEnumerable, System.Collections.Generic.IEnumerable$1<T>{ 
        }
        export interface IReadOnlyList$1<T> extends System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<T>, System.Collections.Generic.IEnumerable$1<T>{ 
        }
        export interface IComparer$1<T>{ 
        }
        export class List$1<T> extends System.Object implements System.Collections.IEnumerable, System.Collections.Generic.IList$1<T>, System.Collections.Generic.IReadOnlyCollection$1<T>, System.Collections.Generic.IReadOnlyList$1<T>, System.Collections.IList, System.Collections.Generic.ICollection$1<T>, System.Collections.ICollection, System.Collections.Generic.IEnumerable$1<T>{ 
            public get Capacity(): number;
            public set Capacity(value: number);
            public get Count(): number;
            public get_Item($index: number):T;
            public set_Item($index: number, $value: T):void;
            public Add($item: T):void;
            public AddRange($collection: System.Collections.Generic.IEnumerable$1<T>):void;
            public AsReadOnly():System.Collections.ObjectModel.ReadOnlyCollection$1<T>;
            public BinarySearch($index: number, $count: number, $item: T, $comparer: System.Collections.Generic.IComparer$1<T>):number;
            public BinarySearch($item: T):number;
            public BinarySearch($item: T, $comparer: System.Collections.Generic.IComparer$1<T>):number;
            public Clear():void;
            public Contains($item: T):boolean;
            public CopyTo($array: System.Array$1<T>):void;
            public CopyTo($index: number, $array: System.Array$1<T>, $arrayIndex: number, $count: number):void;
            public CopyTo($array: System.Array$1<T>, $arrayIndex: number):void;
            public Exists($match: System.Predicate$1<T>):boolean;
            public Find($match: System.Predicate$1<T>):T;
            public FindAll($match: System.Predicate$1<T>):System.Collections.Generic.List$1<T>;
            public FindIndex($match: System.Predicate$1<T>):number;
            public FindIndex($startIndex: number, $match: System.Predicate$1<T>):number;
            public FindIndex($startIndex: number, $count: number, $match: System.Predicate$1<T>):number;
            public FindLast($match: System.Predicate$1<T>):T;
            public FindLastIndex($match: System.Predicate$1<T>):number;
            public FindLastIndex($startIndex: number, $match: System.Predicate$1<T>):number;
            public FindLastIndex($startIndex: number, $count: number, $match: System.Predicate$1<T>):number;
            public ForEach($action: System.Action$1<T>):void;
            public GetEnumerator():System.Collections.Generic.List$1.Enumerator<T>;
            public GetRange($index: number, $count: number):System.Collections.Generic.List$1<T>;
            public IndexOf($item: T):number;
            public IndexOf($item: T, $index: number):number;
            public IndexOf($item: T, $index: number, $count: number):number;
            public Insert($index: number, $item: T):void;
            public InsertRange($index: number, $collection: System.Collections.Generic.IEnumerable$1<T>):void;
            public LastIndexOf($item: T):number;
            public LastIndexOf($item: T, $index: number):number;
            public LastIndexOf($item: T, $index: number, $count: number):number;
            public Remove($item: T):boolean;
            public RemoveAll($match: System.Predicate$1<T>):number;
            public RemoveAt($index: number):void;
            public RemoveRange($index: number, $count: number):void;
            public Reverse():void;
            public Reverse($index: number, $count: number):void;
            public Sort():void;
            public Sort($comparer: System.Collections.Generic.IComparer$1<T>):void;
            public Sort($index: number, $count: number, $comparer: System.Collections.Generic.IComparer$1<T>):void;
            public Sort($comparison: System.Comparison$1<T>):void;
            public ToArray():System.Array$1<T>;
            public TrimExcess():void;
            public TrueForAll($match: System.Predicate$1<T>):boolean;
            public constructor();
            public constructor($capacity: number);
            public constructor($collection: System.Collections.Generic.IEnumerable$1<T>);
        }
        export interface IEnumerator$1<T> extends System.Collections.IEnumerator, System.IDisposable{ 
        }
        export class Dictionary$2<TKey, TValue> extends System.Object implements System.Collections.IDictionary, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>, System.Collections.Generic.IReadOnlyDictionary$2<TKey, TValue>, System.Runtime.Serialization.IDeserializationCallback, System.Collections.Generic.ICollection$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>, System.Runtime.Serialization.ISerializable, System.Collections.ICollection, System.Collections.Generic.IDictionary$2<TKey, TValue>, System.Collections.Generic.IEnumerable$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>{ 
            public get Comparer(): System.Collections.Generic.IEqualityComparer$1<TKey>;
            public get Count(): number;
            public get Keys(): System.Collections.Generic.Dictionary$2.KeyCollection<TKey, TValue>;
            public get Values(): System.Collections.Generic.Dictionary$2.ValueCollection<TKey, TValue>;
            public get_Item($key: TKey):TValue;
            public set_Item($key: TKey, $value: TValue):void;
            public Add($key: TKey, $value: TValue):void;
            public Clear():void;
            public ContainsKey($key: TKey):boolean;
            public ContainsValue($value: TValue):boolean;
            public GetEnumerator():System.Collections.Generic.Dictionary$2.Enumerator<TKey, TValue>;
            public GetObjectData($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext):void;
            public OnDeserialization($sender: any):void;
            public Remove($key: TKey):boolean;
            public TryGetValue($key: TKey, $value: $Ref<TValue>):boolean;
            public constructor();
            public constructor($capacity: number);
            public constructor($comparer: System.Collections.Generic.IEqualityComparer$1<TKey>);
            public constructor($capacity: number, $comparer: System.Collections.Generic.IEqualityComparer$1<TKey>);
        }
        export class KeyValuePair$2<TKey, TValue> extends System.ValueType{ 
        }
        export interface IReadOnlyDictionary$2<TKey, TValue> extends System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>, System.Collections.Generic.IEnumerable$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>{ 
        }
        export interface IDictionary$2<TKey, TValue> extends System.Collections.IEnumerable, System.Collections.Generic.ICollection$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>, System.Collections.Generic.IEnumerable$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>{ 
        }
        export interface IEqualityComparer$1<T>{ 
        }
        export class LinkedListNode$1<T> extends System.Object{ 
        }
        export class LinkedList$1<T> extends System.Object implements System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<T>, System.Runtime.Serialization.IDeserializationCallback, System.Collections.Generic.ICollection$1<T>, System.Runtime.Serialization.ISerializable, System.Collections.ICollection, System.Collections.Generic.IEnumerable$1<T>{ 
        }
        export class HashSet$1<T> extends System.Object implements System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<T>, System.Runtime.Serialization.IDeserializationCallback, System.Collections.Generic.ISet$1<T>, System.Collections.Generic.ICollection$1<T>, System.Runtime.Serialization.ISerializable, System.Collections.Generic.IEnumerable$1<T>{ 
        }
        export interface ISet$1<T> extends System.Collections.IEnumerable, System.Collections.Generic.ICollection$1<T>, System.Collections.Generic.IEnumerable$1<T>{ 
        }
    }
    export namespace System.Runtime.InteropServices {
        export interface _Exception{ 
        }
        export interface _MemberInfo{ 
        }
        export interface _Type{ 
        }
        export interface _MethodBase{ 
        }
        export interface _MethodInfo{ 
        }
        export interface _AssemblyName{ 
        }
        export interface _Assembly{ 
        }
        export class StructLayoutAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
        }
        export interface _Attribute{ 
        }
        export interface _Module{ 
        }
        export interface _ConstructorInfo{ 
        }
        export interface _FieldInfo{ 
        }
        export interface _EventInfo{ 
        }
        export interface _PropertyInfo{ 
        }
        export interface _Thread{ 
        }
    }
    export namespace System.Runtime.Serialization {
        export interface ISerializable{ 
        }
        export interface IDeserializationCallback{ 
        }
        export class SerializationInfo extends System.Object{ 
        }
        export class StreamingContext extends System.ValueType{ 
        }
    }
    export namespace System.Reflection {
        export class MemberInfo extends System.Object implements System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._MemberInfo{ 
        }
        interface MemberInfo {
            FriendlyName():string;
            RTReflectedOrDeclaredType():System.Type;
            RTGetAllAttributes():System.Array$1<any>;
            RTIsDefined($attributeType: System.Type, $inherited: boolean):boolean;
            RTGetAttribute($attributeType: System.Type, $inherited: boolean):System.Attribute;
            IsObsolete($inherited?: boolean):boolean;
        }
        export interface ICustomAttributeProvider{ 
        }
        export interface IReflect{ 
        }
        export class MethodInfo extends System.Reflection.MethodBase implements System.Runtime.InteropServices._MethodBase, System.Runtime.InteropServices._MethodInfo, System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._MemberInfo{ 
        }
        interface MethodInfo {
            RTGetGenericArguments():System.Array$1<System.Type>;
            RTCreateDelegate($type: System.Type, $instance: any):Function;
            IsExtensionMethod():boolean;
            IsPropertyAccessor():boolean;
            GetAccessorProperty():System.Reflection.PropertyInfo;
            GetFirstGenericParameterConstraintType():System.Type;
            CanBeMadeGenericWith($type: System.Type):boolean;
        }
        export class MethodBase extends System.Reflection.MemberInfo implements System.Runtime.InteropServices._MethodBase, System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._MemberInfo{ 
        }
        interface MethodBase {
            GetMethodSpecialType():ParadoxNotion.ReflectionTools.MethodType;
            FriendlyName():string;
            FriendlyName($specialNameType: $Ref<ParadoxNotion.ReflectionTools.MethodType>):string;
            SignatureName():string;
        }
        export type MemberFilter = (m: System.Reflection.MemberInfo, filterCriteria: any) => boolean;
        var MemberFilter: {new (func: (m: System.Reflection.MemberInfo, filterCriteria: any) => boolean): MemberFilter;}
        export enum MemberTypes{ Constructor = 1, Event = 2, Field = 4, Method = 8, Property = 16, TypeInfo = 32, Custom = 64, NestedType = 128, All = 191 }
        export class AssemblyName extends System.Object implements System.ICloneable, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.InteropServices._AssemblyName, System.Runtime.Serialization.ISerializable{ 
        }
        export class Assembly extends System.Object implements System.Security.IEvidenceFactory, System.Runtime.InteropServices._Assembly, System.Reflection.ICustomAttributeProvider, System.Runtime.Serialization.ISerializable{ 
        }
        export class Binder extends System.Object{ 
        }
        export enum BindingFlags{ Default = 0, IgnoreCase = 1, DeclaredOnly = 2, Instance = 4, Static = 8, Public = 16, NonPublic = 32, FlattenHierarchy = 64, InvokeMethod = 256, CreateInstance = 512, GetField = 1024, SetField = 2048, GetProperty = 4096, SetProperty = 8192, PutDispProperty = 16384, PutRefDispProperty = 32768, ExactBinding = 65536, SuppressChangeType = 131072, OptionalParamBinding = 262144, IgnoreReturn = 16777216 }
        export class ParameterModifier extends System.ValueType{ 
        }
        export class Module extends System.Object implements System.Runtime.InteropServices._Module, System.Reflection.ICustomAttributeProvider, System.Runtime.Serialization.ISerializable{ 
        }
        export class ConstructorInfo extends System.Reflection.MethodBase implements System.Runtime.InteropServices._MethodBase, System.Runtime.InteropServices._ConstructorInfo, System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._MemberInfo{ 
        }
        export enum CallingConventions{ Standard = 1, VarArgs = 2, Any = 3, HasThis = 32, ExplicitThis = 64 }
        export class FieldInfo extends System.Reflection.MemberInfo implements System.Runtime.InteropServices._FieldInfo, System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._MemberInfo{ 
        }
        interface FieldInfo {
            IsReadOnly():boolean;
            IsConstant():boolean;
            GetBaseDefinition():System.Reflection.FieldInfo;
        }
        export type TypeFilter = (m: System.Type, filterCriteria: any) => boolean;
        var TypeFilter: {new (func: (m: System.Type, filterCriteria: any) => boolean): TypeFilter;}
        export class EventInfo extends System.Reflection.MemberInfo implements System.Runtime.InteropServices._EventInfo, System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._MemberInfo{ 
        }
        interface EventInfo {
            IsStatic():boolean;
        }
        export class PropertyInfo extends System.Reflection.MemberInfo implements System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._PropertyInfo, System.Runtime.InteropServices._MemberInfo{ 
        }
        interface PropertyInfo {
            GetEntityType($enclosedType: $Ref<SQLiteNetExtensions.Extensions.EnclosedType>):System.Type;
            GetColumnName():string;
            RTGetGetMethod():System.Reflection.MethodInfo;
            RTGetSetMethod():System.Reflection.MethodInfo;
            IsStatic():boolean;
            GetBaseDefinition():System.Reflection.PropertyInfo;
            IsIndexerProperty():boolean;
            IsAutoProperty():boolean;
        }
        export enum TypeAttributes{ VisibilityMask = 7, NotPublic = 0, Public = 1, NestedPublic = 2, NestedPrivate = 3, NestedFamily = 4, NestedAssembly = 5, NestedFamANDAssem = 6, NestedFamORAssem = 7, LayoutMask = 24, AutoLayout = 0, SequentialLayout = 8, ExplicitLayout = 16, ClassSemanticsMask = 32, Class = 0, Interface = 32, Abstract = 128, Sealed = 256, SpecialName = 1024, Import = 4096, Serializable = 8192, WindowsRuntime = 16384, StringFormatMask = 196608, AnsiClass = 0, UnicodeClass = 65536, AutoClass = 131072, CustomFormatClass = 196608, CustomFormatMask = 12582912, BeforeFieldInit = 1048576, ReservedMask = 264192, RTSpecialName = 2048, HasSecurity = 262144 }
        export enum GenericParameterAttributes{ None = 0, VarianceMask = 3, Covariant = 1, Contravariant = 2, SpecialConstraintMask = 28, ReferenceTypeConstraint = 4, NotNullableValueTypeConstraint = 8, DefaultConstructorConstraint = 16 }
        export class InterfaceMapping extends System.ValueType{ 
        }
        export class ParameterInfo extends System.Object implements System.Runtime.InteropServices._ParameterInfo, System.Runtime.Serialization.IObjectReference, System.Reflection.ICustomAttributeProvider{ 
        }
        interface ParameterInfo {
            IsParams($parameters: System.Array$1<System.Reflection.ParameterInfo>):boolean;
        }
    }
    export namespace System.Collections.ObjectModel {
        export class ReadOnlyCollection$1<T> extends System.Object implements System.Collections.IEnumerable, System.Collections.Generic.IList$1<T>, System.Collections.Generic.IReadOnlyCollection$1<T>, System.Collections.Generic.IReadOnlyList$1<T>, System.Collections.IList, System.Collections.Generic.ICollection$1<T>, System.Collections.ICollection, System.Collections.Generic.IEnumerable$1<T>{ 
        }
    }
    export namespace PuertsTest {
        export class TestClass extends System.Object{ 
            public AddEventCallback1($callback1: PuertsTest.Callback1):void;
            public RemoveEventCallback1($callback1: PuertsTest.Callback1):void;
            public AddEventCallback2($callback2: PuertsTest.Callback2):void;
            public Trigger():void;
            public Foo():void;
            public constructor();
        }
        export type Callback1 = (obj: PuertsTest.TestClass) => void;
        var Callback1: {new (func: (obj: PuertsTest.TestClass) => void): Callback1;}
        export type Callback2 = (str: number) => void;
        var Callback2: {new (func: (str: number) => void): Callback2;}
        export class BaseClass extends System.Object{ 
            public static BSF: number;
            public get BMF(): number;
            public set BMF(value: number);
            public static BSFunc():void;
            public BMFunc():void;
            public constructor();
        }
        interface BaseClass {
            PlainExtension():void;
            Extension1():PuertsTest.BaseClass;
            Extension2($b: UnityEngine.GameObject):PuertsTest.BaseClass;
            Extension2($b: PuertsTest.BaseClass1):void;
        }
        export class DerivedClass extends PuertsTest.BaseClass{ 
            public static DSF: number;
            public MyCallback: PuertsTest.MyCallback;
            public get DMF(): number;
            public set DMF(value: number);
            public static DSFunc():void;
            public DMFunc():void;
            public DMFunc($myEnum: PuertsTest.MyEnum):PuertsTest.MyEnum;
            public add_MyEvent($value: PuertsTest.MyCallback):void;
            public remove_MyEvent($value: PuertsTest.MyCallback):void;
            public static add_MyStaticEvent($value: PuertsTest.MyCallback):void;
            public static remove_MyStaticEvent($value: PuertsTest.MyCallback):void;
            public Trigger():void;
            public ParamsFunc($a: number, ...b: string[]):number;
            public InOutArgFunc($a: number, $b: $Ref<number>, $c: $Ref<number>):number;
            public PrintList($lst: System.Collections.Generic.List$1<number>):void;
            public GetAb($size: number):ArrayBuffer;
            public SumOfAb($ab: ArrayBuffer):number;
            public GetFileLength($path: string):System.Threading.Tasks.Task$1<number>;
            public constructor();
        }
        export type MyCallback = (msg: string) => void;
        var MyCallback: {new (func: (msg: string) => void): MyCallback;}
        export enum MyEnum{ E1 = 0, E2 = 1 }
        export class BaseClassExtension extends System.Object{ 
            public static PlainExtension($a: PuertsTest.BaseClass):void;
            public static Extension1($a: PuertsTest.BaseClass):PuertsTest.BaseClass;
            public static Extension2($a: PuertsTest.BaseClass, $b: UnityEngine.GameObject):PuertsTest.BaseClass;
            public static Extension2($a: PuertsTest.BaseClass, $b: PuertsTest.BaseClass1):void;
        }
        export class BaseClass1 extends System.Object{ 
        }
    }
    export namespace System.Collections.Generic.List$1 {
        export class Enumerator<T> extends System.ValueType implements System.Collections.Generic.IEnumerator$1<T>, System.Collections.IEnumerator, System.IDisposable{ 
        }
    }
    export namespace System.Collections.Generic.Dictionary$2 {
        export class KeyCollection<TKey, TValue> extends System.Object implements System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<TKey>, System.Collections.Generic.ICollection$1<TKey>, System.Collections.ICollection, System.Collections.Generic.IEnumerable$1<TKey>{ 
        }
        export class ValueCollection<TKey, TValue> extends System.Object implements System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<TValue>, System.Collections.Generic.ICollection$1<TValue>, System.Collections.ICollection, System.Collections.Generic.IEnumerable$1<TValue>{ 
        }
        export class Enumerator<TKey, TValue> extends System.ValueType implements System.Collections.Generic.IEnumerator$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>, System.Collections.IDictionaryEnumerator, System.Collections.IEnumerator, System.IDisposable{ 
        }
    }
    export namespace Puerts {
        export class ArrayBuffer extends System.Object{ 
        }
        export interface ILoader{ 
            FileExists($filepath: string):boolean;
            ReadFile($filepath: string, $debugpath: $Ref<string>):string;
        }
        export class JsEnv extends System.Object implements System.IDisposable{ 
            public static jsEnvs: System.Collections.Generic.List$1<Puerts.JsEnv>;
            public static OnJsEnvCreate: Puerts.JsEnv.JsEnvCreateCallback;
            public static OnJsEnvDispose: Puerts.JsEnv.JsEnvDisposeCallback;
            public debugPort: number;
            public get Index(): number;
            public Eval($chunk: string, $chunkName?: string):void;
            public ClearModuleCache():void;
            public static ClearAllModuleCaches():void;
            public AddLazyStaticWrapLoader($type: System.Type, $lazyStaticWrapLoader: System.Func$1<Puerts.TypeRegisterInfo>):void;
            public RegisterGeneralGetSet($type: System.Type, $getter: Puerts.GeneralGetter, $setter: Puerts.GeneralSetter):void;
            public GetTypeId($type: System.Type):number;
            public LowMemoryNotification():void;
            public Tick():void;
            public WaitDebugger():void;
            public WaitDebuggerAsync():System.Threading.Tasks.Task;
            public Dispose():void;
            public constructor($mode?: Puerts.JsEnvMode);
            public constructor($loader: Puerts.ILoader, $debugPort?: number, $mode?: Puerts.JsEnvMode);
            public constructor($loader: Puerts.ILoader, $externalRuntime: System.IntPtr, $externalContext: System.IntPtr);
            public constructor($loader: Puerts.ILoader, $debugPort: number, $externalRuntime: System.IntPtr, $externalContext: System.IntPtr);
            public constructor($loader: Puerts.ILoader, $debugPort: number, $mode: Puerts.JsEnvMode, $externalRuntime: System.IntPtr, $externalContext: System.IntPtr);
            public constructor();
        }
        interface JsEnv {
            IsDisposed():boolean;
        }
        export class TypeRegisterInfo extends System.Object{ 
        }
        export type GeneralGetter = (isolate: System.IntPtr, getValueApi: Puerts.IGetValueFromJs, value: System.IntPtr, isByRef: boolean) => any;
        var GeneralGetter: {new (func: (isolate: System.IntPtr, getValueApi: Puerts.IGetValueFromJs, value: System.IntPtr, isByRef: boolean) => any): GeneralGetter;}
        export interface IGetValueFromJs{ 
        }
        export type GeneralSetter = (isolate: System.IntPtr, setValueApi: Puerts.ISetValueToJs, holder: System.IntPtr, obj: any) => void;
        var GeneralSetter: {new (func: (isolate: System.IntPtr, setValueApi: Puerts.ISetValueToJs, holder: System.IntPtr, obj: any) => void): GeneralSetter;}
        export interface ISetValueToJs{ 
        }
        export enum JsEnvMode{ Default = 0, Node = 1, External = 2 }
    }
    export namespace System.Threading.Tasks {
        export class Task$1<TResult> extends System.Threading.Tasks.Task implements System.IAsyncResult, System.Threading.IThreadPoolWorkItem, System.IDisposable{ 
        }
        export class Task extends System.Object implements System.IAsyncResult, System.Threading.IThreadPoolWorkItem, System.IDisposable{ 
        }
    }
    export namespace System.Threading {
        export interface IThreadPoolWorkItem{ 
        }
        export class Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements System.Runtime.InteropServices._Thread{ 
        }
    }
    export namespace UnityEngine.SceneManagement {
        export class Scene extends System.ValueType{ 
        }
        interface Scene {
            GetPhysicsScene():UnityEngine.PhysicsScene;
            GetPhysicsScene2D():UnityEngine.PhysicsScene2D;
            SetDirty():void;
        }
        export enum LoadSceneMode{ Single = 0, Additive = 1 }
    }
    export namespace System.Security {
        export interface IEvidenceFactory{ 
        }
    }
    export namespace System.Globalization {
        export class CultureInfo extends System.Object implements System.ICloneable, System.IFormatProvider{ 
        }
    }
    export namespace UnityEngine.ParticleSystem {
        export class Particle extends System.ValueType{ 
            public get position(): UnityEngine.Vector3;
            public set position(value: UnityEngine.Vector3);
            public get velocity(): UnityEngine.Vector3;
            public set velocity(value: UnityEngine.Vector3);
            public get animatedVelocity(): UnityEngine.Vector3;
            public get totalVelocity(): UnityEngine.Vector3;
            public get remainingLifetime(): number;
            public set remainingLifetime(value: number);
            public get startLifetime(): number;
            public set startLifetime(value: number);
            public get startColor(): UnityEngine.Color32;
            public set startColor(value: UnityEngine.Color32);
            public get randomSeed(): number;
            public set randomSeed(value: number);
            public get axisOfRotation(): UnityEngine.Vector3;
            public set axisOfRotation(value: UnityEngine.Vector3);
            public get startSize(): number;
            public set startSize(value: number);
            public get startSize3D(): UnityEngine.Vector3;
            public set startSize3D(value: UnityEngine.Vector3);
            public get rotation(): number;
            public set rotation(value: number);
            public get rotation3D(): UnityEngine.Vector3;
            public set rotation3D(value: UnityEngine.Vector3);
            public get angularVelocity(): number;
            public set angularVelocity(value: number);
            public get angularVelocity3D(): UnityEngine.Vector3;
            public set angularVelocity3D(value: UnityEngine.Vector3);
            public GetCurrentSize($system: UnityEngine.ParticleSystem):number;
            public GetCurrentSize3D($system: UnityEngine.ParticleSystem):UnityEngine.Vector3;
            public GetCurrentColor($system: UnityEngine.ParticleSystem):UnityEngine.Color32;
            public SetMeshIndex($index: number):void;
            public GetMeshIndex($system: UnityEngine.ParticleSystem):number;
        }
        export class PlaybackState extends System.ValueType{ 
        }
        export class Trails extends System.ValueType{ 
        }
        export class EmitParams extends System.ValueType{ 
            public get particle(): UnityEngine.ParticleSystem.Particle;
            public set particle(value: UnityEngine.ParticleSystem.Particle);
            public get position(): UnityEngine.Vector3;
            public set position(value: UnityEngine.Vector3);
            public get applyShapeToPosition(): boolean;
            public set applyShapeToPosition(value: boolean);
            public get velocity(): UnityEngine.Vector3;
            public set velocity(value: UnityEngine.Vector3);
            public get startLifetime(): number;
            public set startLifetime(value: number);
            public get startSize(): number;
            public set startSize(value: number);
            public get startSize3D(): UnityEngine.Vector3;
            public set startSize3D(value: UnityEngine.Vector3);
            public get axisOfRotation(): UnityEngine.Vector3;
            public set axisOfRotation(value: UnityEngine.Vector3);
            public get rotation(): number;
            public set rotation(value: number);
            public get rotation3D(): UnityEngine.Vector3;
            public set rotation3D(value: UnityEngine.Vector3);
            public get angularVelocity(): number;
            public set angularVelocity(value: number);
            public get angularVelocity3D(): UnityEngine.Vector3;
            public set angularVelocity3D(value: UnityEngine.Vector3);
            public get startColor(): UnityEngine.Color32;
            public set startColor(value: UnityEngine.Color32);
            public get randomSeed(): number;
            public set randomSeed(value: number);
            public set meshIndex(value: number);
            public ResetPosition():void;
            public ResetVelocity():void;
            public ResetAxisOfRotation():void;
            public ResetRotation():void;
            public ResetAngularVelocity():void;
            public ResetStartSize():void;
            public ResetStartColor():void;
            public ResetRandomSeed():void;
            public ResetStartLifetime():void;
            public ResetMeshIndex():void;
        }
        export class MainModule extends System.ValueType{ 
            public get emitterVelocity(): UnityEngine.Vector3;
            public set emitterVelocity(value: UnityEngine.Vector3);
            public get duration(): number;
            public set duration(value: number);
            public get loop(): boolean;
            public set loop(value: boolean);
            public get prewarm(): boolean;
            public set prewarm(value: boolean);
            public get startDelay(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startDelay(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startDelayMultiplier(): number;
            public set startDelayMultiplier(value: number);
            public get startLifetime(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startLifetime(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startLifetimeMultiplier(): number;
            public set startLifetimeMultiplier(value: number);
            public get startSpeed(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startSpeed(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startSpeedMultiplier(): number;
            public set startSpeedMultiplier(value: number);
            public get startSize3D(): boolean;
            public set startSize3D(value: boolean);
            public get startSize(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startSize(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startSizeMultiplier(): number;
            public set startSizeMultiplier(value: number);
            public get startSizeX(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startSizeX(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startSizeXMultiplier(): number;
            public set startSizeXMultiplier(value: number);
            public get startSizeY(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startSizeY(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startSizeYMultiplier(): number;
            public set startSizeYMultiplier(value: number);
            public get startSizeZ(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startSizeZ(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startSizeZMultiplier(): number;
            public set startSizeZMultiplier(value: number);
            public get startRotation3D(): boolean;
            public set startRotation3D(value: boolean);
            public get startRotation(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startRotation(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startRotationMultiplier(): number;
            public set startRotationMultiplier(value: number);
            public get startRotationX(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startRotationX(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startRotationXMultiplier(): number;
            public set startRotationXMultiplier(value: number);
            public get startRotationY(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startRotationY(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startRotationYMultiplier(): number;
            public set startRotationYMultiplier(value: number);
            public get startRotationZ(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startRotationZ(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startRotationZMultiplier(): number;
            public set startRotationZMultiplier(value: number);
            public get flipRotation(): number;
            public set flipRotation(value: number);
            public get startColor(): UnityEngine.ParticleSystem.MinMaxGradient;
            public set startColor(value: UnityEngine.ParticleSystem.MinMaxGradient);
            public get gravityModifier(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set gravityModifier(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get gravityModifierMultiplier(): number;
            public set gravityModifierMultiplier(value: number);
            public get simulationSpace(): UnityEngine.ParticleSystemSimulationSpace;
            public set simulationSpace(value: UnityEngine.ParticleSystemSimulationSpace);
            public get customSimulationSpace(): UnityEngine.Transform;
            public set customSimulationSpace(value: UnityEngine.Transform);
            public get simulationSpeed(): number;
            public set simulationSpeed(value: number);
            public get useUnscaledTime(): boolean;
            public set useUnscaledTime(value: boolean);
            public get scalingMode(): UnityEngine.ParticleSystemScalingMode;
            public set scalingMode(value: UnityEngine.ParticleSystemScalingMode);
            public get playOnAwake(): boolean;
            public set playOnAwake(value: boolean);
            public get maxParticles(): number;
            public set maxParticles(value: number);
            public get emitterVelocityMode(): UnityEngine.ParticleSystemEmitterVelocityMode;
            public set emitterVelocityMode(value: UnityEngine.ParticleSystemEmitterVelocityMode);
            public get stopAction(): UnityEngine.ParticleSystemStopAction;
            public set stopAction(value: UnityEngine.ParticleSystemStopAction);
            public get ringBufferMode(): UnityEngine.ParticleSystemRingBufferMode;
            public set ringBufferMode(value: UnityEngine.ParticleSystemRingBufferMode);
            public get ringBufferLoopRange(): UnityEngine.Vector2;
            public set ringBufferLoopRange(value: UnityEngine.Vector2);
            public get cullingMode(): UnityEngine.ParticleSystemCullingMode;
            public set cullingMode(value: UnityEngine.ParticleSystemCullingMode);
        }
        export class EmissionModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get rateOverTime(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set rateOverTime(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get rateOverTimeMultiplier(): number;
            public set rateOverTimeMultiplier(value: number);
            public get rateOverDistance(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set rateOverDistance(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get rateOverDistanceMultiplier(): number;
            public set rateOverDistanceMultiplier(value: number);
            public get burstCount(): number;
            public set burstCount(value: number);
            public SetBursts($bursts: System.Array$1<UnityEngine.ParticleSystem.Burst>):void;
            public SetBursts($bursts: System.Array$1<UnityEngine.ParticleSystem.Burst>, $size: number):void;
            public GetBursts($bursts: System.Array$1<UnityEngine.ParticleSystem.Burst>):number;
            public SetBurst($index: number, $burst: UnityEngine.ParticleSystem.Burst):void;
            public GetBurst($index: number):UnityEngine.ParticleSystem.Burst;
        }
        export class ShapeModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get shapeType(): UnityEngine.ParticleSystemShapeType;
            public set shapeType(value: UnityEngine.ParticleSystemShapeType);
            public get randomDirectionAmount(): number;
            public set randomDirectionAmount(value: number);
            public get sphericalDirectionAmount(): number;
            public set sphericalDirectionAmount(value: number);
            public get randomPositionAmount(): number;
            public set randomPositionAmount(value: number);
            public get alignToDirection(): boolean;
            public set alignToDirection(value: boolean);
            public get radius(): number;
            public set radius(value: number);
            public get radiusMode(): UnityEngine.ParticleSystemShapeMultiModeValue;
            public set radiusMode(value: UnityEngine.ParticleSystemShapeMultiModeValue);
            public get radiusSpread(): number;
            public set radiusSpread(value: number);
            public get radiusSpeed(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set radiusSpeed(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get radiusSpeedMultiplier(): number;
            public set radiusSpeedMultiplier(value: number);
            public get radiusThickness(): number;
            public set radiusThickness(value: number);
            public get angle(): number;
            public set angle(value: number);
            public get length(): number;
            public set length(value: number);
            public get boxThickness(): UnityEngine.Vector3;
            public set boxThickness(value: UnityEngine.Vector3);
            public get meshShapeType(): UnityEngine.ParticleSystemMeshShapeType;
            public set meshShapeType(value: UnityEngine.ParticleSystemMeshShapeType);
            public get mesh(): UnityEngine.Mesh;
            public set mesh(value: UnityEngine.Mesh);
            public get meshRenderer(): UnityEngine.MeshRenderer;
            public set meshRenderer(value: UnityEngine.MeshRenderer);
            public get skinnedMeshRenderer(): UnityEngine.SkinnedMeshRenderer;
            public set skinnedMeshRenderer(value: UnityEngine.SkinnedMeshRenderer);
            public get sprite(): UnityEngine.Sprite;
            public set sprite(value: UnityEngine.Sprite);
            public get spriteRenderer(): UnityEngine.SpriteRenderer;
            public set spriteRenderer(value: UnityEngine.SpriteRenderer);
            public get useMeshMaterialIndex(): boolean;
            public set useMeshMaterialIndex(value: boolean);
            public get meshMaterialIndex(): number;
            public set meshMaterialIndex(value: number);
            public get useMeshColors(): boolean;
            public set useMeshColors(value: boolean);
            public get normalOffset(): number;
            public set normalOffset(value: number);
            public get meshSpawnMode(): UnityEngine.ParticleSystemShapeMultiModeValue;
            public set meshSpawnMode(value: UnityEngine.ParticleSystemShapeMultiModeValue);
            public get meshSpawnSpread(): number;
            public set meshSpawnSpread(value: number);
            public get meshSpawnSpeed(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set meshSpawnSpeed(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get meshSpawnSpeedMultiplier(): number;
            public set meshSpawnSpeedMultiplier(value: number);
            public get arc(): number;
            public set arc(value: number);
            public get arcMode(): UnityEngine.ParticleSystemShapeMultiModeValue;
            public set arcMode(value: UnityEngine.ParticleSystemShapeMultiModeValue);
            public get arcSpread(): number;
            public set arcSpread(value: number);
            public get arcSpeed(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set arcSpeed(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get arcSpeedMultiplier(): number;
            public set arcSpeedMultiplier(value: number);
            public get donutRadius(): number;
            public set donutRadius(value: number);
            public get position(): UnityEngine.Vector3;
            public set position(value: UnityEngine.Vector3);
            public get rotation(): UnityEngine.Vector3;
            public set rotation(value: UnityEngine.Vector3);
            public get scale(): UnityEngine.Vector3;
            public set scale(value: UnityEngine.Vector3);
            public get texture(): UnityEngine.Texture2D;
            public set texture(value: UnityEngine.Texture2D);
            public get textureClipChannel(): UnityEngine.ParticleSystemShapeTextureChannel;
            public set textureClipChannel(value: UnityEngine.ParticleSystemShapeTextureChannel);
            public get textureClipThreshold(): number;
            public set textureClipThreshold(value: number);
            public get textureColorAffectsParticles(): boolean;
            public set textureColorAffectsParticles(value: boolean);
            public get textureAlphaAffectsParticles(): boolean;
            public set textureAlphaAffectsParticles(value: boolean);
            public get textureBilinearFiltering(): boolean;
            public set textureBilinearFiltering(value: boolean);
            public get textureUVChannel(): number;
            public set textureUVChannel(value: number);
        }
        export class VelocityOverLifetimeModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get x(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set x(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get y(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set y(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get z(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set z(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get xMultiplier(): number;
            public set xMultiplier(value: number);
            public get yMultiplier(): number;
            public set yMultiplier(value: number);
            public get zMultiplier(): number;
            public set zMultiplier(value: number);
            public get orbitalX(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set orbitalX(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get orbitalY(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set orbitalY(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get orbitalZ(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set orbitalZ(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get orbitalXMultiplier(): number;
            public set orbitalXMultiplier(value: number);
            public get orbitalYMultiplier(): number;
            public set orbitalYMultiplier(value: number);
            public get orbitalZMultiplier(): number;
            public set orbitalZMultiplier(value: number);
            public get orbitalOffsetX(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set orbitalOffsetX(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get orbitalOffsetY(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set orbitalOffsetY(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get orbitalOffsetZ(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set orbitalOffsetZ(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get orbitalOffsetXMultiplier(): number;
            public set orbitalOffsetXMultiplier(value: number);
            public get orbitalOffsetYMultiplier(): number;
            public set orbitalOffsetYMultiplier(value: number);
            public get orbitalOffsetZMultiplier(): number;
            public set orbitalOffsetZMultiplier(value: number);
            public get radial(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set radial(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get radialMultiplier(): number;
            public set radialMultiplier(value: number);
            public get speedModifier(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set speedModifier(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get speedModifierMultiplier(): number;
            public set speedModifierMultiplier(value: number);
            public get space(): UnityEngine.ParticleSystemSimulationSpace;
            public set space(value: UnityEngine.ParticleSystemSimulationSpace);
        }
        export class LimitVelocityOverLifetimeModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get limitX(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set limitX(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get limitXMultiplier(): number;
            public set limitXMultiplier(value: number);
            public get limitY(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set limitY(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get limitYMultiplier(): number;
            public set limitYMultiplier(value: number);
            public get limitZ(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set limitZ(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get limitZMultiplier(): number;
            public set limitZMultiplier(value: number);
            public get limit(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set limit(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get limitMultiplier(): number;
            public set limitMultiplier(value: number);
            public get dampen(): number;
            public set dampen(value: number);
            public get separateAxes(): boolean;
            public set separateAxes(value: boolean);
            public get space(): UnityEngine.ParticleSystemSimulationSpace;
            public set space(value: UnityEngine.ParticleSystemSimulationSpace);
            public get drag(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set drag(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get dragMultiplier(): number;
            public set dragMultiplier(value: number);
            public get multiplyDragByParticleSize(): boolean;
            public set multiplyDragByParticleSize(value: boolean);
            public get multiplyDragByParticleVelocity(): boolean;
            public set multiplyDragByParticleVelocity(value: boolean);
        }
        export class InheritVelocityModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get mode(): UnityEngine.ParticleSystemInheritVelocityMode;
            public set mode(value: UnityEngine.ParticleSystemInheritVelocityMode);
            public get curve(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set curve(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get curveMultiplier(): number;
            public set curveMultiplier(value: number);
        }
        export class LifetimeByEmitterSpeedModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get curve(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set curve(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get curveMultiplier(): number;
            public set curveMultiplier(value: number);
            public get range(): UnityEngine.Vector2;
            public set range(value: UnityEngine.Vector2);
        }
        export class ForceOverLifetimeModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get x(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set x(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get y(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set y(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get z(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set z(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get xMultiplier(): number;
            public set xMultiplier(value: number);
            public get yMultiplier(): number;
            public set yMultiplier(value: number);
            public get zMultiplier(): number;
            public set zMultiplier(value: number);
            public get space(): UnityEngine.ParticleSystemSimulationSpace;
            public set space(value: UnityEngine.ParticleSystemSimulationSpace);
            public get randomized(): boolean;
            public set randomized(value: boolean);
        }
        export class ColorOverLifetimeModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get color(): UnityEngine.ParticleSystem.MinMaxGradient;
            public set color(value: UnityEngine.ParticleSystem.MinMaxGradient);
        }
        export class ColorBySpeedModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get color(): UnityEngine.ParticleSystem.MinMaxGradient;
            public set color(value: UnityEngine.ParticleSystem.MinMaxGradient);
            public get range(): UnityEngine.Vector2;
            public set range(value: UnityEngine.Vector2);
        }
        export class SizeOverLifetimeModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get size(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set size(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get sizeMultiplier(): number;
            public set sizeMultiplier(value: number);
            public get x(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set x(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get xMultiplier(): number;
            public set xMultiplier(value: number);
            public get y(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set y(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get yMultiplier(): number;
            public set yMultiplier(value: number);
            public get z(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set z(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get zMultiplier(): number;
            public set zMultiplier(value: number);
            public get separateAxes(): boolean;
            public set separateAxes(value: boolean);
        }
        export class SizeBySpeedModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get size(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set size(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get sizeMultiplier(): number;
            public set sizeMultiplier(value: number);
            public get x(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set x(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get xMultiplier(): number;
            public set xMultiplier(value: number);
            public get y(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set y(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get yMultiplier(): number;
            public set yMultiplier(value: number);
            public get z(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set z(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get zMultiplier(): number;
            public set zMultiplier(value: number);
            public get separateAxes(): boolean;
            public set separateAxes(value: boolean);
            public get range(): UnityEngine.Vector2;
            public set range(value: UnityEngine.Vector2);
        }
        export class RotationOverLifetimeModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get x(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set x(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get xMultiplier(): number;
            public set xMultiplier(value: number);
            public get y(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set y(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get yMultiplier(): number;
            public set yMultiplier(value: number);
            public get z(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set z(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get zMultiplier(): number;
            public set zMultiplier(value: number);
            public get separateAxes(): boolean;
            public set separateAxes(value: boolean);
        }
        export class RotationBySpeedModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get x(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set x(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get xMultiplier(): number;
            public set xMultiplier(value: number);
            public get y(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set y(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get yMultiplier(): number;
            public set yMultiplier(value: number);
            public get z(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set z(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get zMultiplier(): number;
            public set zMultiplier(value: number);
            public get separateAxes(): boolean;
            public set separateAxes(value: boolean);
            public get range(): UnityEngine.Vector2;
            public set range(value: UnityEngine.Vector2);
        }
        export class ExternalForcesModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get multiplier(): number;
            public set multiplier(value: number);
            public get multiplierCurve(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set multiplierCurve(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get influenceFilter(): UnityEngine.ParticleSystemGameObjectFilter;
            public set influenceFilter(value: UnityEngine.ParticleSystemGameObjectFilter);
            public get influenceMask(): UnityEngine.LayerMask;
            public set influenceMask(value: UnityEngine.LayerMask);
            public get influenceCount(): number;
            public IsAffectedBy($field: UnityEngine.ParticleSystemForceField):boolean;
            public AddInfluence($field: UnityEngine.ParticleSystemForceField):void;
            public RemoveInfluence($index: number):void;
            public RemoveInfluence($field: UnityEngine.ParticleSystemForceField):void;
            public RemoveAllInfluences():void;
            public SetInfluence($index: number, $field: UnityEngine.ParticleSystemForceField):void;
            public GetInfluence($index: number):UnityEngine.ParticleSystemForceField;
        }
        export class NoiseModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get separateAxes(): boolean;
            public set separateAxes(value: boolean);
            public get strength(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set strength(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get strengthMultiplier(): number;
            public set strengthMultiplier(value: number);
            public get strengthX(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set strengthX(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get strengthXMultiplier(): number;
            public set strengthXMultiplier(value: number);
            public get strengthY(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set strengthY(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get strengthYMultiplier(): number;
            public set strengthYMultiplier(value: number);
            public get strengthZ(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set strengthZ(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get strengthZMultiplier(): number;
            public set strengthZMultiplier(value: number);
            public get frequency(): number;
            public set frequency(value: number);
            public get damping(): boolean;
            public set damping(value: boolean);
            public get octaveCount(): number;
            public set octaveCount(value: number);
            public get octaveMultiplier(): number;
            public set octaveMultiplier(value: number);
            public get octaveScale(): number;
            public set octaveScale(value: number);
            public get quality(): UnityEngine.ParticleSystemNoiseQuality;
            public set quality(value: UnityEngine.ParticleSystemNoiseQuality);
            public get scrollSpeed(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set scrollSpeed(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get scrollSpeedMultiplier(): number;
            public set scrollSpeedMultiplier(value: number);
            public get remapEnabled(): boolean;
            public set remapEnabled(value: boolean);
            public get remap(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set remap(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get remapMultiplier(): number;
            public set remapMultiplier(value: number);
            public get remapX(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set remapX(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get remapXMultiplier(): number;
            public set remapXMultiplier(value: number);
            public get remapY(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set remapY(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get remapYMultiplier(): number;
            public set remapYMultiplier(value: number);
            public get remapZ(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set remapZ(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get remapZMultiplier(): number;
            public set remapZMultiplier(value: number);
            public get positionAmount(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set positionAmount(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get rotationAmount(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set rotationAmount(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get sizeAmount(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set sizeAmount(value: UnityEngine.ParticleSystem.MinMaxCurve);
        }
        export class CollisionModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get type(): UnityEngine.ParticleSystemCollisionType;
            public set type(value: UnityEngine.ParticleSystemCollisionType);
            public get mode(): UnityEngine.ParticleSystemCollisionMode;
            public set mode(value: UnityEngine.ParticleSystemCollisionMode);
            public get dampen(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set dampen(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get dampenMultiplier(): number;
            public set dampenMultiplier(value: number);
            public get bounce(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set bounce(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get bounceMultiplier(): number;
            public set bounceMultiplier(value: number);
            public get lifetimeLoss(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set lifetimeLoss(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get lifetimeLossMultiplier(): number;
            public set lifetimeLossMultiplier(value: number);
            public get minKillSpeed(): number;
            public set minKillSpeed(value: number);
            public get maxKillSpeed(): number;
            public set maxKillSpeed(value: number);
            public get collidesWith(): UnityEngine.LayerMask;
            public set collidesWith(value: UnityEngine.LayerMask);
            public get enableDynamicColliders(): boolean;
            public set enableDynamicColliders(value: boolean);
            public get maxCollisionShapes(): number;
            public set maxCollisionShapes(value: number);
            public get quality(): UnityEngine.ParticleSystemCollisionQuality;
            public set quality(value: UnityEngine.ParticleSystemCollisionQuality);
            public get voxelSize(): number;
            public set voxelSize(value: number);
            public get radiusScale(): number;
            public set radiusScale(value: number);
            public get sendCollisionMessages(): boolean;
            public set sendCollisionMessages(value: boolean);
            public get colliderForce(): number;
            public set colliderForce(value: number);
            public get multiplyColliderForceByCollisionAngle(): boolean;
            public set multiplyColliderForceByCollisionAngle(value: boolean);
            public get multiplyColliderForceByParticleSpeed(): boolean;
            public set multiplyColliderForceByParticleSpeed(value: boolean);
            public get multiplyColliderForceByParticleSize(): boolean;
            public set multiplyColliderForceByParticleSize(value: boolean);
            public get planeCount(): number;
            public AddPlane($transform: UnityEngine.Transform):void;
            public RemovePlane($index: number):void;
            public RemovePlane($transform: UnityEngine.Transform):void;
            public SetPlane($index: number, $transform: UnityEngine.Transform):void;
            public GetPlane($index: number):UnityEngine.Transform;
        }
        export class TriggerModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get inside(): UnityEngine.ParticleSystemOverlapAction;
            public set inside(value: UnityEngine.ParticleSystemOverlapAction);
            public get outside(): UnityEngine.ParticleSystemOverlapAction;
            public set outside(value: UnityEngine.ParticleSystemOverlapAction);
            public get enter(): UnityEngine.ParticleSystemOverlapAction;
            public set enter(value: UnityEngine.ParticleSystemOverlapAction);
            public get exit(): UnityEngine.ParticleSystemOverlapAction;
            public set exit(value: UnityEngine.ParticleSystemOverlapAction);
            public get colliderQueryMode(): UnityEngine.ParticleSystemColliderQueryMode;
            public set colliderQueryMode(value: UnityEngine.ParticleSystemColliderQueryMode);
            public get radiusScale(): number;
            public set radiusScale(value: number);
            public get colliderCount(): number;
            public AddCollider($collider: UnityEngine.Component):void;
            public RemoveCollider($index: number):void;
            public RemoveCollider($collider: UnityEngine.Component):void;
            public SetCollider($index: number, $collider: UnityEngine.Component):void;
            public GetCollider($index: number):UnityEngine.Component;
        }
        export class SubEmittersModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get subEmittersCount(): number;
            public AddSubEmitter($subEmitter: UnityEngine.ParticleSystem, $type: UnityEngine.ParticleSystemSubEmitterType, $properties: UnityEngine.ParticleSystemSubEmitterProperties, $emitProbability: number):void;
            public AddSubEmitter($subEmitter: UnityEngine.ParticleSystem, $type: UnityEngine.ParticleSystemSubEmitterType, $properties: UnityEngine.ParticleSystemSubEmitterProperties):void;
            public RemoveSubEmitter($index: number):void;
            public RemoveSubEmitter($subEmitter: UnityEngine.ParticleSystem):void;
            public SetSubEmitterSystem($index: number, $subEmitter: UnityEngine.ParticleSystem):void;
            public SetSubEmitterType($index: number, $type: UnityEngine.ParticleSystemSubEmitterType):void;
            public SetSubEmitterProperties($index: number, $properties: UnityEngine.ParticleSystemSubEmitterProperties):void;
            public SetSubEmitterEmitProbability($index: number, $emitProbability: number):void;
            public GetSubEmitterSystem($index: number):UnityEngine.ParticleSystem;
            public GetSubEmitterType($index: number):UnityEngine.ParticleSystemSubEmitterType;
            public GetSubEmitterProperties($index: number):UnityEngine.ParticleSystemSubEmitterProperties;
            public GetSubEmitterEmitProbability($index: number):number;
        }
        export class TextureSheetAnimationModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get mode(): UnityEngine.ParticleSystemAnimationMode;
            public set mode(value: UnityEngine.ParticleSystemAnimationMode);
            public get timeMode(): UnityEngine.ParticleSystemAnimationTimeMode;
            public set timeMode(value: UnityEngine.ParticleSystemAnimationTimeMode);
            public get fps(): number;
            public set fps(value: number);
            public get numTilesX(): number;
            public set numTilesX(value: number);
            public get numTilesY(): number;
            public set numTilesY(value: number);
            public get animation(): UnityEngine.ParticleSystemAnimationType;
            public set animation(value: UnityEngine.ParticleSystemAnimationType);
            public get rowMode(): UnityEngine.ParticleSystemAnimationRowMode;
            public set rowMode(value: UnityEngine.ParticleSystemAnimationRowMode);
            public get frameOverTime(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set frameOverTime(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get frameOverTimeMultiplier(): number;
            public set frameOverTimeMultiplier(value: number);
            public get startFrame(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startFrame(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startFrameMultiplier(): number;
            public set startFrameMultiplier(value: number);
            public get cycleCount(): number;
            public set cycleCount(value: number);
            public get rowIndex(): number;
            public set rowIndex(value: number);
            public get uvChannelMask(): UnityEngine.Rendering.UVChannelFlags;
            public set uvChannelMask(value: UnityEngine.Rendering.UVChannelFlags);
            public get spriteCount(): number;
            public get speedRange(): UnityEngine.Vector2;
            public set speedRange(value: UnityEngine.Vector2);
            public AddSprite($sprite: UnityEngine.Sprite):void;
            public RemoveSprite($index: number):void;
            public SetSprite($index: number, $sprite: UnityEngine.Sprite):void;
            public GetSprite($index: number):UnityEngine.Sprite;
        }
        export class LightsModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get ratio(): number;
            public set ratio(value: number);
            public get useRandomDistribution(): boolean;
            public set useRandomDistribution(value: boolean);
            public get light(): UnityEngine.Light;
            public set light(value: UnityEngine.Light);
            public get useParticleColor(): boolean;
            public set useParticleColor(value: boolean);
            public get sizeAffectsRange(): boolean;
            public set sizeAffectsRange(value: boolean);
            public get alphaAffectsIntensity(): boolean;
            public set alphaAffectsIntensity(value: boolean);
            public get range(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set range(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get rangeMultiplier(): number;
            public set rangeMultiplier(value: number);
            public get intensity(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set intensity(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get intensityMultiplier(): number;
            public set intensityMultiplier(value: number);
            public get maxLights(): number;
            public set maxLights(value: number);
        }
        export class TrailModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get mode(): UnityEngine.ParticleSystemTrailMode;
            public set mode(value: UnityEngine.ParticleSystemTrailMode);
            public get ratio(): number;
            public set ratio(value: number);
            public get lifetime(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set lifetime(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get lifetimeMultiplier(): number;
            public set lifetimeMultiplier(value: number);
            public get minVertexDistance(): number;
            public set minVertexDistance(value: number);
            public get textureMode(): UnityEngine.ParticleSystemTrailTextureMode;
            public set textureMode(value: UnityEngine.ParticleSystemTrailTextureMode);
            public get worldSpace(): boolean;
            public set worldSpace(value: boolean);
            public get dieWithParticles(): boolean;
            public set dieWithParticles(value: boolean);
            public get sizeAffectsWidth(): boolean;
            public set sizeAffectsWidth(value: boolean);
            public get sizeAffectsLifetime(): boolean;
            public set sizeAffectsLifetime(value: boolean);
            public get inheritParticleColor(): boolean;
            public set inheritParticleColor(value: boolean);
            public get colorOverLifetime(): UnityEngine.ParticleSystem.MinMaxGradient;
            public set colorOverLifetime(value: UnityEngine.ParticleSystem.MinMaxGradient);
            public get widthOverTrail(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set widthOverTrail(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get widthOverTrailMultiplier(): number;
            public set widthOverTrailMultiplier(value: number);
            public get colorOverTrail(): UnityEngine.ParticleSystem.MinMaxGradient;
            public set colorOverTrail(value: UnityEngine.ParticleSystem.MinMaxGradient);
            public get generateLightingData(): boolean;
            public set generateLightingData(value: boolean);
            public get ribbonCount(): number;
            public set ribbonCount(value: number);
            public get shadowBias(): number;
            public set shadowBias(value: number);
            public get splitSubEmitterRibbons(): boolean;
            public set splitSubEmitterRibbons(value: boolean);
            public get attachRibbonsToTransform(): boolean;
            public set attachRibbonsToTransform(value: boolean);
        }
        export class CustomDataModule extends System.ValueType{ 
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public SetMode($stream: UnityEngine.ParticleSystemCustomData, $mode: UnityEngine.ParticleSystemCustomDataMode):void;
            public GetMode($stream: UnityEngine.ParticleSystemCustomData):UnityEngine.ParticleSystemCustomDataMode;
            public SetVectorComponentCount($stream: UnityEngine.ParticleSystemCustomData, $count: number):void;
            public GetVectorComponentCount($stream: UnityEngine.ParticleSystemCustomData):number;
            public SetVector($stream: UnityEngine.ParticleSystemCustomData, $component: number, $curve: UnityEngine.ParticleSystem.MinMaxCurve):void;
            public GetVector($stream: UnityEngine.ParticleSystemCustomData, $component: number):UnityEngine.ParticleSystem.MinMaxCurve;
            public SetColor($stream: UnityEngine.ParticleSystemCustomData, $gradient: UnityEngine.ParticleSystem.MinMaxGradient):void;
            public GetColor($stream: UnityEngine.ParticleSystemCustomData):UnityEngine.ParticleSystem.MinMaxGradient;
        }
        export class MinMaxCurve extends System.ValueType{ 
            public get mode(): UnityEngine.ParticleSystemCurveMode;
            public set mode(value: UnityEngine.ParticleSystemCurveMode);
            public get curveMultiplier(): number;
            public set curveMultiplier(value: number);
            public get curveMax(): UnityEngine.AnimationCurve;
            public set curveMax(value: UnityEngine.AnimationCurve);
            public get curveMin(): UnityEngine.AnimationCurve;
            public set curveMin(value: UnityEngine.AnimationCurve);
            public get constantMax(): number;
            public set constantMax(value: number);
            public get constantMin(): number;
            public set constantMin(value: number);
            public get constant(): number;
            public set constant(value: number);
            public get curve(): UnityEngine.AnimationCurve;
            public set curve(value: UnityEngine.AnimationCurve);
            public Evaluate($time: number):number;
            public Evaluate($time: number, $lerpFactor: number):number;
            public static op_Implicit($constant: number):UnityEngine.ParticleSystem.MinMaxCurve;
            public constructor($constant: number);
            public constructor($multiplier: number, $curve: UnityEngine.AnimationCurve);
            public constructor($multiplier: number, $min: UnityEngine.AnimationCurve, $max: UnityEngine.AnimationCurve);
            public constructor($min: number, $max: number);
            public constructor();
        }
        export class MinMaxGradient extends System.ValueType{ 
            public get mode(): UnityEngine.ParticleSystemGradientMode;
            public set mode(value: UnityEngine.ParticleSystemGradientMode);
            public get gradientMax(): UnityEngine.Gradient;
            public set gradientMax(value: UnityEngine.Gradient);
            public get gradientMin(): UnityEngine.Gradient;
            public set gradientMin(value: UnityEngine.Gradient);
            public get colorMax(): UnityEngine.Color;
            public set colorMax(value: UnityEngine.Color);
            public get colorMin(): UnityEngine.Color;
            public set colorMin(value: UnityEngine.Color);
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public get gradient(): UnityEngine.Gradient;
            public set gradient(value: UnityEngine.Gradient);
            public Evaluate($time: number):UnityEngine.Color;
            public Evaluate($time: number, $lerpFactor: number):UnityEngine.Color;
            public static op_Implicit($color: UnityEngine.Color):UnityEngine.ParticleSystem.MinMaxGradient;
            public static op_Implicit($gradient: UnityEngine.Gradient):UnityEngine.ParticleSystem.MinMaxGradient;
            public constructor($color: UnityEngine.Color);
            public constructor($gradient: UnityEngine.Gradient);
            public constructor($min: UnityEngine.Color, $max: UnityEngine.Color);
            public constructor($min: UnityEngine.Gradient, $max: UnityEngine.Gradient);
            public constructor();
        }
        export class Burst extends System.ValueType{ 
            public get time(): number;
            public set time(value: number);
            public get count(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set count(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get minCount(): number;
            public set minCount(value: number);
            public get maxCount(): number;
            public set maxCount(value: number);
            public get cycleCount(): number;
            public set cycleCount(value: number);
            public get repeatInterval(): number;
            public set repeatInterval(value: number);
            public get probability(): number;
            public set probability(value: number);
            public constructor($_time: number, $_count: number);
            public constructor($_time: number, $_minCount: number, $_maxCount: number);
            public constructor($_time: number, $_minCount: number, $_maxCount: number, $_cycleCount: number, $_repeatInterval: number);
            public constructor($_time: number, $_count: UnityEngine.ParticleSystem.MinMaxCurve);
            public constructor($_time: number, $_count: UnityEngine.ParticleSystem.MinMaxCurve, $_cycleCount: number, $_repeatInterval: number);
            public constructor();
        }
        export class ColliderData extends System.ValueType{ 
            public GetColliderCount($particleIndex: number):number;
            public GetCollider($particleIndex: number, $colliderIndex: number):UnityEngine.Component;
        }
    }
    export namespace Unity.Collections {
        export class NativeArray$1<T> extends System.ValueType implements System.Collections.IEnumerable, System.IDisposable, System.IEquatable$1<Unity.Collections.NativeArray$1<T>>, System.Collections.Generic.IEnumerable$1<T>{ 
        }
        export class NativeSlice$1<T> extends System.ValueType implements System.Collections.IEnumerable, System.IEquatable$1<Unity.Collections.NativeSlice$1<T>>, System.Collections.Generic.IEnumerable$1<T>{ 
        }
    }
    export namespace UnityEngine.Canvas {
        export type WillRenderCanvases = () => void;
        var WillRenderCanvases: {new (func: () => void): WillRenderCanvases;}
    }
    export namespace UnityEngine.EventSystems {
        export class UIBehaviour extends UnityEngine.MonoBehaviour{ 
            public IsActive():boolean;
            public IsDestroyed():boolean;
        }
        export interface IEventSystemHandler{ 
        }
        export interface IPointerEnterHandler extends UnityEngine.EventSystems.IEventSystemHandler{ 
        }
        export interface ISelectHandler extends UnityEngine.EventSystems.IEventSystemHandler{ 
        }
        export interface IPointerExitHandler extends UnityEngine.EventSystems.IEventSystemHandler{ 
        }
        export interface IDeselectHandler extends UnityEngine.EventSystems.IEventSystemHandler{ 
        }
        export interface IPointerDownHandler extends UnityEngine.EventSystems.IEventSystemHandler{ 
        }
        export interface IPointerUpHandler extends UnityEngine.EventSystems.IEventSystemHandler{ 
        }
        export interface IMoveHandler extends UnityEngine.EventSystems.IEventSystemHandler{ 
        }
        export class AxisEventData extends UnityEngine.EventSystems.BaseEventData{ 
        }
        export class BaseEventData extends UnityEngine.EventSystems.AbstractEventData{ 
        }
        export class AbstractEventData extends System.Object{ 
        }
        export class PointerEventData extends UnityEngine.EventSystems.BaseEventData{ 
        }
        export interface ISubmitHandler extends UnityEngine.EventSystems.IEventSystemHandler{ 
        }
        export interface IPointerClickHandler extends UnityEngine.EventSystems.IEventSystemHandler{ 
        }
        export interface IBeginDragHandler extends UnityEngine.EventSystems.IEventSystemHandler{ 
        }
        export interface IDragHandler extends UnityEngine.EventSystems.IEventSystemHandler{ 
        }
        export interface IEndDragHandler extends UnityEngine.EventSystems.IEventSystemHandler{ 
        }
        export interface IUpdateSelectedHandler extends UnityEngine.EventSystems.IEventSystemHandler{ 
        }
        export interface ICancelHandler extends UnityEngine.EventSystems.IEventSystemHandler{ 
        }
        export class BaseRaycaster extends UnityEngine.EventSystems.UIBehaviour{ 
        }
        export class RaycastResult extends System.ValueType{ 
        }
        export interface IInitializePotentialDragHandler extends UnityEngine.EventSystems.IEventSystemHandler{ 
        }
        export interface IScrollHandler extends UnityEngine.EventSystems.IEventSystemHandler{ 
        }
        export interface IDropHandler extends UnityEngine.EventSystems.IEventSystemHandler{ 
        }
        export class GamePadInputModule extends UnityEngine.EventSystems.BaseInputModule{ 
            public get inputActionsPerSecond(): number;
            public set inputActionsPerSecond(value: number);
            public get repeatDelay(): number;
            public set repeatDelay(value: number);
            public get horizontalAxis(): string;
            public set horizontalAxis(value: string);
            public get verticalAxis(): string;
            public set verticalAxis(value: string);
            public get submitButton(): string;
            public set submitButton(value: string);
            public get cancelButton(): string;
            public set cancelButton(value: string);
        }
        export class BaseInputModule extends UnityEngine.EventSystems.UIBehaviour{ 
        }
        export class PointerInputModule extends UnityEngine.EventSystems.BaseInputModule{ 
        }
        export enum EventTriggerType{ PointerEnter = 0, PointerExit = 1, PointerDown = 2, PointerUp = 3, PointerClick = 4, Drag = 5, Drop = 6, Scroll = 7, UpdateSelected = 8, Select = 9, Deselect = 10, Move = 11, InitializePotentialDrag = 12, BeginDrag = 13, EndDrag = 14, Submit = 15, Cancel = 16 }
    }
    export namespace UnityEngine.UI {
        export class Selectable extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler, UnityEngine.EventSystems.IMoveHandler{ 
            public static get allSelectablesArray(): System.Array$1<UnityEngine.UI.Selectable>;
            public static get allSelectableCount(): number;
            public get navigation(): UnityEngine.UI.Navigation;
            public set navigation(value: UnityEngine.UI.Navigation);
            public get transition(): UnityEngine.UI.Selectable.Transition;
            public set transition(value: UnityEngine.UI.Selectable.Transition);
            public get colors(): UnityEngine.UI.ColorBlock;
            public set colors(value: UnityEngine.UI.ColorBlock);
            public get spriteState(): UnityEngine.UI.SpriteState;
            public set spriteState(value: UnityEngine.UI.SpriteState);
            public get animationTriggers(): UnityEngine.UI.AnimationTriggers;
            public set animationTriggers(value: UnityEngine.UI.AnimationTriggers);
            public get targetGraphic(): UnityEngine.UI.Graphic;
            public set targetGraphic(value: UnityEngine.UI.Graphic);
            public get interactable(): boolean;
            public set interactable(value: boolean);
            public get image(): UnityEngine.UI.Image;
            public set image(value: UnityEngine.UI.Image);
            public get animator(): UnityEngine.Animator;
            public static AllSelectablesNoAlloc($selectables: System.Array$1<UnityEngine.UI.Selectable>):number;
            public IsInteractable():boolean;
            public FindSelectable($dir: UnityEngine.Vector3):UnityEngine.UI.Selectable;
            public FindSelectableOnLeft():UnityEngine.UI.Selectable;
            public FindSelectableOnRight():UnityEngine.UI.Selectable;
            public FindSelectableOnUp():UnityEngine.UI.Selectable;
            public FindSelectableOnDown():UnityEngine.UI.Selectable;
            public OnMove($eventData: UnityEngine.EventSystems.AxisEventData):void;
            public OnPointerDown($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerUp($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerEnter($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerExit($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnSelect($eventData: UnityEngine.EventSystems.BaseEventData):void;
            public OnDeselect($eventData: UnityEngine.EventSystems.BaseEventData):void;
            public Select():void;
        }
        export class Navigation extends System.ValueType implements System.IEquatable$1<UnityEngine.UI.Navigation>{ 
            public get mode(): UnityEngine.UI.Navigation.Mode;
            public set mode(value: UnityEngine.UI.Navigation.Mode);
            public get wrapAround(): boolean;
            public set wrapAround(value: boolean);
            public get selectOnUp(): UnityEngine.UI.Selectable;
            public set selectOnUp(value: UnityEngine.UI.Selectable);
            public get selectOnDown(): UnityEngine.UI.Selectable;
            public set selectOnDown(value: UnityEngine.UI.Selectable);
            public get selectOnLeft(): UnityEngine.UI.Selectable;
            public set selectOnLeft(value: UnityEngine.UI.Selectable);
            public get selectOnRight(): UnityEngine.UI.Selectable;
            public set selectOnRight(value: UnityEngine.UI.Selectable);
            public static get defaultNavigation(): UnityEngine.UI.Navigation;
            public Equals($other: UnityEngine.UI.Navigation):boolean;
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
        }
        export class ColorBlock extends System.ValueType implements System.IEquatable$1<UnityEngine.UI.ColorBlock>{ 
            public static defaultColorBlock: UnityEngine.UI.ColorBlock;
            public get normalColor(): UnityEngine.Color;
            public set normalColor(value: UnityEngine.Color);
            public get highlightedColor(): UnityEngine.Color;
            public set highlightedColor(value: UnityEngine.Color);
            public get pressedColor(): UnityEngine.Color;
            public set pressedColor(value: UnityEngine.Color);
            public get selectedColor(): UnityEngine.Color;
            public set selectedColor(value: UnityEngine.Color);
            public get disabledColor(): UnityEngine.Color;
            public set disabledColor(value: UnityEngine.Color);
            public get colorMultiplier(): number;
            public set colorMultiplier(value: number);
            public get fadeDuration(): number;
            public set fadeDuration(value: number);
            public Equals($obj: any):boolean;
            public Equals($other: UnityEngine.UI.ColorBlock):boolean;
            public static op_Equality($point1: UnityEngine.UI.ColorBlock, $point2: UnityEngine.UI.ColorBlock):boolean;
            public static op_Inequality($point1: UnityEngine.UI.ColorBlock, $point2: UnityEngine.UI.ColorBlock):boolean;
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
        }
        export class SpriteState extends System.ValueType implements System.IEquatable$1<UnityEngine.UI.SpriteState>{ 
            public get highlightedSprite(): UnityEngine.Sprite;
            public set highlightedSprite(value: UnityEngine.Sprite);
            public get pressedSprite(): UnityEngine.Sprite;
            public set pressedSprite(value: UnityEngine.Sprite);
            public get selectedSprite(): UnityEngine.Sprite;
            public set selectedSprite(value: UnityEngine.Sprite);
            public get disabledSprite(): UnityEngine.Sprite;
            public set disabledSprite(value: UnityEngine.Sprite);
            public Equals($other: UnityEngine.UI.SpriteState):boolean;
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
        }
        export class AnimationTriggers extends System.Object{ 
            public get normalTrigger(): string;
            public set normalTrigger(value: string);
            public get highlightedTrigger(): string;
            public set highlightedTrigger(value: string);
            public get pressedTrigger(): string;
            public set pressedTrigger(value: string);
            public get selectedTrigger(): string;
            public set selectedTrigger(value: string);
            public get disabledTrigger(): string;
            public set disabledTrigger(value: string);
            public constructor();
        }
        export class Graphic extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.UI.ICanvasElement{ 
            public static get defaultGraphicMaterial(): UnityEngine.Material;
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public get raycastTarget(): boolean;
            public set raycastTarget(value: boolean);
            public get raycastPadding(): UnityEngine.Vector4;
            public set raycastPadding(value: UnityEngine.Vector4);
            public get depth(): number;
            public get rectTransform(): UnityEngine.RectTransform;
            public get canvas(): UnityEngine.Canvas;
            public get canvasRenderer(): UnityEngine.CanvasRenderer;
            public get defaultMaterial(): UnityEngine.Material;
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public get materialForRendering(): UnityEngine.Material;
            public get mainTexture(): UnityEngine.Texture;
            public SetAllDirty():void;
            public SetLayoutDirty():void;
            public SetVerticesDirty():void;
            public SetMaterialDirty():void;
            public OnCullingChanged():void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public LayoutComplete():void;
            public GraphicUpdateComplete():void;
            public SetNativeSize():void;
            public Raycast($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public PixelAdjustPoint($point: UnityEngine.Vector2):UnityEngine.Vector2;
            public GetPixelAdjustedRect():UnityEngine.Rect;
            public CrossFadeColor($targetColor: UnityEngine.Color, $duration: number, $ignoreTimeScale: boolean, $useAlpha: boolean):void;
            public CrossFadeColor($targetColor: UnityEngine.Color, $duration: number, $ignoreTimeScale: boolean, $useAlpha: boolean, $useRGB: boolean):void;
            public CrossFadeAlpha($alpha: number, $duration: number, $ignoreTimeScale: boolean):void;
            public RegisterDirtyLayoutCallback($action: UnityEngine.Events.UnityAction):void;
            public UnregisterDirtyLayoutCallback($action: UnityEngine.Events.UnityAction):void;
            public RegisterDirtyVerticesCallback($action: UnityEngine.Events.UnityAction):void;
            public UnregisterDirtyVerticesCallback($action: UnityEngine.Events.UnityAction):void;
            public RegisterDirtyMaterialCallback($action: UnityEngine.Events.UnityAction):void;
            public UnregisterDirtyMaterialCallback($action: UnityEngine.Events.UnityAction):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
        interface Graphic {
            DOColor($endValue: UnityEngine.Color, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions>;
            DOFade($endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions>;
            DOBlendableColor($endValue: UnityEngine.Color, $duration: number):DG.Tweening.Tweener;
        }
        export interface ICanvasElement{ 
            transform: UnityEngine.Transform;
            Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            LayoutComplete():void;
            GraphicUpdateComplete():void;
            IsDestroyed():boolean;
        }
        export class Image extends UnityEngine.UI.MaskableGraphic implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.ICanvasRaycastFilter, UnityEngine.UI.ICanvasElement, UnityEngine.ISerializationCallbackReceiver, UnityEngine.UI.ILayoutElement, UnityEngine.UI.IClippable{ 
            public get sprite(): UnityEngine.Sprite;
            public set sprite(value: UnityEngine.Sprite);
            public get overrideSprite(): UnityEngine.Sprite;
            public set overrideSprite(value: UnityEngine.Sprite);
            public get type(): UnityEngine.UI.Image.Type;
            public set type(value: UnityEngine.UI.Image.Type);
            public get preserveAspect(): boolean;
            public set preserveAspect(value: boolean);
            public get fillCenter(): boolean;
            public set fillCenter(value: boolean);
            public get fillMethod(): UnityEngine.UI.Image.FillMethod;
            public set fillMethod(value: UnityEngine.UI.Image.FillMethod);
            public get fillAmount(): number;
            public set fillAmount(value: number);
            public get fillClockwise(): boolean;
            public set fillClockwise(value: boolean);
            public get fillOrigin(): number;
            public set fillOrigin(value: number);
            public get alphaHitTestMinimumThreshold(): number;
            public set alphaHitTestMinimumThreshold(value: number);
            public get useSpriteMesh(): boolean;
            public set useSpriteMesh(value: boolean);
            public static get defaultETC1GraphicMaterial(): UnityEngine.Material;
            public get mainTexture(): UnityEngine.Texture;
            public get hasBorder(): boolean;
            public get pixelsPerUnitMultiplier(): number;
            public set pixelsPerUnitMultiplier(value: number);
            public get pixelsPerUnit(): number;
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public get minWidth(): number;
            public get preferredWidth(): number;
            public get flexibleWidth(): number;
            public get minHeight(): number;
            public get preferredHeight(): number;
            public get flexibleHeight(): number;
            public get layoutPriority(): number;
            public DisableSpriteOptimizations():void;
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
            public CalculateLayoutInputHorizontal():void;
            public CalculateLayoutInputVertical():void;
            public IsRaycastLocationValid($screenPoint: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
        interface Image {
            cloneSelfMaterial():void;
            setToneIntensity($_toneIntensity: number):void;
            setSaturation($saturation: number):void;
            setContrast($Contrast: number):void;
            setToneColor($toneColor: UnityEngine.Color):void;
            resetDefaultImageEffect():void;
            DOColor($endValue: UnityEngine.Color, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions>;
            DOFade($endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions>;
            DOFillAmount($endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<number, number, DG.Tweening.Plugins.Options.FloatOptions>;
            DOGradientColor($gradient: UnityEngine.Gradient, $duration: number):DG.Tweening.Sequence;
            DOBlendableColor($endValue: UnityEngine.Color, $duration: number):DG.Tweening.Tweener;
        }
        export class MaskableGraphic extends UnityEngine.UI.Graphic implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.UI.ICanvasElement, UnityEngine.UI.IClippable{ 
            public get onCullStateChanged(): UnityEngine.UI.MaskableGraphic.CullStateChangedEvent;
            public set onCullStateChanged(value: UnityEngine.UI.MaskableGraphic.CullStateChangedEvent);
            public get maskable(): boolean;
            public set maskable(value: boolean);
            public get isMaskingGraphic(): boolean;
            public set isMaskingGraphic(value: boolean);
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public RecalculateClipping():void;
            public RecalculateMasking():void;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
        export interface IMaterialModifier{ 
            GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
        }
        export interface IMaskable{ 
            RecalculateMasking():void;
        }
        export interface IClippable{ 
            gameObject: UnityEngine.GameObject;
            rectTransform: UnityEngine.RectTransform;
            RecalculateClipping():void;
            Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
        }
        export interface ILayoutElement{ 
            minWidth: number;
            preferredWidth: number;
            flexibleWidth: number;
            minHeight: number;
            preferredHeight: number;
            flexibleHeight: number;
            layoutPriority: number;
            CalculateLayoutInputHorizontal():void;
            CalculateLayoutInputVertical():void;
        }
        export class Button extends UnityEngine.UI.Selectable implements UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler, UnityEngine.EventSystems.IMoveHandler, UnityEngine.EventSystems.ISubmitHandler, UnityEngine.EventSystems.IPointerClickHandler{ 
            public get onClick(): UnityEngine.UI.Button.ButtonClickedEvent;
            public set onClick(value: UnityEngine.UI.Button.ButtonClickedEvent);
            public OnPointerClick($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnSubmit($eventData: UnityEngine.EventSystems.BaseEventData):void;
        }
        export class InputField extends UnityEngine.UI.Selectable implements UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEndDragHandler, UnityEngine.UI.ICanvasElement, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.IUpdateSelectedHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler, UnityEngine.EventSystems.IMoveHandler, UnityEngine.UI.ILayoutElement, UnityEngine.EventSystems.ISubmitHandler, UnityEngine.EventSystems.IPointerClickHandler{ 
            public get shouldHideMobileInput(): boolean;
            public set shouldHideMobileInput(value: boolean);
            public get shouldActivateOnSelect(): boolean;
            public set shouldActivateOnSelect(value: boolean);
            public get text(): string;
            public set text(value: string);
            public get isFocused(): boolean;
            public get caretBlinkRate(): number;
            public set caretBlinkRate(value: number);
            public get caretWidth(): number;
            public set caretWidth(value: number);
            public get textComponent(): UnityEngine.UI.Text;
            public set textComponent(value: UnityEngine.UI.Text);
            public get placeholder(): UnityEngine.UI.Graphic;
            public set placeholder(value: UnityEngine.UI.Graphic);
            public get caretColor(): UnityEngine.Color;
            public set caretColor(value: UnityEngine.Color);
            public get customCaretColor(): boolean;
            public set customCaretColor(value: boolean);
            public get selectionColor(): UnityEngine.Color;
            public set selectionColor(value: UnityEngine.Color);
            public get onEndEdit(): UnityEngine.UI.InputField.EndEditEvent;
            public set onEndEdit(value: UnityEngine.UI.InputField.EndEditEvent);
            public get onSubmit(): UnityEngine.UI.InputField.SubmitEvent;
            public set onSubmit(value: UnityEngine.UI.InputField.SubmitEvent);
            public get onValueChanged(): UnityEngine.UI.InputField.OnChangeEvent;
            public set onValueChanged(value: UnityEngine.UI.InputField.OnChangeEvent);
            public get onValidateInput(): UnityEngine.UI.InputField.OnValidateInput;
            public set onValidateInput(value: UnityEngine.UI.InputField.OnValidateInput);
            public get characterLimit(): number;
            public set characterLimit(value: number);
            public get contentType(): UnityEngine.UI.InputField.ContentType;
            public set contentType(value: UnityEngine.UI.InputField.ContentType);
            public get lineType(): UnityEngine.UI.InputField.LineType;
            public set lineType(value: UnityEngine.UI.InputField.LineType);
            public get inputType(): UnityEngine.UI.InputField.InputType;
            public set inputType(value: UnityEngine.UI.InputField.InputType);
            public get touchScreenKeyboard(): UnityEngine.TouchScreenKeyboard;
            public get keyboardType(): UnityEngine.TouchScreenKeyboardType;
            public set keyboardType(value: UnityEngine.TouchScreenKeyboardType);
            public get characterValidation(): UnityEngine.UI.InputField.CharacterValidation;
            public set characterValidation(value: UnityEngine.UI.InputField.CharacterValidation);
            public get readOnly(): boolean;
            public set readOnly(value: boolean);
            public get multiLine(): boolean;
            public get asteriskChar(): number;
            public set asteriskChar(value: number);
            public get wasCanceled(): boolean;
            public get caretPosition(): number;
            public set caretPosition(value: number);
            public get selectionAnchorPosition(): number;
            public set selectionAnchorPosition(value: number);
            public get selectionFocusPosition(): number;
            public set selectionFocusPosition(value: number);
            public get minWidth(): number;
            public get preferredWidth(): number;
            public get flexibleWidth(): number;
            public get minHeight(): number;
            public get preferredHeight(): number;
            public get flexibleHeight(): number;
            public get layoutPriority(): number;
            public SetTextWithoutNotify($input: string):void;
            public MoveTextEnd($shift: boolean):void;
            public MoveTextStart($shift: boolean):void;
            public OnBeginDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnEndDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public ProcessEvent($e: UnityEngine.Event):void;
            public OnUpdateSelected($eventData: UnityEngine.EventSystems.BaseEventData):void;
            public ForceLabelUpdate():void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public LayoutComplete():void;
            public GraphicUpdateComplete():void;
            public ActivateInputField():void;
            public OnPointerClick($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public DeactivateInputField():void;
            public OnSubmit($eventData: UnityEngine.EventSystems.BaseEventData):void;
            public CalculateLayoutInputHorizontal():void;
            public CalculateLayoutInputVertical():void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
        export class Text extends UnityEngine.UI.MaskableGraphic implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.UI.ICanvasElement, UnityEngine.UI.ILayoutElement, UnityEngine.UI.IClippable{ 
            public get cachedTextGenerator(): UnityEngine.TextGenerator;
            public get cachedTextGeneratorForLayout(): UnityEngine.TextGenerator;
            public get mainTexture(): UnityEngine.Texture;
            public get font(): UnityEngine.Font;
            public set font(value: UnityEngine.Font);
            public get text(): string;
            public set text(value: string);
            public get supportRichText(): boolean;
            public set supportRichText(value: boolean);
            public get resizeTextForBestFit(): boolean;
            public set resizeTextForBestFit(value: boolean);
            public get resizeTextMinSize(): number;
            public set resizeTextMinSize(value: number);
            public get resizeTextMaxSize(): number;
            public set resizeTextMaxSize(value: number);
            public get alignment(): UnityEngine.TextAnchor;
            public set alignment(value: UnityEngine.TextAnchor);
            public get alignByGeometry(): boolean;
            public set alignByGeometry(value: boolean);
            public get fontSize(): number;
            public set fontSize(value: number);
            public get horizontalOverflow(): UnityEngine.HorizontalWrapMode;
            public set horizontalOverflow(value: UnityEngine.HorizontalWrapMode);
            public get verticalOverflow(): UnityEngine.VerticalWrapMode;
            public set verticalOverflow(value: UnityEngine.VerticalWrapMode);
            public get lineSpacing(): number;
            public set lineSpacing(value: number);
            public get fontStyle(): UnityEngine.FontStyle;
            public set fontStyle(value: UnityEngine.FontStyle);
            public get pixelsPerUnit(): number;
            public get minWidth(): number;
            public get preferredWidth(): number;
            public get flexibleWidth(): number;
            public get minHeight(): number;
            public get preferredHeight(): number;
            public get flexibleHeight(): number;
            public get layoutPriority(): number;
            public FontTextureChanged():void;
            public GetGenerationSettings($extents: UnityEngine.Vector2):UnityEngine.TextGenerationSettings;
            public static GetTextAnchorPivot($anchor: UnityEngine.TextAnchor):UnityEngine.Vector2;
            public CalculateLayoutInputHorizontal():void;
            public CalculateLayoutInputVertical():void;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
        interface Text {
            DOColor($endValue: UnityEngine.Color, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions>;
            DOCounter($fromValue: number, $endValue: number, $duration: number, $addThousandsSeparator?: boolean, $culture?: System.Globalization.CultureInfo):DG.Tweening.Core.TweenerCore$3<number, number, DG.Tweening.Plugins.Options.NoOptions>;
            DOFade($endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions>;
            DOText($endValue: string, $duration: number, $richTextEnabled?: boolean, $scrambleMode?: DG.Tweening.ScrambleMode, $scrambleChars?: string):DG.Tweening.Core.TweenerCore$3<string, string, DG.Tweening.Plugins.Options.StringOptions>;
            DOBlendableColor($endValue: UnityEngine.Color, $duration: number):DG.Tweening.Tweener;
        }
        export enum CanvasUpdate{ Prelayout = 0, Layout = 1, PostLayout = 2, PreRender = 3, LatePreRender = 4, MaxUpdateValue = 5 }
        export class Toggle extends UnityEngine.UI.Selectable implements UnityEngine.UI.ICanvasElement, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler, UnityEngine.EventSystems.IMoveHandler, UnityEngine.EventSystems.ISubmitHandler, UnityEngine.EventSystems.IPointerClickHandler{ 
            public toggleTransition: UnityEngine.UI.Toggle.ToggleTransition;
            public graphic: UnityEngine.UI.Graphic;
            public onValueChanged: UnityEngine.UI.Toggle.ToggleEvent;
            public get group(): UnityEngine.UI.ToggleGroup;
            public set group(value: UnityEngine.UI.ToggleGroup);
            public get isOn(): boolean;
            public set isOn(value: boolean);
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public LayoutComplete():void;
            public GraphicUpdateComplete():void;
            public SetIsOnWithoutNotify($value: boolean):void;
            public OnPointerClick($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnSubmit($eventData: UnityEngine.EventSystems.BaseEventData):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
        export class ToggleGroup extends UnityEngine.EventSystems.UIBehaviour{ 
            public get allowSwitchOff(): boolean;
            public set allowSwitchOff(value: boolean);
            public NotifyToggleOn($toggle: UnityEngine.UI.Toggle, $sendCallback?: boolean):void;
            public UnregisterToggle($toggle: UnityEngine.UI.Toggle):void;
            public RegisterToggle($toggle: UnityEngine.UI.Toggle):void;
            public EnsureValidState():void;
            public AnyTogglesOn():boolean;
            public ActiveToggles():System.Collections.Generic.IEnumerable$1<UnityEngine.UI.Toggle>;
            public GetFirstActiveToggle():UnityEngine.UI.Toggle;
            public SetAllTogglesOff($sendCallback?: boolean):void;
        }
        export class ExtensionsToggle extends UnityEngine.UI.Selectable implements UnityEngine.UI.ICanvasElement, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler, UnityEngine.EventSystems.IMoveHandler, UnityEngine.EventSystems.ISubmitHandler, UnityEngine.EventSystems.IPointerClickHandler{ 
            public UniqueID: string;
            public toggleTransition: UnityEngine.UI.ExtensionsToggle.ToggleTransition;
            public graphic: UnityEngine.UI.Graphic;
            public onValueChanged: UnityEngine.UI.ExtensionsToggle.ToggleEvent;
            public onToggleChanged: UnityEngine.UI.ExtensionsToggle.ToggleEventObject;
            public get Group(): UnityEngine.UI.ExtensionsToggleGroup;
            public set Group(value: UnityEngine.UI.ExtensionsToggleGroup);
            public get IsOn(): boolean;
            public set IsOn(value: boolean);
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public LayoutComplete():void;
            public GraphicUpdateComplete():void;
            public OnPointerClick($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnSubmit($eventData: UnityEngine.EventSystems.BaseEventData):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
        export class ExtensionsToggleGroup extends UnityEngine.EventSystems.UIBehaviour{ 
            public onToggleGroupChanged: UnityEngine.UI.ExtensionsToggleGroup.ToggleGroupEvent;
            public onToggleGroupToggleChanged: UnityEngine.UI.ExtensionsToggleGroup.ToggleGroupEvent;
            public get AllowSwitchOff(): boolean;
            public set AllowSwitchOff(value: boolean);
            public get SelectedToggle(): UnityEngine.UI.ExtensionsToggle;
            public NotifyToggleOn($toggle: UnityEngine.UI.ExtensionsToggle):void;
            public UnregisterToggle($toggle: UnityEngine.UI.ExtensionsToggle):void;
            public RegisterToggle($toggle: UnityEngine.UI.ExtensionsToggle):void;
            public AnyTogglesOn():boolean;
            public ActiveToggles():System.Collections.Generic.IEnumerable$1<UnityEngine.UI.ExtensionsToggle>;
            public SetAllTogglesOff():void;
            public HasTheGroupToggle($value: boolean):void;
            public HasAToggleFlipped($value: boolean):void;
        }
        export class ReturnKeyTriggersButton extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.ISubmitHandler{ 
            public button: UnityEngine.UI.Button;
            public highlightDuration: number;
            public OnSubmit($eventData: UnityEngine.EventSystems.BaseEventData):void;
            public constructor();
        }
        export class CanvasUpdateRegistry extends System.Object{ 
            public static get instance(): UnityEngine.UI.CanvasUpdateRegistry;
            public static RegisterCanvasElementForLayoutRebuild($element: UnityEngine.UI.ICanvasElement):void;
            public static TryRegisterCanvasElementForLayoutRebuild($element: UnityEngine.UI.ICanvasElement):boolean;
            public static RegisterCanvasElementForGraphicRebuild($element: UnityEngine.UI.ICanvasElement):void;
            public static TryRegisterCanvasElementForGraphicRebuild($element: UnityEngine.UI.ICanvasElement):boolean;
            public static UnRegisterCanvasElementForRebuild($element: UnityEngine.UI.ICanvasElement):void;
            public static IsRebuildingLayout():boolean;
            public static IsRebuildingGraphics():boolean;
        }
        export class ClipperRegistry extends System.Object{ 
            public static get instance(): UnityEngine.UI.ClipperRegistry;
            public Cull():void;
            public static Register($c: UnityEngine.UI.IClipper):void;
            public static Unregister($c: UnityEngine.UI.IClipper):void;
        }
        export interface IClipper{ 
            PerformClipping():void;
        }
        export class Clipping extends System.Object{ 
            public static FindCullAndClipWorldRect($rectMaskParents: System.Collections.Generic.List$1<UnityEngine.UI.RectMask2D>, $validRect: $Ref<boolean>):UnityEngine.Rect;
        }
        export class RectMask2D extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.ICanvasRaycastFilter, UnityEngine.UI.IClipper{ 
            public get padding(): UnityEngine.Vector4;
            public set padding(value: UnityEngine.Vector4);
            public get softness(): UnityEngine.Vector2Int;
            public set softness(value: UnityEngine.Vector2Int);
            public get canvasRect(): UnityEngine.Rect;
            public get rectTransform(): UnityEngine.RectTransform;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public PerformClipping():void;
            public UpdateClipSoftness():void;
            public AddClippable($clippable: UnityEngine.UI.IClippable):void;
            public RemoveClippable($clippable: UnityEngine.UI.IClippable):void;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
        }
        export class Dropdown extends UnityEngine.UI.Selectable implements UnityEngine.EventSystems.ICancelHandler, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler, UnityEngine.EventSystems.IMoveHandler, UnityEngine.EventSystems.ISubmitHandler, UnityEngine.EventSystems.IPointerClickHandler{ 
            public get template(): UnityEngine.RectTransform;
            public set template(value: UnityEngine.RectTransform);
            public get captionText(): UnityEngine.UI.Text;
            public set captionText(value: UnityEngine.UI.Text);
            public get captionImage(): UnityEngine.UI.Image;
            public set captionImage(value: UnityEngine.UI.Image);
            public get itemText(): UnityEngine.UI.Text;
            public set itemText(value: UnityEngine.UI.Text);
            public get itemImage(): UnityEngine.UI.Image;
            public set itemImage(value: UnityEngine.UI.Image);
            public get options(): System.Collections.Generic.List$1<UnityEngine.UI.Dropdown.OptionData>;
            public set options(value: System.Collections.Generic.List$1<UnityEngine.UI.Dropdown.OptionData>);
            public get onValueChanged(): UnityEngine.UI.Dropdown.DropdownEvent;
            public set onValueChanged(value: UnityEngine.UI.Dropdown.DropdownEvent);
            public get alphaFadeSpeed(): number;
            public set alphaFadeSpeed(value: number);
            public get value(): number;
            public set value(value: number);
            public SetValueWithoutNotify($input: number):void;
            public RefreshShownValue():void;
            public AddOptions($options: System.Collections.Generic.List$1<UnityEngine.UI.Dropdown.OptionData>):void;
            public AddOptions($options: System.Collections.Generic.List$1<string>):void;
            public AddOptions($options: System.Collections.Generic.List$1<UnityEngine.Sprite>):void;
            public ClearOptions():void;
            public OnPointerClick($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnSubmit($eventData: UnityEngine.EventSystems.BaseEventData):void;
            public OnCancel($eventData: UnityEngine.EventSystems.BaseEventData):void;
            public Show():void;
            public Hide():void;
            public Show():null;
            public Hide():null;
        }
        export class FontData extends System.Object implements UnityEngine.ISerializationCallbackReceiver{ 
            public static get defaultFontData(): UnityEngine.UI.FontData;
            public get font(): UnityEngine.Font;
            public set font(value: UnityEngine.Font);
            public get fontSize(): number;
            public set fontSize(value: number);
            public get fontStyle(): UnityEngine.FontStyle;
            public set fontStyle(value: UnityEngine.FontStyle);
            public get bestFit(): boolean;
            public set bestFit(value: boolean);
            public get minSize(): number;
            public set minSize(value: number);
            public get maxSize(): number;
            public set maxSize(value: number);
            public get alignment(): UnityEngine.TextAnchor;
            public set alignment(value: UnityEngine.TextAnchor);
            public get alignByGeometry(): boolean;
            public set alignByGeometry(value: boolean);
            public get richText(): boolean;
            public set richText(value: boolean);
            public get horizontalOverflow(): UnityEngine.HorizontalWrapMode;
            public set horizontalOverflow(value: UnityEngine.HorizontalWrapMode);
            public get verticalOverflow(): UnityEngine.VerticalWrapMode;
            public set verticalOverflow(value: UnityEngine.VerticalWrapMode);
            public get lineSpacing(): number;
            public set lineSpacing(value: number);
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class FontUpdateTracker extends System.Object{ 
            public static TrackText($t: UnityEngine.UI.Text):void;
            public static UntrackText($t: UnityEngine.UI.Text):void;
        }
        export class GraphicRaycaster extends UnityEngine.EventSystems.BaseRaycaster{ 
            public get sortOrderPriority(): number;
            public get renderOrderPriority(): number;
            public get ignoreReversedGraphics(): boolean;
            public set ignoreReversedGraphics(value: boolean);
            public get blockingObjects(): UnityEngine.UI.GraphicRaycaster.BlockingObjects;
            public set blockingObjects(value: UnityEngine.UI.GraphicRaycaster.BlockingObjects);
            public get blockingMask(): UnityEngine.LayerMask;
            public set blockingMask(value: UnityEngine.LayerMask);
            public get eventCamera(): UnityEngine.Camera;
        }
        export class GraphicRegistry extends System.Object{ 
            public static get instance(): UnityEngine.UI.GraphicRegistry;
            public static RegisterGraphicForCanvas($c: UnityEngine.Canvas, $graphic: UnityEngine.UI.Graphic):void;
            public static RegisterRaycastGraphicForCanvas($c: UnityEngine.Canvas, $graphic: UnityEngine.UI.Graphic):void;
            public static UnregisterGraphicForCanvas($c: UnityEngine.Canvas, $graphic: UnityEngine.UI.Graphic):void;
            public static UnregisterRaycastGraphicForCanvas($c: UnityEngine.Canvas, $graphic: UnityEngine.UI.Graphic):void;
            public static GetGraphicsForCanvas($canvas: UnityEngine.Canvas):System.Collections.Generic.IList$1<UnityEngine.UI.Graphic>;
            public static GetRaycastableGraphicsForCanvas($canvas: UnityEngine.Canvas):System.Collections.Generic.IList$1<UnityEngine.UI.Graphic>;
        }
        export class AspectRatioFitter extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.UI.ILayoutSelfController, UnityEngine.UI.ILayoutController{ 
            public get aspectMode(): UnityEngine.UI.AspectRatioFitter.AspectMode;
            public set aspectMode(value: UnityEngine.UI.AspectRatioFitter.AspectMode);
            public get aspectRatio(): number;
            public set aspectRatio(value: number);
            public SetLayoutHorizontal():void;
            public SetLayoutVertical():void;
            public IsComponentValidOnObject():boolean;
            public IsAspectModeValid():boolean;
        }
        export interface ILayoutSelfController extends UnityEngine.UI.ILayoutController{ 
            SetLayoutHorizontal():void;
            SetLayoutVertical():void;
        }
        export interface ILayoutController{ 
            SetLayoutHorizontal():void;
            SetLayoutVertical():void;
        }
        export class CanvasScaler extends UnityEngine.EventSystems.UIBehaviour{ 
            public get uiScaleMode(): UnityEngine.UI.CanvasScaler.ScaleMode;
            public set uiScaleMode(value: UnityEngine.UI.CanvasScaler.ScaleMode);
            public get referencePixelsPerUnit(): number;
            public set referencePixelsPerUnit(value: number);
            public get scaleFactor(): number;
            public set scaleFactor(value: number);
            public get referenceResolution(): UnityEngine.Vector2;
            public set referenceResolution(value: UnityEngine.Vector2);
            public get screenMatchMode(): UnityEngine.UI.CanvasScaler.ScreenMatchMode;
            public set screenMatchMode(value: UnityEngine.UI.CanvasScaler.ScreenMatchMode);
            public get matchWidthOrHeight(): number;
            public set matchWidthOrHeight(value: number);
            public get physicalUnit(): UnityEngine.UI.CanvasScaler.Unit;
            public set physicalUnit(value: UnityEngine.UI.CanvasScaler.Unit);
            public get fallbackScreenDPI(): number;
            public set fallbackScreenDPI(value: number);
            public get defaultSpriteDPI(): number;
            public set defaultSpriteDPI(value: number);
            public get dynamicPixelsPerUnit(): number;
            public set dynamicPixelsPerUnit(value: number);
        }
        export class ContentSizeFitter extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.UI.ILayoutSelfController, UnityEngine.UI.ILayoutController{ 
            public get horizontalFit(): UnityEngine.UI.ContentSizeFitter.FitMode;
            public set horizontalFit(value: UnityEngine.UI.ContentSizeFitter.FitMode);
            public get verticalFit(): UnityEngine.UI.ContentSizeFitter.FitMode;
            public set verticalFit(value: UnityEngine.UI.ContentSizeFitter.FitMode);
            public SetLayoutHorizontal():void;
            public SetLayoutVertical():void;
        }
        export class GridLayoutGroup extends UnityEngine.UI.LayoutGroup implements UnityEngine.UI.ILayoutGroup, UnityEngine.UI.ILayoutElement, UnityEngine.UI.ILayoutController{ 
            public get startCorner(): UnityEngine.UI.GridLayoutGroup.Corner;
            public set startCorner(value: UnityEngine.UI.GridLayoutGroup.Corner);
            public get startAxis(): UnityEngine.UI.GridLayoutGroup.Axis;
            public set startAxis(value: UnityEngine.UI.GridLayoutGroup.Axis);
            public get cellSize(): UnityEngine.Vector2;
            public set cellSize(value: UnityEngine.Vector2);
            public get spacing(): UnityEngine.Vector2;
            public set spacing(value: UnityEngine.Vector2);
            public get constraint(): UnityEngine.UI.GridLayoutGroup.Constraint;
            public set constraint(value: UnityEngine.UI.GridLayoutGroup.Constraint);
            public get constraintCount(): number;
            public set constraintCount(value: number);
        }
        export class LayoutGroup extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.UI.ILayoutGroup, UnityEngine.UI.ILayoutElement, UnityEngine.UI.ILayoutController{ 
            public get padding(): UnityEngine.RectOffset;
            public set padding(value: UnityEngine.RectOffset);
            public get childAlignment(): UnityEngine.TextAnchor;
            public set childAlignment(value: UnityEngine.TextAnchor);
            public get minWidth(): number;
            public get preferredWidth(): number;
            public get flexibleWidth(): number;
            public get minHeight(): number;
            public get preferredHeight(): number;
            public get flexibleHeight(): number;
            public get layoutPriority(): number;
            public CalculateLayoutInputHorizontal():void;
            public CalculateLayoutInputVertical():void;
            public SetLayoutHorizontal():void;
            public SetLayoutVertical():void;
        }
        export interface ILayoutGroup extends UnityEngine.UI.ILayoutController{ 
            SetLayoutHorizontal():void;
            SetLayoutVertical():void;
        }
        export class HorizontalLayoutGroup extends UnityEngine.UI.HorizontalOrVerticalLayoutGroup implements UnityEngine.UI.ILayoutGroup, UnityEngine.UI.ILayoutElement, UnityEngine.UI.ILayoutController{ 
        }
        export class HorizontalOrVerticalLayoutGroup extends UnityEngine.UI.LayoutGroup implements UnityEngine.UI.ILayoutGroup, UnityEngine.UI.ILayoutElement, UnityEngine.UI.ILayoutController{ 
            public get spacing(): number;
            public set spacing(value: number);
            public get childForceExpandWidth(): boolean;
            public set childForceExpandWidth(value: boolean);
            public get childForceExpandHeight(): boolean;
            public set childForceExpandHeight(value: boolean);
            public get childControlWidth(): boolean;
            public set childControlWidth(value: boolean);
            public get childControlHeight(): boolean;
            public set childControlHeight(value: boolean);
            public get childScaleWidth(): boolean;
            public set childScaleWidth(value: boolean);
            public get childScaleHeight(): boolean;
            public set childScaleHeight(value: boolean);
            public get reverseArrangement(): boolean;
            public set reverseArrangement(value: boolean);
        }
        export interface ILayoutIgnorer{ 
            ignoreLayout: boolean;
        }
        export class LayoutElement extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.UI.ILayoutIgnorer, UnityEngine.UI.ILayoutElement{ 
            public get ignoreLayout(): boolean;
            public set ignoreLayout(value: boolean);
            public get minWidth(): number;
            public set minWidth(value: number);
            public get minHeight(): number;
            public set minHeight(value: number);
            public get preferredWidth(): number;
            public set preferredWidth(value: number);
            public get preferredHeight(): number;
            public set preferredHeight(value: number);
            public get flexibleWidth(): number;
            public set flexibleWidth(value: number);
            public get flexibleHeight(): number;
            public set flexibleHeight(value: number);
            public get layoutPriority(): number;
            public set layoutPriority(value: number);
            public CalculateLayoutInputHorizontal():void;
            public CalculateLayoutInputVertical():void;
        }
        interface LayoutElement {
            DOFlexibleSize($endValue: UnityEngine.Vector2, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            DOMinSize($endValue: UnityEngine.Vector2, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            DOPreferredSize($endValue: UnityEngine.Vector2, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
        }
        export class LayoutRebuilder extends System.Object implements UnityEngine.UI.ICanvasElement{ 
            public get transform(): UnityEngine.Transform;
            public IsDestroyed():boolean;
            public static ForceRebuildLayoutImmediate($layoutRoot: UnityEngine.RectTransform):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public static MarkLayoutForRebuild($rect: UnityEngine.RectTransform):void;
            public LayoutComplete():void;
            public GraphicUpdateComplete():void;
            public constructor();
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
        export class LayoutUtility extends System.Object{ 
            public static GetMinSize($rect: UnityEngine.RectTransform, $axis: number):number;
            public static GetPreferredSize($rect: UnityEngine.RectTransform, $axis: number):number;
            public static GetFlexibleSize($rect: UnityEngine.RectTransform, $axis: number):number;
            public static GetMinWidth($rect: UnityEngine.RectTransform):number;
            public static GetPreferredWidth($rect: UnityEngine.RectTransform):number;
            public static GetFlexibleWidth($rect: UnityEngine.RectTransform):number;
            public static GetMinHeight($rect: UnityEngine.RectTransform):number;
            public static GetPreferredHeight($rect: UnityEngine.RectTransform):number;
            public static GetFlexibleHeight($rect: UnityEngine.RectTransform):number;
            public static GetLayoutProperty($rect: UnityEngine.RectTransform, $property: System.Func$2<UnityEngine.UI.ILayoutElement, number>, $defaultValue: number):number;
            public static GetLayoutProperty($rect: UnityEngine.RectTransform, $property: System.Func$2<UnityEngine.UI.ILayoutElement, number>, $defaultValue: number, $source: $Ref<UnityEngine.UI.ILayoutElement>):number;
        }
        export class VerticalLayoutGroup extends UnityEngine.UI.HorizontalOrVerticalLayoutGroup implements UnityEngine.UI.ILayoutGroup, UnityEngine.UI.ILayoutElement, UnityEngine.UI.ILayoutController{ 
        }
        export class Mask extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.UI.IMaterialModifier, UnityEngine.ICanvasRaycastFilter{ 
            public get rectTransform(): UnityEngine.RectTransform;
            public get showMaskGraphic(): boolean;
            public set showMaskGraphic(value: boolean);
            public get graphic(): UnityEngine.UI.Graphic;
            public MaskEnabled():boolean;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
        }
        export class MaskUtilities extends System.Object{ 
            public static Notify2DMaskStateChanged($mask: UnityEngine.Component):void;
            public static NotifyStencilStateChanged($mask: UnityEngine.Component):void;
            public static FindRootSortOverrideCanvas($start: UnityEngine.Transform):UnityEngine.Transform;
            public static GetStencilDepth($transform: UnityEngine.Transform, $stopAfter: UnityEngine.Transform):number;
            public static IsDescendantOrSelf($father: UnityEngine.Transform, $child: UnityEngine.Transform):boolean;
            public static GetRectMaskForClippable($clippable: UnityEngine.UI.IClippable):UnityEngine.UI.RectMask2D;
            public static GetRectMasksForClip($clipper: UnityEngine.UI.RectMask2D, $masks: System.Collections.Generic.List$1<UnityEngine.UI.RectMask2D>):void;
            public constructor();
        }
        export class RawImage extends UnityEngine.UI.MaskableGraphic implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.UI.ICanvasElement, UnityEngine.UI.IClippable{ 
            public get mainTexture(): UnityEngine.Texture;
            public get texture(): UnityEngine.Texture;
            public set texture(value: UnityEngine.Texture);
            public get uvRect(): UnityEngine.Rect;
            public set uvRect(value: UnityEngine.Rect);
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
        export class Scrollbar extends UnityEngine.UI.Selectable implements UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IInitializePotentialDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.UI.ICanvasElement, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler, UnityEngine.EventSystems.IMoveHandler{ 
            public get handleRect(): UnityEngine.RectTransform;
            public set handleRect(value: UnityEngine.RectTransform);
            public get direction(): UnityEngine.UI.Scrollbar.Direction;
            public set direction(value: UnityEngine.UI.Scrollbar.Direction);
            public get value(): number;
            public set value(value: number);
            public get size(): number;
            public set size(value: number);
            public get numberOfSteps(): number;
            public set numberOfSteps(value: number);
            public get onValueChanged(): UnityEngine.UI.Scrollbar.ScrollEvent;
            public set onValueChanged(value: UnityEngine.UI.Scrollbar.ScrollEvent);
            public SetValueWithoutNotify($input: number):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public LayoutComplete():void;
            public GraphicUpdateComplete():void;
            public OnBeginDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnInitializePotentialDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public SetDirection($direction: UnityEngine.UI.Scrollbar.Direction, $includeRectLayouts: boolean):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
        export class ScrollRect extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.UI.ILayoutGroup, UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IInitializePotentialDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEndDragHandler, UnityEngine.UI.ICanvasElement, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IScrollHandler, UnityEngine.UI.ILayoutElement, UnityEngine.UI.ILayoutController{ 
            public get content(): UnityEngine.RectTransform;
            public set content(value: UnityEngine.RectTransform);
            public get horizontal(): boolean;
            public set horizontal(value: boolean);
            public get vertical(): boolean;
            public set vertical(value: boolean);
            public get movementType(): UnityEngine.UI.ScrollRect.MovementType;
            public set movementType(value: UnityEngine.UI.ScrollRect.MovementType);
            public get elasticity(): number;
            public set elasticity(value: number);
            public get inertia(): boolean;
            public set inertia(value: boolean);
            public get decelerationRate(): number;
            public set decelerationRate(value: number);
            public get scrollSensitivity(): number;
            public set scrollSensitivity(value: number);
            public get viewport(): UnityEngine.RectTransform;
            public set viewport(value: UnityEngine.RectTransform);
            public get horizontalScrollbar(): UnityEngine.UI.Scrollbar;
            public set horizontalScrollbar(value: UnityEngine.UI.Scrollbar);
            public get verticalScrollbar(): UnityEngine.UI.Scrollbar;
            public set verticalScrollbar(value: UnityEngine.UI.Scrollbar);
            public get horizontalScrollbarVisibility(): UnityEngine.UI.ScrollRect.ScrollbarVisibility;
            public set horizontalScrollbarVisibility(value: UnityEngine.UI.ScrollRect.ScrollbarVisibility);
            public get verticalScrollbarVisibility(): UnityEngine.UI.ScrollRect.ScrollbarVisibility;
            public set verticalScrollbarVisibility(value: UnityEngine.UI.ScrollRect.ScrollbarVisibility);
            public get horizontalScrollbarSpacing(): number;
            public set horizontalScrollbarSpacing(value: number);
            public get verticalScrollbarSpacing(): number;
            public set verticalScrollbarSpacing(value: number);
            public get onValueChanged(): UnityEngine.UI.ScrollRect.ScrollRectEvent;
            public set onValueChanged(value: UnityEngine.UI.ScrollRect.ScrollRectEvent);
            public get velocity(): UnityEngine.Vector2;
            public set velocity(value: UnityEngine.Vector2);
            public get normalizedPosition(): UnityEngine.Vector2;
            public set normalizedPosition(value: UnityEngine.Vector2);
            public get horizontalNormalizedPosition(): number;
            public set horizontalNormalizedPosition(value: number);
            public get verticalNormalizedPosition(): number;
            public set verticalNormalizedPosition(value: number);
            public get minWidth(): number;
            public get preferredWidth(): number;
            public get flexibleWidth(): number;
            public get minHeight(): number;
            public get preferredHeight(): number;
            public get flexibleHeight(): number;
            public get layoutPriority(): number;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public LayoutComplete():void;
            public GraphicUpdateComplete():void;
            public StopMovement():void;
            public OnScroll($data: UnityEngine.EventSystems.PointerEventData):void;
            public OnInitializePotentialDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnBeginDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnEndDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public CalculateLayoutInputHorizontal():void;
            public CalculateLayoutInputVertical():void;
            public SetLayoutHorizontal():void;
            public SetLayoutVertical():void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
        interface ScrollRect {
            ScrollToTop():void;
            ScrollToBottom():void;
            DONormalizedPos($endValue: UnityEngine.Vector2, $duration: number, $snapping?: boolean):DG.Tweening.Tweener;
            DOHorizontalNormalizedPos($endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Tweener;
            DOVerticalNormalizedPos($endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Tweener;
        }
        export class Slider extends UnityEngine.UI.Selectable implements UnityEngine.EventSystems.IInitializePotentialDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.UI.ICanvasElement, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler, UnityEngine.EventSystems.IMoveHandler{ 
            public get fillRect(): UnityEngine.RectTransform;
            public set fillRect(value: UnityEngine.RectTransform);
            public get handleRect(): UnityEngine.RectTransform;
            public set handleRect(value: UnityEngine.RectTransform);
            public get direction(): UnityEngine.UI.Slider.Direction;
            public set direction(value: UnityEngine.UI.Slider.Direction);
            public get minValue(): number;
            public set minValue(value: number);
            public get maxValue(): number;
            public set maxValue(value: number);
            public get wholeNumbers(): boolean;
            public set wholeNumbers(value: boolean);
            public get value(): number;
            public set value(value: number);
            public get normalizedValue(): number;
            public set normalizedValue(value: number);
            public get onValueChanged(): UnityEngine.UI.Slider.SliderEvent;
            public set onValueChanged(value: UnityEngine.UI.Slider.SliderEvent);
            public SetValueWithoutNotify($input: number):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public LayoutComplete():void;
            public GraphicUpdateComplete():void;
            public OnDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnInitializePotentialDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public SetDirection($direction: UnityEngine.UI.Slider.Direction, $includeRectLayouts: boolean):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
        interface Slider {
            DOValue($endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<number, number, DG.Tweening.Plugins.Options.FloatOptions>;
        }
        export class StencilMaterial extends System.Object{ 
            public static Add($baseMat: UnityEngine.Material, $stencilID: number, $operation: UnityEngine.Rendering.StencilOp, $compareFunction: UnityEngine.Rendering.CompareFunction, $colorWriteMask: UnityEngine.Rendering.ColorWriteMask):UnityEngine.Material;
            public static Add($baseMat: UnityEngine.Material, $stencilID: number, $operation: UnityEngine.Rendering.StencilOp, $compareFunction: UnityEngine.Rendering.CompareFunction, $colorWriteMask: UnityEngine.Rendering.ColorWriteMask, $readMask: number, $writeMask: number):UnityEngine.Material;
            public static Remove($customMat: UnityEngine.Material):void;
            public static ClearAll():void;
        }
        export class VertexHelper extends System.Object implements System.IDisposable{ 
            public get currentVertCount(): number;
            public get currentIndexCount(): number;
            public Dispose():void;
            public Clear():void;
            public PopulateUIVertex($vertex: $Ref<UnityEngine.UIVertex>, $i: number):void;
            public SetUIVertex($vertex: UnityEngine.UIVertex, $i: number):void;
            public FillMesh($mesh: UnityEngine.Mesh):void;
            public AddVert($position: UnityEngine.Vector3, $color: UnityEngine.Color32, $uv0: UnityEngine.Vector4, $uv1: UnityEngine.Vector4, $uv2: UnityEngine.Vector4, $uv3: UnityEngine.Vector4, $normal: UnityEngine.Vector3, $tangent: UnityEngine.Vector4):void;
            public AddVert($position: UnityEngine.Vector3, $color: UnityEngine.Color32, $uv0: UnityEngine.Vector4, $uv1: UnityEngine.Vector4, $normal: UnityEngine.Vector3, $tangent: UnityEngine.Vector4):void;
            public AddVert($position: UnityEngine.Vector3, $color: UnityEngine.Color32, $uv0: UnityEngine.Vector4):void;
            public AddVert($v: UnityEngine.UIVertex):void;
            public AddTriangle($idx0: number, $idx1: number, $idx2: number):void;
            public AddUIVertexQuad($verts: System.Array$1<UnityEngine.UIVertex>):void;
            public AddUIVertexStream($verts: System.Collections.Generic.List$1<UnityEngine.UIVertex>, $indices: System.Collections.Generic.List$1<number>):void;
            public AddUIVertexTriangleStream($verts: System.Collections.Generic.List$1<UnityEngine.UIVertex>):void;
            public GetUIVertexStream($stream: System.Collections.Generic.List$1<UnityEngine.UIVertex>):void;
            public constructor();
            public constructor($m: UnityEngine.Mesh);
        }
        export class BaseMeshEffect extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.UI.IMeshModifier{ 
            public ModifyMesh($mesh: UnityEngine.Mesh):void;
            public ModifyMesh($vh: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
        }
        export interface IMeshModifier{ 
            ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
        }
        export class Outline extends UnityEngine.UI.Shadow implements UnityEngine.UI.IMeshModifier{ 
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($mesh: UnityEngine.Mesh):void;
            public ModifyMesh($vh: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($mesh: UnityEngine.Mesh):void;
            public ModifyMesh($vh: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
        }
        interface Outline {
            DOColor($endValue: UnityEngine.Color, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions>;
            DOFade($endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions>;
            DOScale($endValue: UnityEngine.Vector2, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
        }
        export class Shadow extends UnityEngine.UI.BaseMeshEffect implements UnityEngine.UI.IMeshModifier{ 
            public get effectColor(): UnityEngine.Color;
            public set effectColor(value: UnityEngine.Color);
            public get effectDistance(): UnityEngine.Vector2;
            public set effectDistance(value: UnityEngine.Vector2);
            public get useGraphicAlpha(): boolean;
            public set useGraphicAlpha(value: boolean);
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($mesh: UnityEngine.Mesh):void;
            public ModifyMesh($vh: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
        }
        export class PositionAsUV1 extends UnityEngine.UI.BaseMeshEffect implements UnityEngine.UI.IMeshModifier{ 
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($mesh: UnityEngine.Mesh):void;
            public ModifyMesh($vh: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
        }
    }
    export namespace UnityEngine.UI.Selectable {
        export enum Transition{ None = 0, ColorTint = 1, SpriteSwap = 2, Animation = 3 }
    }
    export namespace UnityEngine.UI.Button {
        export class ButtonClickedEvent extends UnityEngine.Events.UnityEvent implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
    }
    export namespace UnityEngine.Events {
        export class UnityEvent extends UnityEngine.Events.UnityEventBase implements UnityEngine.ISerializationCallbackReceiver{ 
            public AddListener($call: UnityEngine.Events.UnityAction):void;
            public RemoveListener($call: UnityEngine.Events.UnityAction):void;
            public Invoke():void;
            public constructor();
        }
        interface UnityEvent {
            GetAwaiter():Cysharp.Threading.Tasks.UniTask.Awaiter;
        }
        export class UnityEventBase extends System.Object implements UnityEngine.ISerializationCallbackReceiver{ 
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export type UnityAction = () => void;
        var UnityAction: {new (func: () => void): UnityAction;}
        export class UnityEvent$1<T0> extends UnityEngine.Events.UnityEventBase implements UnityEngine.ISerializationCallbackReceiver{ 
            public AddListener($call: UnityEngine.Events.UnityAction$1<T0>):void;
            public RemoveListener($call: UnityEngine.Events.UnityAction$1<T0>):void;
            public Invoke($arg0: T0):void;
            public constructor();
        }
        export type UnityAction$1<T0> = (arg0: T0) => void;
        export type UnityAction$3<T0, T1, T2> = (arg0: T0, arg1: T1, arg2: T2) => void;
        export type UnityAction$2<T0, T1> = (arg0: T0, arg1: T1) => void;
        export class UnityEvent$3<T0, T1, T2> extends UnityEngine.Events.UnityEventBase implements UnityEngine.ISerializationCallbackReceiver{ 
        }
        export class UnityEvent$2<T0, T1> extends UnityEngine.Events.UnityEventBase implements UnityEngine.ISerializationCallbackReceiver{ 
        }
    }
    export namespace UnityEngine.UI.InputField {
        export class EndEditEvent extends UnityEngine.Events.UnityEvent$1<string> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class SubmitEvent extends UnityEngine.Events.UnityEvent$1<string> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class OnChangeEvent extends UnityEngine.Events.UnityEvent$1<string> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export type OnValidateInput = (text: string, charIndex: number, addedChar: number) => number;
        var OnValidateInput: {new (func: (text: string, charIndex: number, addedChar: number) => number): OnValidateInput;}
        export enum ContentType{ Standard = 0, Autocorrected = 1, IntegerNumber = 2, DecimalNumber = 3, Alphanumeric = 4, Name = 5, EmailAddress = 6, Password = 7, Pin = 8, Custom = 9 }
        export enum LineType{ SingleLine = 0, MultiLineSubmit = 1, MultiLineNewline = 2 }
        export enum InputType{ Standard = 0, AutoCorrect = 1, Password = 2 }
        export enum CharacterValidation{ None = 0, Integer = 1, Decimal = 2, Alphanumeric = 3, Name = 4, EmailAddress = 5 }
    }
    export namespace UnityEngine.UI.Toggle {
        export enum ToggleTransition{ None = 0, Fade = 1 }
        export class ToggleEvent extends UnityEngine.Events.UnityEvent$1<boolean> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace Examples.Plants {
        export class pumkinPeaShooter extends System.Object implements Examples.Plants.Shootable, Examples.Plants.Pumpkin$1.Protectable<Examples.Plants.pumkinPeaShooter>{ 
            public shoot():void;
            public protect():void;
            public constructor();
        }
        export interface Shootable{ 
            shoot():void;
        }
    }
    export namespace Examples.Plants.Pumpkin$1 {
        export interface Protectable<T>{ 
        }
    }
    export namespace Examples.Zombies {
        export interface Walkable{ 
            action():void;
        }
        export interface Flyable{ 
            action():void;
        }
        export class BalloonZombie extends System.Object implements Examples.Zombies.Flyable, Examples.Zombies.Walkable{ 
            public constructor();
            public action():void;
        }
    }
    export namespace UnityEngine.Playables {
        export class PlayableGraph extends System.ValueType{ 
        }
        export interface IPlayable{ 
        }
        export class PlayableDirector extends UnityEngine.Behaviour implements UnityEngine.IExposedPropertyTable{ 
            public SetReferenceValue($id: UnityEngine.PropertyName, $value: UnityEngine.Object):void;
            public GetReferenceValue($id: UnityEngine.PropertyName, $idValid: $Ref<boolean>):UnityEngine.Object;
            public ClearReferenceValue($id: UnityEngine.PropertyName):void;
        }
        export interface INotification{ 
        }
        export interface INotificationReceiver{ 
        }
        export class Playable extends System.ValueType implements UnityEngine.Playables.IPlayable, System.IEquatable$1<UnityEngine.Playables.Playable>{ 
        }
    }
    export namespace UnityEngine.Animations {
        export class AnimatorControllerPlayable extends System.ValueType implements UnityEngine.Playables.IPlayable, System.IEquatable$1<UnityEngine.Animations.AnimatorControllerPlayable>{ 
        }
    }
    export namespace System.IO {
        export class Stream extends System.MarshalByRefObject implements System.IDisposable{ 
        }
        export class DirectoryInfo extends System.IO.FileSystemInfo implements System.Runtime.Serialization.ISerializable{ 
        }
        interface DirectoryInfo {
            DeleteEmptyDirs():void;
        }
        export class FileSystemInfo extends System.MarshalByRefObject implements System.Runtime.Serialization.ISerializable{ 
        }
        export class FileInfo extends System.IO.FileSystemInfo implements System.Runtime.Serialization.ISerializable{ 
        }
        interface FileInfo {
            RenameTo($newName: string):void;
        }
        export class TextWriter extends System.MarshalByRefObject implements System.IDisposable{ 
        }
        export class StreamWriter extends System.IO.TextWriter implements System.IDisposable{ 
        }
        export class StreamReader extends System.IO.TextReader implements System.IDisposable{ 
        }
        export class TextReader extends System.MarshalByRefObject implements System.IDisposable{ 
        }
        export class MemoryStream extends System.IO.Stream implements System.IDisposable{ 
        }
    }
    export namespace UnityEngine.AudioSettings {
        export type AudioConfigurationChangeHandler = (deviceWasChanged: boolean) => void;
        var AudioConfigurationChangeHandler: {new (func: (deviceWasChanged: boolean) => void): AudioConfigurationChangeHandler;}
        export class Mobile extends System.Object{ 
            public static get muteState(): boolean;
            public static get stopAudioOutputOnMute(): boolean;
            public static set stopAudioOutputOnMute(value: boolean);
            public static get audioOutputStarted(): boolean;
            public static add_OnMuteStateChanged($value: System.Action$1<boolean>):void;
            public static remove_OnMuteStateChanged($value: System.Action$1<boolean>):void;
            public static StartAudioOutput():void;
            public static StopAudioOutput():void;
        }
    }
    export namespace UnityEngine.Audio {
        export class AudioMixerGroup extends UnityEngine.Object implements UnityEngine.Internal.ISubAssetNotDuplicatable{ 
        }
        export class AudioMixer extends UnityEngine.Object{ 
        }
        interface AudioMixer {
            DOSetFloat($floatName: string, $endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<number, number, DG.Tweening.Plugins.Options.FloatOptions>;
            DOComplete($withCallbacks?: boolean):number;
            DOKill($complete?: boolean):number;
            DOFlip():number;
            DOGoto($to: number, $andPlay?: boolean):number;
            DOPause():number;
            DOPlay():number;
            DOPlayBackwards():number;
            DOPlayForward():number;
            DORestart():number;
            DORewind():number;
            DOSmoothRewind():number;
            DOTogglePause():number;
        }
        export class AudioMixerSnapshot extends UnityEngine.Object implements UnityEngine.Internal.ISubAssetNotDuplicatable{ 
        }
    }
    export namespace UnityEngine.Internal {
        export interface ISubAssetNotDuplicatable{ 
        }
    }
    export namespace UnityEngine.AudioClip {
        export type PCMReaderCallback = (data: System.Array$1<number>) => void;
        var PCMReaderCallback: {new (func: (data: System.Array$1<number>) => void): PCMReaderCallback;}
        export type PCMSetPositionCallback = (position: number) => void;
        var PCMSetPositionCallback: {new (func: (position: number) => void): PCMSetPositionCallback;}
    }
    export namespace UnityEngine.Application {
        export type AdvertisingIdentifierCallback = (advertisingId: string, trackingEnabled: boolean, errorMsg: string) => void;
        var AdvertisingIdentifierCallback: {new (func: (advertisingId: string, trackingEnabled: boolean, errorMsg: string) => void): AdvertisingIdentifierCallback;}
        export type LowMemoryCallback = () => void;
        var LowMemoryCallback: {new (func: () => void): LowMemoryCallback;}
        export type LogCallback = (condition: string, stackTrace: string, type: UnityEngine.LogType) => void;
        var LogCallback: {new (func: (condition: string, stackTrace: string, type: UnityEngine.LogType) => void): LogCallback;}
    }
    export namespace UnityEngine.Camera {
        export type CameraCallback = (cam: UnityEngine.Camera) => void;
        var CameraCallback: {new (func: (cam: UnityEngine.Camera) => void): CameraCallback;}
        export enum GateFitMode{ Vertical = 1, Horizontal = 2, Fill = 3, Overscan = 4, None = 0 }
        export enum MonoOrStereoscopicEye{ Left = 0, Right = 1, Mono = 2 }
        export class GateFitParameters extends System.ValueType{ 
            public get mode(): UnityEngine.Camera.GateFitMode;
            public set mode(value: UnityEngine.Camera.GateFitMode);
            public get aspect(): number;
            public set aspect(value: number);
            public constructor($mode: UnityEngine.Camera.GateFitMode, $aspect: number);
            public constructor();
        }
        export enum StereoscopicEye{ Left = 0, Right = 1 }
        export class RenderRequest extends System.ValueType{ 
            public get isValid(): boolean;
            public get mode(): UnityEngine.Camera.RenderRequestMode;
            public get result(): UnityEngine.RenderTexture;
            public get outputSpace(): UnityEngine.Camera.RenderRequestOutputSpace;
            public constructor($mode: UnityEngine.Camera.RenderRequestMode, $rt: UnityEngine.RenderTexture);
            public constructor($mode: UnityEngine.Camera.RenderRequestMode, $space: UnityEngine.Camera.RenderRequestOutputSpace, $rt: UnityEngine.RenderTexture);
            public constructor();
        }
        export enum FieldOfViewAxis{ Vertical = 0, Horizontal = 1 }
        export enum RenderRequestMode{ None = 0, ObjectId = 1, Depth = 2, VertexNormal = 3, WorldPosition = 4, EntityId = 5, BaseColor = 6, SpecularColor = 7, Metallic = 8, Emission = 9, Normal = 10, Smoothness = 11, Occlusion = 12, DiffuseColor = 13 }
        export enum RenderRequestOutputSpace{ ScreenSpace = -1, UV0 = 0, UV1 = 1, UV2 = 2, UV3 = 3, UV4 = 4, UV5 = 5, UV6 = 6, UV7 = 7, UV8 = 8 }
    }
    export namespace UnityEngine.Rendering {
        export enum OpaqueSortMode{ Default = 0, FrontToBack = 1, NoDistanceSort = 2 }
        export enum CameraEvent{ BeforeDepthTexture = 0, AfterDepthTexture = 1, BeforeDepthNormalsTexture = 2, AfterDepthNormalsTexture = 3, BeforeGBuffer = 4, AfterGBuffer = 5, BeforeLighting = 6, AfterLighting = 7, BeforeFinalPass = 8, AfterFinalPass = 9, BeforeForwardOpaque = 10, AfterForwardOpaque = 11, BeforeImageEffectsOpaque = 12, AfterImageEffectsOpaque = 13, BeforeSkybox = 14, AfterSkybox = 15, BeforeForwardAlpha = 16, AfterForwardAlpha = 17, BeforeImageEffects = 18, AfterImageEffects = 19, AfterEverything = 20, BeforeReflections = 21, AfterReflections = 22, BeforeHaloAndLensFlares = 23, AfterHaloAndLensFlares = 24 }
        export class CommandBuffer extends System.Object implements System.IDisposable{ 
        }
        export enum ComputeQueueType{ Default = 0, Background = 1, Urgent = 2 }
        export class ScriptableCullingParameters extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.ScriptableCullingParameters>{ 
        }
        export enum ReflectionProbeType{ Cube = 0, Card = 1 }
        export enum ReflectionProbeClearFlags{ Skybox = 1, SolidColor = 2 }
        export enum ReflectionProbeMode{ Baked = 0, Realtime = 1, Custom = 2 }
        export enum ReflectionProbeRefreshMode{ OnAwake = 0, EveryFrame = 1, ViaScripting = 2 }
        export enum ReflectionProbeTimeSlicingMode{ AllFacesAtOnce = 0, IndividualFaces = 1, NoTimeSlicing = 2 }
        export enum GraphicsTier{ Tier1 = 0, Tier2 = 1, Tier3 = 2 }
        export enum OpenGLESVersion{ None = 0, OpenGLES20 = 1, OpenGLES30 = 2, OpenGLES31 = 3, OpenGLES31AEP = 4, OpenGLES32 = 5 }
        export class GraphicsFence extends System.ValueType{ 
        }
        export enum SynchronisationStage{ VertexProcessing = 0, PixelProcessing = 1 }
        export enum GraphicsFenceType{ AsyncQueueSynchronisation = 0, CPUSynchronisation = 1 }
        export enum SynchronisationStageFlags{ VertexProcessing = 1, PixelProcessing = 2, ComputeProcessing = 4, AllGPUOperations = 7 }
        export enum ShadowCastingMode{ Off = 0, On = 1, TwoSided = 2, ShadowsOnly = 3 }
        export enum LightProbeUsage{ Off = 0, BlendProbes = 1, UseProxyVolume = 2, CustomProvided = 4 }
        export class GPUFence extends System.ValueType{ 
        }
        export class SphericalHarmonicsL2 extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.SphericalHarmonicsL2>{ 
        }
        export enum RenderBufferLoadAction{ Load = 0, Clear = 1, DontCare = 2 }
        export enum RenderBufferStoreAction{ Store = 0, Resolve = 1, StoreAndResolve = 2, DontCare = 3 }
        export class RenderPipelineAsset extends UnityEngine.ScriptableObject{ 
        }
        export enum IndexFormat{ UInt16 = 0, UInt32 = 1 }
        export class VertexAttributeDescriptor extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.VertexAttributeDescriptor>{ 
        }
        export enum VertexAttribute{ Position = 0, Normal = 1, Tangent = 2, Color = 3, TexCoord0 = 4, TexCoord1 = 5, TexCoord2 = 6, TexCoord3 = 7, TexCoord4 = 8, TexCoord5 = 9, TexCoord6 = 10, TexCoord7 = 11, BlendWeight = 12, BlendIndices = 13 }
        export enum VertexAttributeFormat{ Float32 = 0, Float16 = 1, UNorm8 = 2, SNorm8 = 3, UNorm16 = 4, SNorm16 = 5, UInt8 = 6, SInt8 = 7, UInt16 = 8, SInt16 = 9, UInt32 = 10, SInt32 = 11 }
        export class SubMeshDescriptor extends System.ValueType{ 
        }
        export enum MeshUpdateFlags{ Default = 0, DontValidateIndices = 1, DontResetBoneBounds = 2, DontNotifyMeshUsers = 4, DontRecalculateBounds = 8 }
        export enum ReflectionProbeUsage{ Off = 0, BlendProbes = 1, BlendProbesAndSkybox = 2, Simple = 3 }
        export class ReflectionProbeBlendInfo extends System.ValueType{ 
        }
        export enum ShaderHardwareTier{ Tier1 = 0, Tier2 = 1, Tier3 = 2 }
        export class ShaderTagId extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.ShaderTagId>{ 
        }
        export enum RenderTextureSubElement{ Color = 0, Depth = 1, Stencil = 2, Default = 3 }
        export enum ShaderPropertyType{ Color = 0, Vector = 1, Float = 2, Range = 3, Texture = 4, Int = 5 }
        export enum ShaderPropertyFlags{ None = 0, HideInInspector = 1, PerRendererData = 2, NoScaleOffset = 4, Normal = 8, HDR = 16, Gamma = 32, NonModifiableTextureData = 64, MainTexture = 128, MainColor = 256 }
        export enum TextureDimension{ Unknown = -1, None = 0, Any = 1, Tex2D = 2, Tex3D = 3, Cube = 4, Tex2DArray = 5, CubeArray = 6 }
        export enum AmbientMode{ Skybox = 0, Trilight = 1, Flat = 3, Custom = 4 }
        export enum DefaultReflectionMode{ Skybox = 0, Custom = 1 }
        export enum LightShadowResolution{ FromQualitySettings = -1, Low = 0, Medium = 1, High = 2, VeryHigh = 3 }
        export enum LightEvent{ BeforeShadowMap = 0, AfterShadowMap = 1, BeforeScreenspaceMask = 2, AfterScreenspaceMask = 3, BeforeShadowMapPass = 4, AfterShadowMapPass = 5 }
        export enum ShadowMapPass{ PointlightPositiveX = 1, PointlightNegativeX = 2, PointlightPositiveY = 4, PointlightNegativeY = 8, PointlightPositiveZ = 16, PointlightNegativeZ = 32, DirectionalCascade0 = 64, DirectionalCascade1 = 128, DirectionalCascade2 = 256, DirectionalCascade3 = 512, Spotlight = 1024, Pointlight = 63, Directional = 960, All = 2047 }
        export enum ShadowSamplingMode{ CompareDepths = 0, RawDepth = 1, None = 2 }
        export enum PassType{ Normal = 0, Vertex = 1, VertexLM = 2, VertexLMRGBM = 3, ForwardBase = 4, ForwardAdd = 5, LightPrePassBase = 6, LightPrePassFinal = 7, ShadowCaster = 8, Deferred = 10, Meta = 11, MotionVectors = 12, ScriptableRenderPipeline = 13, ScriptableRenderPipelineDefaultUnlit = 14 }
        export enum GraphicsDeviceType{ OpenGL2 = 0, Direct3D9 = 1, Direct3D11 = 2, PlayStation3 = 3, Null = 4, Xbox360 = 6, OpenGLES2 = 8, OpenGLES3 = 11, PlayStationVita = 12, PlayStation4 = 13, XboxOne = 14, PlayStationMobile = 15, Metal = 16, OpenGLCore = 17, Direct3D12 = 18, N3DS = 19, Vulkan = 21, Switch = 22, XboxOneD3D12 = 23, GameCoreXboxOne = 24, GameCoreScarlett = 25, GameCoreXboxSeries = 25, PlayStation5 = 26, PlayStation5NGGC = 27 }
        export enum RenderingThreadingMode{ Direct = 0, SingleThreaded = 1, MultiThreaded = 2, LegacyJobified = 3, NativeGraphicsJobs = 4, NativeGraphicsJobsWithoutRenderThread = 5 }
        export enum CopyTextureSupport{ None = 0, Basic = 1, Copy3D = 2, DifferentTypes = 4, TextureToRT = 8, RTToTexture = 16 }
        export enum UVChannelFlags{ UV0 = 1, UV1 = 2, UV2 = 4, UV3 = 8 }
        export enum StencilOp{ Keep = 0, Zero = 1, Replace = 2, IncrementSaturate = 3, DecrementSaturate = 4, Invert = 5, IncrementWrap = 6, DecrementWrap = 7 }
        export enum CompareFunction{ Disabled = 0, Never = 1, Less = 2, Equal = 3, LessEqual = 4, Greater = 5, NotEqual = 6, GreaterEqual = 7, Always = 8 }
        export enum ColorWriteMask{ Alpha = 1, Blue = 2, Green = 4, Red = 8, All = 15 }
    }
    export namespace UnityEngine.CullingGroup {
        export type StateChanged = (sphere: UnityEngine.CullingGroupEvent) => void;
        var StateChanged: {new (func: (sphere: UnityEngine.CullingGroupEvent) => void): StateChanged;}
    }
    export namespace UnityEngine.ReflectionProbe {
        export enum ReflectionProbeEvent{ ReflectionProbeAdded = 0, ReflectionProbeRemoved = 1 }
    }
    export namespace UnityEngine.BoundsInt {
        export class PositionEnumerator extends System.ValueType implements System.Collections.Generic.IEnumerator$1<UnityEngine.Vector3Int>, System.Collections.IEnumerator, System.IDisposable{ 
            public get Current(): UnityEngine.Vector3Int;
            public GetEnumerator():UnityEngine.BoundsInt.PositionEnumerator;
            public MoveNext():boolean;
            public Reset():void;
            public constructor($min: UnityEngine.Vector3Int, $max: UnityEngine.Vector3Int);
            public constructor();
        }
    }
    export namespace UnityEngine.RectInt {
        export class PositionEnumerator extends System.ValueType implements System.Collections.Generic.IEnumerator$1<UnityEngine.Vector2Int>, System.Collections.IEnumerator, System.IDisposable{ 
            public get Current(): UnityEngine.Vector2Int;
            public GetEnumerator():UnityEngine.RectInt.PositionEnumerator;
            public MoveNext():boolean;
            public Reset():void;
            public constructor($min: UnityEngine.Vector2Int, $max: UnityEngine.Vector2Int);
            public constructor();
        }
    }
    export namespace UnityEngine.LightingSettings {
        export enum Lightmapper{ Enlighten = 0, ProgressiveCPU = 1, ProgressiveGPU = 2 }
        export enum Sampling{ Auto = 0, Fixed = 1 }
        export enum FilterMode{ None = 0, Auto = 1, Advanced = 2 }
        export enum DenoiserType{ None = 0, Optix = 1, OpenImage = 2, RadeonPro = 3 }
        export enum FilterType{ Gaussian = 0, ATrous = 1, None = 2 }
    }
    export namespace UnityEngine.Display {
        export type DisplaysUpdatedDelegate = () => void;
        var DisplaysUpdatedDelegate: {new (func: () => void): DisplaysUpdatedDelegate;}
    }
    export namespace UnityEngine.Experimental.Rendering {
        export enum GraphicsFormat{ None = 0, R8_SRGB = 1, R8G8_SRGB = 2, R8G8B8_SRGB = 3, R8G8B8A8_SRGB = 4, R8_UNorm = 5, R8G8_UNorm = 6, R8G8B8_UNorm = 7, R8G8B8A8_UNorm = 8, R8_SNorm = 9, R8G8_SNorm = 10, R8G8B8_SNorm = 11, R8G8B8A8_SNorm = 12, R8_UInt = 13, R8G8_UInt = 14, R8G8B8_UInt = 15, R8G8B8A8_UInt = 16, R8_SInt = 17, R8G8_SInt = 18, R8G8B8_SInt = 19, R8G8B8A8_SInt = 20, R16_UNorm = 21, R16G16_UNorm = 22, R16G16B16_UNorm = 23, R16G16B16A16_UNorm = 24, R16_SNorm = 25, R16G16_SNorm = 26, R16G16B16_SNorm = 27, R16G16B16A16_SNorm = 28, R16_UInt = 29, R16G16_UInt = 30, R16G16B16_UInt = 31, R16G16B16A16_UInt = 32, R16_SInt = 33, R16G16_SInt = 34, R16G16B16_SInt = 35, R16G16B16A16_SInt = 36, R32_UInt = 37, R32G32_UInt = 38, R32G32B32_UInt = 39, R32G32B32A32_UInt = 40, R32_SInt = 41, R32G32_SInt = 42, R32G32B32_SInt = 43, R32G32B32A32_SInt = 44, R16_SFloat = 45, R16G16_SFloat = 46, R16G16B16_SFloat = 47, R16G16B16A16_SFloat = 48, R32_SFloat = 49, R32G32_SFloat = 50, R32G32B32_SFloat = 51, R32G32B32A32_SFloat = 52, B8G8R8_SRGB = 56, B8G8R8A8_SRGB = 57, B8G8R8_UNorm = 58, B8G8R8A8_UNorm = 59, B8G8R8_SNorm = 60, B8G8R8A8_SNorm = 61, B8G8R8_UInt = 62, B8G8R8A8_UInt = 63, B8G8R8_SInt = 64, B8G8R8A8_SInt = 65, R4G4B4A4_UNormPack16 = 66, B4G4R4A4_UNormPack16 = 67, R5G6B5_UNormPack16 = 68, B5G6R5_UNormPack16 = 69, R5G5B5A1_UNormPack16 = 70, B5G5R5A1_UNormPack16 = 71, A1R5G5B5_UNormPack16 = 72, E5B9G9R9_UFloatPack32 = 73, B10G11R11_UFloatPack32 = 74, A2B10G10R10_UNormPack32 = 75, A2B10G10R10_UIntPack32 = 76, A2B10G10R10_SIntPack32 = 77, A2R10G10B10_UNormPack32 = 78, A2R10G10B10_UIntPack32 = 79, A2R10G10B10_SIntPack32 = 80, A2R10G10B10_XRSRGBPack32 = 81, A2R10G10B10_XRUNormPack32 = 82, R10G10B10_XRSRGBPack32 = 83, R10G10B10_XRUNormPack32 = 84, A10R10G10B10_XRSRGBPack32 = 85, A10R10G10B10_XRUNormPack32 = 86, RGB_DXT1_SRGB = 96, RGBA_DXT1_SRGB = 96, RGB_DXT1_UNorm = 97, RGBA_DXT1_UNorm = 97, RGBA_DXT3_SRGB = 98, RGBA_DXT3_UNorm = 99, RGBA_DXT5_SRGB = 100, RGBA_DXT5_UNorm = 101, R_BC4_UNorm = 102, R_BC4_SNorm = 103, RG_BC5_UNorm = 104, RG_BC5_SNorm = 105, RGB_BC6H_UFloat = 106, RGB_BC6H_SFloat = 107, RGBA_BC7_SRGB = 108, RGBA_BC7_UNorm = 109, RGB_PVRTC_2Bpp_SRGB = 110, RGB_PVRTC_2Bpp_UNorm = 111, RGB_PVRTC_4Bpp_SRGB = 112, RGB_PVRTC_4Bpp_UNorm = 113, RGBA_PVRTC_2Bpp_SRGB = 114, RGBA_PVRTC_2Bpp_UNorm = 115, RGBA_PVRTC_4Bpp_SRGB = 116, RGBA_PVRTC_4Bpp_UNorm = 117, RGB_ETC_UNorm = 118, RGB_ETC2_SRGB = 119, RGB_ETC2_UNorm = 120, RGB_A1_ETC2_SRGB = 121, RGB_A1_ETC2_UNorm = 122, RGBA_ETC2_SRGB = 123, RGBA_ETC2_UNorm = 124, R_EAC_UNorm = 125, R_EAC_SNorm = 126, RG_EAC_UNorm = 127, RG_EAC_SNorm = 128, RGBA_ASTC4X4_SRGB = 129, RGBA_ASTC4X4_UNorm = 130, RGBA_ASTC5X5_SRGB = 131, RGBA_ASTC5X5_UNorm = 132, RGBA_ASTC6X6_SRGB = 133, RGBA_ASTC6X6_UNorm = 134, RGBA_ASTC8X8_SRGB = 135, RGBA_ASTC8X8_UNorm = 136, RGBA_ASTC10X10_SRGB = 137, RGBA_ASTC10X10_UNorm = 138, RGBA_ASTC12X12_SRGB = 139, RGBA_ASTC12X12_UNorm = 140, YUV2 = 141, DepthAuto = 142, ShadowAuto = 143, VideoAuto = 144, RGBA_ASTC4X4_UFloat = 145, RGBA_ASTC5X5_UFloat = 146, RGBA_ASTC6X6_UFloat = 147, RGBA_ASTC8X8_UFloat = 148, RGBA_ASTC10X10_UFloat = 149, RGBA_ASTC12X12_UFloat = 150 }
        export enum RayTracingMode{ Off = 0, Static = 1, DynamicTransform = 2, DynamicGeometry = 3 }
        export enum DefaultFormat{ LDR = 0, HDR = 1 }
        export enum TextureCreationFlags{ None = 0, MipChain = 1, Crunch = 64 }
        export enum FormatUsage{ Sample = 0, Linear = 1, Sparse = 2, Render = 4, Blend = 5, GetPixels = 6, SetPixels = 7, SetPixels32 = 8, ReadPixels = 9, LoadStore = 10, MSAA2x = 11, MSAA4x = 12, MSAA8x = 13, StencilSampling = 16 }
    }
    export namespace UnityEngine.Mesh {
        export class MeshDataArray extends System.ValueType implements System.IDisposable{ 
            public get Length(): number;
            public get_Item($index: number):UnityEngine.Mesh.MeshData;
            public Dispose():void;
        }
        export class MeshData extends System.ValueType{ 
            public get vertexCount(): number;
            public get vertexBufferCount(): number;
            public get indexFormat(): UnityEngine.Rendering.IndexFormat;
            public get subMeshCount(): number;
            public set subMeshCount(value: number);
            public HasVertexAttribute($attr: UnityEngine.Rendering.VertexAttribute):boolean;
            public GetVertexAttributeDimension($attr: UnityEngine.Rendering.VertexAttribute):number;
            public GetVertexAttributeFormat($attr: UnityEngine.Rendering.VertexAttribute):UnityEngine.Rendering.VertexAttributeFormat;
            public GetVertices($outVertices: Unity.Collections.NativeArray$1<UnityEngine.Vector3>):void;
            public GetNormals($outNormals: Unity.Collections.NativeArray$1<UnityEngine.Vector3>):void;
            public GetTangents($outTangents: Unity.Collections.NativeArray$1<UnityEngine.Vector4>):void;
            public GetColors($outColors: Unity.Collections.NativeArray$1<UnityEngine.Color>):void;
            public GetColors($outColors: Unity.Collections.NativeArray$1<UnityEngine.Color32>):void;
            public GetUVs($channel: number, $outUVs: Unity.Collections.NativeArray$1<UnityEngine.Vector2>):void;
            public GetUVs($channel: number, $outUVs: Unity.Collections.NativeArray$1<UnityEngine.Vector3>):void;
            public GetUVs($channel: number, $outUVs: Unity.Collections.NativeArray$1<UnityEngine.Vector4>):void;
            public SetVertexBufferParams($vertexCount: number, ...attributes: UnityEngine.Rendering.VertexAttributeDescriptor[]):void;
            public SetVertexBufferParams($vertexCount: number, $attributes: Unity.Collections.NativeArray$1<UnityEngine.Rendering.VertexAttributeDescriptor>):void;
            public SetIndexBufferParams($indexCount: number, $format: UnityEngine.Rendering.IndexFormat):void;
            public GetIndices($outIndices: Unity.Collections.NativeArray$1<number>, $submesh: number, $applyBaseVertex?: boolean):void;
            public GetIndices($outIndices: Unity.Collections.NativeArray$1<number>, $submesh: number, $applyBaseVertex?: boolean):void;
            public GetSubMesh($index: number):UnityEngine.Rendering.SubMeshDescriptor;
            public SetSubMesh($index: number, $desc: UnityEngine.Rendering.SubMeshDescriptor, $flags?: UnityEngine.Rendering.MeshUpdateFlags):void;
        }
    }
    export namespace UnityEngine.GraphicsBuffer {
        export enum Target{ Vertex = 1, Index = 2, Structured = 16, Raw = 32, Append = 64, Counter = 128, IndirectArguments = 256, Constant = 512 }
    }
    export namespace UnityEngine.LightProbeProxyVolume {
        export enum BoundingBoxMode{ AutomaticLocal = 0, AutomaticWorld = 1, Custom = 2 }
        export enum ResolutionMode{ Automatic = 0, Custom = 1 }
        export enum ProbePositionMode{ CellCorner = 0, CellCenter = 1 }
        export enum RefreshMode{ Automatic = 0, EveryFrame = 1, ViaScripting = 2 }
        export enum QualityMode{ Low = 0, Normal = 1 }
        export enum DataFormat{ HalfFloat = 0, Float = 1 }
    }
    export namespace UnityEngine.Texture2D {
        export enum EXRFlags{ None = 0, OutputAsFloat = 1, CompressZIP = 2, CompressRLE = 4, CompressPIZ = 8 }
    }
    export namespace UnityEngine.ADBannerView {
        export enum Layout{ Top = 0, Bottom = 1, TopLeft = 0, TopRight = 4, TopCenter = 8, BottomLeft = 1, BottomRight = 5, BottomCenter = 9, CenterLeft = 2, CenterRight = 6, Center = 10, Manual = -1 }
        export enum Type{ Banner = 0, MediumRect = 1 }
        export type BannerWasClickedDelegate = () => void;
        var BannerWasClickedDelegate: {new (func: () => void): BannerWasClickedDelegate;}
        export type BannerWasLoadedDelegate = () => void;
        var BannerWasLoadedDelegate: {new (func: () => void): BannerWasLoadedDelegate;}
    }
    export namespace UnityEngine.ADInterstitialAd {
        export type InterstitialWasLoadedDelegate = () => void;
        var InterstitialWasLoadedDelegate: {new (func: () => void): InterstitialWasLoadedDelegate;}
    }
    export namespace UnityEngine.Random {
        export class State extends System.ValueType{ 
        }
    }
    export namespace UnityEngine.Scripting {
        export class PreserveAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
        }
    }
    export namespace UnityEngine.ShaderVariantCollection {
        export class ShaderVariant extends System.ValueType{ 
            public shader: UnityEngine.Shader;
            public passType: UnityEngine.Rendering.PassType;
            public keywords: System.Array$1<string>;
            public constructor($shader: UnityEngine.Shader, $passType: UnityEngine.Rendering.PassType, ...keywords: string[]);
            public constructor();
        }
    }
    export namespace UnityEngine.TouchScreenKeyboard {
        export enum Status{ Visible = 0, Done = 1, Canceled = 2, LostFocus = 3 }
    }
    export namespace UnityEngine.RectTransform {
        export type ReapplyDrivenProperties = (driven: UnityEngine.RectTransform) => void;
        var ReapplyDrivenProperties: {new (func: (driven: UnityEngine.RectTransform) => void): ReapplyDrivenProperties;}
        export enum Edge{ Left = 0, Right = 1, Top = 2, Bottom = 3 }
        export enum Axis{ Horizontal = 0, Vertical = 1 }
    }
    export namespace UnityEngine.SocialPlatforms {
        export interface ISocialPlatform{ 
        }
        export interface ILocalUser extends UnityEngine.SocialPlatforms.IUserProfile{ 
        }
        export interface IUserProfile{ 
        }
        export interface IAchievementDescription{ 
        }
        export interface IAchievement{ 
        }
        export interface IScore{ 
        }
        export interface ILeaderboard{ 
        }
    }
    export namespace UnityEngine.GridLayout {
        export enum CellLayout{ Rectangle = 0, Hexagon = 1, Isometric = 2, IsometricZAsY = 3 }
        export enum CellSwizzle{ XYZ = 0, XZY = 1, YXZ = 2, YZX = 3, ZXY = 4, ZYX = 5 }
    }
    export namespace UnityEngine.GUI {
        export enum ToolbarButtonSize{ Fixed = 0, FitToContents = 1 }
        export type WindowFunction = (id: number) => void;
        var WindowFunction: {new (func: (id: number) => void): WindowFunction;}
        export class Scope extends System.Object implements System.IDisposable{ 
            public Dispose():void;
        }
    }
    export namespace UnityEngine.TextEditor {
        export enum DblClickSnapping{ WORDS = 0, PARAGRAPHS = 1 }
    }
    export namespace Unity.Jobs {
        export class JobHandle extends System.ValueType{ 
        }
    }
    export namespace UnityEngine.CompositeCollider2D {
        export enum GeometryType{ Outlines = 0, Polygons = 1 }
        export enum GenerationType{ Synchronous = 0, Manual = 1 }
    }
    export namespace UnityEngine.ScreenCapture {
        export enum StereoScreenCaptureMode{ LeftEye = 1, RightEye = 2, BothEyes = 3 }
    }
    export namespace UnityEngine.Terrain {
        export enum MaterialType{ BuiltInStandard = 0, BuiltInLegacyDiffuse = 1, BuiltInLegacySpecular = 2, Custom = 3 }
    }
    export namespace UnityEngine.Font {
        export type FontTextureRebuildCallback = () => void;
        var FontTextureRebuildCallback: {new (func: () => void): FontTextureRebuildCallback;}
    }
    export namespace UnityEngine.GridBrushBase {
        export enum RotationDirection{ Clockwise = 0, CounterClockwise = 1 }
        export enum FlipAxis{ X = 0, Y = 1 }
        export enum Tool{ Select = 0, Move = 1, Paint = 2, Box = 3, Pick = 4, Erase = 5, FloodFill = 6 }
    }
    export namespace UnityEngine.CanvasRenderer {
        export type OnRequestRebuild = () => void;
        var OnRequestRebuild: {new (func: () => void): OnRequestRebuild;}
    }
    export namespace UnityEngine.UISystemProfilerApi {
        export enum SampleType{ Layout = 0, Render = 1 }
    }
    export namespace UnityEngine.RemoteSettings {
        export type UpdatedEventHandler = () => void;
        var UpdatedEventHandler: {new (func: () => void): UpdatedEventHandler;}
    }
    export namespace System.Text {
        export class Encoding extends System.Object implements System.ICloneable{ 
        }
    }
    export namespace UnityEngine.UI.ExtensionsToggle {
        export enum ToggleTransition{ None = 0, Fade = 1 }
        export class ToggleEvent extends UnityEngine.Events.UnityEvent$1<boolean> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class ToggleEventObject extends UnityEngine.Events.UnityEvent$1<UnityEngine.UI.ExtensionsToggle> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace UnityEngine.UI.ExtensionsToggleGroup {
        export class ToggleGroupEvent extends UnityEngine.Events.UnityEvent$1<boolean> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace Runtime {
        export class Api extends Sirenix.OdinInspector.SerializedMonoBehaviour implements Sirenix.Serialization.ISupportsPrefabSerialization, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class DefaultStateAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public get type(): System.Type;
            public set type(value: System.Type);
            public constructor($_type: System.Type);
            public constructor();
        }
        export class DoInject extends System.Object{ 
        }
        export class DontDrawThisAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class DontGenAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class FoldoutAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute{ 
            public name: string;
            public foldEverything: boolean;
            public constructor($name: string, $foldEverything?: boolean);
            public constructor();
        }
        export class InjectAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public name: string;
            public type: System.Type;
            public static Dispatch():void;
            public constructor($_name: string);
            public constructor($_type: System.Type, $_name?: string);
            public constructor();
        }
        export class OnAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public get type(): System.Type;
            public set type(value: System.Type);
            public constructor($type: System.Type);
            public constructor();
        }
        export class PreloadSettingAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public static Inited: boolean;
            public constructor();
        }
        export class AssemblyFilterAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class SubTypeFilterAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class ExcludeFilterAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class IncludeFilterAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class PuertsIgnoreAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class RegisterEnvAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public get Order(): number;
            public set Order(value: number);
            public constructor();
            public constructor($order: number);
        }
        export class TypeFilterAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class PuertsBlacklistAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class TypingExportAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class ReferenceAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute{ 
            public PropName: string;
            public constructor($propName: string);
            public constructor();
        }
        export class SceneBindAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public Type: System.Type;
            public Tags: System.Collections.Generic.List$1<string>;
            public get SceneName(): string;
            public static GetAssemblyByName($name?: string):System.Reflection.Assembly;
            public constructor();
            public constructor($name: any);
            public constructor($name: any, $component?: System.Type, ...tags: any[]);
        }
        export class TagFieldAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public categoryName: string;
            public constructor();
        }
        export class TagFilterAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute{ 
            public get Type(): System.Type;
            public constructor($type: System.Type);
            public constructor();
        }
        export class ConfigData extends Sirenix.Utilities.GlobalConfig$1<Runtime.ConfigData>{ 
            public MyGlobalVariable: number;
            public constructor();
        }
        export class CustomJsLoader extends System.Object implements Puerts.ILoader{ 
            public static get config(): Runtime.TsConfig;
            public FileExists($filepath: string):boolean;
            public ReadFile($filepath: string, $debugpath: $Ref<string>):string;
            public constructor();
            public constructor($root: string);
            public FileExists($filepath: string):boolean;
            public ReadFile($filepath: string, $debugpath: $Ref<string>):string;
        }
        export class TsConfig extends UnityEngine.ScriptableObject{ 
            public isRunQuickStart: boolean;
            public debugPort: number;
            public rootPath: string;
            public isWatching: boolean;
            public isPause: boolean;
            public isLog: boolean;
            public isLogRequirePath: boolean;
            public sourcePath: System.Collections.Generic.List$1<string>;
            public static get instance(): Runtime.TsConfig;
            public static get hasInstance(): boolean;
            public get outputPath(): string;
            public get isLogDebugPath(): boolean;
            public set isLogDebugPath(value: boolean);
            public static add_OnLoad($value: System.Action):void;
            public static remove_OnLoad($value: System.Action):void;
            public static FindAsset():Runtime.TsConfig;
            public static GenScriptPath():void;
            public constructor();
        }
        export class Assets extends System.Object{ 
            public static GetAwaiter($operation: UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationHandle):Cysharp.Threading.Tasks.UniTask.Awaiter;
            public static GetAwaiter($uevent: UnityEngine.Events.UnityEvent):Cysharp.Threading.Tasks.UniTask.Awaiter;
        }
        export class Awaiters extends System.Object{ 
            public static GetAwaiter($asyncOp: UnityEngine.Networking.UnityWebRequestAsyncOperation):Runtime.Awaiters.UnityWebRequestAwaiter;
            public static GetAwaiter($asyncOp: UnityEngine.AsyncOperation):System.Runtime.CompilerServices.TaskAwaiter;
        }
        export class Components extends System.Object{ 
            public static AddComponent($go: UnityEngine.GameObject, $toAdd: UnityEngine.Component):UnityEngine.Component;
            public static Init($go: UnityEngine.GameObject, $comp: UnityEngine.Component):void;
            public static GetCopyOf($comp: UnityEngine.Component, $other: UnityEngine.Component):UnityEngine.Component;
            public static RequireComponent($trans: UnityEngine.Transform, $type: System.Type):UnityEngine.MonoBehaviour;
            public static RequireComponent($trans: UnityEngine.Component, $type: System.Type):UnityEngine.MonoBehaviour;
            public static RequireComponent($go: UnityEngine.GameObject, $type: System.Type):UnityEngine.MonoBehaviour;
            public static FindChildGameObject($trans: UnityEngine.Transform, $layerStr: string):UnityEngine.GameObject;
            public static SetActiveAll($go: UnityEngine.GameObject, $active: boolean, $recursively: boolean, $includeInactive?: boolean):void;
            public static FindFirstComponentInChild($trans: UnityEngine.Transform, $layerStr: string, $type: System.Type):UnityEngine.Component;
            public static FindFirstComponentInChild($go: UnityEngine.GameObject, $layerStr: string, $type: System.Type):UnityEngine.Component;
            public static DestroySelf($go: UnityEngine.Transform, $delay: number):boolean;
            public static DestroySelf($go: UnityEngine.Object, $delay: number):boolean;
            public static DestroySelf($go: UnityEngine.GameObject, $delay: number):boolean;
            public static SetLayer($go: UnityEngine.GameObject, $layer: number, $withChildren: boolean):void;
            public static DestroySelf($obj: UnityEngine.Object):void;
            public static DestroyGameObject($go: $Ref<UnityEngine.GameObject>):void;
            public static ResetTransform($trans: UnityEngine.Transform):void;
            public static ResetTransform($go: UnityEngine.GameObject):void;
            public static CopyTempTransform($trans: UnityEngine.Transform):UnityEngine.Transform;
            public static ResetParent($trans: UnityEngine.Transform, $parent: UnityEngine.Transform, $resetTransform?: boolean):void;
            public static LookAt_2D($trans: UnityEngine.Transform, $pos: UnityEngine.Vector3):void;
            public static LookAtDir($trans: UnityEngine.Transform, $dir: UnityEngine.Vector3):void;
            public static LookAtDir_2D($trans: UnityEngine.Transform, $dir: UnityEngine.Vector3):void;
            public static WrappedSetParent($rectTrans: UnityEngine.RectTransform, $parent: UnityEngine.Transform):void;
            public static Clear($curve: UnityEngine.AnimationCurve):UnityEngine.AnimationCurve;
            public static GetCurrentClipLength($animator: UnityEngine.Animator, $defaultVal?: number):number;
            public static GetNextClipLength($animator: UnityEngine.Animator, $defaultVal?: number):number;
            public static PlayerPrefs_GetString($key: string, $defaultString: string):string;
            public static PlayerPrefs_GetInt($key: string, $defaultInt: number):number;
            public static PlayerPrefs_GetFloat($key: string, $defaultFloat: number):number;
        }
        export class DoTweens extends System.Object{ 
            public static DOJump($target: UnityEngine.RectTransform, $endValue: UnityEngine.Vector3, $numJumps: number, $duration: number, $snapping?: boolean):DG.Tweening.Sequence;
            public static cloneSelfMaterial($img: UnityEngine.UI.Image):void;
            public static setToneIntensity($image: UnityEngine.UI.Image, $_toneIntensity: number):void;
            public static setSaturation($image: UnityEngine.UI.Image, $saturation: number):void;
            public static setContrast($image: UnityEngine.UI.Image, $Contrast: number):void;
            public static setToneColor($image: UnityEngine.UI.Image, $toneColor: UnityEngine.Color):void;
            public static resetDefaultImageEffect($image: UnityEngine.UI.Image):void;
        }
        export class Floats extends System.Object{ 
            public static eq($a: number, $b: number, $epsilon?: number):boolean;
        }
        export class GameObjects extends System.Object{ 
            public static SetParent($gameObject: UnityEngine.GameObject, $parent: UnityEngine.Transform):void;
            public static SetParent($gameObject: UnityEngine.GameObject, $parent: UnityEngine.GameObject):void;
            public static AddComponentOnce($gameObject: UnityEngine.GameObject, $type: System.Type):UnityEngine.MonoBehaviour;
            public static ToggleShow($gameObject: UnityEngine.GameObject):boolean;
            public static LogName($go: UnityEngine.GameObject):void;
            public static AddComonentOnce($transform: UnityEngine.Transform, $type: System.Type):UnityEngine.MonoBehaviour;
            public static AddComonentOnce($mb: UnityEngine.MonoBehaviour, $type: System.Type):UnityEngine.MonoBehaviour;
            public static AddComponentOnce($component: UnityEngine.Component, $type: System.Type):UnityEngine.MonoBehaviour;
        }
        export class Linqes extends System.Object{ 
        }
        export class Lists extends System.Object{ 
            public static Add($list: System.Collections.Generic.List$1<string>, $value: any):void;
            public static ForEach($array: System.Array$1<number>, $action: System.Action$3<number, number, number>):System.Array$1<number>;
            public static ToCols0($array: System.Array$1<number>, $action?: System.Action$1<System.Collections.Generic.List$1<System.Collections.Generic.List$1<number>>>):System.Collections.Generic.List$1<System.Collections.Generic.List$1<number>>;
            public static ToRows0($array: System.Array$1<number>, $action?: System.Action$1<System.Collections.Generic.List$1<System.Collections.Generic.List$1<number>>>):System.Collections.Generic.List$1<System.Collections.Generic.List$1<number>>;
            public static ToRows($array: System.Array$1<number>, $action?: System.Action$2<System.Collections.Generic.List$1<System.Collections.Generic.List$1<number>>, System.Collections.Generic.List$1<number>>):System.Collections.Generic.List$1<System.Collections.Generic.List$1<number>>;
            public static ToRows2($array: System.Array$1<number>, $action?: System.Action$3<System.Collections.Generic.List$1<System.Collections.Generic.List$1<number>>, System.Collections.Generic.List$1<number>, number>):System.Collections.Generic.List$1<System.Collections.Generic.List$1<number>>;
            public static ToCols2($array: System.Array$1<number>, $action?: System.Action$3<System.Collections.Generic.List$1<System.Collections.Generic.List$1<number>>, System.Collections.Generic.List$1<number>, number>):System.Collections.Generic.List$1<System.Collections.Generic.List$1<number>>;
            public static ToCols($array: System.Array$1<number>, $action?: System.Action$2<System.Collections.Generic.List$1<System.Collections.Generic.List$1<number>>, System.Collections.Generic.List$1<number>>):System.Collections.Generic.List$1<System.Collections.Generic.List$1<number>>;
        }
        export class Monos extends System.Object{ 
            public static StartCoroutine($mb: UnityEngine.MonoBehaviour, $funcs: System.Action):void;
            public static StartCoroutine($mb: UnityEngine.MonoBehaviour, ...funcs: System.Action[]):void;
            public static StartCoroutine($mb: UnityEngine.MonoBehaviour, $funcs: System.Action, $time?: number):void;
            public static StartCoroutine($mb: UnityEngine.MonoBehaviour, $time: number, ...funcs: System.Action[]):void;
            public static MyPosition($selfComponent: UnityEngine.Component, $position: UnityEngine.Vector3):UnityEngine.Component;
            public static MyLocalScale($selfComponent: UnityEngine.Component, $xyz: number):UnityEngine.Component;
            public static MyRotation($selfComponent: UnityEngine.Component, $rotation: UnityEngine.Quaternion):UnityEngine.Component;
        }
        export class Objects extends System.Object{ 
            public static IsNull($o: UnityEngine.Object):boolean;
        }
        export class Paths extends System.Object{ 
            public static GetFullPath($path: string):string;
            public static DeleteEmptyDirs($dir: System.IO.DirectoryInfo):void;
            public static RenameTo($fileInfo: System.IO.FileInfo, $newName: string):void;
            public static AssetPathNormal($path: string):string;
            public static PathCombine($path: string, ...names: string[]):string;
            public static RenameObject($obj: UnityEngine.Object, $newName: string):void;
            public static RenamePath($fullpath: string, $newName: string):void;
        }
        export class Prefabs extends System.Object{ 
            public static SyncAssets($gameObject: UnityEngine.GameObject, $path?: string):void;
            public static _GetPrefabSavePath($gameObject: UnityEngine.GameObject, $getDirName?: boolean):string;
        }
        export class RectTransforms extends System.Object{ 
            public static MatchOther($rt: UnityEngine.RectTransform, $other: UnityEngine.RectTransform):void;
            public static Height($rt: UnityEngine.RectTransform, $height?: number):number;
            public static Width($rt: UnityEngine.RectTransform, $width?: number):number;
            public static Top($rt: UnityEngine.RectTransform, $top?: number):number;
            public static Bottom($rt: UnityEngine.RectTransform, $bottom?: number):number;
            public static Pos($rt: UnityEngine.RectTransform, $pos: UnityEngine.Vector2):UnityEngine.Vector2;
            public static Pos($rt: UnityEngine.RectTransform, $x?: number, $y?: number):UnityEngine.Vector2;
            public static PosX($rt: UnityEngine.RectTransform, $x?: number):number;
            public static PosY($rt: UnityEngine.RectTransform, $y?: number):number;
            public static SetLeft($rt: UnityEngine.RectTransform, $left: number):void;
            public static SetRight($rt: UnityEngine.RectTransform, $right: number):void;
            public static SetTop($rt: UnityEngine.RectTransform, $top: number):void;
            public static SetBottom($rt: UnityEngine.RectTransform, $bottom: number):void;
        }
        export class Scenes extends System.Object{ 
            public static SetDirty($scene: UnityEngine.SceneManagement.Scene):void;
        }
        export class Scritables extends System.Object{ 
            public static Save($obj: UnityEngine.ScriptableObject):UnityEngine.ScriptableObject;
            public static Restore($obj: UnityEngine.ScriptableObject):UnityEngine.ScriptableObject;
        }
        export class Strings extends System.Object{ 
            public static IsNotNullOrEmpty($value: string):boolean;
            public static IsNullOrEmpty($input: string):boolean;
            public static IsNullOrWhiteSpace($input: string):boolean;
            public static _TagKey($str: string):string;
            public static ToPadSides($str: string, $totalWidth?: number, $paddingChar?: number):string;
            public static ToCapitalStr($str: string):string;
            public static ToGreen($str: any, ...extra: any[]):string;
            public static ToYellow($str: any, ...extra: any[]):string;
            public static ToWhite($str: any, ...extra: any[]):string;
            public static ToBlue($str: any, ...extra: any[]):string;
            public static ToRed($str: any, ...extra: any[]):string;
            public static ToBold($str: any, ...extra: any[]):string;
            public static GetBytes($str: string):System.Array$1<number>;
            public static GetString($bytes: System.Array$1<number>):string;
            public static Md5($str: string):string;
            public static PadBoth($str: string, $length: number, $chars?: string):string;
            public static Color($str: string, $color: UnityEngine.Color):string;
            public static md5($observedText: string):string;
            public static JsPath($path: string, $ext?: string, $fullpath?: boolean):string;
            public static JsFullPath($path: string):string;
            public static RemoveAssets($path: string):string;
            public static GetObjectPath($obj: UnityEngine.Object):string;
            public static GetGUID($path: string):string;
            public static FullPath($path: string):string;
            public ToGreen(...extra: any[]):null;
            public ToYellow(...extra: any[]):null;
            public ToWhite(...extra: any[]):null;
            public ToBlue(...extra: any[]):null;
            public ToRed(...extra: any[]):null;
            public ToBold(...extra: any[]):null;
        }
        export class Transforms extends System.Object{ 
            public static GameObjectAssetPath($go: UnityEngine.GameObject):string;
            public static Show($gameObject: UnityEngine.GameObject):void;
            public static Hide($gameObject: UnityEngine.GameObject):void;
            public static Toggle($gameObject: UnityEngine.GameObject):void;
            public static Show($transform: UnityEngine.Component):void;
            public static Hide($transform: UnityEngine.Component):void;
            public static Toggle($transform: UnityEngine.Component):void;
            public static Active($component: UnityEngine.Component, $enable?: boolean):void;
            public static FindOrCreate($transform: UnityEngine.Transform, $name: string):UnityEngine.Transform;
            public static FindOrCreate($go: UnityEngine.GameObject, $name: string):UnityEngine.GameObject;
            public static FindOrCreateRoot($gameObject: UnityEngine.GameObject, $name: string):UnityEngine.GameObject;
            public static ToVector3Int($vector3: UnityEngine.Vector3):UnityEngine.Vector3Int;
            public static X($component: UnityEngine.Component, $withParent?: boolean, $x?: number):number;
            public static Y($component: UnityEngine.Component, $withParent?: boolean, $y?: number):number;
            public static Z($component: UnityEngine.Component, $withParent?: boolean, $z?: number):number;
            public static IntX($component: UnityEngine.Component, $withParent?: boolean, $x?: number):number;
            public static IntY($component: UnityEngine.Component, $withParent?: boolean, $y?: number):number;
            public static IntZ($component: UnityEngine.Component, $withParent?: boolean, $z?: number):number;
            public static XAdd($component: UnityEngine.Component, $x: number):UnityEngine.Vector3;
            public static YAdd($component: UnityEngine.Component, $y: number):UnityEngine.Vector3;
            public static ZAdd($component: UnityEngine.Component, $z: number):UnityEngine.Vector3;
            public static XY($component: UnityEngine.Component, $withParent?: boolean, $x?: number, $y?: number):UnityEngine.Vector2Int;
            public static XZ($component: UnityEngine.Component, $withParent?: boolean, $x?: number, $z?: number):UnityEngine.Vector2Int;
            public static getvVector3Int($component: UnityEngine.Component, $withParent?: boolean, $x?: number, $y?: number, $z?: number):UnityEngine.Vector3Int;
            public static addVector3($component: UnityEngine.Component, $x: number, $y: number, $z: number):UnityEngine.Vector3;
            public static addVector3($component: UnityEngine.Component, $x: number, $y: number, $z: number):UnityEngine.Vector3;
            public static AlignTo($src: UnityEngine.Transform, $dest: UnityEngine.Transform, $moveToLast?: boolean):UnityEngine.Transform;
            public static AlignTo($src: UnityEngine.RectTransform, $dest: UnityEngine.RectTransform, $moveToLast?: boolean):UnityEngine.RectTransform;
            public static AlignTo($src: UnityEngine.RectTransform, $dest: UnityEngine.Transform, $moveToLast?: boolean):UnityEngine.RectTransform;
            public static AlignTo($src: UnityEngine.Transform, $dest: UnityEngine.RectTransform, $moveToLast?: boolean):UnityEngine.RectTransform;
            public static ClearChildTransforms($transform: UnityEngine.Transform, $expr?: System.Linq.Expressions.Expression$1<System.Func$2<UnityEngine.Transform, boolean>>, $directOnly?: boolean):void;
            public static ChildGameObjects($transform: UnityEngine.Transform, $expr?: System.Linq.Expressions.Expression$1<System.Func$2<UnityEngine.Transform, boolean>>, $directOnly?: boolean):System.Collections.Generic.List$1<UnityEngine.GameObject>;
            public static ChildGameObjects($component: UnityEngine.Component, $expr?: System.Linq.Expressions.Expression$1<System.Func$2<UnityEngine.Transform, boolean>>, $directOnly?: boolean):System.Collections.Generic.List$1<UnityEngine.GameObject>;
            public static ChildGameObjects($gameObject: UnityEngine.GameObject, $expr?: System.Linq.Expressions.Expression$1<System.Func$2<UnityEngine.Transform, boolean>>, $directOnly?: boolean):System.Collections.Generic.List$1<UnityEngine.GameObject>;
            public static Childs($gameObject: UnityEngine.GameObject, $expr?: System.Linq.Expressions.Expression$1<System.Func$2<UnityEngine.Transform, boolean>>, $directOnly?: boolean):System.Collections.Generic.List$1<UnityEngine.Transform>;
            public static Childs($gameObject: UnityEngine.Component, $expr?: System.Linq.Expressions.Expression$1<System.Func$2<UnityEngine.Transform, boolean>>, $directOnly?: boolean):System.Collections.Generic.List$1<UnityEngine.Transform>;
            public static Childs($transform: UnityEngine.Transform, $expr?: System.Linq.Expressions.Expression$1<System.Func$2<UnityEngine.Transform, boolean>>, $directOnly?: boolean):System.Collections.Generic.List$1<UnityEngine.Transform>;
            public static dataPathRoot($path: string):string;
            public static M_PregReplace($str: string, $rule: System.Array$1<string>, $to: string):string;
            public static M_PregReplace($str: string, $rule: string, $to: string):string;
            public static M_PregReplace($str: string, $rule: System.Array$1<string>, $to: System.Array$1<string>):string;
            public static dataPathRoot($obj: UnityEngine.Object):string;
            public static Dirname($path: string, $create?: boolean):string;
            public static FileExtension($path: string):string;
            public static ResourcePath($obj: UnityEngine.Object):string;
            public static ResourcePath($path: string):string;
            public static GetAssetPath($obj: UnityEngine.Object):string;
            public static CreateDirFromFilePath($path: string, $isFile?: boolean):string;
            public static GetPath($gameObject: UnityEngine.GameObject):string;
            public static GetPath($component: UnityEngine.Component):string;
            public static GetClassPath($component: UnityEngine.Component):string;
            public static M_VarName($theVar: string, $toCaptical?: boolean):string;
            public static GetClassPath($gameObject: UnityEngine.GameObject):string;
        }
        export class Vectors extends System.Object{ 
            public static SetX($target: UnityEngine.Vector3, $value: number):UnityEngine.Vector3;
            public static SetY($target: UnityEngine.Vector3, $value: number):UnityEngine.Vector3;
        }
        export class JsEnvUtils extends System.Object{ 
            public static Env($target: any):Puerts.JsEnv;
            public static IsDisposed($jsEnv: Puerts.JsEnv):boolean;
            public static GetFullName($myEnum: System.Enum):string;
            public static AsString($obj: any):string;
            public Env():null;
            public AsString():null;
        }
        export class JsMain extends UnityEngine.MonoBehaviour{ 
            public static get instance(): Runtime.JsMain;
            public get TscTickTime(): string;
            public set TscTickTime(value: string);
            public get TscReloadTime(): string;
            public set TscReloadTime(value: string);
            public get EnvTickTime(): string;
            public set EnvTickTime(value: string);
            public static set SetTickTime(value: string);
            public static set SetTscReloadTime(value: string);
            public static get env(): Puerts.JsEnv;
            public static get config(): Runtime.TsConfig;
            public static GetAssemblyByName($name: string):System.Reflection.Assembly;
            public static AutoUsing():void;
            public static api($obj?: Runtime.Api$1<T>):Runtime.Api$1<T>;
            public Start():void;
            public static json($obj: any):string;
            public static getTsFiles($dir: string):string;
            public constructor();
        }
        export class Api$1<T> extends Runtime.Api implements Sirenix.Serialization.ISupportsPrefabSerialization, UnityEngine.ISerializationCallbackReceiver{ 
        }
        export interface IMeshFactory{ 
            name: string;
        }
        export class Shell extends System.Object{ 
            public static Wsl($cmd: string, $noWindow?: boolean):string;
            public static Run($command: string, $argument: string, $noWindow?: boolean):string;
            public constructor();
        }
    }
    export namespace Sirenix.OdinInspector {
        export class SerializedMonoBehaviour extends UnityEngine.MonoBehaviour implements Sirenix.Serialization.ISupportsPrefabSerialization, UnityEngine.ISerializationCallbackReceiver{ 
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class SerializedScriptableObject extends UnityEngine.ScriptableObject implements UnityEngine.ISerializationCallbackReceiver{ 
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace Sirenix.Serialization {
        export interface ISupportsPrefabSerialization{ 
        }
    }
    export namespace Sirenix.Utilities {
        export class GlobalConfig$1<T> extends UnityEngine.ScriptableObject{ 
        }
    }
    export namespace Cysharp.Threading.Tasks.UniTask$1 {
        export class Awaiter<T> extends System.ValueType implements System.Runtime.CompilerServices.INotifyCompletion, System.Runtime.CompilerServices.ICriticalNotifyCompletion{ 
        }
    }
    export namespace System.Runtime.CompilerServices {
        export interface INotifyCompletion{ 
        }
        export interface ICriticalNotifyCompletion extends System.Runtime.CompilerServices.INotifyCompletion{ 
        }
        export class TaskAwaiter extends System.ValueType implements System.Runtime.CompilerServices.INotifyCompletion, System.Runtime.CompilerServices.ICriticalNotifyCompletion{ 
        }
        export interface ITuple{ 
        }
    }
    export namespace UnityEngine.ResourceManagement.AsyncOperations {
        export class AsyncOperationHandle$1<TObject> extends System.ValueType implements System.Collections.IEnumerator, System.IEquatable$1<UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationHandle$1<TObject>>{ 
        }
        export class AsyncOperationHandle extends System.ValueType implements System.Collections.IEnumerator{ 
        }
        interface AsyncOperationHandle {
            GetAwaiter():Cysharp.Threading.Tasks.UniTask.Awaiter;
        }
    }
    export namespace Cysharp.Threading.Tasks.UniTask {
        export class Awaiter extends System.ValueType implements System.Runtime.CompilerServices.INotifyCompletion, System.Runtime.CompilerServices.ICriticalNotifyCompletion{ 
        }
    }
    export namespace Runtime.Awaiters {
        export class UnityWebRequestAwaiter extends System.Object implements System.Runtime.CompilerServices.INotifyCompletion{ 
            public get IsCompleted(): boolean;
            public GetResult():void;
            public OnCompleted($continuation: System.Action):void;
            public constructor($asyncOp: UnityEngine.Networking.UnityWebRequestAsyncOperation);
            public constructor();
        }
    }
    export namespace UnityEngine.Networking {
        export class UnityWebRequestAsyncOperation extends UnityEngine.AsyncOperation{ 
        }
        interface UnityWebRequestAsyncOperation {
            GetAwaiter():Runtime.Awaiters.UnityWebRequestAwaiter;
        }
    }
    export namespace DG.Tweening {
        export class Sequence extends DG.Tweening.Tween{ 
        }
        export class Tween extends DG.Tweening.Core.ABSSequentiable{ 
        }
        interface Tween {
            WaitForCompletion($returnCustomYieldInstruction: boolean):UnityEngine.CustomYieldInstruction;
            WaitForRewind($returnCustomYieldInstruction: boolean):UnityEngine.CustomYieldInstruction;
            WaitForKill($returnCustomYieldInstruction: boolean):UnityEngine.CustomYieldInstruction;
            WaitForElapsedLoops($elapsedLoops: number, $returnCustomYieldInstruction: boolean):UnityEngine.CustomYieldInstruction;
            WaitForPosition($position: number, $returnCustomYieldInstruction: boolean):UnityEngine.CustomYieldInstruction;
            WaitForStart($returnCustomYieldInstruction: boolean):UnityEngine.CustomYieldInstruction;
            AsyncWaitForCompletion():System.Threading.Tasks.Task;
            AsyncWaitForRewind():System.Threading.Tasks.Task;
            AsyncWaitForKill():System.Threading.Tasks.Task;
            AsyncWaitForElapsedLoops($elapsedLoops: number):System.Threading.Tasks.Task;
            AsyncWaitForPosition($position: number):System.Threading.Tasks.Task;
            AsyncWaitForStart():System.Threading.Tasks.Task;
        }
        export class DOTweenModuleAudio extends System.Object{ 
            public static DOFade($target: UnityEngine.AudioSource, $endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<number, number, DG.Tweening.Plugins.Options.FloatOptions>;
            public static DOPitch($target: UnityEngine.AudioSource, $endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<number, number, DG.Tweening.Plugins.Options.FloatOptions>;
            public static DOSetFloat($target: UnityEngine.Audio.AudioMixer, $floatName: string, $endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<number, number, DG.Tweening.Plugins.Options.FloatOptions>;
            public static DOComplete($target: UnityEngine.Audio.AudioMixer, $withCallbacks?: boolean):number;
            public static DOKill($target: UnityEngine.Audio.AudioMixer, $complete?: boolean):number;
            public static DOFlip($target: UnityEngine.Audio.AudioMixer):number;
            public static DOGoto($target: UnityEngine.Audio.AudioMixer, $to: number, $andPlay?: boolean):number;
            public static DOPause($target: UnityEngine.Audio.AudioMixer):number;
            public static DOPlay($target: UnityEngine.Audio.AudioMixer):number;
            public static DOPlayBackwards($target: UnityEngine.Audio.AudioMixer):number;
            public static DOPlayForward($target: UnityEngine.Audio.AudioMixer):number;
            public static DORestart($target: UnityEngine.Audio.AudioMixer):number;
            public static DORewind($target: UnityEngine.Audio.AudioMixer):number;
            public static DOSmoothRewind($target: UnityEngine.Audio.AudioMixer):number;
            public static DOTogglePause($target: UnityEngine.Audio.AudioMixer):number;
        }
        export class Tweener extends DG.Tweening.Tween{ 
        }
        export class DOTweenModulePhysics extends System.Object{ 
            public static DOMove($target: UnityEngine.Rigidbody, $endValue: UnityEngine.Vector3, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOMoveX($target: UnityEngine.Rigidbody, $endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOMoveY($target: UnityEngine.Rigidbody, $endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOMoveZ($target: UnityEngine.Rigidbody, $endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DORotate($target: UnityEngine.Rigidbody, $endValue: UnityEngine.Vector3, $duration: number, $mode?: DG.Tweening.RotateMode):DG.Tweening.Core.TweenerCore$3<UnityEngine.Quaternion, UnityEngine.Vector3, DG.Tweening.Plugins.Options.QuaternionOptions>;
            public static DOLookAt($target: UnityEngine.Rigidbody, $towards: UnityEngine.Vector3, $duration: number, $axisConstraint?: DG.Tweening.AxisConstraint, $up?: System.Nullable$1<UnityEngine.Vector3>):DG.Tweening.Core.TweenerCore$3<UnityEngine.Quaternion, UnityEngine.Vector3, DG.Tweening.Plugins.Options.QuaternionOptions>;
            public static DOJump($target: UnityEngine.Rigidbody, $endValue: UnityEngine.Vector3, $jumpPower: number, $numJumps: number, $duration: number, $snapping?: boolean):DG.Tweening.Sequence;
            public static DOPath($target: UnityEngine.Rigidbody, $path: System.Array$1<UnityEngine.Vector3>, $duration: number, $pathType?: DG.Tweening.PathType, $pathMode?: DG.Tweening.PathMode, $resolution?: number, $gizmoColor?: System.Nullable$1<UnityEngine.Color>):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions>;
            public static DOLocalPath($target: UnityEngine.Rigidbody, $path: System.Array$1<UnityEngine.Vector3>, $duration: number, $pathType?: DG.Tweening.PathType, $pathMode?: DG.Tweening.PathMode, $resolution?: number, $gizmoColor?: System.Nullable$1<UnityEngine.Color>):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions>;
        }
        export enum RotateMode{ Fast = 0, FastBeyond360 = 1, WorldAxisAdd = 2, LocalAxisAdd = 3 }
        export enum AxisConstraint{ None = 0, X = 2, Y = 4, Z = 8, W = 16 }
        export enum PathType{ Linear = 0, CatmullRom = 1, CubicBezier = 2 }
        export enum PathMode{ Ignore = 0, Full3D = 1, TopDown2D = 2, Sidescroller2D = 3 }
        export class DOTweenModulePhysics2D extends System.Object{ 
            public static DOMove($target: UnityEngine.Rigidbody2D, $endValue: UnityEngine.Vector2, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOMoveX($target: UnityEngine.Rigidbody2D, $endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOMoveY($target: UnityEngine.Rigidbody2D, $endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DORotate($target: UnityEngine.Rigidbody2D, $endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<number, number, DG.Tweening.Plugins.Options.FloatOptions>;
            public static DOJump($target: UnityEngine.Rigidbody2D, $endValue: UnityEngine.Vector2, $jumpPower: number, $numJumps: number, $duration: number, $snapping?: boolean):DG.Tweening.Sequence;
            public static DOPath($target: UnityEngine.Rigidbody2D, $path: System.Array$1<UnityEngine.Vector2>, $duration: number, $pathType?: DG.Tweening.PathType, $pathMode?: DG.Tweening.PathMode, $resolution?: number, $gizmoColor?: System.Nullable$1<UnityEngine.Color>):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions>;
            public static DOLocalPath($target: UnityEngine.Rigidbody2D, $path: System.Array$1<UnityEngine.Vector2>, $duration: number, $pathType?: DG.Tweening.PathType, $pathMode?: DG.Tweening.PathMode, $resolution?: number, $gizmoColor?: System.Nullable$1<UnityEngine.Color>):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions>;
        }
        export class DOTweenModuleSprite extends System.Object{ 
            public static DOColor($target: UnityEngine.SpriteRenderer, $endValue: UnityEngine.Color, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions>;
            public static DOFade($target: UnityEngine.SpriteRenderer, $endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions>;
            public static DOGradientColor($target: UnityEngine.SpriteRenderer, $gradient: UnityEngine.Gradient, $duration: number):DG.Tweening.Sequence;
            public static DOBlendableColor($target: UnityEngine.SpriteRenderer, $endValue: UnityEngine.Color, $duration: number):DG.Tweening.Tweener;
        }
        export class DOTweenModuleUI extends System.Object{ 
            public static DOFade($target: UnityEngine.CanvasGroup, $endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<number, number, DG.Tweening.Plugins.Options.FloatOptions>;
            public static DOColor($target: UnityEngine.UI.Graphic, $endValue: UnityEngine.Color, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions>;
            public static DOFade($target: UnityEngine.UI.Graphic, $endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions>;
            public static DOColor($target: UnityEngine.UI.Image, $endValue: UnityEngine.Color, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions>;
            public static DOFade($target: UnityEngine.UI.Image, $endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions>;
            public static DOFillAmount($target: UnityEngine.UI.Image, $endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<number, number, DG.Tweening.Plugins.Options.FloatOptions>;
            public static DOGradientColor($target: UnityEngine.UI.Image, $gradient: UnityEngine.Gradient, $duration: number):DG.Tweening.Sequence;
            public static DOFlexibleSize($target: UnityEngine.UI.LayoutElement, $endValue: UnityEngine.Vector2, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOMinSize($target: UnityEngine.UI.LayoutElement, $endValue: UnityEngine.Vector2, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOPreferredSize($target: UnityEngine.UI.LayoutElement, $endValue: UnityEngine.Vector2, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOColor($target: UnityEngine.UI.Outline, $endValue: UnityEngine.Color, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions>;
            public static DOFade($target: UnityEngine.UI.Outline, $endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions>;
            public static DOScale($target: UnityEngine.UI.Outline, $endValue: UnityEngine.Vector2, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOAnchorPos($target: UnityEngine.RectTransform, $endValue: UnityEngine.Vector2, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOAnchorPosX($target: UnityEngine.RectTransform, $endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOAnchorPosY($target: UnityEngine.RectTransform, $endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOAnchorPos3D($target: UnityEngine.RectTransform, $endValue: UnityEngine.Vector3, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOAnchorPos3DX($target: UnityEngine.RectTransform, $endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOAnchorPos3DY($target: UnityEngine.RectTransform, $endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOAnchorPos3DZ($target: UnityEngine.RectTransform, $endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOAnchorMax($target: UnityEngine.RectTransform, $endValue: UnityEngine.Vector2, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOAnchorMin($target: UnityEngine.RectTransform, $endValue: UnityEngine.Vector2, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOPivot($target: UnityEngine.RectTransform, $endValue: UnityEngine.Vector2, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOPivotX($target: UnityEngine.RectTransform, $endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOPivotY($target: UnityEngine.RectTransform, $endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOSizeDelta($target: UnityEngine.RectTransform, $endValue: UnityEngine.Vector2, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOPunchAnchorPos($target: UnityEngine.RectTransform, $punch: UnityEngine.Vector2, $duration: number, $vibrato?: number, $elasticity?: number, $snapping?: boolean):DG.Tweening.Tweener;
            public static DOShakeAnchorPos($target: UnityEngine.RectTransform, $duration: number, $strength?: number, $vibrato?: number, $randomness?: number, $snapping?: boolean, $fadeOut?: boolean):DG.Tweening.Tweener;
            public static DOShakeAnchorPos($target: UnityEngine.RectTransform, $duration: number, $strength: UnityEngine.Vector2, $vibrato?: number, $randomness?: number, $snapping?: boolean, $fadeOut?: boolean):DG.Tweening.Tweener;
            public static DOJumpAnchorPos($target: UnityEngine.RectTransform, $endValue: UnityEngine.Vector2, $jumpPower: number, $numJumps: number, $duration: number, $snapping?: boolean):DG.Tweening.Sequence;
            public static DONormalizedPos($target: UnityEngine.UI.ScrollRect, $endValue: UnityEngine.Vector2, $duration: number, $snapping?: boolean):DG.Tweening.Tweener;
            public static DOHorizontalNormalizedPos($target: UnityEngine.UI.ScrollRect, $endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Tweener;
            public static DOVerticalNormalizedPos($target: UnityEngine.UI.ScrollRect, $endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Tweener;
            public static DOValue($target: UnityEngine.UI.Slider, $endValue: number, $duration: number, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<number, number, DG.Tweening.Plugins.Options.FloatOptions>;
            public static DOColor($target: UnityEngine.UI.Text, $endValue: UnityEngine.Color, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions>;
            public static DOCounter($target: UnityEngine.UI.Text, $fromValue: number, $endValue: number, $duration: number, $addThousandsSeparator?: boolean, $culture?: System.Globalization.CultureInfo):DG.Tweening.Core.TweenerCore$3<number, number, DG.Tweening.Plugins.Options.NoOptions>;
            public static DOFade($target: UnityEngine.UI.Text, $endValue: number, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions>;
            public static DOText($target: UnityEngine.UI.Text, $endValue: string, $duration: number, $richTextEnabled?: boolean, $scrambleMode?: DG.Tweening.ScrambleMode, $scrambleChars?: string):DG.Tweening.Core.TweenerCore$3<string, string, DG.Tweening.Plugins.Options.StringOptions>;
            public static DOBlendableColor($target: UnityEngine.UI.Graphic, $endValue: UnityEngine.Color, $duration: number):DG.Tweening.Tweener;
            public static DOBlendableColor($target: UnityEngine.UI.Image, $endValue: UnityEngine.Color, $duration: number):DG.Tweening.Tweener;
            public static DOBlendableColor($target: UnityEngine.UI.Text, $endValue: UnityEngine.Color, $duration: number):DG.Tweening.Tweener;
            public static DOShapeCircle($target: UnityEngine.RectTransform, $center: UnityEngine.Vector2, $endValueDegrees: number, $duration: number, $relativeCenter?: boolean, $snapping?: boolean):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.CircleOptions>;
        }
        export enum ScrambleMode{ None = 0, All = 1, Uppercase = 2, Lowercase = 3, Numerals = 4, Custom = 5 }
        export class DOTweenModuleUnityVersion extends System.Object{ 
            public static DOGradientColor($target: UnityEngine.Material, $gradient: UnityEngine.Gradient, $duration: number):DG.Tweening.Sequence;
            public static DOGradientColor($target: UnityEngine.Material, $gradient: UnityEngine.Gradient, $property: string, $duration: number):DG.Tweening.Sequence;
            public static WaitForCompletion($t: DG.Tweening.Tween, $returnCustomYieldInstruction: boolean):UnityEngine.CustomYieldInstruction;
            public static WaitForRewind($t: DG.Tweening.Tween, $returnCustomYieldInstruction: boolean):UnityEngine.CustomYieldInstruction;
            public static WaitForKill($t: DG.Tweening.Tween, $returnCustomYieldInstruction: boolean):UnityEngine.CustomYieldInstruction;
            public static WaitForElapsedLoops($t: DG.Tweening.Tween, $elapsedLoops: number, $returnCustomYieldInstruction: boolean):UnityEngine.CustomYieldInstruction;
            public static WaitForPosition($t: DG.Tweening.Tween, $position: number, $returnCustomYieldInstruction: boolean):UnityEngine.CustomYieldInstruction;
            public static WaitForStart($t: DG.Tweening.Tween, $returnCustomYieldInstruction: boolean):UnityEngine.CustomYieldInstruction;
            public static DOOffset($target: UnityEngine.Material, $endValue: UnityEngine.Vector2, $propertyID: number, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            public static DOTiling($target: UnityEngine.Material, $endValue: UnityEngine.Vector2, $propertyID: number, $duration: number):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions>;
            public static AsyncWaitForCompletion($t: DG.Tweening.Tween):System.Threading.Tasks.Task;
            public static AsyncWaitForRewind($t: DG.Tweening.Tween):System.Threading.Tasks.Task;
            public static AsyncWaitForKill($t: DG.Tweening.Tween):System.Threading.Tasks.Task;
            public static AsyncWaitForElapsedLoops($t: DG.Tweening.Tween, $elapsedLoops: number):System.Threading.Tasks.Task;
            public static AsyncWaitForPosition($t: DG.Tweening.Tween, $position: number):System.Threading.Tasks.Task;
            public static AsyncWaitForStart($t: DG.Tweening.Tween):System.Threading.Tasks.Task;
        }
        export class DOTweenCYInstruction extends System.Object{ 
        }
        export class DOTweenModuleUtils extends System.Object{ 
            public static Init():void;
        }
    }
    export namespace DG.Tweening.Core {
        export class ABSSequentiable extends System.Object{ 
        }
        export class TweenerCore$3<T1, T2, TPlugOptions> extends DG.Tweening.Tweener{ 
        }
    }
    export namespace System.Linq.Expressions {
        export class Expression$1<TDelegate> extends System.Linq.Expressions.LambdaExpression implements System.Linq.Expressions.IParameterProvider{ 
        }
        export class LambdaExpression extends System.Linq.Expressions.Expression implements System.Linq.Expressions.IParameterProvider{ 
        }
        export class Expression extends System.Object{ 
        }
        export interface IParameterProvider{ 
        }
        export class UnaryExpression extends System.Linq.Expressions.Expression{ 
        }
    }
    export namespace Runtime.DoInject {
        export class InjectAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public get type(): System.Type;
            public set type(value: System.Type);
            public constructor();
        }
        export class EventAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public EventName: string;
            public EventObj: any;
            public get type(): System.Type;
            public set type(value: System.Type);
            public constructor($name: any);
            public constructor($name: string);
            public constructor();
        }
        export class UpdateAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public get type(): System.Type;
            public set type(value: System.Type);
            public constructor();
        }
        export class OutputAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public get type(): System.Type;
            public set type(value: System.Type);
            public constructor($type: System.Type);
            public constructor();
        }
        export class EnableAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public get type(): System.Type;
            public set type(value: System.Type);
            public constructor();
        }
        export class DisableAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public get type(): System.Type;
            public set type(value: System.Type);
            public constructor();
        }
    }
    export namespace Runtime.RectTransforms {
        export class RectTransformData extends System.Object{ 
            public Index: number;
            public Name: string;
            public LocalPosition: UnityEngine.Vector3;
            public AnchoredPosition: UnityEngine.Vector2;
            public SizeDelta: UnityEngine.Vector2;
            public AnchorMin: UnityEngine.Vector2;
            public AnchorMax: UnityEngine.Vector2;
            public Pivot: UnityEngine.Vector2;
            public Scale: UnityEngine.Vector3;
            public Rotation: UnityEngine.Quaternion;
            public PullFromTransform($transform: UnityEngine.Transform):void;
            public PushToTransform($go: UnityEngine.GameObject):void;
            public PushToTransform($transform: UnityEngine.Transform):UnityEngine.Transform;
            public PullFromTransform($transform: UnityEngine.RectTransform):UnityEngine.Transform;
            public PushToTransform($transform: UnityEngine.RectTransform):UnityEngine.RectTransform;
            public constructor();
            public constructor($go: UnityEngine.GameObject);
            public constructor($transform: UnityEngine.Transform);
            public constructor($transform: UnityEngine.RectTransform);
        }
    }
    export namespace UnityEngine.InputManagerEntry {
        export enum Kind{ KeyOrButton = 0, Mouse = 1, Axis = 2 }
        export enum Axis{ X = 0, Y = 1, Third = 2, Fourth = 3, Fifth = 4, Sixth = 5, Seventh = 6, Eigth = 7 }
        export enum Joy{ All = 0, First = 1, Second = 2 }
    }
    export namespace UnityEngine.UI.Dropdown {
        export class OptionData extends System.Object{ 
            public get text(): string;
            public set text(value: string);
            public get image(): UnityEngine.Sprite;
            public set image(value: UnityEngine.Sprite);
            public constructor();
            public constructor($text: string);
            public constructor($image: UnityEngine.Sprite);
            public constructor($text: string, $image: UnityEngine.Sprite);
        }
        export class DropdownEvent extends UnityEngine.Events.UnityEvent$1<number> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class OptionDataList extends System.Object{ 
            public get options(): System.Collections.Generic.List$1<UnityEngine.UI.Dropdown.OptionData>;
            public set options(value: System.Collections.Generic.List$1<UnityEngine.UI.Dropdown.OptionData>);
            public constructor();
        }
    }
    export namespace UnityEngine.UI.GraphicRaycaster {
        export enum BlockingObjects{ None = 0, TwoD = 1, ThreeD = 2, All = 3 }
    }
    export namespace UnityEngine.UI.Image {
        export enum Type{ Simple = 0, Sliced = 1, Tiled = 2, Filled = 3 }
        export enum FillMethod{ Horizontal = 0, Vertical = 1, Radial90 = 2, Radial180 = 3, Radial360 = 4 }
        export enum OriginHorizontal{ Left = 0, Right = 1 }
        export enum OriginVertical{ Bottom = 0, Top = 1 }
        export enum Origin90{ BottomLeft = 0, TopLeft = 1, TopRight = 2, BottomRight = 3 }
        export enum Origin180{ Bottom = 0, Left = 1, Top = 2, Right = 3 }
        export enum Origin360{ Bottom = 0, Right = 1, Top = 2, Left = 3 }
    }
    export namespace UnityEngine.UI.AspectRatioFitter {
        export enum AspectMode{ None = 0, WidthControlsHeight = 1, HeightControlsWidth = 2, FitInParent = 3, EnvelopeParent = 4 }
    }
    export namespace UnityEngine.UI.CanvasScaler {
        export enum ScaleMode{ ConstantPixelSize = 0, ScaleWithScreenSize = 1, ConstantPhysicalSize = 2 }
        export enum ScreenMatchMode{ MatchWidthOrHeight = 0, Expand = 1, Shrink = 2 }
        export enum Unit{ Centimeters = 0, Millimeters = 1, Inches = 2, Points = 3, Picas = 4 }
    }
    export namespace UnityEngine.UI.ContentSizeFitter {
        export enum FitMode{ Unconstrained = 0, MinSize = 1, PreferredSize = 2 }
    }
    export namespace UnityEngine.UI.GridLayoutGroup {
        export enum Corner{ UpperLeft = 0, UpperRight = 1, LowerLeft = 2, LowerRight = 3 }
        export enum Axis{ Horizontal = 0, Vertical = 1 }
        export enum Constraint{ Flexible = 0, FixedColumnCount = 1, FixedRowCount = 2 }
    }
    export namespace UnityEngine.UI.MaskableGraphic {
        export class CullStateChangedEvent extends UnityEngine.Events.UnityEvent$1<boolean> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace UnityEngine.UI.Navigation {
        export enum Mode{ None = 0, Horizontal = 1, Vertical = 2, Automatic = 3, Explicit = 4 }
    }
    export namespace UnityEngine.UI.Scrollbar {
        export enum Direction{ LeftToRight = 0, RightToLeft = 1, BottomToTop = 2, TopToBottom = 3 }
        export class ScrollEvent extends UnityEngine.Events.UnityEvent$1<number> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace UnityEngine.UI.ScrollRect {
        export enum MovementType{ Unrestricted = 0, Elastic = 1, Clamped = 2 }
        export enum ScrollbarVisibility{ Permanent = 0, AutoHide = 1, AutoHideAndExpandViewport = 2 }
        export class ScrollRectEvent extends UnityEngine.Events.UnityEvent$1<UnityEngine.Vector2> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace UnityEngine.UI.Slider {
        export enum Direction{ LeftToRight = 0, RightToLeft = 1, BottomToTop = 2, TopToBottom = 3 }
        export class SliderEvent extends UnityEngine.Events.UnityEvent$1<number> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace UnityEngine.UI.DefaultControls {
        export interface IFactoryControls{ 
            CreateGameObject($name: string, ...components: System.Type[]):UnityEngine.GameObject;
        }
        export class Resources extends System.ValueType{ 
            public standard: UnityEngine.Sprite;
            public background: UnityEngine.Sprite;
            public inputField: UnityEngine.Sprite;
            public knob: UnityEngine.Sprite;
            public checkmark: UnityEngine.Sprite;
            public dropdown: UnityEngine.Sprite;
            public mask: UnityEngine.Sprite;
        }
    }
        export class SceneTransitionMgr extends Tetris.Singleton$1<SceneTransitionMgr>{ 
            public useUnscaledDeltaTime: boolean;
            public get Material(): UnityEngine.Material;
            public static add_OnTransitionStarted($value: System.Action):void;
            public static remove_OnTransitionStarted($value: System.Action):void;
            public static add_OnTransitionCompleted($value: System.Action):void;
            public static remove_OnTransitionCompleted($value: System.Action):void;
            public StartTransition($transition: ISceneTransition, $dstScene: number):void;
            public WaitForLevelToLoad():System.Collections.IEnumerator;
            public ProcessTransiton($duration: number, $reverse?: boolean):System.Collections.IEnumerator;
            public constructor();
        }
        export interface ISceneTransition{ 
            GetShader():UnityEngine.Shader;
            OnScreenObscured($transitionMgr: SceneTransitionMgr):System.Collections.IEnumerator;
        }
        export class SquaresTransition extends System.Object implements ISceneTransition{ 
            public squareColor: UnityEngine.Color;
            public duration: number;
            public fadedDelay: number;
            public squareSize: UnityEngine.Vector2;
            public smoothness: number;
            public GetShader():UnityEngine.Shader;
            public OnScreenObscured($transitionMgr: SceneTransitionMgr):System.Collections.IEnumerator;
            public constructor();
            public OnScreenObscured($transitionMgr: SceneTransitionMgr):System.Collections.IEnumerator;
        }
        export class ReflectionEx extends System.Object{ 
            public static get GetAllAssemblyTypes(): System.Collections.Generic.IEnumerable$1<System.Type>;
        }
        export class AudioManager extends UnityEngine.MonoBehaviour{ 
            public audioMixer: UnityEngine.Audio.AudioMixer;
            public gameplaySnapshot: UnityEngine.Audio.AudioMixerSnapshot;
            public endMatchSnapshot: UnityEngine.Audio.AudioMixerSnapshot;
            public appearSFX: UnityEngine.AudioClip;
            public GoToDefaultSnapshot():void;
            public GoToEndMatchSnapshot():void;
            public PlayAppearSFX($location: UnityEngine.Vector3):void;
            public constructor();
        }
        export class IconPreview extends UnityEngine.MonoBehaviour{ 
            public icons: System.Array$1<UnityEngine.Sprite>;
            public constructor();
        }
        export class Test extends UnityEngine.MonoBehaviour{ 
            public constructor();
        }
        export class Walker extends UnityEngine.MonoBehaviour{ 
            public constructor();
        }
        export class LightTrigger extends UnityEngine.MonoBehaviour{ 
            public constructor();
        }
        export class Sample extends UnityEngine.MonoBehaviour{ 
            public Target: UnityEngine.GameObject;
            public constructor();
        }
        export class SetEnumFlag extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public Variable: NodeCanvas.Framework.Internal.BBObjectParameter;
            public Flag: NodeCanvas.Framework.Internal.BBObjectParameter;
            public Clear: NodeCanvas.Framework.BBParameter$1<boolean>;
            public constructor();
        }
        export class CheckEnumFlag extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public Variable: NodeCanvas.Framework.Internal.BBObjectParameter;
            public Flag: NodeCanvas.Framework.Internal.BBObjectParameter;
            public constructor();
        }
        export class ReportRadialTouch extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler{ 
            public OutputField: UnityEngine.UI.Text;
            public OnPointerEnter($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerDown($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerUp($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public constructor();
        }
        export class UICircleChangeColor extends UnityEngine.MonoBehaviour{ 
            public TargetUICircle: UnityEngine.GameObject;
            public UpdateBaseColor($value: number):void;
            public UpdateProgressColor($value: number):void;
            public constructor();
        }
        export class UICircleChangeDensity extends UnityEngine.MonoBehaviour{ 
            public MultiColorObject: UnityEngine.GameObject;
            public TextOutputObject: UnityEngine.GameObject;
            public UpdateDensity($value: number):void;
            public constructor();
        }
        export class DrawLine extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IDropHandler, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler{ 
            public lineRenderer: UnityEngine.UI.Extensions.UILineRenderer;
            public SceneDemoMode: DrawLine.DemoMode;
            public OnDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnDrop($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerDown($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerUp($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public constructor();
        }
        export class ParticleSystemControllerWindow extends UnityEngine.MonoBehaviour{ 
            public windowRect: UnityEngine.Rect;
            public includeChildren: boolean;
            public constructor();
        }
        export class ColorChangedEvent extends UnityEngine.Events.UnityEvent$1<UnityEngine.Color> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class HSVChangedEvent extends UnityEngine.Events.UnityEvent$3<number, number, number> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class TestCompression extends UnityEngine.MonoBehaviour{ 
            public constructor();
        }
    export namespace Tetris {
        export class Singleton$1<T> extends UnityEngine.MonoBehaviour{ 
        }
        export class BlockSpawner extends System.Object{ 
            public NextBlock():Tetris.Block.Block;
            public InitNextChainSlot($count?: number):void;
            public UpdateNextChainSlot($count?: number):void;
            public constructor($blocks: System.Array$1<Tetris.Block.Block>);
            public constructor();
        }
        export class EX extends System.Object{ 
            public static Float2Int($val: number):number;
            public constructor();
        }
        export class Game extends UnityEngine.MonoBehaviour{ 
            public OnPauseCallback: UnityEngine.Events.UnityEvent;
            public OnGammingCallback: UnityEngine.Events.UnityEvent;
            public get DAS(): number;
            public set DAS(value: number);
            public PauseGame():void;
            public StartGame():void;
            public QuitGame():void;
            public constructor();
        }
        export class Logger extends System.Object{ 
            public Print():void;
            public Log($log: string):void;
            public constructor();
        }
        export class SV extends System.Object{ 
            public static ClipMove: string;
            public static ClipRotate: string;
            public static ClipHold: string;
            public static ClipHardDrop: string;
            public static ClipSoftDrop: string;
            public static ClipLanding: string;
            public static ClipSingle: string;
            public static ClipDouble: string;
            public static ClipTriple: string;
            public static ClipTetris: string;
            public static ClipSpecial: string;
            public static BGMainTheme: string;
            public constructor();
        }
        export class Tetris extends System.Object{ 
            public static Height: number;
            public static Width: number;
            public static ExtraHeight: number;
            public static DeltaNormal: number;
            public static DeltaSoft: number;
            public static Grid: System.Array$1<UnityEngine.Transform>;
            public level: number;
            public score: number;
            public line: number;
            public time: number;
            public static OnScoreChanged: System.Action$1<number>;
            public static OnLevelChanged: System.Action$1<number>;
            public static OnGoalChanged: System.Action$1<number>;
            public static OnTimeChanged: System.Action$1<number>;
            public static OnGameOver: System.Action;
            public static OnHardDrop: System.Action$1<UnityEngine.Vector2>;
            public static OnLineClear: System.Action$1<number>;
            public get FallDeltaTime(): number;
            public NextBlock():void;
            public HoldBlock():void;
            public MoveRight():void;
            public MoveLeft():void;
            public ClockwiseRotation():void;
            public AntiClockwiseRotation():void;
            public SoftDrop():void;
            public NormalDrop():void;
            public HardDrop():void;
            public Fall($deltaTime: number):void;
            public DrawGizmos():void;
            public constructor($spawner: Tetris.BlockSpawner);
            public constructor($spawner: Tetris.BlockSpawner, $vfx: Tetris.VFX);
            public constructor();
        }
        export class VFX extends UnityEngine.MonoBehaviour{ 
            public VFX_LineClear($line: number):void;
            public VFX_HardDrop($position: UnityEngine.Vector2):void;
            public TextVFX_Start():void;
            public HideTextRen():void;
            public UpdateTextRen($count: number):void;
            public TextVFX_Tetris():void;
            public TextVFX_B2B():void;
            public TextVFX_TSpinSingle():void;
            public TextVFX_TSpinDouble():void;
            public TextVFX_TSpinTriple():void;
            public PlayClip($key: string):void;
            public PlayBG($key: string):void;
            public constructor();
        }
        export class VFXInstance extends UnityEngine.MonoBehaviour implements Tetris.Tools.IPoolable$1<Tetris.VFXInstance>{ 
            public get InPooled(): boolean;
            public set InPooled(value: boolean);
            public get Pool(): Tetris.Tools.Pool$1<Tetris.VFXInstance>;
            public set Pool(value: Tetris.Tools.Pool$1<Tetris.VFXInstance>);
            public Play():void;
            public constructor();
        }
    }
    export namespace api {
        export class Sandbox extends UnityEngine.MonoBehaviour{ 
            public constructor();
        }
        export class Tsc extends UnityEngine.MonoBehaviour{ 
            public constructor();
        }
    }
    export namespace Examples {
        export class Plants extends System.Object{ 
            public constructor();
        }
        export class Zombies extends System.Object{ 
            public constructor();
        }
    }
    export namespace Examples.Node_tsc {
        export class UIEvent extends UnityEngine.MonoBehaviour{ 
            public constructor();
        }
    }
    export namespace Js {
        export class JsBinding extends UnityEngine.MonoBehaviour{ 
            public args: System.Array$1<Js.JsArg>;
            public constructor();
        }
        export class JsArg extends System.ValueType{ 
            public name: string;
            public value: UnityEngine.Object;
        }
        export class JsBindingEditor extends UnityEditor.Editor implements UnityEditor.IPreviewable, UnityEditor.IToolModeOwner{ 
        }
    }
    export namespace UnityEditor {
        export class Editor extends UnityEngine.ScriptableObject implements UnityEditor.IPreviewable, UnityEditor.IToolModeOwner{ 
        }
        export interface IPreviewable{ 
        }
        export interface IToolModeOwner{ 
        }
        export class GenericMenu extends System.Object{ 
        }
        interface GenericMenu {
            ShowAsBrowser($pos: UnityEngine.Vector2, $title: string, $keyType?: System.Type):void;
            ShowAsBrowser($title: string, $keyType?: System.Type):void;
            Show($asBrowser: boolean, $title: string, $keyType?: System.Type):void;
        }
        export class PropertyDrawer extends UnityEditor.GUIDrawer{ 
        }
        export class GUIDrawer extends System.Object{ 
        }
        export class SerializedProperty extends System.Object implements System.IDisposable{ 
        }
        export class SerializedObject extends System.Object implements System.IDisposable{ 
        }
        export class EditorWindow extends UnityEngine.ScriptableObject{ 
        }
        export class PopupWindowContent extends System.Object{ 
        }
        export class AssetPostprocessor extends System.Object{ 
        }
        export class MonoScript extends UnityEngine.TextAsset{ 
        }
    }
    export namespace UnityRoyale {
        export class AAUsageExample extends UnityEngine.MonoBehaviour{ 
            public refObject: UnityEngine.AddressableAssets.AssetReferenceGameObject;
            public scene: UnityEngine.AddressableAssets.AssetReference;
            public constructor();
        }
        export class CPUOpponent extends UnityEngine.MonoBehaviour{ 
            public aiDeck: UnityRoyale.DeckData;
            public OnCardUsed: UnityEngine.Events.UnityAction$3<UnityRoyale.CardData, UnityEngine.Vector3, UnityRoyale.Placeable.Faction>;
            public opponentLoopTime: number;
            public LoadDeck():void;
            public StartActing():void;
            public StopActing():void;
            public constructor();
        }
        export class DeckData extends UnityEngine.ScriptableObject{ 
            public labelsToInclude: System.Array$1<UnityEngine.AddressableAssets.AssetLabelReference>;
            public CardsRetrieved($cardDataDownloaded: System.Collections.Generic.List$1<UnityRoyale.CardData>):void;
            public ShuffleCards():void;
            public GetNextCardFromDeck():UnityRoyale.CardData;
            public constructor();
        }
        export class CardData extends UnityEngine.ScriptableObject{ 
            public cardImage: UnityEngine.Sprite;
            public placeablesData: System.Array$1<UnityRoyale.PlaceableData>;
            public relativeOffsets: System.Array$1<UnityEngine.Vector3>;
            public constructor();
        }
        export class DeckLoader extends UnityEngine.MonoBehaviour{ 
            public OnDeckLoaded: UnityEngine.Events.UnityAction;
            public LoadDeck($deckToLoad: UnityRoyale.DeckData):void;
            public constructor();
        }
        export class CardManager extends UnityEngine.MonoBehaviour{ 
            public mainCamera: UnityEngine.Camera;
            public playingFieldMask: UnityEngine.LayerMask;
            public cardPrefab: UnityEngine.GameObject;
            public playersDeck: UnityRoyale.DeckData;
            public forbiddenAreaRenderer: UnityEngine.MeshRenderer;
            public OnCardUsed: UnityEngine.Events.UnityAction$3<UnityRoyale.CardData, UnityEngine.Vector3, UnityRoyale.Placeable.Faction>;
            public backupCardTransform: UnityEngine.RectTransform;
            public cardsDashboard: UnityEngine.RectTransform;
            public cardsPanel: UnityEngine.RectTransform;
            public LoadDeck():void;
            public constructor();
        }
        export class CinematicsManager extends UnityEngine.MonoBehaviour{ 
            public redCastleCollapse: UnityEngine.Playables.PlayableDirector;
            public blueCastleCollapse: UnityEngine.Playables.PlayableDirector;
            public PlayCollapseCutscene($f: UnityRoyale.Placeable.Faction):void;
            public constructor();
        }
        export class GameManager extends UnityEngine.MonoBehaviour{ 
            public autoStart: boolean;
            public navMesh: UnityEngine.AI.NavMeshSurface;
            public playersCastle: UnityEngine.GameObject;
            public opponentCastle: UnityEngine.GameObject;
            public introTimeline: UnityEngine.GameObject;
            public castlePData: UnityRoyale.PlaceableData;
            public appearEffectPool: UnityRoyale.ParticlePool;
            public StartMatch():void;
            public UseCard($cardData: UnityRoyale.CardData, $position: UnityEngine.Vector3, $pFaction: UnityRoyale.Placeable.Faction):void;
            public OnEndGameCutsceneOver():void;
            public constructor();
        }
        export class PlaceableData extends UnityEngine.ScriptableObject{ 
            public pType: UnityRoyale.Placeable.PlaceableType;
            public associatedPrefab: UnityEngine.GameObject;
            public alternatePrefab: UnityEngine.GameObject;
            public attackType: UnityRoyale.ThinkingPlaceable.AttackType;
            public targetType: UnityRoyale.Placeable.PlaceableTarget;
            public attackRatio: number;
            public damagePerAttack: number;
            public attackRange: number;
            public hitPoints: number;
            public attackClip: UnityEngine.AudioClip;
            public dieClip: UnityEngine.AudioClip;
            public speed: number;
            public lifeTime: number;
            public damagePerSecond: number;
            public constructor();
        }
        export class ParticlePool extends UnityEngine.MonoBehaviour{ 
            public effectPrefab: UnityEngine.GameObject;
            public amount: number;
            public UseParticles($pos: UnityEngine.Vector3):void;
            public constructor();
        }
        export class InputManager extends UnityEngine.MonoBehaviour{ 
            public constructor();
        }
        export class Building extends UnityRoyale.ThinkingPlaceable{ 
            public constructionTimeline: UnityEngine.Playables.PlayableDirector;
            public destructionTimeline: UnityEngine.Playables.PlayableDirector;
            public Activate($pFaction: UnityRoyale.Placeable.Faction, $pData: UnityRoyale.PlaceableData):void;
            public constructor();
        }
        export class ThinkingPlaceable extends UnityRoyale.Placeable{ 
            public state: UnityRoyale.ThinkingPlaceable.States;
            public attackType: UnityRoyale.ThinkingPlaceable.AttackType;
            public target: UnityRoyale.ThinkingPlaceable;
            public healthBar: UnityRoyale.HealthBar;
            public hitPoints: number;
            public attackRange: number;
            public attackRatio: number;
            public lastBlowTime: number;
            public damage: number;
            public attackAudioClip: UnityEngine.AudioClip;
            public timeToActNext: number;
            public projectilePrefab: UnityEngine.GameObject;
            public projectileSpawnPoint: UnityEngine.Transform;
            public OnDealDamage: UnityEngine.Events.UnityAction$1<UnityRoyale.ThinkingPlaceable>;
            public OnProjectileFired: UnityEngine.Events.UnityAction$1<UnityRoyale.ThinkingPlaceable>;
            public SetTarget($t: UnityRoyale.ThinkingPlaceable):void;
            public StartAttack():void;
            public DealBlow():void;
            public DealDamage():void;
            public FireProjectile():void;
            public Seek():void;
            public IsTargetInRange():boolean;
            public SufferDamage($amount: number):number;
            public Stop():void;
            public constructor();
        }
        export class Placeable extends UnityEngine.MonoBehaviour{ 
            public pType: UnityRoyale.Placeable.PlaceableType;
            public faction: UnityRoyale.Placeable.Faction;
            public targetType: UnityRoyale.Placeable.PlaceableTarget;
            public dieAudioClip: UnityEngine.AudioClip;
            public OnDie: UnityEngine.Events.UnityAction$1<UnityRoyale.Placeable>;
            public constructor();
        }
        export class Obstacle extends UnityRoyale.Placeable{ 
            public timeToRemoval: number;
            public Activate($pData: UnityRoyale.PlaceableData):void;
            public constructor();
        }
        export class HealthBar extends UnityEngine.MonoBehaviour{ 
            public bar: UnityEngine.RectTransform;
            public wholeWidget: UnityEngine.GameObject;
            public Initialise($p: UnityRoyale.ThinkingPlaceable):void;
            public SetHealth($newHP: number):void;
            public Move():void;
            public constructor();
        }
        export class Unit extends UnityRoyale.ThinkingPlaceable{ 
            public Activate($pFaction: UnityRoyale.Placeable.Faction, $pData: UnityRoyale.PlaceableData):void;
            public constructor();
        }
        export class Projectile extends UnityEngine.MonoBehaviour{ 
            public target: UnityRoyale.ThinkingPlaceable;
            public damage: number;
            public Move():number;
            public constructor();
        }
        export class CardMarker extends UnityEngine.Timeline.Marker implements UnityEngine.Timeline.IMarker, UnityEngine.Playables.INotification{ 
            public card: UnityRoyale.CardData;
            public position: UnityEngine.Vector3;
            public faction: UnityRoyale.Placeable.Faction;
            public get id(): UnityEngine.PropertyName;
            public constructor();
        }
        export class CardPlayerBridge extends UnityEngine.MonoBehaviour implements UnityEngine.Playables.INotificationReceiver{ 
            public gameManager: UnityRoyale.GameManager;
            public OnNotify($origin: UnityEngine.Playables.Playable, $notification: UnityEngine.Playables.INotification, $context: any):void;
            public constructor();
        }
        export class Card extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler{ 
            public OnDragAction: UnityEngine.Events.UnityAction$2<number, UnityEngine.Vector2>;
            public OnTapDownAction: UnityEngine.Events.UnityAction$1<number>;
            public OnTapReleaseAction: UnityEngine.Events.UnityAction$1<number>;
            public cardId: number;
            public cardData: UnityRoyale.CardData;
            public portraitImage: UnityEngine.UI.Image;
            public InitialiseWithData($cData: UnityRoyale.CardData):void;
            public OnPointerDown($pointerEvent: UnityEngine.EventSystems.PointerEventData):void;
            public OnDrag($pointerEvent: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerUp($pointerEvent: UnityEngine.EventSystems.PointerEventData):void;
            public ChangeActiveState($isActive: boolean):void;
            public constructor();
        }
        export class UIManager extends UnityEngine.MonoBehaviour{ 
            public healthBarPrefab: UnityEngine.GameObject;
            public gameOverUI: UnityEngine.GameObject;
            public AddHealthUI($p: UnityRoyale.ThinkingPlaceable):void;
            public RemoveHealthUI($p: UnityRoyale.ThinkingPlaceable):void;
            public ShowGameOverUI():void;
            public OnRetryButton():void;
            public constructor();
        }
    }
    export namespace UnityEngine.AddressableAssets {
        export class AssetReferenceGameObject extends UnityEngine.AddressableAssets.AssetReferenceT$1<UnityEngine.GameObject> implements UnityEngine.AddressableAssets.IKeyEvaluator{ 
        }
        export class AssetReferenceT$1<TObject> extends UnityEngine.AddressableAssets.AssetReference implements UnityEngine.AddressableAssets.IKeyEvaluator{ 
        }
        export class AssetReference extends System.Object implements UnityEngine.AddressableAssets.IKeyEvaluator{ 
        }
        export interface IKeyEvaluator{ 
        }
        export class AssetLabelReference extends System.Object implements UnityEngine.AddressableAssets.IKeyEvaluator{ 
        }
        export class AssetReferenceSprite extends UnityEngine.AddressableAssets.AssetReferenceT$1<UnityEngine.Sprite> implements UnityEngine.AddressableAssets.IKeyEvaluator{ 
        }
        export class AssetReferenceTexture extends UnityEngine.AddressableAssets.AssetReferenceT$1<UnityEngine.Texture> implements UnityEngine.AddressableAssets.IKeyEvaluator{ 
        }
        export class AssetReferenceTexture2D extends UnityEngine.AddressableAssets.AssetReferenceT$1<UnityEngine.Texture2D> implements UnityEngine.AddressableAssets.IKeyEvaluator{ 
        }
        export class AssetReferenceTexture3D extends UnityEngine.AddressableAssets.AssetReferenceT$1<UnityEngine.Texture3D> implements UnityEngine.AddressableAssets.IKeyEvaluator{ 
        }
    }
    export namespace UnityRoyale.Placeable {
        export enum Faction{ Player = 0, Opponent = 1, None = 2 }
        export enum PlaceableType{ Unit = 0, Obstacle = 1, Building = 2, Spell = 3, Castle = 4 }
        export enum PlaceableTarget{ OnlyBuildings = 0, Both = 1, None = 2 }
    }
    export namespace UnityEngine.AI {
        export class NavMeshSurface extends UnityEngine.MonoBehaviour{ 
            public get agentTypeID(): number;
            public set agentTypeID(value: number);
            public get collectObjects(): UnityEngine.AI.CollectObjects;
            public set collectObjects(value: UnityEngine.AI.CollectObjects);
            public get size(): UnityEngine.Vector3;
            public set size(value: UnityEngine.Vector3);
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            public get layerMask(): UnityEngine.LayerMask;
            public set layerMask(value: UnityEngine.LayerMask);
            public get useGeometry(): UnityEngine.AI.NavMeshCollectGeometry;
            public set useGeometry(value: UnityEngine.AI.NavMeshCollectGeometry);
            public get defaultArea(): number;
            public set defaultArea(value: number);
            public get ignoreNavMeshAgent(): boolean;
            public set ignoreNavMeshAgent(value: boolean);
            public get ignoreNavMeshObstacle(): boolean;
            public set ignoreNavMeshObstacle(value: boolean);
            public get overrideTileSize(): boolean;
            public set overrideTileSize(value: boolean);
            public get tileSize(): number;
            public set tileSize(value: number);
            public get overrideVoxelSize(): boolean;
            public set overrideVoxelSize(value: boolean);
            public get voxelSize(): number;
            public set voxelSize(value: number);
            public get buildHeightMesh(): boolean;
            public set buildHeightMesh(value: boolean);
            public get navMeshData(): UnityEngine.AI.NavMeshData;
            public set navMeshData(value: UnityEngine.AI.NavMeshData);
            public static get activeSurfaces(): System.Collections.Generic.List$1<UnityEngine.AI.NavMeshSurface>;
            public AddData():void;
            public RemoveData():void;
            public GetBuildSettings():UnityEngine.AI.NavMeshBuildSettings;
            public BuildNavMesh():void;
            public UpdateNavMesh($data: UnityEngine.AI.NavMeshData):UnityEngine.AsyncOperation;
            public constructor();
        }
        export class NavMeshLink extends UnityEngine.MonoBehaviour{ 
            public get agentTypeID(): number;
            public set agentTypeID(value: number);
            public get startPoint(): UnityEngine.Vector3;
            public set startPoint(value: UnityEngine.Vector3);
            public get endPoint(): UnityEngine.Vector3;
            public set endPoint(value: UnityEngine.Vector3);
            public get width(): number;
            public set width(value: number);
            public get costModifier(): number;
            public set costModifier(value: number);
            public get bidirectional(): boolean;
            public set bidirectional(value: boolean);
            public get autoUpdate(): boolean;
            public set autoUpdate(value: boolean);
            public get area(): number;
            public set area(value: number);
            public UpdateLink():void;
            public constructor();
        }
        export class NavMeshModifier extends UnityEngine.MonoBehaviour{ 
            public get overrideArea(): boolean;
            public set overrideArea(value: boolean);
            public get area(): number;
            public set area(value: number);
            public get ignoreFromBuild(): boolean;
            public set ignoreFromBuild(value: boolean);
            public static get activeModifiers(): System.Collections.Generic.List$1<UnityEngine.AI.NavMeshModifier>;
            public AffectsAgentType($agentTypeID: number):boolean;
            public constructor();
        }
        export class NavMeshModifierVolume extends UnityEngine.MonoBehaviour{ 
            public get size(): UnityEngine.Vector3;
            public set size(value: UnityEngine.Vector3);
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            public get area(): number;
            public set area(value: number);
            public static get activeModifiers(): System.Collections.Generic.List$1<UnityEngine.AI.NavMeshModifierVolume>;
            public AffectsAgentType($agentTypeID: number):boolean;
            public constructor();
        }
        export enum CollectObjects{ All = 0, Volume = 1, Children = 2 }
        export enum NavMeshCollectGeometry{ RenderMeshes = 0, PhysicsColliders = 1 }
        export class NavMeshData extends UnityEngine.Object{ 
        }
        export class NavMeshBuildSettings extends System.ValueType{ 
        }
        export class NavMeshAgent extends UnityEngine.Behaviour{ 
        }
    }
    export namespace UnityRoyale.ThinkingPlaceable {
        export enum States{ Dragged = 0, Idle = 1, Seeking = 2, Attacking = 3, Dead = 4 }
        export enum AttackType{ Melee = 0, Ranged = 1 }
    }
    export namespace UnityEngine.Timeline {
        export class Marker extends UnityEngine.ScriptableObject implements UnityEngine.Timeline.IMarker{ 
        }
        export interface IMarker{ 
        }
    }
    export namespace Tetris.Block {
        export class Block extends UnityEngine.MonoBehaviour{ 
            public ClockwiseRotation():boolean;
            public AntiClockwiseRotation():boolean;
            public MoveLeft($amount?: number):boolean;
            public MoveRight($amount?: number):boolean;
            public MoveDown($amount?: number):boolean;
            public SingleMove($x: number, $y: number):void;
            public SingleUp($amount?: number):void;
            public ResetState():void;
            public DisableBlock():boolean;
            public DrawGizmos():void;
            public constructor();
        }
        export class BlockI extends Tetris.Block.Block{ 
            public constructor();
        }
        export class BlockO extends Tetris.Block.Block{ 
            public constructor();
        }
        export class BlockT extends Tetris.Block.Block{ 
            public IsTSpin($isMini: $Ref<boolean>):boolean;
            public constructor();
        }
        export class WallKickData extends System.Object{ 
            public static I: System.Collections.Generic.List$1<System.Array$1<UnityEngine.Vector2Int>>;
            public static Other: System.Collections.Generic.List$1<System.Array$1<UnityEngine.Vector2Int>>;
            public constructor();
        }
    }
    export namespace Tetris.Tools {
        export interface IPoolable$1<T>{ 
        }
        export class Pool$1<T> extends System.Object{ 
        }
        export class FPSCounter extends UnityEngine.MonoBehaviour{ 
            public showFps: boolean;
            public constructor();
        }
        export class GameEntry extends System.Object{ 
            public static get DeltaTimeInEditor(): number;
            public static add_OnInit($value: System.Action):void;
            public static remove_OnInit($value: System.Action):void;
            public static add_OnUpdate($value: System.Action):void;
            public static remove_OnUpdate($value: System.Action):void;
            public static add_OnFixedUpdate($value: System.Action):void;
            public static remove_OnFixedUpdate($value: System.Action):void;
            public static add_OnLateUpdate($value: System.Action):void;
            public static remove_OnLateUpdate($value: System.Action):void;
            public static RegisterUpdateEvent($mode: Tetris.Tools.UpdateMode, $action: System.Action):void;
            public static UnregisterUpdateEvent($mode: Tetris.Tools.UpdateMode, $action: System.Action):void;
            public constructor();
        }
        export enum UpdateMode{ Init = 0, Update = 1, FixedUpdate = 2, LateUpdate = 3 }
        export class TimerExtention extends System.Object{ 
            public static Register($behaviour: UnityEngine.MonoBehaviour, $duration: number, $onComplete: System.Action, $onUpdate?: System.Action, $isLooped?: boolean, $useRealTime?: boolean):Tetris.Tools.Timer;
        }
        export class Timer extends System.Object{ 
            public get duration(): number;
            public set duration(value: number);
            public get isLooped(): boolean;
            public set isLooped(value: boolean);
            public get isCompleted(): boolean;
            public get dispose(): boolean;
            public set dispose(value: boolean);
            public get useRealTime(): boolean;
            public get isPaused(): boolean;
            public get isCancelled(): boolean;
            public get isDone(): boolean;
            public static Register($duration: number, $onComplete?: System.Action, $onUpdate?: System.Action, $dispose?: boolean, $isLooped?: boolean, $useRealTime?: boolean, $autoDestroyerOwner?: UnityEngine.MonoBehaviour):Tetris.Tools.Timer;
            public Start():void;
            public Restart():void;
            public static Cancel($timer: Tetris.Tools.Timer):void;
            public static Pause($timer: Tetris.Tools.Timer):void;
            public static Resume($timer: Tetris.Tools.Timer):void;
            public static CancelAllRegisteredTimers():void;
            public static PauseAllRegisteredTimers():void;
            public static ResumeAllRegisteredTimers():void;
            public Cancel():void;
            public Pause():void;
            public Resume():void;
            public GetTimeElapsed():number;
            public ClearEvent():void;
        }
    }
    export namespace Tetris.View {
        export class RenText extends UnityEngine.MonoBehaviour{ 
            public RestartTween($count: number):void;
            public constructor();
        }
        export class StartPanel extends UnityEngine.MonoBehaviour{ 
            public constructor();
        }
        export class View extends UnityEngine.MonoBehaviour{ 
            public score: TMPro.TMP_Text;
            public level: TMPro.TMP_Text;
            public goal: TMPro.TMP_Text;
            public time: TMPro.TMP_Text;
            public gameOverPanel: UnityEngine.GameObject;
            public constructor();
        }
    }
    export namespace TMPro {
        export class TMP_Text extends UnityEngine.UI.MaskableGraphic implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.UI.ICanvasElement, UnityEngine.UI.IClippable{ 
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
    }
    export namespace Saro {
        export enum MenuItemState{ Disabled = 0, Selected = 1, Normal = 2 }
        export class EditorEx extends System.Object{ 
        }
        export class TweenCanvasGroupAlpha extends Saro.TweenFloat{ 
            public targetCanvasGroup: UnityEngine.CanvasGroup;
            public get Current(): number;
            public set Current(value: number);
            public constructor();
        }
        export class TweenFloat extends Saro.TweenFormTo$1<number>{ 
        }
        export class TweenFormTo$1<T> extends Saro.TweenAnimation{ 
        }
        export class TweenAnimation extends UnityEngine.MonoBehaviour{ 
            public static allTypeDic: System.Collections.Generic.Dictionary$2<System.Type, Saro.TweenAnimationAttribute>;
            public get MinNormalizedTime(): number;
            public set MinNormalizedTime(value: number);
            public get MaxNormalizedTime(): number;
            public set MaxNormalizedTime(value: number);
            public SetEase($type: Saro.CustomizableInterpolator.Type):void;
            public OnUpdate($normalizedTime: number):void;
            public Record():void;
            public Restore():void;
            public Reset():void;
        }
        export class TweenSpriteColor extends Saro.TweenColor{ 
            public targetRenderer: UnityEngine.SpriteRenderer;
            public get Current(): UnityEngine.Color;
            public set Current(value: UnityEngine.Color);
            public constructor();
        }
        export class TweenColor extends Saro.TweenFormTo$1<UnityEngine.Color>{ 
            public useGradient: boolean;
            public gradient: UnityEngine.Gradient;
        }
        export class TweenTMPTextColor extends Saro.TweenColor{ 
            public targetText: TMPro.TMP_Text;
            public get Current(): UnityEngine.Color;
            public set Current(value: UnityEngine.Color);
            public constructor();
        }
        export class TweenTMPTextFontSize extends Saro.TweenFloat{ 
            public targetText: TMPro.TMP_Text;
            public get Current(): number;
            public set Current(value: number);
            public constructor();
        }
        export class TweenRectTransformAnchorPosition extends Saro.TweenVector2{ 
            public targetRectTransform: UnityEngine.RectTransform;
            public get Current(): UnityEngine.Vector2;
            public set Current(value: UnityEngine.Vector2);
            public constructor();
        }
        export class TweenVector2 extends Saro.TweenFormTo$1<UnityEngine.Vector2>{ 
        }
        export class TweenRectTransformSizeDelta extends Saro.TweenVector2{ 
            public targetRectTransform: UnityEngine.RectTransform;
            public get Current(): UnityEngine.Vector2;
            public set Current(value: UnityEngine.Vector2);
            public constructor();
        }
        export class Tween3DLightColor extends Saro.TweenColor{ 
            public targetLight: UnityEngine.Light;
            public get Current(): UnityEngine.Color;
            public set Current(value: UnityEngine.Color);
            public constructor();
        }
        export class Tween3DLightIntensity extends Saro.TweenFloat{ 
            public targetLight: UnityEngine.Light;
            public get Current(): number;
            public set Current(value: number);
            public constructor();
        }
        export class TweenMaterialProperty extends Saro.TweenAnimation{ 
            public targetRenderer: UnityEngine.Renderer;
            public from: UnityEngine.Vector4;
            public to: UnityEngine.Vector4;
            public get PropertyName(): string;
            public get PropertyId(): number;
            public get PropertyType(): Saro.TweenMaterialProperty.Type;
            public get AllMaterialSelected(): boolean;
            public get NoneMaterialSelected(): boolean;
            public SelectAllMaterials():void;
            public DeselectAllMaterials():void;
            public SetProperty($name: string, $type: Saro.TweenMaterialProperty.Type):void;
            public IsMaterialSelected($idx: number):boolean;
            public SetMaterialSelected($idx: number, $selected: boolean):void;
            public constructor();
        }
        export class TweenTransformEulerAngles extends Saro.TweenVector3{ 
            public targetTransform: UnityEngine.Transform;
            public coordinate: UnityEngine.Space;
            public get Current(): UnityEngine.Vector3;
            public set Current(value: UnityEngine.Vector3);
            public constructor();
        }
        export class TweenVector3 extends Saro.TweenFormTo$1<UnityEngine.Vector3>{ 
        }
        export class TweenTransformPosition extends Saro.TweenVector3{ 
            public targetTransform: UnityEngine.Transform;
            public coordinate: UnityEngine.Space;
            public get Current(): UnityEngine.Vector3;
            public set Current(value: UnityEngine.Vector3);
            public constructor();
        }
        export class TweenTransformRotation extends Saro.TweenQuaternion{ 
            public targetTransform: UnityEngine.Transform;
            public coordinate: UnityEngine.Space;
            public get Current(): UnityEngine.Quaternion;
            public set Current(value: UnityEngine.Quaternion);
            public constructor();
        }
        export class TweenQuaternion extends Saro.TweenFormTo$1<UnityEngine.Quaternion>{ 
        }
        export class TweenTransformScale extends Saro.TweenVector3{ 
            public targetTransform: UnityEngine.Transform;
            public get Current(): UnityEngine.Vector3;
            public set Current(value: UnityEngine.Vector3);
            public constructor();
        }
        export class ConfigurableUpdate extends UnityEngine.MonoBehaviour{ 
            public get UpdateMode(): Tetris.Tools.UpdateMode;
            public set UpdateMode(value: Tetris.Tools.UpdateMode);
        }
        export class CustomizableInterpolator extends System.ValueType{ 
            public type: Saro.CustomizableInterpolator.Type;
            public strength: number;
            public customCurve: UnityEngine.AnimationCurve;
            public get_Item($t: number):number;
            public constructor($type: Saro.CustomizableInterpolator.Type, $strength: number, $customCurve: UnityEngine.AnimationCurve);
            public constructor();
        }
        export class Interpolator extends System.ValueType{ 
            public type: Saro.Interpolator.Type;
            public strength: number;
            public static Interpolators: System.Array$1<System.Func$3<number, number, number>>;
            public get_Item($t: number):number;
            public static Linear($t: number):number;
            public static Accelerate($t: number):number;
            public static AccelerateWeakly($t: number):number;
            public static AccelerateStrongly($t: number):number;
            public static Accelerate($t: number, $strength: number):number;
            public static Decelerate($t: number):number;
            public static DecelerateWeakly($t: number):number;
            public static DecelerateStrongly($t: number):number;
            public static Decelerate($t: number, $strength: number):number;
            public static AccelerateDecelerate($t: number, $strength: number):number;
            public static Anticipate($t: number, $strength?: number):number;
            public static Overshoot($t: number, $strength?: number):number;
            public static AnticipateOvershoot($t: number, $strength: number):number;
            public static Bounce($t: number, $strength?: number):number;
            public static Parabolic($t: number):number;
            public static Sine($t: number):number;
            public constructor($type: Saro.Interpolator.Type, $strength?: number);
            public constructor();
        }
        export enum TimeMode{ Normal = 0, Unscaled = 1 }
        export enum WrapMode{ Clamp = 0, Loop = 1, PingPong = 2 }
        export enum ArrivedAction{ KeepPlaying = 0, StopOnForwardArrived = 1, StopOnBackArrived = 2, AlwaysStopOnArrived = 3 }
        export enum PlayDirection{ Forward = 0, Backward = 1 }
        export class Tween extends Saro.ConfigurableUpdate{ 
            public playDirection: Saro.PlayDirection;
            public get Duration(): number;
            public set Duration(value: number);
            public get NormalizedTime(): number;
            public set NormalizedTime(value: number);
            public add_OnForwardArrived($value: UnityEngine.Events.UnityAction):void;
            public remove_OnForwardArrived($value: UnityEngine.Events.UnityAction):void;
            public add_OnBackwardArrived($value: UnityEngine.Events.UnityAction):void;
            public remove_OnBackwardArrived($value: UnityEngine.Events.UnityAction):void;
            public ResetNormalizedTime():void;
            public ReverseDirection():void;
            public SetDirectionForward():void;
            public SetDirectionBackward():void;
            public ForwardEnable():void;
            public BackwardEnable():void;
            public RemoveAnimation($anim: Saro.TweenAnimation):boolean;
            public UndoRemoveAnimation($anim: Saro.TweenAnimation):void;
            public constructor();
        }
        export class TweenAnimationAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public menu: string;
            public name: string;
            public constructor($menu: string, $name: string);
            public constructor();
        }
        export class LabelWidthScope extends System.ValueType implements System.IDisposable{ 
            public constructor($value: number);
            public constructor();
        }
        export class DisabledScope extends System.ValueType implements System.IDisposable{ 
            public constructor($disabled: boolean);
            public constructor();
        }
        export class GUIContentColorScope extends System.ValueType implements System.IDisposable{ 
            public constructor($value: UnityEngine.Color);
            public constructor();
        }
        export class GUIColorScope extends System.ValueType implements System.IDisposable{ 
            public constructor($value: UnityEngine.Color);
            public constructor();
        }
        export class ChangeCheckScope extends System.ValueType implements System.IDisposable{ 
            public get Changed(): boolean;
            public constructor($m_UndoRecordTarget: UnityEngine.Object);
            public constructor();
        }
        export class HandlesColorScope extends System.ValueType implements System.IDisposable{ 
            public constructor($value: UnityEngine.Color);
            public constructor();
        }
        export class InterpolatorDrawer extends UnityEditor.PropertyDrawer{ 
            public static get ButtonStyle(): UnityEngine.GUIStyle;
            public constructor();
        }
        export class BaseEditor$1<T> extends UnityEditor.Editor implements UnityEditor.IPreviewable, UnityEditor.IToolModeOwner{ 
        }
    }
    export namespace Saro.TweenMaterialProperty {
        export enum Type{ Color = 0, Vector = 1, Float = 2, Range = 3 }
    }
    export namespace Saro.CustomizableInterpolator {
        export enum Type{ Linear = 0, Accelerate = 1, Decelerate = 2, AccelerateDecelerate = 3, Anticipate = 4, Overshoot = 5, AnticipateOvershoot = 6, Bounce = 7, Parabolic = 8, Sine = 9, CustomCurve = -1 }
    }
    export namespace Saro.Interpolator {
        export enum Type{ Linear = 0, Accelerate = 1, Decelerate = 2, AccelerateDecelerate = 3, Anticipate = 4, Overshoot = 5, AnticipateOvershoot = 6, Bounce = 7, Parabolic = 8, Sine = 9 }
    }
    export namespace TankShooter {
        export class HUDFPS extends UnityEngine.MonoBehaviour{ 
            public updateInterval: number;
            public constructor();
        }
    }
    export namespace TankShooter.UI {
        export class GameButtonEvents extends UnityEngine.MonoBehaviour{ 
            public ResumeButtonEvent():void;
            public RestartButtonEvent():void;
            public ExitButtonEvent():void;
            public constructor();
        }
        export class LifeBar extends UnityEngine.MonoBehaviour{ 
            public lifeImages: System.Array$1<UnityEngine.UI.Image>;
            public HideLife($restLifes: number):void;
            public constructor();
        }
        export class MenuButtonEvents extends UnityEngine.MonoBehaviour{ 
            public mainPanel: UnityEngine.CanvasGroup;
            public levelsPanel: UnityEngine.CanvasGroup;
            public loadingPanel: UnityEngine.CanvasGroup;
            public optionsPanel: UnityEngine.CanvasGroup;
            public soundButton: UnityEngine.UI.Toggle;
            public musicButton: UnityEngine.UI.Toggle;
            public controlTypeLabel: UnityEngine.GameObject;
            public PlayButtonEvent():void;
            public OptionsButtonEvent():void;
            public ExitButtonEvent():void;
            public LevelButtonEvent($level: number):void;
            public BackButtonEvent():void;
            public SoundToggleButtonEvent():void;
            public MusicToggleButtonEvent():void;
            public ControlTypeButtonEvent($label: UnityEngine.UI.Text):void;
            public constructor();
        }
    }
    export namespace TankShooter.Interaction {
        export class BreakableObject extends UnityEngine.MonoBehaviour{ 
            public explosionPrefab: UnityEngine.GameObject;
            public StartBreak():void;
            public constructor();
        }
        export class CameraFollow extends UnityEngine.MonoBehaviour{ 
            public target: UnityEngine.Transform;
            public distance: number;
            public height: number;
            public heightDamping: number;
            public rotationDamping: number;
            public constructor();
        }
        export class Cannon extends UnityEngine.MonoBehaviour{ 
            public target: TankShooter.Bullets.BaseBullet.Target;
            public bulletType: TankShooter.Interaction.Cannon.BulletType;
            public bulletPrefab: UnityEngine.GameObject;
            public bulletStartPoints: System.Array$1<UnityEngine.Transform>;
            public bulletTrailMaterial: UnityEngine.Material;
            public flashPrefab: UnityEngine.GameObject;
            public flashPoints: System.Array$1<UnityEngine.Transform>;
            public maxShootsInRow: number;
            public Fire():void;
            public Fire($targetPoint: UnityEngine.Vector3):void;
            public constructor();
        }
        export class EnemyAI extends UnityEngine.MonoBehaviour{ 
            public body: UnityEngine.Transform;
            public cannon: TankShooter.Interaction.Cannon;
            public explosionPrefab: UnityEngine.GameObject;
            public lifes: number;
            public minMoveDistance: number;
            public maxMoveDistance: number;
            public enemyMoveSpeed: number;
            public bodyRotationSpeed: number;
            public cannonRotationSpeed: number;
            public minFireRate: number;
            public maxFireRate: number;
            public chasePlayer: boolean;
            public AddDamage($power: number):void;
            public isEnemyAlive():boolean;
            public constructor();
        }
        export class ExplosiveBarrel extends UnityEngine.MonoBehaviour{ 
            public explosionPrefab: UnityEngine.GameObject;
            public power: number;
            public Explode():void;
            public constructor();
        }
        export class Gameplay extends UnityEngine.MonoBehaviour{ 
            public ingamePanel: UnityEngine.CanvasGroup;
            public winPanel: UnityEngine.CanvasGroup;
            public losePanel: UnityEngine.CanvasGroup;
            public pausePanel: UnityEngine.CanvasGroup;
            public loadingPanel: UnityEngine.CanvasGroup;
            public startText: UnityEngine.UI.Text;
            public enemyCounterText: UnityEngine.UI.Text;
            public SetPaused($paused: boolean):void;
            public SetGameOver($isWin: boolean, $afterSeconds: number):void;
            public SetGameState($newGameState: TankShooter.Interaction.Gameplay.GameState):void;
            public getGameState():TankShooter.Interaction.Gameplay.GameState;
            public isPlaying():boolean;
            public isEnded():boolean;
            public DecreaseEnemiesCount():void;
            public constructor();
        }
    }
    export namespace TankShooter.Bullets.BaseBullet {
        export enum Target{ Player = 0, Enemy = 1 }
    }
    export namespace TankShooter.Interaction.Cannon {
        export enum BulletType{ BounceBullet = 0, MortarBomb = 1, HomingMissile = 2, Mine = 3 }
    }
    export namespace TankShooter.Interaction.Gameplay {
        export enum GameState{ Playing = 0, Paused = 1, GameOver = 2, None = 3 }
    }
    export namespace TankShooter.Controls {
        export class Joystick extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler{ 
            public thumb: UnityEngine.RectTransform;
            public autoReturnSpeed: UnityEngine.Vector2;
            public radius: number;
            public isMoving: boolean;
            public isReturned: boolean;
            public _canvas: UnityEngine.RectTransform;
            public get offset(): UnityEngine.Vector2;
            public constructor();
        }
        export class TankController extends UnityEngine.MonoBehaviour{ 
            public body: UnityEngine.Transform;
            public cannon: TankShooter.Interaction.Cannon;
            public explosionPrefab: UnityEngine.GameObject;
            public lifes: number;
            public tankMoveSpeed: number;
            public bodyRotationSpeed: number;
            public cannonRotationSpeed: number;
            public leftJoystick: TankShooter.Controls.Joystick;
            public rightJoystick: TankShooter.Controls.Joystick;
            public AddDamage($power: number):void;
            public constructor();
        }
    }
    export namespace TankShooter.Bullets {
        export class BaseBullet extends UnityEngine.MonoBehaviour{ 
            public speed: number;
            public power: number;
            public explosionPrefab: UnityEngine.GameObject;
            public StartMove($target: TankShooter.Bullets.BaseBullet.Target):void;
            public StartMove($target: TankShooter.Bullets.BaseBullet.Target, $targetPoint: UnityEngine.Vector3):void;
            public constructor();
        }
        export class BounceBullet extends TankShooter.Bullets.BaseBullet{ 
            public bounces: number;
            public constructor();
        }
        export class HomingMissile extends TankShooter.Bullets.BaseBullet{ 
            public lifeTime: number;
            public constructor();
        }
        export class Mine extends TankShooter.Bullets.BaseBullet{ 
            public destroyAfterSeconds: number;
            public constructor();
        }
        export class MortarBomb extends TankShooter.Bullets.BaseBullet{ 
            public constructor();
        }
    }
    export namespace Dungeon.Weapons {
        export class WeaponBase extends System.Object{ 
            public type: Dungeon.Weapons.WeaponBase.Type;
            public minAttack: number;
            public maxAttack: number;
            public Image: UnityEngine.Sprite;
            public Hit($pos: Dungeon.Util.IntVector2, $attackSide: Dungeon.Util.Sides.sideChoices):System.Array$1<Dungeon.GameObject.KillableObj>;
            public GetAttack():number;
            public constructor();
        }
    }
    export namespace Dungeon.Weapons.WeaponBase {
        export enum Type{ dagger = 0, sword = 1, pole = 2 }
    }
    export namespace Dungeon.GameObject {
        export class KillableObj extends Dungeon.GameObject.BaseObj{ 
            public status: Dungeon.Status.CharStatus;
            public SetWeapon($weapon: Dungeon.Weapons.WeaponBase):void;
            public GetWeapon():Dungeon.Weapons.WeaponBase;
            public UpdateGUI():void;
            public Damage($damage: number):void;
            public isDead():boolean;
            public Die():void;
            public constructor();
        }
        export class BaseObj extends UnityEngine.MonoBehaviour{ 
            public chanceTospawn: number;
            public ObjType: Dungeon.GameObject.BaseObj.Type;
            public graphics: UnityEngine.GameObject;
            public Start():void;
            public WallInPathToPlayer():boolean;
            public DistanceFromObject($obj: Dungeon.GameObject.BaseObj):number;
            public DirectionToObj($obj: Dungeon.GameObject.BaseObj):Dungeon.Util.Sides.sideChoices;
            public Position():Dungeon.Util.IntVector2;
            public AttackObj($obj: Dungeon.GameObject.KillableObj, $damage: number):void;
            public AttackAnimation($side: UnityEngine.Vector3):System.Collections.IEnumerator;
            public UpdatePosition($newPos: Dungeon.Util.IntVector2):void;
            public MoveAnimation($obj: UnityEngine.Transform, $from: UnityEngine.Vector3, $to: UnityEngine.Vector3, $time: number):System.Collections.IEnumerator;
            public Move($side: Dungeon.Util.Sides.sideChoices):void;
            public HitObj($posX: number, $posZ: number):System.Collections.Generic.List$1<Dungeon.GameObject.BaseObj>;
            public OnDestroy():void;
            public OnStep():void;
            public static UpdateStep():void;
            public constructor();
        }
        export class DoorObj extends Dungeon.GameObject.InteractiveObj{ 
            public isOpen: boolean;
            public OpenDoor():void;
            public constructor();
        }
        export class InteractiveObj extends Dungeon.GameObject.BaseObj{ 
            public EnemyGet():void;
            public PlayerGet():void;
            public constructor();
        }
        export class EnemyObj extends Dungeon.GameObject.KillableObj{ 
            public distanceToSeePlayer: number;
            public distanceToAttack: number;
            public npcAudio: Dungeon.Audio.NPCAudioManager;
            public MovementTest():System.Collections.IEnumerator;
            public CanSeePlayer():boolean;
            public DirectionToPlayer():Dungeon.Util.Sides.sideChoices;
            public CanAttackPlayer():boolean;
            public AttackPlayer():void;
            public Movement():void;
            public constructor();
        }
        export class EnemyRangedObj extends Dungeon.GameObject.EnemyObj{ 
            public AttackInstance: Dungeon.Projectile.ProjectileBase;
            public constructor();
        }
        export class ItemStatusObj extends Dungeon.GameObject.InteractiveObj{ 
            public giveLife: number;
            public giveStr: number;
            public constructor();
        }
        export class ItemWeaponObj extends Dungeon.GameObject.InteractiveObj{ 
            public weaponData: Dungeon.Weapons.WeaponBase;
            public constructor();
        }
        export class NextLevelObj extends Dungeon.GameObject.InteractiveObj{ 
            public constructor();
        }
        export class PlayerObj extends Dungeon.GameObject.KillableObj{ 
            public static playerInstance: Dungeon.GameObject.PlayerObj;
            public static PlayerStatus: Dungeon.Status.CharStatus;
            public OnLevelUp():void;
            public SaveData():void;
            public DeleteData():void;
            public Update():void;
            public InitStep():void;
            public SetScreenStatus():void;
            public constructor();
        }
        export class TrapObject extends Dungeon.GameObject.InteractiveObj{ 
            public damage: number;
            public distanceToAttack: number;
            public AttackInstance: Dungeon.Projectile.ProjectileBase;
            public npcAudio: Dungeon.Audio.NPCAudioManager;
            public ammo: number;
            public AttackObj($obj: Dungeon.GameObject.KillableObj, $damage: number, $side: Dungeon.Util.IntVector2):void;
            public IsHit():Dungeon.Util.Sides.sideChoices;
            public CheckForPlayer($side: Dungeon.Util.Sides.sideChoices, $pos: Dungeon.Util.IntVector2, $distance: number):boolean;
            public constructor();
            public AttackObj($obj: Dungeon.GameObject.KillableObj, $damage: number):void;
        }
        export class WallObj extends Dungeon.GameObject.BaseObj{ 
            public constructor();
        }
    }
    export namespace Dungeon.Util {
        export class IntVector2 extends System.ValueType{ 
            public x: number;
            public z: number;
            public static op_Addition($a: Dungeon.Util.IntVector2, $b: Dungeon.Util.IntVector2):Dungeon.Util.IntVector2;
            public static op_Addition($a: Dungeon.Util.IntVector2, $b: UnityEngine.Vector3):UnityEngine.Vector3;
            public static op_Subtraction($a: Dungeon.Util.IntVector2, $b: Dungeon.Util.IntVector2):Dungeon.Util.IntVector2;
            public static op_Multiply($b: number, $a: Dungeon.Util.IntVector2):Dungeon.Util.IntVector2;
            public constructor($x: number, $z: number);
            public constructor();
        }
        export class AnimatePosition extends UnityEngine.MonoBehaviour{ 
            public curveX: UnityEngine.AnimationCurve;
            public curveY: UnityEngine.AnimationCurve;
            public curveZ: UnityEngine.AnimationCurve;
            public animationSpeed: number;
            public currTime: number;
            public constructor();
        }
        export class GameObjectSpawner extends Dungeon.Util.SpawnChance{ 
            public SpawnPool: System.Array$1<UnityEngine.GameObject>;
            public constructor();
        }
        export class SpawnChance extends UnityEngine.MonoBehaviour{ 
            public chanceTospawn: number;
            public constructor();
        }
        export class GenerateDungeonTool extends UnityEngine.MonoBehaviour{ 
            public cameraFollow: UnityEngine.Camera;
            public xSize: UnityEngine.UI.InputField;
            public zSize: UnityEngine.UI.InputField;
            public Generate():void;
            public constructor();
        }
        export class LoadStage extends UnityEngine.MonoBehaviour{ 
            public stageName: string;
            public Load():void;
            public constructor();
        }
        export class MoveCamera extends UnityEngine.MonoBehaviour{ 
            public constructor();
        }
        export class Rotate extends UnityEngine.MonoBehaviour{ 
            public rotation: UnityEngine.Vector3;
            public constructor();
        }
        export class Sides extends System.Object{ 
            public static sideVector: System.Array$1<Dungeon.Util.IntVector2>;
            public static SideToVector($side: Dungeon.Util.Sides.sideChoices):Dungeon.Util.IntVector2;
            public static invert($side: Dungeon.Util.Sides.sideChoices):Dungeon.Util.Sides.sideChoices;
            public static RandomSide():Dungeon.Util.Sides.sideChoices;
        }
    }
    export namespace Dungeon.Util.Sides {
        export enum sideChoices{ up = 0, down = 1, left = 2, right = 3, none = 4 }
    }
    export namespace Dungeon.UI {
        export class DestroyOnParticleEnd extends UnityEngine.MonoBehaviour{ 
            public constructor();
        }
        export class UIManager extends UnityEngine.MonoBehaviour{ 
            public canvas: UnityEngine.Canvas;
            public ProgressBar: UnityEngine.UI.Image;
            public ProgressBarBackground: UnityEngine.UI.Image;
            public damageBox: Dungeon.Effects.DamageText;
            public static get instance(): Dungeon.UI.UIManager;
            public static InstatianteInCanvas($instance: UnityEngine.GameObject):UnityEngine.GameObject;
            public static WorldSpace2Canvas($pos: UnityEngine.Vector3):UnityEngine.Vector2;
            public constructor();
        }
    }
    export namespace Dungeon.Effects {
        export class DamageText extends UnityEngine.MonoBehaviour{ 
            public textBox: UnityEngine.UI.Text;
            public curve: UnityEngine.AnimationCurve;
            public animationTime: number;
            public CreateBox($value: number):void;
            public StartAnimation():System.Collections.IEnumerator;
            public constructor();
        }
    }
    export namespace Dungeon.Status {
        export class CharStatus extends System.Object{ 
            public weapon: Dungeon.Weapons.WeaponBase;
            public life: number;
            public strengh: number;
            public defense: number;
            public luck: number;
            public speed: number;
            public GiveExpOnKill: number;
            public currLife: number;
            public currExp: number;
            public nextLevel: number;
            public currLevel: number;
            public EventLevelUp: Dungeon.Status.CharStatus.OnLevelUp;
            public Init():void;
            public GetExp($exp: number):void;
            public LevelUp():void;
            public CalculateAttack():number;
            public CalculateDefense():number;
            public CalculateDamage($damage: number):number;
            public TakeDamage($damage: number):void;
            public UpdateLife($givenLife: number):void;
            public constructor();
        }
    }
    export namespace Dungeon.Status.CharStatus {
        export type OnLevelUp = () => void;
        var OnLevelUp: {new (func: () => void): OnLevelUp;}
    }
    export namespace Dungeon.Projectile {
        export class Arrow extends Dungeon.Projectile.ProjectileBase{ 
            public speed: number;
            public constructor();
        }
        export class ProjectileBase extends UnityEngine.MonoBehaviour{ 
            public parent: Dungeon.GameObject.BaseObj;
            public target: UnityEngine.GameObject;
            public damage: number;
            public Start():void;
            public Update():void;
            public OnDestroy():void;
            public Position():Dungeon.Util.IntVector2;
            public constructor();
        }
    }
    export namespace Dungeon.PrefabManager {
        export class ObjectPrefabs extends UnityEngine.MonoBehaviour{ 
            public OnObjectDeath: UnityEngine.GameObject;
            public OnAttackMiss: UnityEngine.GameObject;
            public OnAttackHit: UnityEngine.GameObject;
            public OnLeveup: UnityEngine.GameObject;
            public static instance: Dungeon.PrefabManager.ObjectPrefabs;
            public constructor();
        }
    }
    export namespace Dungeon.GameObject.BaseObj {
        export enum Type{ player = 0, enemy = 1, interactive = 2, wall = 3 }
    }
    export namespace Dungeon.Audio {
        export class NPCAudioManager extends UnityEngine.MonoBehaviour{ 
            public ArrowShot: Dungeon.Audio.AudioManager;
            public PlayArrowShot():void;
            public constructor();
        }
        export class AudioManager extends System.Object{ 
            public source: UnityEngine.AudioSource;
            public clips: System.Array$1<UnityEngine.AudioClip>;
            public PlayRandom():void;
            public constructor();
        }
        export class GameAudioManager extends UnityEngine.MonoBehaviour{ 
            public footstep: Dungeon.Audio.AudioManager;
            public weaponHit: Dungeon.Audio.AudioManager;
            public openDoor: Dungeon.Audio.AudioManager;
            public LevelUp: Dungeon.Audio.AudioManager;
            public static PlayFootstep():void;
            public static PlayWeaponHit():void;
            public static OpenDoor():void;
            public static PlayLevelUp():void;
            public constructor();
        }
    }
    export namespace Dungeon.Dungeon {
        export class CellManager extends UnityEngine.MonoBehaviour{ 
            public AddWall($side: Dungeon.Util.Sides.sideChoices, $prefab: UnityEngine.GameObject):void;
            public RemoveWall($side: Dungeon.Util.Sides.sideChoices):void;
            public constructor();
        }
        export class DungeonGenerator extends UnityEngine.MonoBehaviour{ 
            public static CellSize: number;
            public static HalfCellSize: number;
            public generateOnStart: boolean;
            public generateHero: boolean;
            public level: number;
            public xSize: number;
            public zSize: number;
            public MainPathMaxLen: number;
            public MainPathCurrLen: number;
            public PlayerPrefab: UnityEngine.GameObject;
            public prefabs: System.Array$1<Dungeon.Dungeon.LevelPrefabs>;
            public static get instance(): Dungeon.Dungeon.DungeonGenerator;
            public DestroyDungeon():void;
            public GenerateDungeon():void;
            public CreateDungeon():System.Collections.IEnumerator;
            public AddDecorations():void;
            public AddItemWeapons():void;
            public CreatePlayer():void;
            public MakePath($pos: Dungeon.Util.IntVector2, $lastChoice?: Dungeon.Util.Sides.sideChoices):void;
            public FillGrid():void;
            public NextStep($currX: number, $currZ: number):Dungeon.Util.Sides.sideChoices;
            public ExistCell($pos: Dungeon.Util.IntVector2):boolean;
            public GetCell($pos: Dungeon.Util.IntVector2):Dungeon.Dungeon.CellManager;
            public CellIsCreated($pos: Dungeon.Util.IntVector2):boolean;
            public constructor();
        }
        export class LevelPrefabs extends System.Object{ 
            public AppearInAllLevels: boolean;
            public AppearFromLevel: number;
            public ApperToLevel: number;
            public prefabs: Dungeon.Dungeon.DungeonPrefabs;
            public constructor();
        }
        export class DungeonPrefabs extends System.Object{ 
            public FirstCells: System.Collections.Generic.List$1<Dungeon.Dungeon.CellManager>;
            public EndingCells: System.Collections.Generic.List$1<Dungeon.Dungeon.CellManager>;
            public CellPrefabs: System.Collections.Generic.List$1<Dungeon.Dungeon.CellManager>;
            public WallPrefabs: System.Collections.Generic.List$1<UnityEngine.GameObject>;
            public DoorPrefabs: System.Collections.Generic.List$1<UnityEngine.GameObject>;
            public WallDecorationsPrefab: System.Collections.Generic.List$1<UnityEngine.GameObject>;
            public weaponItems: System.Collections.Generic.List$1<UnityEngine.GameObject>;
            public Reset():void;
            public Add($toAdd: Dungeon.Dungeon.DungeonPrefabs):void;
            public GetRandomFirstCellPrefab():Dungeon.Dungeon.CellManager;
            public GetRandomEndCellPrefab():Dungeon.Dungeon.CellManager;
            public GetRandomCellPrefab():Dungeon.Dungeon.CellManager;
            public GetRandomWallPrefab():UnityEngine.GameObject;
            public GetRandomWallDecorationPrefab():UnityEngine.GameObject;
            public GetRandomDoorPrefab():UnityEngine.GameObject;
            public GetRandomWeaponItem():UnityEngine.GameObject;
            public constructor();
        }
        export class ObjectManager extends System.Object{ 
            public static WaitForActionsToFinish: boolean;
            public static get sizeX(): number;
            public static get sizeZ(): number;
            public static StartAction():void;
            public static EndAction():void;
            public static IsActionsHapping():boolean;
            public static Start($sizeX: number, $sizeZ: number):void;
            public static InsideBounds($pos: Dungeon.Util.IntVector2):boolean;
            public static GetObjectOfTypeAt($pos: Dungeon.Util.IntVector2, $type: Dungeon.GameObject.BaseObj.Type):Dungeon.GameObject.BaseObj;
            public static GetObjectOfTypeAt($x: number, $z: number, $type: Dungeon.GameObject.BaseObj.Type):Dungeon.GameObject.BaseObj;
            public static GetObjectsAt($pos: Dungeon.Util.IntVector2):System.Collections.Generic.List$1<Dungeon.GameObject.BaseObj>;
            public static GetObjectsAt($x: number, $z: number):System.Collections.Generic.List$1<Dungeon.GameObject.BaseObj>;
            public static GetInteractive($pos: Dungeon.Util.IntVector2):Dungeon.GameObject.InteractiveObj;
            public static GetInteractive($x: number, $z: number):Dungeon.GameObject.InteractiveObj;
            public static SetObjectsAt($x: number, $z: number, $obj: Dungeon.GameObject.BaseObj):void;
            public static UpdateObjectsAt($fromX: number, $fromZ: number, $toX: number, $toZ: number, $obj: Dungeon.GameObject.BaseObj):void;
            public static RemoveObjectsAt($x: number, $z: number, $obj: Dungeon.GameObject.BaseObj):void;
            public static CheckObstacle($x: number, $z: number):boolean;
            public static CheckObstacle($pos: Dungeon.Util.IntVector2):boolean;
            public static RemoveOverlayObjects():void;
        }
    }
    export namespace Dungeon.Camera {
        export class CameraController extends UnityEngine.MonoBehaviour{ 
            public smoothCamera: boolean;
            public smoothMoveCurve: UnityEngine.AnimationCurve;
            public moveSpeed: number;
            public constructor();
        }
    }
    export namespace Tetris.VFX {
        export class SoundBank extends System.Object{ 
            public key: string;
            public clip: UnityEngine.AudioClip;
            public constructor();
        }
    }
    export namespace Tetris.Tools.GameEntry {
        export class GlobalApplication extends UnityEngine.MonoBehaviour{ 
            public UpdateInfo($action: System.Action, $type: number):void;
            public constructor();
        }
    }
    export namespace Saro.Tween {
        export class Editor extends Saro.BaseEditor$1<Saro.Tween> implements UnityEditor.IPreviewable, UnityEditor.IToolModeOwner{ 
        }
    }
    export namespace Saro.TweenAnimation {
        export class Editor extends UnityEditor.Editor implements UnityEditor.IPreviewable, UnityEditor.IToolModeOwner{ 
        }
    }
    export namespace Tetris.Tools.GameEntry.GlobalApplication {
        export class GameEntryEditor extends UnityEditor.Editor implements UnityEditor.IPreviewable, UnityEditor.IToolModeOwner{ 
        }
    }
    export namespace NodeCanvas.Framework {
        export class ActionTask extends NodeCanvas.Framework.Task implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public status: NodeCanvas.Framework.Status;
            public timeStarted: number;
            public latch: boolean;
            public static get CurrentFlow(): FlowCanvas.Flow;
            public static set CurrentFlow(value: FlowCanvas.Flow);
            public get transform(): UnityEngine.Transform;
            public get gameObject(): UnityEngine.GameObject;
            public get elapsedTime(): number;
            public get isRunning(): boolean;
            public get isPaused(): boolean;
            public ExecuteIndependent($agent: UnityEngine.Component, $blackboard: NodeCanvas.Framework.IBlackboard, $callback: System.Action$1<NodeCanvas.Framework.Status>):void;
            public Execute($agent: UnityEngine.Component, $blackboard: NodeCanvas.Framework.IBlackboard):NodeCanvas.Framework.Status;
            public EndAction():void;
            public EndAction($success: boolean):void;
            public EndAction($success: System.Nullable$1<boolean>):void;
            public Pause():void;
            public OnExecute():void;
            public OnUpdate():void;
            public OnStop($interrupted: boolean):void;
            public OnStop():void;
            public OnPause():void;
            public OnResume():void;
        }
        export class Task extends System.Object implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public showDefaultUI: boolean;
            public get ownerSystem(): NodeCanvas.Framework.ITaskSystem;
            public get ownerSystemAgent(): UnityEngine.Component;
            public get ownerSystemBlackboard(): NodeCanvas.Framework.IBlackboard;
            public get ownerSystemElapsedTime(): number;
            public get isUserEnabled(): boolean;
            public get obsolete(): string;
            public get name(): string;
            public get description(): string;
            public get summaryInfo(): string;
            public get agentType(): System.Type;
            public get agentInfo(): string;
            public get agentParameterName(): string;
            public get agentIsOverride(): boolean;
            public set agentIsOverride(value: boolean);
            public get agent(): UnityEngine.Component;
            public get blackboard(): NodeCanvas.Framework.IBlackboard;
            public get router(): ParadoxNotion.Services.EventRouter;
            public get icon(): UnityEngine.Texture2D;
            public static Create($type: System.Type, $newOwnerSystem: NodeCanvas.Framework.ITaskSystem):NodeCanvas.Framework.Task;
            public Duplicate($newOwnerSystem: NodeCanvas.Framework.ITaskSystem):NodeCanvas.Framework.Task;
            public Validate($ownerSystem: NodeCanvas.Framework.ITaskSystem):void;
            public SetOwnerSystem($newOwnerSystem: NodeCanvas.Framework.ITaskSystem):void;
            public OnCreate($ownerSystem: NodeCanvas.Framework.ITaskSystem):void;
            public OnValidate($ownerSystem: NodeCanvas.Framework.ITaskSystem):void;
            public OnDrawGizmosSelected():void;
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class BBParameter$1<T> extends NodeCanvas.Framework.BBParameter implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
        }
        export class BBParameter extends System.Object implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public node: NodeCanvas.Framework.Node;
            public get targetVariableID(): string;
            public get varRef(): NodeCanvas.Framework.Variable;
            public get name(): string;
            public set name(value: string);
            public get bb(): NodeCanvas.Framework.IBlackboard;
            public set bb(value: NodeCanvas.Framework.IBlackboard);
            public get useBlackboard(): boolean;
            public set useBlackboard(value: boolean);
            public get isPresumedDynamic(): boolean;
            public get isNone(): boolean;
            public get isNull(): boolean;
            public get isNoneOrNull(): boolean;
            public get isDefined(): boolean;
            public get refType(): System.Type;
            public get value(): any;
            public set value(value: any);
            public get varType(): System.Type;
            public add_onVariableReferenceChanged($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableReferenceChanged($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public static CreateInstance($t: System.Type, $bb: NodeCanvas.Framework.IBlackboard):NodeCanvas.Framework.BBParameter;
            public static SetBBFields($target: any, $bb: NodeCanvas.Framework.IBlackboard):void;
            public GetValueBoxed():any;
            public SetValueBoxed($value: any):void;
            public PromoteToVariable($targetBB: NodeCanvas.Framework.IBlackboard):NodeCanvas.Framework.Variable;
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class ConditionTask extends NodeCanvas.Framework.Task implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public get invert(): boolean;
            public set invert(value: boolean);
            public Enable($agent: UnityEngine.Component, $bb: NodeCanvas.Framework.IBlackboard):void;
            public Disable():void;
            public Check($agent: UnityEngine.Component, $blackboard: NodeCanvas.Framework.IBlackboard):boolean;
            public CheckOnce($agent: UnityEngine.Component, $blackboard: NodeCanvas.Framework.IBlackboard):boolean;
        }
        export class Connection extends System.Object implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public get startRect(): UnityEngine.Rect;
            public get endRect(): UnityEngine.Rect;
            public get relinkState(): NodeCanvas.Framework.Connection.RelinkState;
            public get defaultColor(): UnityEngine.Color;
            public get animate(): boolean;
            public get defaultSize(): number;
            public get tipConnectionStyle(): NodeCanvas.Framework.Connection.TipConnectionStyle;
            public get direction(): ParadoxNotion.PlanarDirection;
            public get UID(): string;
            public get sourceNode(): NodeCanvas.Framework.Node;
            public get targetNode(): NodeCanvas.Framework.Node;
            public get isActive(): boolean;
            public set isActive(value: boolean);
            public get status(): NodeCanvas.Framework.Status;
            public set status(value: NodeCanvas.Framework.Status);
            public get graph(): NodeCanvas.Framework.Graph;
            public get name(): string;
            public DrawConnectionGUI($fromPos: UnityEngine.Vector2, $toPos: UnityEngine.Vector2):void;
            public static ShowConnectionInspectorGUI($c: NodeCanvas.Framework.Connection):void;
            public GetMidRect():UnityEngine.Rect;
            public static Create($source: NodeCanvas.Framework.Node, $target: NodeCanvas.Framework.Node, $sourceIndex?: number, $targetIndex?: number):NodeCanvas.Framework.Connection;
            public Duplicate($newSource: NodeCanvas.Framework.Node, $newTarget: NodeCanvas.Framework.Node):NodeCanvas.Framework.Connection;
            public SetSourceNode($newSource: NodeCanvas.Framework.Node, $index?: number):number;
            public SetTargetNode($newTarget: NodeCanvas.Framework.Node, $index?: number):number;
            public Execute($agent: UnityEngine.Component, $blackboard: NodeCanvas.Framework.IBlackboard):NodeCanvas.Framework.Status;
            public Reset($recursively?: boolean):void;
            public OnCreate($sourceIndex: number, $targetIndex: number):void;
            public OnValidate($sourceIndex: number, $targetIndex: number):void;
            public OnDestroy():void;
        }
        export interface IGraphElement{ 
            name: string;
            UID: string;
            graph: NodeCanvas.Framework.Graph;
            status: NodeCanvas.Framework.Status;
        }
        export class Node extends System.Object implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public static CurrentNode: NodeCanvas.Framework.Node;
            public tags: System.Collections.Generic.HashSet$1<string>;
            public get rect(): UnityEngine.Rect;
            public get isActive(): boolean;
            public get collapsed(): boolean;
            public set collapsed(value: boolean);
            public get isHidden(): boolean;
            public get customColor(): UnityEngine.Color;
            public set customColor(value: UnityEngine.Color);
            public get verboseLevel(): NodeCanvas.Framework.Node.VerboseLevel;
            public set verboseLevel(value: NodeCanvas.Framework.Node.VerboseLevel);
            public get isSelected(): boolean;
            public get nodeColor(): UnityEngine.Color;
            public static get useAssetForSubGraph(): boolean;
            public get graph(): NodeCanvas.Framework.Graph;
            public get ID(): number;
            public get UID(): string;
            public get inConnections(): System.Collections.Generic.List$1<NodeCanvas.Framework.Connection>;
            public get outConnections(): System.Collections.Generic.List$1<NodeCanvas.Framework.Connection>;
            public get position(): UnityEngine.Vector2;
            public set position(value: UnityEngine.Vector2);
            public get tag(): string;
            public set tag(value: string);
            public get comments(): string;
            public set comments(value: string);
            public get isBreakpoint(): boolean;
            public set isBreakpoint(value: boolean);
            public get name(): string;
            public set name(value: string);
            public get description(): string;
            public get priority(): number;
            public get maxInConnections(): number;
            public get maxOutConnections(): number;
            public get outConnectionType(): System.Type;
            public get allowAsPrime(): boolean;
            public get canSelfConnect(): boolean;
            public get commentsAlignment(): ParadoxNotion.Alignment2x2;
            public get iconAlignment(): ParadoxNotion.Alignment2x2;
            public get status(): NodeCanvas.Framework.Status;
            public get graphAgent(): UnityEngine.Component;
            public get graphBlackboard(): NodeCanvas.Framework.IBlackboard;
            public get elapsedTime(): number;
            public static ShowNodeGUI($node: NodeCanvas.Framework.Node, $drawCanvas: UnityEngine.Rect, $fullDrawPass: boolean, $canvasMousePos: UnityEngine.Vector2, $zoomFactor: number):void;
            public static GetNodeMenu_Single($node: NodeCanvas.Framework.Node):UnityEditor.GenericMenu;
            public static ShowNodeInspectorGUI($node: NodeCanvas.Framework.Node):void;
            public TrySortConnectionsByPositionX():void;
            public OnActiveRelinkEnd($connection: NodeCanvas.Framework.Connection):void;
            public GetConnectionInfo($index: number):string;
            public OnConnectionInspectorGUI($index: number):void;
            public OnActiveRelinkStart($connection: NodeCanvas.Framework.Connection):void;
            public static Create($targetGraph: NodeCanvas.Framework.Graph, $nodeType: System.Type, $pos: UnityEngine.Vector2):NodeCanvas.Framework.Node;
            public Duplicate($targetGraph: NodeCanvas.Framework.Graph):NodeCanvas.Framework.Node;
            public Validate($assignedGraph: NodeCanvas.Framework.Graph):void;
            public Execute($agent: UnityEngine.Component, $blackboard: NodeCanvas.Framework.IBlackboard):NodeCanvas.Framework.Status;
            public Reset($recursively?: boolean):void;
            public Error($msg: any):NodeCanvas.Framework.Status;
            public Fail($msg: string):NodeCanvas.Framework.Status;
            public Warn($msg: string):void;
            public SetStatus($status: NodeCanvas.Framework.Status):void;
            public static IsNewConnectionAllowed($sourceNode: NodeCanvas.Framework.Node, $targetNode: NodeCanvas.Framework.Node, $refConnection?: NodeCanvas.Framework.Connection):boolean;
            public static AreNodesConnected($a: NodeCanvas.Framework.Node, $b: NodeCanvas.Framework.Node):boolean;
            public StartCoroutine($routine: System.Collections.IEnumerator):UnityEngine.Coroutine;
            public StopCoroutine($routine: UnityEngine.Coroutine):void;
            public GetParentNodes():System.Collections.Generic.IEnumerable$1<NodeCanvas.Framework.Node>;
            public GetChildNodes():System.Collections.Generic.IEnumerable$1<NodeCanvas.Framework.Node>;
            public IsChildOf($parentNode: NodeCanvas.Framework.Node):boolean;
            public IsParentOf($childNode: NodeCanvas.Framework.Node):boolean;
            public OnCreate($assignedGraph: NodeCanvas.Framework.Graph):void;
            public OnValidate($assignedGraph: NodeCanvas.Framework.Graph):void;
            public OnDestroy():void;
            public OnParentConnected($connectionIndex: number):void;
            public OnParentDisconnected($connectionIndex: number):void;
            public OnChildConnected($connectionIndex: number):void;
            public OnChildDisconnected($connectionIndex: number):void;
            public OnChildrenConnectionsSorted($oldIndeces: System.Array$1<number>):void;
            public OnGraphStarted():void;
            public OnPostGraphStarted():void;
            public OnGraphStoped():void;
            public OnPostGraphStoped():void;
            public OnGraphPaused():void;
            public OnGraphUnpaused():void;
            public constructor();
        }
        interface Node {
            ReplaceWith($t: System.Type):NodeCanvas.Framework.Node;
        }
        export class Graph extends UnityEngine.ScriptableObject implements NodeCanvas.Framework.ITaskSystem, UnityEngine.ISerializationCallbackReceiver{ 
            public get baseNodeType(): System.Type;
            public get requiresAgent(): boolean;
            public get requiresPrimeNode(): boolean;
            public get isTree(): boolean;
            public get allowBlackboardOverrides(): boolean;
            public get canAcceptVariableDrops(): boolean;
            public get category(): string;
            public set category(value: string);
            public get comments(): string;
            public set comments(value: string);
            public get translation(): UnityEngine.Vector2;
            public set translation(value: UnityEngine.Vector2);
            public get zoomFactor(): number;
            public set zoomFactor(value: number);
            public get allNodes(): System.Collections.Generic.List$1<NodeCanvas.Framework.Node>;
            public set allNodes(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Node>);
            public get canvasGroups(): System.Collections.Generic.List$1<NodeCanvas.Framework.CanvasGroup>;
            public set canvasGroups(value: System.Collections.Generic.List$1<NodeCanvas.Framework.CanvasGroup>);
            public get rootGraph(): NodeCanvas.Framework.Graph;
            public get serializationHalted(): boolean;
            public static get runningGraphs(): System.Collections.Generic.IEnumerable$1<NodeCanvas.Framework.Graph>;
            public get parentGraph(): NodeCanvas.Framework.Graph;
            public get elapsedTime(): number;
            public get deltaTime(): number;
            public get lastUpdateFrame(): number;
            public get didUpdateLastFrame(): boolean;
            public get isRunning(): boolean;
            public get isPaused(): boolean;
            public get updateMode(): NodeCanvas.Framework.Graph.UpdateMode;
            public get primeNode(): NodeCanvas.Framework.Node;
            public set primeNode(value: NodeCanvas.Framework.Node);
            public get agent(): UnityEngine.Component;
            public set agent(value: UnityEngine.Component);
            public get blackboard(): NodeCanvas.Framework.IBlackboard;
            public get parentBlackboard(): NodeCanvas.Framework.IBlackboard;
            public get contextObject(): UnityEngine.Object;
            public GetCurrentChildGraph():NodeCanvas.Framework.Graph;
            public SetCurrentChildGraphAssignable($assignable: NodeCanvas.Framework.IGraphAssignable):void;
            public static add_onGraphSerialized($value: System.Action$1<NodeCanvas.Framework.Graph>):void;
            public static remove_onGraphSerialized($value: System.Action$1<NodeCanvas.Framework.Graph>):void;
            public static add_onGraphDeserialized($value: System.Action$1<NodeCanvas.Framework.Graph>):void;
            public static remove_onGraphDeserialized($value: System.Action$1<NodeCanvas.Framework.Graph>):void;
            public SelfSerialize():boolean;
            public SelfDeserialize():boolean;
            public Serialize($references: System.Collections.Generic.List$1<UnityEngine.Object>):string;
            public Deserialize($serializedGraph: string, $references: System.Collections.Generic.List$1<UnityEngine.Object>, $validate: boolean):boolean;
            public SerializeLocalBlackboard($references: $Ref<System.Collections.Generic.List$1<UnityEngine.Object>>):string;
            public DeserializeLocalBlackboard($json: string, $references: System.Collections.Generic.List$1<UnityEngine.Object>):boolean;
            public static Clone($graph: NodeCanvas.Framework.Graph, $parentGraph: NodeCanvas.Framework.Graph):NodeCanvas.Framework.Graph;
            public Validate():void;
            public add_onFinish($value: System.Action$1<boolean>):void;
            public remove_onFinish($value: System.Action$1<boolean>):void;
            public UpdateReferencesFromOwner($owner: NodeCanvas.Framework.GraphOwner, $force?: boolean):void;
            public UpdateReferences($newAgent: UnityEngine.Component, $newParentBlackboard: NodeCanvas.Framework.IBlackboard, $force?: boolean):void;
            public UpdateNodeIDs($alsoReorderList: boolean):void;
            public LoadOverwriteAsync($data: NodeCanvas.Framework.Internal.GraphLoadData, $callback: System.Action):void;
            public LoadOverwrite($data: NodeCanvas.Framework.Internal.GraphLoadData):void;
            public Initialize($newAgent: UnityEngine.Component, $newParentBlackboard: NodeCanvas.Framework.IBlackboard, $preInitializeSubGraphs: boolean):void;
            public StartGraph($newAgent: UnityEngine.Component, $newParentBlackboard: NodeCanvas.Framework.IBlackboard, $newUpdateMode: NodeCanvas.Framework.Graph.UpdateMode, $callback?: System.Action$1<boolean>):void;
            public Stop($success?: boolean):void;
            public Pause():void;
            public Resume():void;
            public Restart():void;
            public UpdateGraph():void;
            public UpdateGraph($deltaTime: number):void;
            public OnDerivedDataSerialization():any;
            public OnDerivedDataDeserialization($data: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public static SendGlobalEvent($name: string, $value: any, $sender: any):void;
            public GetAllParameters():System.Collections.Generic.IEnumerable$1<NodeCanvas.Framework.BBParameter>;
            public GetAllConnections():System.Collections.Generic.IEnumerable$1<NodeCanvas.Framework.Connection>;
            public GetNodeWithID($searchID: number):NodeCanvas.Framework.Node;
            public GetRootNodes():System.Collections.Generic.IEnumerable$1<NodeCanvas.Framework.Node>;
            public GetLeafNodes():System.Collections.Generic.IEnumerable$1<NodeCanvas.Framework.Node>;
            public GetAllInstancedNestedGraphs():System.Collections.Generic.IEnumerable$1<NodeCanvas.Framework.Graph>;
            public GetDefinedParameters():System.Collections.Generic.IEnumerable$1<NodeCanvas.Framework.BBParameter>;
            public PromoteMissingParametersToVariables($bb: NodeCanvas.Framework.IBlackboard):void;
            public static GetElementGraph($obj: any):NodeCanvas.Framework.Graph;
            public GetFlatMetaGraph():ParadoxNotion.HierarchyTree.Element;
            public GetFullMetaGraph():ParadoxNotion.HierarchyTree.Element;
            public GetNestedMetaGraph():ParadoxNotion.HierarchyTree.Element;
            public GetTaskParentElement($targetTask: NodeCanvas.Framework.Task):NodeCanvas.Framework.IGraphElement;
            public GetParameterParentElement($targetParameter: NodeCanvas.Framework.BBParameter):NodeCanvas.Framework.IGraphElement;
            public static GetTasksInElement($target: NodeCanvas.Framework.IGraphElement):System.Collections.Generic.IEnumerable$1<NodeCanvas.Framework.Task>;
            public static GetParametersInElement($target: NodeCanvas.Framework.IGraphElement):System.Collections.Generic.IEnumerable$1<NodeCanvas.Framework.BBParameter>;
            public AddNode($nodeType: System.Type):NodeCanvas.Framework.Node;
            public AddNode($nodeType: System.Type, $pos: UnityEngine.Vector2):NodeCanvas.Framework.Node;
            public RemoveNode($node: NodeCanvas.Framework.Node, $recordUndo?: boolean, $force?: boolean):void;
            public ConnectNodes($sourceNode: NodeCanvas.Framework.Node, $targetNode: NodeCanvas.Framework.Node, $sourceIndex?: number, $targetIndex?: number):NodeCanvas.Framework.Connection;
            public RemoveConnection($connection: NodeCanvas.Framework.Connection, $recordUndo?: boolean):void;
            public static CloneNodes($originalNodes: System.Collections.Generic.List$1<NodeCanvas.Framework.Node>, $targetGraph?: NodeCanvas.Framework.Graph, $originPosition?: UnityEngine.Vector2):System.Collections.Generic.List$1<NodeCanvas.Framework.Node>;
            public ClearGraph():void;
            public UpdateTasksOwner():void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        interface Graph {
            GetGraphJSONFileExtension():string;
            GetSelectedOrAll():System.Collections.Generic.IEnumerable$1<NodeCanvas.Framework.Node>;
        }
        export interface ITaskSystem{ 
            agent: UnityEngine.Component;
            blackboard: NodeCanvas.Framework.IBlackboard;
            contextObject: UnityEngine.Object;
            elapsedTime: number;
            UpdateTasksOwner():void;
            SendEvent($name: string, $value: any, $sender: any):void;
        }
        export interface IBlackboard{ 
            tempName: string;
            identifier: string;
            parent: NodeCanvas.Framework.IBlackboard;
            variables: System.Collections.Generic.Dictionary$2<string, NodeCanvas.Framework.Variable>;
            propertiesBindTarget: UnityEngine.Component;
            unityContextObject: UnityEngine.Object;
            independantVariablesFieldName: string;
            add_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            remove_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            add_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            remove_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            TryInvokeOnVariableAdded($variable: NodeCanvas.Framework.Variable):void;
            TryInvokeOnVariableRemoved($variable: NodeCanvas.Framework.Variable):void;
        }
        interface IBlackboard {
            GetRoot():NodeCanvas.Framework.IBlackboard;
            GetAllParents($includeSelf: boolean):System.Collections.Generic.IEnumerable$1<NodeCanvas.Framework.IBlackboard>;
            IsPartOf($child: NodeCanvas.Framework.IBlackboard):boolean;
            AddVariable($varName: string, $value: any):NodeCanvas.Framework.Variable;
            AddVariable($varName: string, $type: System.Type):NodeCanvas.Framework.Variable;
            RemoveVariable($varName: string):NodeCanvas.Framework.Variable;
            SetVariableValue($varName: string, $value: any):NodeCanvas.Framework.Variable;
            InitializePropertiesBinding($target: UnityEngine.Component, $callSetter: boolean):void;
            GetVariable($varName: string, $ofType?: System.Type):NodeCanvas.Framework.Variable;
            GetVariableByID($ID: string):NodeCanvas.Framework.Variable;
            GetVariables($ofType?: System.Type):System.Collections.Generic.IEnumerable$1<NodeCanvas.Framework.Variable>;
            ChangeVariableType($target: NodeCanvas.Framework.Variable, $newType: System.Type):NodeCanvas.Framework.Variable;
            OverwriteFrom($sourceBlackboard: NodeCanvas.Framework.IBlackboard, $removeMissingVariables?: boolean):void;
        }
        export class Variable extends System.Object{ 
            public get name(): string;
            public set name(value: string);
            public get ID(): string;
            public get value(): any;
            public set value(value: any);
            public get isExposedPublic(): boolean;
            public set isExposedPublic(value: boolean);
            public get isPropertyBound(): boolean;
            public get isDataBound(): boolean;
            public get varType(): System.Type;
            public get propertyPath(): string;
            public set propertyPath(value: string);
            public add_onNameChanged($value: System.Action$1<string>):void;
            public remove_onNameChanged($value: System.Action$1<string>):void;
            public add_onValueChanged($value: System.Action$1<any>):void;
            public remove_onValueChanged($value: System.Action$1<any>):void;
            public add_onDestroy($value: System.Action):void;
            public remove_onDestroy($value: System.Action):void;
            public BindProperty($prop: System.Reflection.MemberInfo, $target?: UnityEngine.GameObject):void;
            public UnBind():void;
            public InitializePropertyBinding($go: UnityEngine.GameObject, $callSetter?: boolean):void;
            public GetValueBoxed():any;
            public SetValueBoxed($value: any):void;
            public Duplicate($targetBB: NodeCanvas.Framework.IBlackboard):NodeCanvas.Framework.Variable;
            public CanConvertTo($toType: System.Type):boolean;
            public GetGetConverter($toType: System.Type):System.Func$1<any>;
            public CanConvertFrom($fromType: System.Type):boolean;
            public GetSetConverter($fromType: System.Type):System.Action$1<any>;
        }
        export interface IUpdatable extends NodeCanvas.Framework.IGraphElement{ 
            name: string;
            UID: string;
            graph: NodeCanvas.Framework.Graph;
            status: NodeCanvas.Framework.Status;
            Update():void;
        }
        export interface IGraphAssignable extends NodeCanvas.Framework.IGraphElement{ 
            subGraph: NodeCanvas.Framework.Graph;
            currentInstance: NodeCanvas.Framework.Graph;
            instances: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            subGraphParameter: NodeCanvas.Framework.BBParameter;
            variablesMap: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            name: string;
            UID: string;
            graph: NodeCanvas.Framework.Graph;
            status: NodeCanvas.Framework.Status;
        }
        interface IGraphAssignable {
            CheckInstance():NodeCanvas.Framework.Graph;
            TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):boolean;
            TryStopSubGraph():boolean;
            TryPauseSubGraph():boolean;
            TryResumeSubGraph():boolean;
            TryUpdateSubGraph():boolean;
            TryWriteMappedVariables():void;
            TryReadMappedVariables():void;
            ValidateSubGraphAndParameters():void;
            AutoLinkByName():void;
            ShowVariablesMappingGUI():void;
        }
        export class SignalDefinition extends UnityEngine.ScriptableObject{ 
            public get parameters(): System.Collections.Generic.List$1<ParadoxNotion.DynamicParameterDefinition>;
            public add_onInvoke($value: NodeCanvas.Framework.SignalDefinition.InvokeArguments):void;
            public remove_onInvoke($value: NodeCanvas.Framework.SignalDefinition.InvokeArguments):void;
            public Invoke($sender: UnityEngine.Transform, $receiver: UnityEngine.Transform, $isGlobal: boolean, ...args: any[]):void;
            public AddParameter($name: string, $type: System.Type):void;
            public RemoveParameter($name: string):void;
            public constructor();
        }
        export interface IReflectedWrapper{ 
            GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class GraphOwner$1<T> extends NodeCanvas.Framework.GraphOwner implements UnityEngine.ISerializationCallbackReceiver{ 
        }
        export class GraphOwner extends UnityEngine.MonoBehaviour implements UnityEngine.ISerializationCallbackReceiver{ 
            public get graph(): NodeCanvas.Framework.Graph;
            public set graph(value: NodeCanvas.Framework.Graph);
            public get blackboard(): NodeCanvas.Framework.IBlackboard;
            public set blackboard(value: NodeCanvas.Framework.IBlackboard);
            public get graphType(): System.Type;
            public get initialized(): boolean;
            public get enableCalled(): boolean;
            public get startCalled(): boolean;
            public get boundGraphSource(): NodeCanvas.Framework.Internal.GraphSource;
            public get boundGraphSerialization(): string;
            public get boundGraphObjectReferences(): System.Collections.Generic.List$1<UnityEngine.Object>;
            public get lockBoundGraphPrefabOverrides(): boolean;
            public set lockBoundGraphPrefabOverrides(value: boolean);
            public get preInitializeSubGraphs(): boolean;
            public set preInitializeSubGraphs(value: boolean);
            public get firstActivation(): NodeCanvas.Framework.GraphOwner.FirstActivation;
            public set firstActivation(value: NodeCanvas.Framework.GraphOwner.FirstActivation);
            public get enableAction(): NodeCanvas.Framework.GraphOwner.EnableAction;
            public set enableAction(value: NodeCanvas.Framework.GraphOwner.EnableAction);
            public get disableAction(): NodeCanvas.Framework.GraphOwner.DisableAction;
            public set disableAction(value: NodeCanvas.Framework.GraphOwner.DisableAction);
            public get updateMode(): NodeCanvas.Framework.Graph.UpdateMode;
            public set updateMode(value: NodeCanvas.Framework.Graph.UpdateMode);
            public get graphIsBound(): boolean;
            public get isRunning(): boolean;
            public get isPaused(): boolean;
            public get elapsedTime(): number;
            public static add_onOwnerBehaviourStateChange($value: System.Action$1<NodeCanvas.Framework.GraphOwner>):void;
            public static remove_onOwnerBehaviourStateChange($value: System.Action$1<NodeCanvas.Framework.GraphOwner>):void;
            public add_onMonoBehaviourStart($value: System.Action):void;
            public remove_onMonoBehaviourStart($value: System.Action):void;
            public StartBehaviour():void;
            public StartBehaviour($callback: System.Action$1<boolean>):void;
            public StartBehaviour($updateMode: NodeCanvas.Framework.Graph.UpdateMode, $callback?: System.Action$1<boolean>):void;
            public PauseBehaviour():void;
            public StopBehaviour($success?: boolean):void;
            public UpdateBehaviour():void;
            public RestartBehaviour():void;
            public SendEvent($eventName: string):void;
            public SendEvent($eventName: string, $value: any, $sender: any):void;
            public Initialize():void;
            public BindExposedParameters():void;
            public Validate():void;
            public SetBoundGraphReference($target: NodeCanvas.Framework.Graph):void;
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export interface IGraphAssignable$1<T> extends NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IGraphAssignable{ 
            name: string;
            UID: string;
            graph: NodeCanvas.Framework.Graph;
            status: NodeCanvas.Framework.Status;
            subGraph: NodeCanvas.Framework.Graph;
            currentInstance: NodeCanvas.Framework.Graph;
            instances: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            subGraphParameter: NodeCanvas.Framework.BBParameter;
            variablesMap: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            CheckInstance():null;
            TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            TryStopSubGraph():null;
            TryPauseSubGraph():null;
            TryResumeSubGraph():null;
            TryUpdateSubGraph():null;
            TryWriteMappedVariables():null;
            TryReadMappedVariables():null;
            ValidateSubGraphAndParameters():null;
            AutoLinkByName():null;
            ShowVariablesMappingGUI():null;
        }
        export interface ITaskAssignable extends NodeCanvas.Framework.IGraphElement{ 
            task: NodeCanvas.Framework.Task;
            name: string;
            UID: string;
            graph: NodeCanvas.Framework.Graph;
            status: NodeCanvas.Framework.Status;
        }
        export interface ITaskAssignable$1<T> extends NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.ITaskAssignable{ 
            name: string;
            UID: string;
            graph: NodeCanvas.Framework.Graph;
            status: NodeCanvas.Framework.Status;
            task: NodeCanvas.Framework.Task;
        }
        export interface IHaveNodeReference extends NodeCanvas.Framework.IGraphElement{ 
            targetReference: NodeCanvas.Framework.INodeReference;
            name: string;
            UID: string;
            graph: NodeCanvas.Framework.Graph;
            status: NodeCanvas.Framework.Status;
        }
        export class NodeReference$1<T> extends System.Object implements NodeCanvas.Framework.INodeReference{ 
            public get type(): System.Type;
            public Get($graph: NodeCanvas.Framework.Graph):NodeCanvas.Framework.Node;
            public Set($target: NodeCanvas.Framework.Node):void;
        }
        export interface INodeReference{ 
            type: System.Type;
            Get($graph: NodeCanvas.Framework.Graph):NodeCanvas.Framework.Node;
            Set($target: NodeCanvas.Framework.Node):void;
        }
        export interface IInvokable extends NodeCanvas.Framework.IGraphElement{ 
            name: string;
            UID: string;
            graph: NodeCanvas.Framework.Graph;
            status: NodeCanvas.Framework.Status;
            GetInvocationID():string;
            Invoke(...args: any[]):any;
            InvokeAsync($callback: System.Action$1<any>, ...args: any[]):void;
        }
        export class ActionList extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public executionMode: NodeCanvas.Framework.ActionList.ActionsExecutionMode;
            public actions: System.Collections.Generic.List$1<NodeCanvas.Framework.ActionTask>;
            public AddAction($action: NodeCanvas.Framework.ActionTask):void;
            public ShowListGUI():void;
            public ShowNestedActionsGUI():void;
            public constructor();
        }
        export enum Status{ Failure = 0, Success = 1, Running = 2, Resting = 3, Error = 4, Optional = 5 }
        export class ActionTask$1<T> extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
        }
        export class ConditionTask$1<T> extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
        }
        export class Blackboard extends Sirenix.OdinInspector.SerializedMonoBehaviour implements NodeCanvas.Framework.IBlackboard, Sirenix.Serialization.ISupportsPrefabSerialization, UnityEngine.ISerializationCallbackReceiver{ 
            public get tempName(): string;
            public set tempName(value: string);
            public get identifier(): string;
            public get parent(): NodeCanvas.Framework.IBlackboard;
            public get variables(): System.Collections.Generic.Dictionary$2<string, NodeCanvas.Framework.Variable>;
            public set variables(value: System.Collections.Generic.Dictionary$2<string, NodeCanvas.Framework.Variable>);
            public get propertiesBindTarget(): UnityEngine.Component;
            public get unityContextObject(): UnityEngine.Object;
            public get independantVariablesFieldName(): string;
            public SelfSerialize():void;
            public SelfDeserialize():void;
            public Serialize($references: System.Collections.Generic.List$1<UnityEngine.Object>, $pretyJson?: boolean):string;
            public Deserialize($json: string, $references: System.Collections.Generic.List$1<UnityEngine.Object>, $removeMissingVariables?: boolean):boolean;
            public add_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public add_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public AddVariable($name: string, $type: System.Type):NodeCanvas.Framework.Variable;
            public AddVariable($name: string, $value: any):NodeCanvas.Framework.Variable;
            public RemoveVariable($name: string):NodeCanvas.Framework.Variable;
            public GetVariable($name: string, $ofType?: System.Type):NodeCanvas.Framework.Variable;
            public GetVariableByID($ID: string):NodeCanvas.Framework.Variable;
            public SetVariableValue($name: string, $value: any):NodeCanvas.Framework.Variable;
            public Save():string;
            public Save($saveKey: string):string;
            public Load():boolean;
            public Load($saveKey: string):boolean;
            public constructor();
            public add_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public add_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public TryInvokeOnVariableAdded($variable: NodeCanvas.Framework.Variable):void;
            public TryInvokeOnVariableRemoved($variable: NodeCanvas.Framework.Variable):void;
            public GetRoot():null;
            public GetAllParents($includeSelf: boolean):null;
            public IsPartOf($child: NodeCanvas.Framework.IBlackboard):null;
            public AddVariable($varName: string, $value: any):null;
            public AddVariable($varName: string, $type: System.Type):null;
            public RemoveVariable($varName: string):null;
            public SetVariableValue($varName: string, $value: any):null;
            public InitializePropertiesBinding($target: UnityEngine.Component, $callSetter: boolean):null;
            public GetVariable($varName: string, $ofType?: System.Type):null;
            public GetVariableByID($ID: string):null;
            public GetVariables($ofType?: System.Type):null;
            public ChangeVariableType($target: NodeCanvas.Framework.Variable, $newType: System.Type):null;
            public OverwriteFrom($sourceBlackboard: NodeCanvas.Framework.IBlackboard, $removeMissingVariables?: boolean):null;
        }
        export interface ISubParametersContainer{ 
            GetSubParameters():System.Array$1<NodeCanvas.Framework.BBParameter>;
        }
        export class ConditionList extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public checkMode: NodeCanvas.Framework.ConditionList.ConditionsCheckMode;
            public conditions: System.Collections.Generic.List$1<NodeCanvas.Framework.ConditionTask>;
            public AddCondition($condition: NodeCanvas.Framework.ConditionTask):void;
            public ShowListGUI():void;
            public ShowNestedConditionsGUI():void;
            public constructor();
        }
        export class GraphInfoAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public packageName: string;
            public docsURL: string;
            public resourcesURL: string;
            public forumsURL: string;
            public constructor();
        }
        export class DropReferenceType extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public type: System.Type;
            public constructor($type: System.Type);
            public constructor();
        }
        export class BlackboardOnlyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class LogTag extends System.Object{ 
            public static EDITOR: string;
            public static EVENT: string;
            public static EXECUTION: string;
            public static VARIABLE: string;
            public static BLACKBOARD: string;
            public static GRAPH: string;
            public static INIT: string;
            public static VALIDATION: string;
            public static SERIALIZATION: string;
        }
        export class CanvasGroup extends System.Object{ 
            public name: string;
            public rect: UnityEngine.Rect;
            public color: UnityEngine.Color;
            public autoGroup: boolean;
            public editState: NodeCanvas.Framework.CanvasGroup.EditState;
            public GatherContainedNodes($graph: NodeCanvas.Framework.Graph):System.Array$1<NodeCanvas.Framework.Node>;
            public AdjustToContainedNodes():UnityEngine.Rect;
            public FlushContainedNodes():void;
            public GatherAjustAndFlushContainedNodes($graph: NodeCanvas.Framework.Graph):void;
            public constructor();
            public constructor($rect: UnityEngine.Rect, $name: string);
        }
        export class NodeUtils extends System.Object{ 
        }
        export class EdtDummy extends Sirenix.OdinInspector.SerializedScriptableObject implements UnityEngine.ISerializationCallbackReceiver{ 
        }
        export class ExposedParameter extends System.Object{ 
            public get targetVariableID(): string;
            public get type(): System.Type;
            public get valueBoxed(): any;
            public set valueBoxed(value: any);
            public get varRefBoxed(): NodeCanvas.Framework.Variable;
            public Bind($blackboard: NodeCanvas.Framework.IBlackboard):void;
            public UnBind($blackboard: NodeCanvas.Framework.IBlackboard):void;
            public static CreateInstance($target: NodeCanvas.Framework.Variable):NodeCanvas.Framework.ExposedParameter;
        }
        export class IGraphAssignableExtensions extends System.Object{ 
            public static CheckInstance($assignable: NodeCanvas.Framework.IGraphAssignable):NodeCanvas.Framework.Graph;
            public static TryStartSubGraph($assignable: NodeCanvas.Framework.IGraphAssignable, $agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):boolean;
            public static TryStopSubGraph($assignable: NodeCanvas.Framework.IGraphAssignable):boolean;
            public static TryPauseSubGraph($assignable: NodeCanvas.Framework.IGraphAssignable):boolean;
            public static TryResumeSubGraph($assignable: NodeCanvas.Framework.IGraphAssignable):boolean;
            public static TryUpdateSubGraph($assignable: NodeCanvas.Framework.IGraphAssignable):boolean;
            public static TryWriteMappedVariables($assignable: NodeCanvas.Framework.IGraphAssignable):void;
            public static TryReadMappedVariables($assignable: NodeCanvas.Framework.IGraphAssignable):void;
            public static ValidateSubGraphAndParameters($assignable: NodeCanvas.Framework.IGraphAssignable):void;
            public static AutoLinkByName($assignable: NodeCanvas.Framework.IGraphAssignable):void;
            public static ShowVariablesMappingGUI($assignable: NodeCanvas.Framework.IGraphAssignable):void;
        }
        export interface ISubTasksContainer{ 
            GetSubTasks():System.Array$1<NodeCanvas.Framework.Task>;
        }
        export class EventReceiverAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public eventMessages: System.Array$1<string>;
            public constructor(...args: string[]);
            public constructor();
        }
        export class AssetBlackboard extends UnityEngine.ScriptableObject implements NodeCanvas.Framework.IBlackboard, NodeCanvas.Framework.IGlobalBlackboard, UnityEngine.ISerializationCallbackReceiver{ 
            public get tempName(): string;
            public set tempName(value: string);
            public get identifier(): string;
            public get UID(): string;
            public get parent(): NodeCanvas.Framework.IBlackboard;
            public get variables(): System.Collections.Generic.Dictionary$2<string, NodeCanvas.Framework.Variable>;
            public set variables(value: System.Collections.Generic.Dictionary$2<string, NodeCanvas.Framework.Variable>);
            public get propertiesBindTarget(): UnityEngine.Component;
            public get unityContextObject(): UnityEngine.Object;
            public get independantVariablesFieldName(): string;
            public add_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public add_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public constructor();
            public add_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public add_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public TryInvokeOnVariableAdded($variable: NodeCanvas.Framework.Variable):void;
            public TryInvokeOnVariableRemoved($variable: NodeCanvas.Framework.Variable):void;
            public GetRoot():null;
            public GetAllParents($includeSelf: boolean):null;
            public IsPartOf($child: NodeCanvas.Framework.IBlackboard):null;
            public AddVariable($varName: string, $value: any):null;
            public AddVariable($varName: string, $type: System.Type):null;
            public RemoveVariable($varName: string):null;
            public SetVariableValue($varName: string, $value: any):null;
            public InitializePropertiesBinding($target: UnityEngine.Component, $callSetter: boolean):null;
            public GetVariable($varName: string, $ofType?: System.Type):null;
            public GetVariableByID($ID: string):null;
            public GetVariables($ofType?: System.Type):null;
            public ChangeVariableType($target: NodeCanvas.Framework.Variable, $newType: System.Type):null;
            public OverwriteFrom($sourceBlackboard: NodeCanvas.Framework.IBlackboard, $removeMissingVariables?: boolean):null;
            public add_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public add_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public TryInvokeOnVariableAdded($variable: NodeCanvas.Framework.Variable):void;
            public TryInvokeOnVariableRemoved($variable: NodeCanvas.Framework.Variable):void;
            public GetAllParents($includeSelf: boolean):null;
            public IsPartOf($child: NodeCanvas.Framework.IBlackboard):null;
            public AddVariable($varName: string, $value: any):null;
            public AddVariable($varName: string, $type: System.Type):null;
            public RemoveVariable($varName: string):null;
            public SetVariableValue($varName: string, $value: any):null;
            public InitializePropertiesBinding($target: UnityEngine.Component, $callSetter: boolean):null;
            public GetVariable($varName: string, $ofType?: System.Type):null;
            public GetVariableByID($ID: string):null;
            public GetVariables($ofType?: System.Type):null;
            public ChangeVariableType($target: NodeCanvas.Framework.Variable, $newType: System.Type):null;
            public OverwriteFrom($sourceBlackboard: NodeCanvas.Framework.IBlackboard, $removeMissingVariables?: boolean):null;
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export interface IGlobalBlackboard extends NodeCanvas.Framework.IBlackboard{ 
            UID: string;
            tempName: string;
            identifier: string;
            parent: NodeCanvas.Framework.IBlackboard;
            variables: System.Collections.Generic.Dictionary$2<string, NodeCanvas.Framework.Variable>;
            propertiesBindTarget: UnityEngine.Component;
            unityContextObject: UnityEngine.Object;
            independantVariablesFieldName: string;
            add_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            remove_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            add_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            remove_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            TryInvokeOnVariableAdded($variable: NodeCanvas.Framework.Variable):void;
            TryInvokeOnVariableRemoved($variable: NodeCanvas.Framework.Variable):void;
            GetRoot():null;
            GetAllParents($includeSelf: boolean):null;
            IsPartOf($child: NodeCanvas.Framework.IBlackboard):null;
            AddVariable($varName: string, $value: any):null;
            AddVariable($varName: string, $type: System.Type):null;
            RemoveVariable($varName: string):null;
            SetVariableValue($varName: string, $value: any):null;
            InitializePropertiesBinding($target: UnityEngine.Component, $callSetter: boolean):null;
            GetVariable($varName: string, $ofType?: System.Type):null;
            GetVariableByID($ID: string):null;
            GetVariables($ofType?: System.Type):null;
            ChangeVariableType($target: NodeCanvas.Framework.Variable, $newType: System.Type):null;
            OverwriteFrom($sourceBlackboard: NodeCanvas.Framework.IBlackboard, $removeMissingVariables?: boolean):null;
        }
        export class AssetRefs extends Sirenix.OdinInspector.SerializedMonoBehaviour implements Sirenix.Serialization.ISupportsPrefabSerialization, UnityEngine.ISerializationCallbackReceiver{ 
            public get main(): UnityEngine.AddressableAssets.AssetReference;
            public get all(): System.Collections.Generic.List$1<UnityEngine.AddressableAssets.AssetReference>;
            public constructor();
        }
        export class Variable$1<T> extends NodeCanvas.Framework.Variable{ 
        }
        export class GlobalBlackboard extends NodeCanvas.Framework.Blackboard implements NodeCanvas.Framework.IBlackboard, NodeCanvas.Framework.IGlobalBlackboard, Sirenix.Serialization.ISupportsPrefabSerialization, UnityEngine.ISerializationCallbackReceiver{ 
            public get identifier(): string;
            public get UID(): string;
            public get name(): string;
            public static GetAll():System.Collections.Generic.IEnumerable$1<NodeCanvas.Framework.GlobalBlackboard>;
            public static Create():NodeCanvas.Framework.GlobalBlackboard;
            public static Find($name: string):NodeCanvas.Framework.GlobalBlackboard;
            public constructor();
            public add_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public add_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public TryInvokeOnVariableAdded($variable: NodeCanvas.Framework.Variable):void;
            public TryInvokeOnVariableRemoved($variable: NodeCanvas.Framework.Variable):void;
            public GetAllParents($includeSelf: boolean):null;
            public IsPartOf($child: NodeCanvas.Framework.IBlackboard):null;
            public AddVariable($varName: string, $value: any):null;
            public AddVariable($varName: string, $type: System.Type):null;
            public RemoveVariable($varName: string):null;
            public SetVariableValue($varName: string, $value: any):null;
            public InitializePropertiesBinding($target: UnityEngine.Component, $callSetter: boolean):null;
            public GetVariable($varName: string, $ofType?: System.Type):null;
            public GetVariableByID($ID: string):null;
            public GetVariables($ofType?: System.Type):null;
            public ChangeVariableType($target: NodeCanvas.Framework.Variable, $newType: System.Type):null;
            public OverwriteFrom($sourceBlackboard: NodeCanvas.Framework.IBlackboard, $removeMissingVariables?: boolean):null;
            public add_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public add_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public TryInvokeOnVariableAdded($variable: NodeCanvas.Framework.Variable):void;
            public TryInvokeOnVariableRemoved($variable: NodeCanvas.Framework.Variable):void;
            public GetAllParents($includeSelf: boolean):null;
            public IsPartOf($child: NodeCanvas.Framework.IBlackboard):null;
            public AddVariable($varName: string, $value: any):null;
            public AddVariable($varName: string, $type: System.Type):null;
            public RemoveVariable($varName: string):null;
            public SetVariableValue($varName: string, $value: any):null;
            public InitializePropertiesBinding($target: UnityEngine.Component, $callSetter: boolean):null;
            public GetVariable($varName: string, $ofType?: System.Type):null;
            public GetVariableByID($ID: string):null;
            public GetVariables($ofType?: System.Type):null;
            public ChangeVariableType($target: NodeCanvas.Framework.Variable, $newType: System.Type):null;
            public OverwriteFrom($sourceBlackboard: NodeCanvas.Framework.IBlackboard, $removeMissingVariables?: boolean):null;
            public add_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public add_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public TryInvokeOnVariableAdded($variable: NodeCanvas.Framework.Variable):void;
            public TryInvokeOnVariableRemoved($variable: NodeCanvas.Framework.Variable):void;
            public GetAllParents($includeSelf: boolean):null;
            public IsPartOf($child: NodeCanvas.Framework.IBlackboard):null;
            public AddVariable($varName: string, $value: any):null;
            public AddVariable($varName: string, $type: System.Type):null;
            public RemoveVariable($varName: string):null;
            public SetVariableValue($varName: string, $value: any):null;
            public InitializePropertiesBinding($target: UnityEngine.Component, $callSetter: boolean):null;
            public GetVariable($varName: string, $ofType?: System.Type):null;
            public GetVariableByID($ID: string):null;
            public GetVariables($ofType?: System.Type):null;
            public ChangeVariableType($target: NodeCanvas.Framework.Variable, $newType: System.Type):null;
            public OverwriteFrom($sourceBlackboard: NodeCanvas.Framework.IBlackboard, $removeMissingVariables?: boolean):null;
            public add_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public add_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public add_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public add_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public AddVariable($name: string, $type: System.Type):NodeCanvas.Framework.Variable;
            public AddVariable($name: string, $value: any):NodeCanvas.Framework.Variable;
            public AddVariable($varName: string, $value: any):null;
            public AddVariable($varName: string, $type: System.Type):null;
            public RemoveVariable($name: string):NodeCanvas.Framework.Variable;
            public RemoveVariable($varName: string):null;
            public GetVariable($name: string, $ofType?: System.Type):NodeCanvas.Framework.Variable;
            public GetVariable($varName: string, $ofType?: System.Type):null;
            public GetVariableByID($ID: string):NodeCanvas.Framework.Variable;
            public GetVariableByID($ID: string):null;
            public SetVariableValue($name: string, $value: any):NodeCanvas.Framework.Variable;
            public SetVariableValue($varName: string, $value: any):null;
            public TryInvokeOnVariableAdded($variable: NodeCanvas.Framework.Variable):void;
            public TryInvokeOnVariableRemoved($variable: NodeCanvas.Framework.Variable):void;
            public GetAllParents($includeSelf: boolean):null;
            public IsPartOf($child: NodeCanvas.Framework.IBlackboard):null;
            public InitializePropertiesBinding($target: UnityEngine.Component, $callSetter: boolean):null;
            public GetVariables($ofType?: System.Type):null;
            public ChangeVariableType($target: NodeCanvas.Framework.Variable, $newType: System.Type):null;
            public OverwriteFrom($sourceBlackboard: NodeCanvas.Framework.IBlackboard, $removeMissingVariables?: boolean):null;
        }
        export class IBlackboardExtensions extends System.Object{ 
            public static GetRoot($blackboard: NodeCanvas.Framework.IBlackboard):NodeCanvas.Framework.IBlackboard;
            public static GetAllParents($blackboard: NodeCanvas.Framework.IBlackboard, $includeSelf: boolean):System.Collections.Generic.IEnumerable$1<NodeCanvas.Framework.IBlackboard>;
            public static IsPartOf($blackboard: NodeCanvas.Framework.IBlackboard, $child: NodeCanvas.Framework.IBlackboard):boolean;
            public static AddVariable($blackboard: NodeCanvas.Framework.IBlackboard, $varName: string, $value: any):NodeCanvas.Framework.Variable;
            public static AddVariable($blackboard: NodeCanvas.Framework.IBlackboard, $varName: string, $type: System.Type):NodeCanvas.Framework.Variable;
            public static RemoveVariable($blackboard: NodeCanvas.Framework.IBlackboard, $varName: string):NodeCanvas.Framework.Variable;
            public static SetVariableValue($blackboard: NodeCanvas.Framework.IBlackboard, $varName: string, $value: any):NodeCanvas.Framework.Variable;
            public static InitializePropertiesBinding($blackboard: NodeCanvas.Framework.IBlackboard, $target: UnityEngine.Component, $callSetter: boolean):void;
            public static GetVariable($blackboard: NodeCanvas.Framework.IBlackboard, $varName: string, $ofType?: System.Type):NodeCanvas.Framework.Variable;
            public static GetVariableByID($blackboard: NodeCanvas.Framework.IBlackboard, $ID: string):NodeCanvas.Framework.Variable;
            public static GetVariables($blackboard: NodeCanvas.Framework.IBlackboard, $ofType?: System.Type):System.Collections.Generic.IEnumerable$1<NodeCanvas.Framework.Variable>;
            public static ChangeVariableType($blackboard: NodeCanvas.Framework.IBlackboard, $target: NodeCanvas.Framework.Variable, $newType: System.Type):NodeCanvas.Framework.Variable;
            public static OverwriteFrom($blackboard: NodeCanvas.Framework.IBlackboard, $sourceBlackboard: NodeCanvas.Framework.IBlackboard, $removeMissingVariables?: boolean):void;
        }
        export class VariableSeperator extends System.Object{ 
            public get isEditingName(): boolean;
            public set isEditingName(value: boolean);
            public constructor();
        }
    }
    export namespace ParadoxNotion.Serialization.FullSerializer {
        export interface ISerializationCollectable{ 
        }
        export interface IMigratable{ 
        }
        export interface IMigratable$1<T> extends ParadoxNotion.Serialization.FullSerializer.IMigratable{ 
        }
        export interface ISerializationCollector extends ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable{ 
            OnPush($parent: ParadoxNotion.Serialization.FullSerializer.ISerializationCollector):void;
            OnCollect($child: ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, $depth: number):void;
            OnPop($parent: ParadoxNotion.Serialization.FullSerializer.ISerializationCollector):void;
        }
        export class fsObjectProcessor extends System.Object{ 
            public CanProcess($type: System.Type):boolean;
            public OnBeforeSerialize($storageType: System.Type, $instance: any):void;
            public OnAfterSerialize($storageType: System.Type, $instance: any, $data: $Ref<ParadoxNotion.Serialization.FullSerializer.fsData>):void;
            public OnBeforeDeserialize($storageType: System.Type, $data: $Ref<ParadoxNotion.Serialization.FullSerializer.fsData>):void;
            public OnBeforeDeserializeAfterInstanceCreation($storageType: System.Type, $instance: any, $data: $Ref<ParadoxNotion.Serialization.FullSerializer.fsData>):void;
            public OnAfterDeserialize($storageType: System.Type, $instance: any):void;
        }
        export class fsData extends System.Object{ 
            public static True: ParadoxNotion.Serialization.FullSerializer.fsData;
            public static False: ParadoxNotion.Serialization.FullSerializer.fsData;
            public static Null: ParadoxNotion.Serialization.FullSerializer.fsData;
            public get Type(): ParadoxNotion.Serialization.FullSerializer.fsDataType;
            public get IsNull(): boolean;
            public get IsDouble(): boolean;
            public get IsInt64(): boolean;
            public get IsBool(): boolean;
            public get IsString(): boolean;
            public get IsDictionary(): boolean;
            public get IsList(): boolean;
            public get AsDouble(): number;
            public get AsInt64(): bigint;
            public get AsBool(): boolean;
            public get AsString(): string;
            public get AsDictionary(): System.Collections.Generic.Dictionary$2<string, ParadoxNotion.Serialization.FullSerializer.fsData>;
            public get AsList(): System.Collections.Generic.List$1<ParadoxNotion.Serialization.FullSerializer.fsData>;
            public static CreateDictionary():ParadoxNotion.Serialization.FullSerializer.fsData;
            public static CreateList():ParadoxNotion.Serialization.FullSerializer.fsData;
            public static CreateList($capacity: number):ParadoxNotion.Serialization.FullSerializer.fsData;
            public Equals($obj: any):boolean;
            public Equals($other: ParadoxNotion.Serialization.FullSerializer.fsData):boolean;
            public static op_Equality($a: ParadoxNotion.Serialization.FullSerializer.fsData, $b: ParadoxNotion.Serialization.FullSerializer.fsData):boolean;
            public static op_Inequality($a: ParadoxNotion.Serialization.FullSerializer.fsData, $b: ParadoxNotion.Serialization.FullSerializer.fsData):boolean;
            public constructor();
            public constructor($boolean: boolean);
            public constructor($f: number);
            public constructor($i: bigint);
            public constructor($str: string);
            public constructor($dict: System.Collections.Generic.Dictionary$2<string, ParadoxNotion.Serialization.FullSerializer.fsData>);
            public constructor($list: System.Collections.Generic.List$1<ParadoxNotion.Serialization.FullSerializer.fsData>);
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
        }
        export class fsConverter extends ParadoxNotion.Serialization.FullSerializer.fsBaseConverter{ 
            public CanProcess($type: System.Type):boolean;
        }
        export class fsBaseConverter extends System.Object{ 
            public Serializer: ParadoxNotion.Serialization.FullSerializer.fsSerializer;
            public CreateInstance($data: ParadoxNotion.Serialization.FullSerializer.fsData, $storageType: System.Type):any;
            public RequestCycleSupport($storageType: System.Type):boolean;
            public RequestInheritanceSupport($storageType: System.Type):boolean;
            public TrySerialize($instance: any, $serialized: $Ref<ParadoxNotion.Serialization.FullSerializer.fsData>, $storageType: System.Type):ParadoxNotion.Serialization.FullSerializer.fsResult;
            public TryDeserialize($data: ParadoxNotion.Serialization.FullSerializer.fsData, $instance: $Ref<any>, $storageType: System.Type):ParadoxNotion.Serialization.FullSerializer.fsResult;
        }
        export class fsResult extends System.ValueType{ 
            public static Success: ParadoxNotion.Serialization.FullSerializer.fsResult;
            public get Failed(): boolean;
            public get Succeeded(): boolean;
            public get HasWarnings(): boolean;
            public get AsException(): System.Exception;
            public get RawMessages(): System.Collections.Generic.IEnumerable$1<string>;
            public get FormattedMessages(): string;
            public static Warn($warning: string):ParadoxNotion.Serialization.FullSerializer.fsResult;
            public static Fail($warning: string):ParadoxNotion.Serialization.FullSerializer.fsResult;
            public AddMessage($message: string):void;
            public AddMessages($result: ParadoxNotion.Serialization.FullSerializer.fsResult):void;
            public static op_Addition($a: ParadoxNotion.Serialization.FullSerializer.fsResult, $b: ParadoxNotion.Serialization.FullSerializer.fsResult):ParadoxNotion.Serialization.FullSerializer.fsResult;
            public AssertSuccess():ParadoxNotion.Serialization.FullSerializer.fsResult;
            public AssertSuccessWithoutWarnings():ParadoxNotion.Serialization.FullSerializer.fsResult;
        }
        export class fsForwardAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public MemberName: string;
            public constructor($memberName: string);
            public constructor();
        }
        export class fsWriteOnlyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class fsReadOnlyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class fsIgnoreAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class fsIgnoreInBuildAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class fsSerializeAsAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public Name: string;
            public constructor();
            public constructor($name: string);
        }
        export class fsMigrateToAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public targetType: System.Type;
            public constructor($targetType: System.Type);
            public constructor();
        }
        export class fsMigrateVersionsAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public previousTypes: System.Array$1<System.Type>;
            public constructor(...previousTypes: System.Type[]);
            public constructor();
        }
        export class fsSerializeAsReference extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class fsDeserializeOverwrite extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class fsUninitialized extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class fsAutoInstance extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public makeInstance: boolean;
            public constructor($makeInstance?: boolean);
            public constructor();
        }
        export class fsObjectAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public Converter: System.Type;
            public Processor: System.Type;
            public constructor();
        }
        export class fsSerializer extends System.Object{ 
            public static KEY_OBJECT_REFERENCE: string;
            public static KEY_OBJECT_DEFINITION: string;
            public static KEY_INSTANCE_TYPE: string;
            public static KEY_VERSION: string;
            public static KEY_CONTENT: string;
            public get ReferencesDatabase(): System.Collections.Generic.List$1<UnityEngine.Object>;
            public set ReferencesDatabase(value: System.Collections.Generic.List$1<UnityEngine.Object>);
            public get IgnoreSerializeCycleReferences(): boolean;
            public set IgnoreSerializeCycleReferences(value: boolean);
            public static IsReservedKeyword($key: string):boolean;
            public static RemoveMetaData($data: $Ref<ParadoxNotion.Serialization.FullSerializer.fsData>):void;
            public add_onBeforeObjectSerialized($value: System.Action$1<any>):void;
            public remove_onBeforeObjectSerialized($value: System.Action$1<any>):void;
            public add_onAfterObjectSerialized($value: System.Action$2<any, ParadoxNotion.Serialization.FullSerializer.fsData>):void;
            public remove_onAfterObjectSerialized($value: System.Action$2<any, ParadoxNotion.Serialization.FullSerializer.fsData>):void;
            public PurgeTemporaryData():void;
            public AddConverter($converter: ParadoxNotion.Serialization.FullSerializer.fsBaseConverter):void;
            public TrySerialize($storageType: System.Type, $instance: any, $data: $Ref<ParadoxNotion.Serialization.FullSerializer.fsData>):ParadoxNotion.Serialization.FullSerializer.fsResult;
            public TrySerialize($storageType: System.Type, $instance: any, $data: $Ref<ParadoxNotion.Serialization.FullSerializer.fsData>, $overrideConverterType: System.Type):ParadoxNotion.Serialization.FullSerializer.fsResult;
            public TryDeserialize($data: ParadoxNotion.Serialization.FullSerializer.fsData, $storageType: System.Type, $result: $Ref<any>):ParadoxNotion.Serialization.FullSerializer.fsResult;
            public TryDeserialize($data: ParadoxNotion.Serialization.FullSerializer.fsData, $storageType: System.Type, $result: $Ref<any>, $overrideConverterType: System.Type):ParadoxNotion.Serialization.FullSerializer.fsResult;
            public constructor();
        }
        export class fsCyclicReferenceManager extends System.Object{ 
            public Clear():void;
            public Enter():boolean;
            public Exit():boolean;
            public GetReferenceObject($id: number):any;
            public AddReferenceWithId($id: number, $reference: any):void;
            public GetReferenceId($item: any):number;
            public IsReference($item: any):boolean;
            public MarkSerialized($item: any):void;
            public constructor();
        }
        export enum fsDataType{ Array = 0, Object = 1, Double = 2, Int64 = 3, Boolean = 4, String = 5, Null = 6 }
        export class fsDirectConverter extends ParadoxNotion.Serialization.FullSerializer.fsBaseConverter{ 
            public get ModelType(): System.Type;
        }
        export class fsGlobalConfig extends System.Object{ 
            public static SerializeDefaultValues: boolean;
            public static IsCaseSensitive: boolean;
            public static IgnoreSerializeAttributes: System.Array$1<System.Type>;
            public static SerializeAttributes: System.Array$1<System.Type>;
            public static CustomDateTimeFormatString: string;
            public static Serialize64BitIntegerAsString: boolean;
            public static SerializeEnumsAsInteger: boolean;
        }
        export class fsJsonParser extends System.Object{ 
            public static Parse($input: string, $data: $Ref<ParadoxNotion.Serialization.FullSerializer.fsData>):ParadoxNotion.Serialization.FullSerializer.fsResult;
            public static Parse($input: string):ParadoxNotion.Serialization.FullSerializer.fsData;
        }
        export class fsJsonPrinter extends System.Object{ 
            public static ToJson($data: ParadoxNotion.Serialization.FullSerializer.fsData, $pretty: boolean):string;
            public static PrettyJson($data: ParadoxNotion.Serialization.FullSerializer.fsData, $outputStream: System.IO.TextWriter):void;
            public static PrettyJson($data: ParadoxNotion.Serialization.FullSerializer.fsData):string;
            public static CompressedJson($data: ParadoxNotion.Serialization.FullSerializer.fsData, $outputStream: System.IO.StreamWriter):void;
            public static CompressedJson($data: ParadoxNotion.Serialization.FullSerializer.fsData):string;
        }
        export class fsMetaProperty extends System.Object{ 
            public get Field(): System.Reflection.FieldInfo;
            public get JsonName(): string;
            public get StorageType(): System.Type;
            public get MemberName(): string;
            public get ReadOnly(): boolean;
            public get WriteOnly(): boolean;
            public get AutoInstance(): boolean;
            public get AsReference(): boolean;
            public Read($context: any):any;
            public Write($context: any, $value: any):void;
        }
        export class fsMetaType extends System.Object{ 
            public get reflectedType(): System.Type;
            public get Properties(): System.Array$1<ParadoxNotion.Serialization.FullSerializer.fsMetaProperty>;
            public get DeserializeOverwriteRequest(): boolean;
            public static Get($type: System.Type):ParadoxNotion.Serialization.FullSerializer.fsMetaType;
            public static FlushMem():void;
            public static CanSerializeField($field: System.Reflection.FieldInfo):boolean;
            public GetDefaultInstance():any;
            public CreateInstance():any;
        }
        export class fsDirectConverter$1<TModel> extends ParadoxNotion.Serialization.FullSerializer.fsDirectConverter{ 
        }
    }
    export namespace NodeCanvas.Framework.Internal {
        export class BBObjectParameter extends NodeCanvas.Framework.BBParameter$1<any> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public get varType(): System.Type;
            public SetType($t: System.Type):void;
            public constructor();
            public constructor($t: System.Type);
            public constructor($source: NodeCanvas.Framework.BBParameter);
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class GraphLoadData extends System.ValueType{ 
            public source: NodeCanvas.Framework.Internal.GraphSource;
            public json: string;
            public references: System.Collections.Generic.List$1<UnityEngine.Object>;
            public agent: UnityEngine.Component;
            public parentBlackboard: NodeCanvas.Framework.IBlackboard;
            public preInitializeSubGraphs: boolean;
        }
        export class GraphSource extends System.Object implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollector, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable{ 
            public static FRAMEWORK_VERSION: number;
            public get allTasks(): System.Collections.Generic.List$1<NodeCanvas.Framework.Task>;
            public get allParameters(): System.Collections.Generic.List$1<NodeCanvas.Framework.BBParameter>;
            public get version(): number;
            public set version(value: number);
            public get category(): string;
            public set category(value: string);
            public get comments(): string;
            public set comments(value: string);
            public get translation(): UnityEngine.Vector2;
            public set translation(value: UnityEngine.Vector2);
            public get zoomFactor(): number;
            public set zoomFactor(value: number);
            public get type(): string;
            public set type(value: string);
            public get nodes(): System.Collections.Generic.List$1<NodeCanvas.Framework.Node>;
            public set nodes(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Node>);
            public get connections(): System.Collections.Generic.List$1<NodeCanvas.Framework.Connection>;
            public get canvasGroups(): System.Collections.Generic.List$1<NodeCanvas.Framework.CanvasGroup>;
            public set canvasGroups(value: System.Collections.Generic.List$1<NodeCanvas.Framework.CanvasGroup>);
            public get localBlackboard(): NodeCanvas.Framework.Internal.BlackboardSource;
            public set localBlackboard(value: NodeCanvas.Framework.Internal.BlackboardSource);
            public get derivedData(): any;
            public set derivedData(value: any);
            public Pack($graph: NodeCanvas.Framework.Graph):NodeCanvas.Framework.Internal.GraphSource;
            public Unpack($graph: NodeCanvas.Framework.Graph):NodeCanvas.Framework.Internal.GraphSource;
            public SetMetaData($source: NodeCanvas.Framework.Internal.GraphSource):NodeCanvas.Framework.Internal.GraphSource;
            public PurgeRedundantReferences():void;
            public constructor();
            public OnPush($parent: ParadoxNotion.Serialization.FullSerializer.ISerializationCollector):void;
            public OnCollect($child: ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, $depth: number):void;
            public OnPop($parent: ParadoxNotion.Serialization.FullSerializer.ISerializationCollector):void;
        }
        export class BBMappingParameter extends NodeCanvas.Framework.Internal.BBObjectParameter implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public get targetSubGraphVariableID(): string;
            public get canRead(): boolean;
            public set canRead(value: boolean);
            public get canWrite(): boolean;
            public set canWrite(value: boolean);
            public constructor();
            public constructor($subVariable: NodeCanvas.Framework.Variable);
            public constructor($t: System.Type);
            public constructor($source: NodeCanvas.Framework.BBParameter);
        }
        export class BlackboardSource extends System.Object implements NodeCanvas.Framework.IBlackboard{ 
            public get tempName(): string;
            public set tempName(value: string);
            public get identifier(): string;
            public get variables(): System.Collections.Generic.Dictionary$2<string, NodeCanvas.Framework.Variable>;
            public set variables(value: System.Collections.Generic.Dictionary$2<string, NodeCanvas.Framework.Variable>);
            public get parent(): NodeCanvas.Framework.IBlackboard;
            public set parent(value: NodeCanvas.Framework.IBlackboard);
            public get unityContextObject(): UnityEngine.Object;
            public set unityContextObject(value: UnityEngine.Object);
            public get propertiesBindTarget(): UnityEngine.Component;
            public set propertiesBindTarget(value: UnityEngine.Component);
            public get independantVariablesFieldName(): string;
            public add_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public add_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public constructor();
            public add_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableAdded($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public add_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public remove_onVariableRemoved($value: System.Action$1<NodeCanvas.Framework.Variable>):void;
            public TryInvokeOnVariableAdded($variable: NodeCanvas.Framework.Variable):void;
            public TryInvokeOnVariableRemoved($variable: NodeCanvas.Framework.Variable):void;
            public GetRoot():null;
            public GetAllParents($includeSelf: boolean):null;
            public IsPartOf($child: NodeCanvas.Framework.IBlackboard):null;
            public AddVariable($varName: string, $value: any):null;
            public AddVariable($varName: string, $type: System.Type):null;
            public RemoveVariable($varName: string):null;
            public SetVariableValue($varName: string, $value: any):null;
            public InitializePropertiesBinding($target: UnityEngine.Component, $callSetter: boolean):null;
            public GetVariable($varName: string, $ofType?: System.Type):null;
            public GetVariableByID($ID: string):null;
            public GetVariables($ofType?: System.Type):null;
            public ChangeVariableType($target: NodeCanvas.Framework.Variable, $newType: System.Type):null;
            public OverwriteFrom($sourceBlackboard: NodeCanvas.Framework.IBlackboard, $removeMissingVariables?: boolean):null;
        }
        export class MissingConnection extends NodeCanvas.Framework.Connection implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, ParadoxNotion.Serialization.IMissingRecoverable{ 
            public get defaultColor(): UnityEngine.Color;
            public get tipConnectionStyle(): NodeCanvas.Framework.Connection.TipConnectionStyle;
            public get direction(): ParadoxNotion.PlanarDirection;
            public get missingType(): string;
            public set missingType(value: string);
            public get recoveryState(): string;
            public set recoveryState(value: string);
            public constructor();
        }
        export class MissingNode extends NodeCanvas.Framework.Node implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, ParadoxNotion.Serialization.IMissingRecoverable{ 
            public get name(): string;
            public get outConnectionType(): System.Type;
            public get maxInConnections(): number;
            public get maxOutConnections(): number;
            public get allowAsPrime(): boolean;
            public get canSelfConnect(): boolean;
            public get commentsAlignment(): ParadoxNotion.Alignment2x2;
            public get iconAlignment(): ParadoxNotion.Alignment2x2;
            public get missingType(): string;
            public set missingType(value: string);
            public get recoveryState(): string;
            public set recoveryState(value: string);
            public constructor();
        }
        export class ReflectedAction extends NodeCanvas.Framework.Internal.ReflectedActionWrapper implements NodeCanvas.Framework.IReflectedWrapper{ 
            public constructor();
        }
        export class ReflectedActionWrapper extends NodeCanvas.Framework.Internal.ReflectedWrapper implements NodeCanvas.Framework.IReflectedWrapper{ 
            public static Create($method: System.Reflection.MethodInfo, $bb: NodeCanvas.Framework.IBlackboard):NodeCanvas.Framework.Internal.ReflectedActionWrapper;
            public Call():void;
            public static Create($method: System.Reflection.MethodInfo, $bb: NodeCanvas.Framework.IBlackboard):NodeCanvas.Framework.Internal.ReflectedWrapper;
        }
        export class ReflectedWrapper extends System.Object implements NodeCanvas.Framework.IReflectedWrapper{ 
            public static Create($method: System.Reflection.MethodInfo, $bb: NodeCanvas.Framework.IBlackboard):NodeCanvas.Framework.Internal.ReflectedWrapper;
            public SetVariablesBB($bb: NodeCanvas.Framework.IBlackboard):void;
            public GetSerializedMethod():ParadoxNotion.Serialization.SerializedMethodInfo;
            public GetMethod():System.Reflection.MethodInfo;
            public HasChanged():boolean;
            public AsString():string;
            public GetVariables():System.Array$1<NodeCanvas.Framework.BBParameter>;
            public Init($instance: any):void;
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
            public AsString():null;
        }
        export class ReflectedFunctionWrapper extends NodeCanvas.Framework.Internal.ReflectedWrapper implements NodeCanvas.Framework.IReflectedWrapper{ 
            public static Create($method: System.Reflection.MethodInfo, $bb: NodeCanvas.Framework.IBlackboard):NodeCanvas.Framework.Internal.ReflectedFunctionWrapper;
            public Call():any;
            public static Create($method: System.Reflection.MethodInfo, $bb: NodeCanvas.Framework.IBlackboard):NodeCanvas.Framework.Internal.ReflectedWrapper;
        }
        export class MissingAction extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, ParadoxNotion.Serialization.IMissingRecoverable, UnityEngine.ISerializationCallbackReceiver{ 
            public get missingType(): string;
            public set missingType(value: string);
            public get recoveryState(): string;
            public set recoveryState(value: string);
            public constructor();
        }
        export class MissingCondition extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, ParadoxNotion.Serialization.IMissingRecoverable, UnityEngine.ISerializationCallbackReceiver{ 
            public get missingType(): string;
            public set missingType(value: string);
            public get recoveryState(): string;
            public set recoveryState(value: string);
            public constructor();
        }
        export class TaskAgentParameter extends NodeCanvas.Framework.BBParameter$1<UnityEngine.Object> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public get varType(): System.Type;
            public get value(): UnityEngine.Object;
            public set value(value: UnityEngine.Object);
            public SetType($newType: System.Type):void;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class fsBBParameterProcessor extends ParadoxNotion.Serialization.fsRecoveryProcessor$2<NodeCanvas.Framework.BBParameter, NodeCanvas.Framework.Internal.MissingBBParameterType>{ 
            public constructor();
        }
        export class MissingBBParameterType extends NodeCanvas.Framework.BBParameter$1<any> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, ParadoxNotion.Serialization.IMissingRecoverable, UnityEngine.ISerializationCallbackReceiver{ 
            public get missingType(): string;
            public set missingType(value: string);
            public get recoveryState(): string;
            public set recoveryState(value: string);
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class MissingVariableType extends NodeCanvas.Framework.Variable$1<any> implements ParadoxNotion.Serialization.IMissingRecoverable{ 
            public get missingType(): string;
            public set missingType(value: string);
            public get recoveryState(): string;
            public set recoveryState(value: string);
            public constructor();
        }
    }
    export namespace UnityEngine.UI.Extensions {
        export class UILineRenderer extends UnityEngine.UI.Extensions.UIPrimitiveBase implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.ICanvasRaycastFilter, UnityEngine.UI.ICanvasElement, UnityEngine.UI.ILayoutElement, UnityEngine.UI.IClippable{ 
            public LineJoins: UnityEngine.UI.Extensions.UILineRenderer.JoinType;
            public BezierMode: UnityEngine.UI.Extensions.UILineRenderer.BezierType;
            public drivenExternally: boolean;
            public get LineThickness(): number;
            public set LineThickness(value: number);
            public get RelativeSize(): boolean;
            public set RelativeSize(value: boolean);
            public get LineList(): boolean;
            public set LineList(value: boolean);
            public get LineCaps(): boolean;
            public set LineCaps(value: boolean);
            public get BezierSegmentsPerCurve(): number;
            public set BezierSegmentsPerCurve(value: number);
            public get Points(): System.Array$1<UnityEngine.Vector2>;
            public set Points(value: System.Array$1<UnityEngine.Vector2>);
            public get Segments(): System.Collections.Generic.List$1<System.Array$1<UnityEngine.Vector2>>;
            public set Segments(value: System.Collections.Generic.List$1<System.Array$1<UnityEngine.Vector2>>);
            public GetPosition($index: number, $segmentIndex?: number):UnityEngine.Vector2;
            public GetPositionBySegment($index: number, $segment: number):UnityEngine.Vector2;
            public GetClosestPoint($p1: UnityEngine.Vector2, $p2: UnityEngine.Vector2, $p3: UnityEngine.Vector2):UnityEngine.Vector2;
            public constructor();
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public IsRaycastLocationValid($screenPoint: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
        }
        export class UIPrimitiveBase extends UnityEngine.UI.MaskableGraphic implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.ICanvasRaycastFilter, UnityEngine.UI.ICanvasElement, UnityEngine.UI.ILayoutElement, UnityEngine.UI.IClippable{ 
            public get sprite(): UnityEngine.Sprite;
            public set sprite(value: UnityEngine.Sprite);
            public get overrideSprite(): UnityEngine.Sprite;
            public set overrideSprite(value: UnityEngine.Sprite);
            public get eventAlphaThreshold(): number;
            public set eventAlphaThreshold(value: number);
            public get ImproveResolution(): UnityEngine.UI.Extensions.ResolutionMode;
            public set ImproveResolution(value: UnityEngine.UI.Extensions.ResolutionMode);
            public get Resolution(): number;
            public set Resolution(value: number);
            public get UseNativeSize(): boolean;
            public set UseNativeSize(value: boolean);
            public static get defaultETC1GraphicMaterial(): UnityEngine.Material;
            public get mainTexture(): UnityEngine.Texture;
            public get hasBorder(): boolean;
            public get pixelsPerUnit(): number;
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public get minWidth(): number;
            public get preferredWidth(): number;
            public get flexibleWidth(): number;
            public get minHeight(): number;
            public get preferredHeight(): number;
            public get flexibleHeight(): number;
            public get layoutPriority(): number;
            public CalculateLayoutInputHorizontal():void;
            public CalculateLayoutInputVertical():void;
            public IsRaycastLocationValid($screenPoint: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
        export class Accordion extends UnityEngine.MonoBehaviour{ 
            public get transition(): UnityEngine.UI.Extensions.Accordion.Transition;
            public set transition(value: UnityEngine.UI.Extensions.Accordion.Transition);
            public get transitionDuration(): number;
            public set transitionDuration(value: number);
            public constructor();
        }
        export class AccordionElement extends UnityEngine.UI.Toggle implements UnityEngine.UI.ICanvasElement, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler, UnityEngine.EventSystems.IMoveHandler, UnityEngine.EventSystems.ISubmitHandler, UnityEngine.EventSystems.IPointerClickHandler{ 
            public OnValueChanged($state: boolean):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
        export class BoxSlider extends UnityEngine.UI.Selectable implements UnityEngine.EventSystems.IInitializePotentialDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.UI.ICanvasElement, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler, UnityEngine.EventSystems.IMoveHandler{ 
            public get HandleRect(): UnityEngine.RectTransform;
            public set HandleRect(value: UnityEngine.RectTransform);
            public get MinValue(): number;
            public set MinValue(value: number);
            public get MaxValue(): number;
            public set MaxValue(value: number);
            public get WholeNumbers(): boolean;
            public set WholeNumbers(value: boolean);
            public get ValueX(): number;
            public set ValueX(value: number);
            public get NormalizedValueX(): number;
            public set NormalizedValueX(value: number);
            public get ValueY(): number;
            public set ValueY(value: number);
            public get NormalizedValueY(): number;
            public set NormalizedValueY(value: number);
            public get OnValueChanged(): UnityEngine.UI.Extensions.BoxSlider.BoxSliderEvent;
            public set OnValueChanged(value: UnityEngine.UI.Extensions.BoxSlider.BoxSliderEvent);
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public LayoutComplete():void;
            public GraphicUpdateComplete():void;
            public OnDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnInitializePotentialDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
        export class TiltWindow extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEventSystemHandler{ 
            public range: UnityEngine.Vector2;
            public OnDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public constructor();
        }
        export enum AutoCompleteSearchType{ ArraySort = 0, Linq = 1 }
        export class AutoCompleteComboBox extends UnityEngine.MonoBehaviour{ 
            public disabledTextColor: UnityEngine.Color;
            public AvailableOptions: System.Collections.Generic.List$1<string>;
            public SelectFirstItemOnStart: boolean;
            public ValidSelectionTextColor: UnityEngine.Color;
            public MatchingItemsRemainingTextColor: UnityEngine.Color;
            public NoItemsRemainingTextColor: UnityEngine.Color;
            public autocompleteSearchType: UnityEngine.UI.Extensions.AutoCompleteSearchType;
            public OnSelectionTextChanged: UnityEngine.UI.Extensions.AutoCompleteComboBox.SelectionTextChangedEvent;
            public OnSelectionValidityChanged: UnityEngine.UI.Extensions.AutoCompleteComboBox.SelectionValidityChangedEvent;
            public OnSelectionChanged: UnityEngine.UI.Extensions.AutoCompleteComboBox.SelectionChangedEvent;
            public get SelectedItem(): UnityEngine.UI.Extensions.DropDownListItem;
            public get Text(): string;
            public get ScrollBarWidth(): number;
            public set ScrollBarWidth(value: number);
            public get ItemsToDisplay(): number;
            public set ItemsToDisplay(value: number);
            public get InputColorMatching(): boolean;
            public set InputColorMatching(value: boolean);
            public Awake():void;
            public Start():void;
            public OnValueChanged($currText: string):void;
            public ToggleDropdownPanel($directClick: boolean):void;
            public constructor();
        }
        export class DropDownListItem extends System.Object{ 
            public OnSelect: System.Action;
            public get Caption(): string;
            public set Caption(value: string);
            public get Image(): UnityEngine.Sprite;
            public set Image(value: UnityEngine.Sprite);
            public get IsDisabled(): boolean;
            public set IsDisabled(value: boolean);
            public get ID(): string;
            public set ID(value: string);
            public constructor($caption?: string, $inId?: string, $image?: UnityEngine.Sprite, $disabled?: boolean, $onSelect?: System.Action);
            public constructor();
        }
        export class ComboBox extends UnityEngine.MonoBehaviour{ 
            public disabledTextColor: UnityEngine.Color;
            public AvailableOptions: System.Collections.Generic.List$1<string>;
            public OnSelectionChanged: UnityEngine.UI.Extensions.ComboBox.SelectionChangedEvent;
            public get SelectedItem(): UnityEngine.UI.Extensions.DropDownListItem;
            public get Text(): string;
            public get ScrollBarWidth(): number;
            public set ScrollBarWidth(value: number);
            public get ItemsToDisplay(): number;
            public set ItemsToDisplay(value: number);
            public Awake():void;
            public OnValueChanged($currText: string):void;
            public ToggleDropdownPanel($directClick: boolean):void;
            public constructor();
        }
        export class DropDownList extends UnityEngine.MonoBehaviour{ 
            public disabledTextColor: UnityEngine.Color;
            public Items: System.Collections.Generic.List$1<UnityEngine.UI.Extensions.DropDownListItem>;
            public OverrideHighlighted: boolean;
            public SelectFirstItemOnStart: boolean;
            public OnSelectionChanged: UnityEngine.UI.Extensions.DropDownList.SelectionChangedEvent;
            public get SelectedItem(): UnityEngine.UI.Extensions.DropDownListItem;
            public get ScrollBarWidth(): number;
            public set ScrollBarWidth(value: number);
            public get ItemsToDisplay(): number;
            public set ItemsToDisplay(value: number);
            public Start():void;
            public ToggleDropdownPanel($directClick: boolean):void;
            public constructor();
        }
        export class DropDownListButton extends System.Object{ 
            public rectTransform: UnityEngine.RectTransform;
            public btn: UnityEngine.UI.Button;
            public txt: UnityEngine.UI.Text;
            public btnImg: UnityEngine.UI.Image;
            public img: UnityEngine.UI.Image;
            public gameobject: UnityEngine.GameObject;
            public constructor($btnObj: UnityEngine.GameObject);
            public constructor();
        }
        export class CooldownButton extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerDownHandler{ 
            public OnCooldownStart: UnityEngine.UI.Extensions.CooldownButton.CooldownButtonEvent;
            public OnButtonClickDuringCooldown: UnityEngine.UI.Extensions.CooldownButton.CooldownButtonEvent;
            public OnCoolDownFinish: UnityEngine.UI.Extensions.CooldownButton.CooldownButtonEvent;
            public get CooldownTimeout(): number;
            public set CooldownTimeout(value: number);
            public get CooldownSpeed(): number;
            public set CooldownSpeed(value: number);
            public get CooldownInEffect(): boolean;
            public get CooldownActive(): boolean;
            public set CooldownActive(value: boolean);
            public get CooldownTimeElapsed(): number;
            public set CooldownTimeElapsed(value: number);
            public get CooldownTimeRemaining(): number;
            public get CooldownPercentRemaining(): number;
            public get CooldownPercentComplete(): number;
            public PauseCooldown():void;
            public RestartCooldown():void;
            public StartCooldown():void;
            public StopCooldown():void;
            public CancelCooldown():void;
            public constructor();
        }
        export class InputFocus extends UnityEngine.MonoBehaviour{ 
            public _ignoreNextActivation: boolean;
            public buttonPressed():void;
            public OnEndEdit($textString: string):void;
            public constructor();
        }
        export class MultiTouchScrollRect extends UnityEngine.UI.ScrollRect implements UnityEngine.UI.ILayoutGroup, UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IInitializePotentialDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEndDragHandler, UnityEngine.UI.ICanvasElement, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IScrollHandler, UnityEngine.UI.ILayoutElement, UnityEngine.UI.ILayoutController{ 
            public constructor();
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
        export class RadialSlider extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler{ 
            public get Angle(): number;
            public set Angle(value: number);
            public get Value(): number;
            public set Value(value: number);
            public get EndColor(): UnityEngine.Color;
            public set EndColor(value: UnityEngine.Color);
            public get StartColor(): UnityEngine.Color;
            public set StartColor(value: UnityEngine.Color);
            public get LerpToTarget(): boolean;
            public set LerpToTarget(value: boolean);
            public get LerpCurve(): UnityEngine.AnimationCurve;
            public set LerpCurve(value: UnityEngine.AnimationCurve);
            public get LerpInProgress(): boolean;
            public get RadialImage(): UnityEngine.UI.Image;
            public get onValueChanged(): UnityEngine.UI.Extensions.RadialSlider.RadialSliderValueChangedEvent;
            public set onValueChanged(value: UnityEngine.UI.Extensions.RadialSlider.RadialSliderValueChangedEvent);
            public get onTextValueChanged(): UnityEngine.UI.Extensions.RadialSlider.RadialSliderTextValueChangedEvent;
            public set onTextValueChanged(value: UnityEngine.UI.Extensions.RadialSlider.RadialSliderTextValueChangedEvent);
            public OnPointerEnter($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerDown($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerUp($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public constructor();
        }
        export class RangeSlider extends UnityEngine.UI.Selectable implements UnityEngine.EventSystems.IInitializePotentialDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.UI.ICanvasElement, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler, UnityEngine.EventSystems.IMoveHandler{ 
            public get FillRect(): UnityEngine.RectTransform;
            public set FillRect(value: UnityEngine.RectTransform);
            public get LowHandleRect(): UnityEngine.RectTransform;
            public set LowHandleRect(value: UnityEngine.RectTransform);
            public get HighHandleRect(): UnityEngine.RectTransform;
            public set HighHandleRect(value: UnityEngine.RectTransform);
            public get MinValue(): number;
            public set MinValue(value: number);
            public get MaxValue(): number;
            public set MaxValue(value: number);
            public get WholeNumbers(): boolean;
            public set WholeNumbers(value: boolean);
            public get LowValue(): number;
            public set LowValue(value: number);
            public get NormalizedLowValue(): number;
            public set NormalizedLowValue(value: number);
            public get HighValue(): number;
            public set HighValue(value: number);
            public get NormalizedHighValue(): number;
            public set NormalizedHighValue(value: number);
            public get OnValueChanged(): UnityEngine.UI.Extensions.RangeSlider.RangeSliderEvent;
            public set OnValueChanged(value: UnityEngine.UI.Extensions.RangeSlider.RangeSliderEvent);
            public SetValueWithoutNotify($low: number, $high: number):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public LayoutComplete():void;
            public GraphicUpdateComplete():void;
            public OnDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnInitializePotentialDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
        export class ReorderableList extends UnityEngine.MonoBehaviour{ 
            public ContentLayout: UnityEngine.UI.LayoutGroup;
            public DraggableArea: UnityEngine.RectTransform;
            public IsDraggable: boolean;
            public CloneDraggedObject: boolean;
            public IsDropable: boolean;
            public IsDisplacable: boolean;
            public EqualizeSizesOnDrag: boolean;
            public maxItems: number;
            public OnElementDropped: UnityEngine.UI.Extensions.ReorderableList.ReorderableListHandler;
            public OnElementGrabbed: UnityEngine.UI.Extensions.ReorderableList.ReorderableListHandler;
            public OnElementRemoved: UnityEngine.UI.Extensions.ReorderableList.ReorderableListHandler;
            public OnElementAdded: UnityEngine.UI.Extensions.ReorderableList.ReorderableListHandler;
            public OnElementDisplacedFrom: UnityEngine.UI.Extensions.ReorderableList.ReorderableListHandler;
            public OnElementDisplacedTo: UnityEngine.UI.Extensions.ReorderableList.ReorderableListHandler;
            public OnElementDisplacedFromReturned: UnityEngine.UI.Extensions.ReorderableList.ReorderableListHandler;
            public OnElementDisplacedToReturned: UnityEngine.UI.Extensions.ReorderableList.ReorderableListHandler;
            public OnElementDroppedWithMaxItems: UnityEngine.UI.Extensions.ReorderableList.ReorderableListHandler;
            public get Content(): UnityEngine.RectTransform;
            public Refresh():void;
            public TestReOrderableListTarget($item: UnityEngine.UI.Extensions.ReorderableList.ReorderableListEventStruct):void;
            public constructor();
        }
        export class ReorderableListContent extends UnityEngine.MonoBehaviour{ 
            public OnTransformChildrenChanged():void;
            public Init($extList: UnityEngine.UI.Extensions.ReorderableList):void;
            public constructor();
        }
        export class ReorderableListDebug extends UnityEngine.MonoBehaviour{ 
            public DebugLabel: UnityEngine.UI.Text;
            public constructor();
        }
        export class ReorderableListElement extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEndDragHandler, UnityEngine.EventSystems.IEventSystemHandler{ 
            public IsGrabbable: boolean;
            public IsTransferable: boolean;
            public isDroppableInSpace: boolean;
            public OnBeginDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public finishDisplacingElement():void;
            public OnEndDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public Init($reorderableList: UnityEngine.UI.Extensions.ReorderableList):void;
            public constructor();
        }
        export class RescaleDragPanel extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerDownHandler{ 
            public OnPointerDown($data: UnityEngine.EventSystems.PointerEventData):void;
            public OnDrag($data: UnityEngine.EventSystems.PointerEventData):void;
            public constructor();
        }
        export class RescalePanel extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerDownHandler{ 
            public minSize: UnityEngine.Vector2;
            public maxSize: UnityEngine.Vector2;
            public OnPointerDown($data: UnityEngine.EventSystems.PointerEventData):void;
            public OnDrag($data: UnityEngine.EventSystems.PointerEventData):void;
            public constructor();
        }
        export class ResizePanel extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerDownHandler{ 
            public minSize: UnityEngine.Vector2;
            public maxSize: UnityEngine.Vector2;
            public OnPointerDown($data: UnityEngine.EventSystems.PointerEventData):void;
            public OnDrag($data: UnityEngine.EventSystems.PointerEventData):void;
            public constructor();
        }
        export class Segment extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler, UnityEngine.EventSystems.ISubmitHandler, UnityEngine.EventSystems.IPointerClickHandler{ 
            public get selected(): boolean;
            public set selected(value: boolean);
            public OnPointerClick($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerEnter($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerExit($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerDown($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerUp($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnSelect($eventData: UnityEngine.EventSystems.BaseEventData):void;
            public OnDeselect($eventData: UnityEngine.EventSystems.BaseEventData):void;
            public OnSubmit($eventData: UnityEngine.EventSystems.BaseEventData):void;
        }
        export class SegmentedControl extends UnityEngine.EventSystems.UIBehaviour{ 
            public get segments(): System.Array$1<UnityEngine.UI.Selectable>;
            public get separator(): UnityEngine.UI.Graphic;
            public set separator(value: UnityEngine.UI.Graphic);
            public get allowSwitchingOff(): boolean;
            public set allowSwitchingOff(value: boolean);
            public get selectedSegmentIndex(): number;
            public set selectedSegmentIndex(value: number);
            public get onValueChanged(): UnityEngine.UI.Extensions.SegmentedControl.SegmentSelectedEvent;
            public set onValueChanged(value: UnityEngine.UI.Extensions.SegmentedControl.SegmentSelectedEvent);
            public LayoutSegments():void;
        }
        export class ExampleSelectable extends UnityEngine.MonoBehaviour implements UnityEngine.UI.Extensions.IBoxSelectable{ 
            public get selected(): boolean;
            public set selected(value: boolean);
            public get preSelected(): boolean;
            public set preSelected(value: boolean);
            public constructor();
        }
        export interface IBoxSelectable{ 
            selected: boolean;
            preSelected: boolean;
            transform: UnityEngine.Transform;
        }
        export class SelectionBox extends UnityEngine.MonoBehaviour{ 
            public color: UnityEngine.Color;
            public art: UnityEngine.Sprite;
            public selectionMask: UnityEngine.RectTransform;
            public onSelectionChange: UnityEngine.UI.Extensions.SelectionBox.SelectionEvent;
            public GetAllSelected():System.Array$1<UnityEngine.UI.Extensions.IBoxSelectable>;
            public constructor();
        }
        export class Stepper extends UnityEngine.EventSystems.UIBehaviour{ 
            public get sides(): System.Array$1<UnityEngine.UI.Selectable>;
            public get value(): number;
            public set value(value: number);
            public get minimum(): number;
            public set minimum(value: number);
            public get maximum(): number;
            public set maximum(value: number);
            public get step(): number;
            public set step(value: number);
            public get wrap(): boolean;
            public set wrap(value: boolean);
            public get separator(): UnityEngine.UI.Graphic;
            public set separator(value: UnityEngine.UI.Graphic);
            public get onValueChanged(): UnityEngine.UI.Extensions.Stepper.StepperValueChangedEvent;
            public set onValueChanged(value: UnityEngine.UI.Extensions.Stepper.StepperValueChangedEvent);
            public StepUp():void;
            public StepDown():void;
            public LayoutSides($sides?: System.Array$1<UnityEngine.UI.Selectable>):void;
        }
        export class StepperSide extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler, UnityEngine.EventSystems.ISubmitHandler, UnityEngine.EventSystems.IPointerClickHandler{ 
            public OnPointerClick($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnSubmit($eventData: UnityEngine.EventSystems.BaseEventData):void;
            public OnPointerEnter($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerExit($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerDown($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerUp($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnSelect($eventData: UnityEngine.EventSystems.BaseEventData):void;
            public OnDeselect($eventData: UnityEngine.EventSystems.BaseEventData):void;
        }
        export class TextPic extends UnityEngine.UI.Text implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.UI.ICanvasElement, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.UI.ILayoutElement, UnityEngine.UI.IClippable, UnityEngine.EventSystems.IPointerClickHandler{ 
            public inspectorIconList: System.Array$1<UnityEngine.UI.Extensions.TextPic.IconName>;
            public ImageScalingFactor: number;
            public hyperlinkColor: string;
            public imageOffset: UnityEngine.Vector2;
            public isCreating_m_HrefInfos: boolean;
            public get onHrefClick(): UnityEngine.UI.Extensions.TextPic.HrefClickEvent;
            public set onHrefClick(value: UnityEngine.UI.Extensions.TextPic.HrefClickEvent);
            public get Selected(): boolean;
            public set Selected(value: boolean);
            public ResetIconList():void;
            public OnHrefClick($hrefName: string):void;
            public OnPointerClick($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerEnter($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerExit($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnSelect($eventData: UnityEngine.EventSystems.BaseEventData):void;
            public OnDeselect($eventData: UnityEngine.EventSystems.BaseEventData):void;
            public constructor();
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
        }
        export class UI_Knob extends UnityEngine.UI.Selectable implements UnityEngine.EventSystems.IInitializePotentialDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IMoveHandler, UnityEngine.EventSystems.IPointerUpHandler{ 
            public direction: UnityEngine.UI.Extensions.UI_Knob.Direction;
            public knobValue: number;
            public maxValue: number;
            public loops: number;
            public clampOutput01: boolean;
            public snapToPosition: boolean;
            public snapStepsPerLoop: number;
            public OnValueChanged: UnityEngine.UI.Extensions.KnobFloatValueEvent;
            public OnDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnInitializePotentialDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public constructor();
        }
        export class KnobFloatValueEvent extends UnityEngine.Events.UnityEvent$1<number> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class BestFitOutline extends UnityEngine.UI.Shadow implements UnityEngine.UI.IMeshModifier{ 
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($mesh: UnityEngine.Mesh):void;
            public ModifyMesh($vh: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($mesh: UnityEngine.Mesh):void;
            public ModifyMesh($vh: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
        }
        export class CUIBezierCurve extends UnityEngine.MonoBehaviour{ 
            public static CubicBezierCurvePtNum: number;
            public OnRefresh: System.Action;
            public get ControlPoints(): System.Array$1<UnityEngine.Vector3>;
            public set EDITOR_ControlPoints(value: System.Array$1<UnityEngine.Vector3>);
            public Refresh():void;
            public GetPoint($_time: number):UnityEngine.Vector3;
            public GetTangent($_time: number):UnityEngine.Vector3;
            public ReportSet():void;
            public constructor();
        }
        export class CUIGraphic extends UnityEngine.UI.BaseMeshEffect implements UnityEngine.UI.IMeshModifier{ 
            public static bottomCurveIdx: number;
            public static topCurveIdx: number;
            public get IsCurved(): boolean;
            public get IsLockWithRatio(): boolean;
            public get RectTrans(): UnityEngine.RectTransform;
            public get UIGraphic(): UnityEngine.UI.Graphic;
            public get RefCUIGraphic(): UnityEngine.UI.Extensions.CUIGraphic;
            public get RefCurves(): System.Array$1<UnityEngine.UI.Extensions.CUIBezierCurve>;
            public get RefCurvesControlRatioPoints(): System.Array$1<UnityEngine.UI.Extensions.Vector3_Array2D>;
            public set EDITOR_RefCurves(value: System.Array$1<UnityEngine.UI.Extensions.CUIBezierCurve>);
            public set EDITOR_RefCurvesControlRatioPoints(value: System.Array$1<UnityEngine.UI.Extensions.Vector3_Array2D>);
            public Refresh():void;
            public ReportSet():void;
            public FixTextToRectTrans():void;
            public ReferenceCUIForBCurves():void;
            public UpdateCurveControlPointPositions():void;
            public GetBCurveSandwichSpacePoint($_xTime: number, $_yTime: number):UnityEngine.Vector3;
            public GetBCurveSandwichSpaceTangent($_xTime: number, $_yTime: number):UnityEngine.Vector3;
            public constructor();
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($mesh: UnityEngine.Mesh):void;
            public ModifyMesh($vh: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
        }
        export class Vector3_Array2D extends System.ValueType{ 
            public array: System.Array$1<UnityEngine.Vector3>;
            public get_Item($_idx: number):UnityEngine.Vector3;
            public set_Item($_idx: number, $value: UnityEngine.Vector3):void;
        }
        export class CUIImage extends UnityEngine.UI.Extensions.CUIGraphic implements UnityEngine.UI.IMeshModifier{ 
            public static SlicedImageCornerRefVertexIdx: number;
            public static FilledImageCornerRefVertexIdx: number;
            public cornerPosRatio: UnityEngine.Vector2;
            public get OriCornerPosRatio(): UnityEngine.Vector2;
            public get UIImage(): UnityEngine.UI.Image;
            public static ImageTypeCornerRefVertexIdx($_type: UnityEngine.UI.Image.Type):number;
            public constructor();
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($mesh: UnityEngine.Mesh):void;
            public ModifyMesh($vh: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($mesh: UnityEngine.Mesh):void;
            public ModifyMesh($vh: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
        }
        export class CUIText extends UnityEngine.UI.Extensions.CUIGraphic implements UnityEngine.UI.IMeshModifier{ 
            public constructor();
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($mesh: UnityEngine.Mesh):void;
            public ModifyMesh($vh: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($mesh: UnityEngine.Mesh):void;
            public ModifyMesh($vh: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
        }
        export class CurvedText extends UnityEngine.UI.BaseMeshEffect implements UnityEngine.UI.IMeshModifier{ 
            public get CurveForText(): UnityEngine.AnimationCurve;
            public set CurveForText(value: UnityEngine.AnimationCurve);
            public get CurveMultiplier(): number;
            public set CurveMultiplier(value: number);
            public constructor();
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($mesh: UnityEngine.Mesh):void;
            public ModifyMesh($vh: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
        }
        export class CylinderText extends UnityEngine.UI.BaseMeshEffect implements UnityEngine.UI.IMeshModifier{ 
            public radius: number;
            public constructor();
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($mesh: UnityEngine.Mesh):void;
            public ModifyMesh($vh: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
        }
        export class Gradient extends UnityEngine.UI.BaseMeshEffect implements UnityEngine.UI.IMeshModifier{ 
            public get GradientMode(): UnityEngine.UI.Extensions.GradientMode;
            public set GradientMode(value: UnityEngine.UI.Extensions.GradientMode);
            public get GradientDir(): UnityEngine.UI.Extensions.GradientDir;
            public set GradientDir(value: UnityEngine.UI.Extensions.GradientDir);
            public get OverwriteAllColor(): boolean;
            public set OverwriteAllColor(value: boolean);
            public get Vertex1(): UnityEngine.Color;
            public set Vertex1(value: UnityEngine.Color);
            public get Vertex2(): UnityEngine.Color;
            public set Vertex2(value: UnityEngine.Color);
            public constructor();
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($mesh: UnityEngine.Mesh):void;
            public ModifyMesh($vh: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
        }
        export enum GradientMode{ Global = 0, Local = 1 }
        export enum GradientDir{ Vertical = 0, Horizontal = 1, DiagonalLeftToRight = 2, DiagonalRightToLeft = 3 }
        export class Gradient2 extends UnityEngine.UI.BaseMeshEffect implements UnityEngine.UI.IMeshModifier{ 
            public get BlendMode(): UnityEngine.UI.Extensions.Gradient2.Blend;
            public set BlendMode(value: UnityEngine.UI.Extensions.Gradient2.Blend);
            public get EffectGradient(): UnityEngine.Gradient;
            public set EffectGradient(value: UnityEngine.Gradient);
            public get GradientType(): UnityEngine.UI.Extensions.Gradient2.Type;
            public set GradientType(value: UnityEngine.UI.Extensions.Gradient2.Type);
            public get ModifyVertices(): boolean;
            public set ModifyVertices(value: boolean);
            public get Offset(): number;
            public set Offset(value: number);
            public get Zoom(): number;
            public set Zoom(value: number);
            public constructor();
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($mesh: UnityEngine.Mesh):void;
            public ModifyMesh($vh: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
        }
        export class LetterSpacing extends UnityEngine.UI.BaseMeshEffect implements UnityEngine.UI.IMeshModifier{ 
            public get spacing(): number;
            public set spacing(value: number);
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($mesh: UnityEngine.Mesh):void;
            public ModifyMesh($vh: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
        }
        export class MonoSpacing extends UnityEngine.UI.BaseMeshEffect implements UnityEngine.UI.IMeshModifier{ 
            public HalfCharWidth: number;
            public UseHalfCharWidth: boolean;
            public get Spacing(): number;
            public set Spacing(value: number);
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($mesh: UnityEngine.Mesh):void;
            public ModifyMesh($vh: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
        }
        export class NicerOutline extends UnityEngine.UI.BaseMeshEffect implements UnityEngine.UI.IMeshModifier{ 
            public get effectColor(): UnityEngine.Color;
            public set effectColor(value: UnityEngine.Color);
            public get effectDistance(): UnityEngine.Vector2;
            public set effectDistance(value: UnityEngine.Vector2);
            public get useGraphicAlpha(): boolean;
            public set useGraphicAlpha(value: boolean);
            public constructor();
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($mesh: UnityEngine.Mesh):void;
            public ModifyMesh($vh: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
        }
        export class RaycastMask extends UnityEngine.MonoBehaviour implements UnityEngine.ICanvasRaycastFilter{ 
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public constructor();
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
        }
        export class UIAdditiveEffect extends UnityEngine.MonoBehaviour{ 
            public SetMaterial():void;
            public OnValidate():void;
            public constructor();
        }
        export class UIImageCrop extends UnityEngine.MonoBehaviour{ 
            public XCrop: number;
            public YCrop: number;
            public SetMaterial():void;
            public OnValidate():void;
            public SetXCrop($xcrop: number):void;
            public SetYCrop($ycrop: number):void;
            public constructor();
        }
        export class UILinearDodgeEffect extends UnityEngine.MonoBehaviour{ 
            public SetMaterial():void;
            public OnValidate():void;
            public constructor();
        }
        export class UIMultiplyEffect extends UnityEngine.MonoBehaviour{ 
            public SetMaterial():void;
            public OnValidate():void;
            public constructor();
        }
        export class UIScreenEffect extends UnityEngine.MonoBehaviour{ 
            public SetMaterial():void;
            public OnValidate():void;
            public constructor();
        }
        export class UISoftAdditiveEffect extends UnityEngine.MonoBehaviour{ 
            public SetMaterial():void;
            public OnValidate():void;
            public constructor();
        }
        export class ShineEffect extends UnityEngine.UI.MaskableGraphic implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.UI.ICanvasElement, UnityEngine.UI.IClippable{ 
            public get Yoffset(): number;
            public set Yoffset(value: number);
            public get Width(): number;
            public set Width(value: number);
            public Triangulate($vh: UnityEngine.UI.VertexHelper):void;
            public constructor();
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
        export class ShineEffector extends UnityEngine.MonoBehaviour{ 
            public effector: UnityEngine.UI.Extensions.ShineEffect;
            public yOffset: number;
            public width: number;
            public get YOffset(): number;
            public set YOffset(value: number);
            public constructor();
        }
        export class SoftMaskScript extends UnityEngine.MonoBehaviour{ 
            public MaskArea: UnityEngine.RectTransform;
            public AlphaMask: UnityEngine.Texture;
            public CutOff: number;
            public HardBlend: boolean;
            public FlipAlphaMask: boolean;
            public DontClipMaskScalingRect: boolean;
            public GetCanvasRect():UnityEngine.Rect;
            public constructor();
        }
        export class UIFlippable extends UnityEngine.UI.BaseMeshEffect implements UnityEngine.UI.IMeshModifier{ 
            public get horizontal(): boolean;
            public set horizontal(value: boolean);
            public get vertical(): boolean;
            public set vertical(value: boolean);
            public constructor();
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($mesh: UnityEngine.Mesh):void;
            public ModifyMesh($vh: UnityEngine.UI.VertexHelper):void;
            public ModifyMesh($verts: UnityEngine.UI.VertexHelper):void;
        }
        export class UIParticleSystem extends UnityEngine.UI.MaskableGraphic implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.UI.ICanvasElement, UnityEngine.UI.IClippable{ 
            public fixedTime: boolean;
            public use3dRotation: boolean;
            public get mainTexture(): UnityEngine.Texture;
            public StartParticleEmission():void;
            public StopParticleEmission():void;
            public PauseParticleEmission():void;
            public constructor();
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
        export class CardExpanding2D extends UnityEngine.MonoBehaviour{ 
            public ToggleCard():void;
            public constructor();
        }
        export class CardPopup2D extends UnityEngine.MonoBehaviour{ 
            public CardEnter():void;
            public CardFallAway($fallRotation: number):void;
            public constructor();
        }
        export class CardStack2D extends UnityEngine.MonoBehaviour{ 
            public static canUseHorizontalAxis: boolean;
            public constructor();
        }
        export class CardExpanding3D extends UnityEngine.MonoBehaviour{ 
            public cardCorners: System.Array$1<UnityEngine.RectTransform>;
            public cardEdges: System.Array$1<UnityEngine.RectTransform>;
            public cardCenter: UnityEngine.RectTransform;
            public cardAutoSize: boolean;
            public cardSize: UnityEngine.Vector2;
            public cardPosition: UnityEngine.Vector2;
            public cardSuperness: number;
            public pageAutoSize: boolean;
            public pageSize: UnityEngine.Vector2;
            public pagePosition: UnityEngine.Vector2;
            public pageSuperness: number;
            public ToggleCard():void;
            public constructor();
        }
        export class MeshCreator extends UnityEngine.MonoBehaviour{ 
            public CreateMesh($points: System.Collections.Generic.List$1<UnityEngine.Vector2>):void;
            public constructor();
        }
        export class SuperellipsePoints extends UnityEngine.MonoBehaviour{ 
            public xLimits: number;
            public yLimits: number;
            public superness: number;
            public levelOfDetail: number;
            public material: UnityEngine.Material;
            public constructor();
        }
        export class Triangulator extends System.Object{ 
            public Triangulate():System.Array$1<number>;
            public constructor($points: System.Array$1<UnityEngine.Vector2>);
            public constructor();
        }
        export class ContentScrollSnapHorizontal extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IEndDragHandler, UnityEngine.EventSystems.IEventSystemHandler{ 
            public ignoreInactiveItems: boolean;
            public startInfo: UnityEngine.UI.Extensions.ContentScrollSnapHorizontal.MoveInfo;
            public prevButton: UnityEngine.GameObject;
            public nextButton: UnityEngine.GameObject;
            public pagination: UnityEngine.GameObject;
            public snappingVelocityThreshold: number;
            public jumpToItem: boolean;
            public lerpTime: number;
            public get MovementStarted(): UnityEngine.UI.Extensions.ContentScrollSnapHorizontal.StartMovementEvent;
            public set MovementStarted(value: UnityEngine.UI.Extensions.ContentScrollSnapHorizontal.StartMovementEvent);
            public get CurrentItemChanged(): UnityEngine.UI.Extensions.ContentScrollSnapHorizontal.CurrentItemChangeEvent;
            public set CurrentItemChanged(value: UnityEngine.UI.Extensions.ContentScrollSnapHorizontal.CurrentItemChangeEvent);
            public get ItemFoundToSnap(): UnityEngine.UI.Extensions.ContentScrollSnapHorizontal.FoundItemToSnapToEvent;
            public set ItemFoundToSnap(value: UnityEngine.UI.Extensions.ContentScrollSnapHorizontal.FoundItemToSnapToEvent);
            public get ItemSnappedTo(): UnityEngine.UI.Extensions.ContentScrollSnapHorizontal.SnappedToItemEvent;
            public set ItemSnappedTo(value: UnityEngine.UI.Extensions.ContentScrollSnapHorizontal.SnappedToItemEvent);
            public get Moving(): boolean;
            public get Sliding(): boolean;
            public get Lerping(): boolean;
            public get ClosestItemIndex(): number;
            public get LerpTargetIndex(): number;
            public GoTo($info: UnityEngine.UI.Extensions.ContentScrollSnapHorizontal.MoveInfo):void;
            public NextItem():void;
            public PreviousItem():void;
            public UpdateLayout():void;
            public UpdateLayoutAndMoveTo($info: UnityEngine.UI.Extensions.ContentScrollSnapHorizontal.MoveInfo):void;
            public OnBeginDrag($ped: UnityEngine.EventSystems.PointerEventData):void;
            public OnEndDrag($ped: UnityEngine.EventSystems.PointerEventData):void;
            public constructor();
        }
        export class CurvedLayout extends UnityEngine.UI.LayoutGroup implements UnityEngine.UI.ILayoutGroup, UnityEngine.UI.ILayoutElement, UnityEngine.UI.ILayoutController{ 
            public CurveOffset: UnityEngine.Vector3;
            public itemAxis: UnityEngine.Vector3;
            public itemSize: number;
            public centerpoint: number;
            public constructor();
        }
        export class NullContext extends System.Object{ 
            public constructor();
        }
        export class FancyGridViewContext extends System.Object implements UnityEngine.UI.Extensions.IFancyCellGroupContext, UnityEngine.UI.Extensions.IFancyScrollRectContext, UnityEngine.UI.Extensions.IFancyGridViewContext{ 
            public get CellTemplate(): UnityEngine.GameObject;
            public set CellTemplate(value: UnityEngine.GameObject);
            public get GetGroupCount(): System.Func$1<number>;
            public set GetGroupCount(value: System.Func$1<number>);
            public get ScrollDirection(): UnityEngine.UI.Extensions.ScrollDirection;
            public set ScrollDirection(value: UnityEngine.UI.Extensions.ScrollDirection);
            public get CalculateScrollSize(): System.Func$1<System.ValueTuple$2<number, number>>;
            public set CalculateScrollSize(value: System.Func$1<System.ValueTuple$2<number, number>>);
            public get GetStartAxisSpacing(): System.Func$1<number>;
            public set GetStartAxisSpacing(value: System.Func$1<number>);
            public get GetCellSize(): System.Func$1<number>;
            public set GetCellSize(value: System.Func$1<number>);
            public constructor();
        }
        export interface IFancyCellGroupContext{ 
            CellTemplate: UnityEngine.GameObject;
            GetGroupCount: System.Func$1<number>;
        }
        export interface IFancyScrollRectContext{ 
            ScrollDirection: UnityEngine.UI.Extensions.ScrollDirection;
            CalculateScrollSize: System.Func$1<System.ValueTuple$2<number, number>>;
        }
        export interface IFancyGridViewContext extends UnityEngine.UI.Extensions.IFancyCellGroupContext, UnityEngine.UI.Extensions.IFancyScrollRectContext{ 
            GetStartAxisSpacing: System.Func$1<number>;
            GetCellSize: System.Func$1<number>;
            CellTemplate: UnityEngine.GameObject;
            GetGroupCount: System.Func$1<number>;
            ScrollDirection: UnityEngine.UI.Extensions.ScrollDirection;
            CalculateScrollSize: System.Func$1<System.ValueTuple$2<number, number>>;
        }
        export enum MovementDirection{ Left = 0, Right = 1, Up = 2, Down = 3 }
        export enum MovementType{ Unrestricted = 0, Elastic = 1, Clamped = 2 }
        export enum ScrollDirection{ Vertical = 0, Horizontal = 1 }
        export class Scroller extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEndDragHandler, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IScrollHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler{ 
            public get ViewportSize(): number;
            public get ScrollDirection(): UnityEngine.UI.Extensions.ScrollDirection;
            public get MovementType(): UnityEngine.UI.Extensions.MovementType;
            public set MovementType(value: UnityEngine.UI.Extensions.MovementType);
            public get Elasticity(): number;
            public set Elasticity(value: number);
            public get ScrollSensitivity(): number;
            public set ScrollSensitivity(value: number);
            public get Inertia(): boolean;
            public set Inertia(value: boolean);
            public get DecelerationRate(): number;
            public set DecelerationRate(value: number);
            public get SnapEnabled(): boolean;
            public set SnapEnabled(value: boolean);
            public get Draggable(): boolean;
            public set Draggable(value: boolean);
            public get Scrollbar(): UnityEngine.UI.Scrollbar;
            public get Position(): number;
            public set Position(value: number);
            public OnValueChanged($callback: System.Action$1<number>):void;
            public OnSelectionChanged($callback: System.Action$1<number>):void;
            public SetTotalCount($totalCount: number):void;
            public ScrollTo($position: number, $duration: number, $onComplete?: System.Action):void;
            public ScrollTo($position: number, $duration: number, $easing: UnityEngine.UI.Extensions.EasingCore.Ease, $onComplete?: System.Action):void;
            public ScrollTo($position: number, $duration: number, $easingFunction: UnityEngine.UI.Extensions.EasingCore.EasingFunction, $onComplete?: System.Action):void;
            public JumpTo($index: number):void;
            public GetMovementDirection($sourceIndex: number, $destIndex: number):UnityEngine.UI.Extensions.MovementDirection;
            public constructor();
        }
        export class FancyScrollRectContext extends System.Object implements UnityEngine.UI.Extensions.IFancyScrollRectContext{ 
            public get ScrollDirection(): UnityEngine.UI.Extensions.ScrollDirection;
            public set ScrollDirection(value: UnityEngine.UI.Extensions.ScrollDirection);
            public get CalculateScrollSize(): System.Func$1<System.ValueTuple$2<number, number>>;
            public set CalculateScrollSize(value: System.Func$1<System.ValueTuple$2<number, number>>);
            public constructor();
        }
        export class FlowLayoutGroup extends UnityEngine.UI.LayoutGroup implements UnityEngine.UI.ILayoutGroup, UnityEngine.UI.ILayoutElement, UnityEngine.UI.ILayoutController{ 
            public SpacingX: number;
            public SpacingY: number;
            public ExpandHorizontalSpacing: boolean;
            public ChildForceExpandWidth: boolean;
            public ChildForceExpandHeight: boolean;
            public invertOrder: boolean;
            public get startAxis(): UnityEngine.UI.Extensions.FlowLayoutGroup.Axis;
            public set startAxis(value: UnityEngine.UI.Extensions.FlowLayoutGroup.Axis);
            public SetLayout($axis: number, $layoutInput: boolean):number;
            public GetGreatestMinimumChildWidth():number;
            public GetGreatestMinimumChildHeigth():number;
            public constructor();
        }
        export class HorizontalScrollSnap extends UnityEngine.UI.Extensions.ScrollSnapBase implements UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEndDragHandler, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.UI.Extensions.IScrollSnap, UnityEngine.EventSystems.IPointerClickHandler{ 
            public DistributePages():void;
            public AddChild($GO: UnityEngine.GameObject):void;
            public AddChild($GO: UnityEngine.GameObject, $WorldPositionStays: boolean):void;
            public RemoveChild($index: number, $ChildRemoved: $Ref<UnityEngine.GameObject>):void;
            public RemoveChild($index: number, $WorldPositionStays: boolean, $ChildRemoved: $Ref<UnityEngine.GameObject>):void;
            public RemoveAllChildren($ChildrenRemoved: $Ref<System.Array$1<UnityEngine.GameObject>>):void;
            public RemoveAllChildren($WorldPositionStays: boolean, $ChildrenRemoved: $Ref<System.Array$1<UnityEngine.GameObject>>):void;
            public UpdateLayout():void;
            public constructor();
        }
        export class ScrollSnapBase extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEndDragHandler, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.UI.Extensions.IScrollSnap, UnityEngine.EventSystems.IPointerClickHandler{ 
            public StartingScreen: number;
            public PageStep: number;
            public Pagination: UnityEngine.GameObject;
            public PrevButton: UnityEngine.GameObject;
            public NextButton: UnityEngine.GameObject;
            public transitionSpeed: number;
            public UseHardSwipe: boolean;
            public UseFastSwipe: boolean;
            public UseSwipeDeltaThreshold: boolean;
            public FastSwipeThreshold: number;
            public SwipeVelocityThreshold: number;
            public SwipeDeltaThreshold: number;
            public UseTimeScale: boolean;
            public MaskArea: UnityEngine.RectTransform;
            public MaskBuffer: number;
            public JumpOnEnable: boolean;
            public RestartOnEnable: boolean;
            public UseParentTransform: boolean;
            public ChildObjects: System.Array$1<UnityEngine.GameObject>;
            public get CurrentPage(): number;
            public get OnSelectionChangeStartEvent(): UnityEngine.UI.Extensions.ScrollSnapBase.SelectionChangeStartEvent;
            public set OnSelectionChangeStartEvent(value: UnityEngine.UI.Extensions.ScrollSnapBase.SelectionChangeStartEvent);
            public get OnSelectionPageChangedEvent(): UnityEngine.UI.Extensions.ScrollSnapBase.SelectionPageChangedEvent;
            public set OnSelectionPageChangedEvent(value: UnityEngine.UI.Extensions.ScrollSnapBase.SelectionPageChangedEvent);
            public get OnSelectionChangeEndEvent(): UnityEngine.UI.Extensions.ScrollSnapBase.SelectionChangeEndEvent;
            public set OnSelectionChangeEndEvent(value: UnityEngine.UI.Extensions.ScrollSnapBase.SelectionChangeEndEvent);
            public NextScreen():void;
            public PreviousScreen():void;
            public GoToScreen($screenIndex: number):void;
            public StartScreenChange():void;
            public CurrentPageObject():UnityEngine.Transform;
            public CurrentPageObject($returnObject: $Ref<UnityEngine.Transform>):void;
            public OnBeginDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnEndDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public SetLerp($value: boolean):void;
            public ChangePage($page: number):void;
            public OnPointerClick($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public constructor();
        }
        export interface IScrollSnap{ 
        }
        export class RadialLayout extends UnityEngine.UI.LayoutGroup implements UnityEngine.UI.ILayoutGroup, UnityEngine.UI.ILayoutElement, UnityEngine.UI.ILayoutController{ 
            public fDistance: number;
            public MinAngle: number;
            public MaxAngle: number;
            public StartAngle: number;
            public OnlyLayoutVisible: boolean;
            public constructor();
        }
        export class ScrollPositionController extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEndDragHandler, UnityEngine.EventSystems.IEventSystemHandler{ 
            public OnUpdatePosition($onUpdatePosition: System.Action$1<number>):void;
            public OnItemSelected($onItemSelected: System.Action$1<number>):void;
            public SetDataCount($dataCount: number):void;
            public ScrollTo($index: number, $duration: number):void;
            public JumpTo($index: number):void;
            public constructor();
        }
        export class ScrollSnap extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEndDragHandler, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.UI.Extensions.IScrollSnap{ 
            public NextButton: UnityEngine.UI.Button;
            public PrevButton: UnityEngine.UI.Button;
            public ItemsVisibleAtOnce: number;
            public AutoLayoutItems: boolean;
            public LinkScrolbarSteps: boolean;
            public LinkScrolrectScrollSensitivity: boolean;
            public UseFastSwipe: boolean;
            public FastSwipeThreshold: number;
            public direction: UnityEngine.UI.Extensions.ScrollSnap.ScrollDirection;
            public add_onPageChange($value: UnityEngine.UI.Extensions.ScrollSnap.PageSnapChange):void;
            public remove_onPageChange($value: UnityEngine.UI.Extensions.ScrollSnap.PageSnapChange):void;
            public UpdateListItemsSize():void;
            public UpdateListItemPositions():void;
            public ResetPage():void;
            public NextScreen():void;
            public PreviousScreen():void;
            public CurrentPage():number;
            public SetLerp($value: boolean):void;
            public ChangePage($page: number):void;
            public OnBeginDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnEndDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public StartScreenChange():void;
            public constructor();
        }
        export class ScrollSnapScrollbarHelper extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEndDragHandler, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler{ 
            public OnBeginDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnEndDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerDown($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerUp($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public constructor();
        }
        export class TableLayoutGroup extends UnityEngine.UI.LayoutGroup implements UnityEngine.UI.ILayoutGroup, UnityEngine.UI.ILayoutElement, UnityEngine.UI.ILayoutController{ 
            public get StartCorner(): UnityEngine.UI.Extensions.TableLayoutGroup.Corner;
            public set StartCorner(value: UnityEngine.UI.Extensions.TableLayoutGroup.Corner);
            public get ColumnWidths(): System.Array$1<number>;
            public set ColumnWidths(value: System.Array$1<number>);
            public get MinimumRowHeight(): number;
            public set MinimumRowHeight(value: number);
            public get FlexibleRowHeight(): boolean;
            public set FlexibleRowHeight(value: boolean);
            public get ColumnSpacing(): number;
            public set ColumnSpacing(value: number);
            public get RowSpacing(): number;
            public set RowSpacing(value: number);
            public constructor();
        }
        export class TileSizeFitter extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.UI.ILayoutSelfController, UnityEngine.UI.ILayoutController{ 
            public get Border(): UnityEngine.Vector2;
            public set Border(value: UnityEngine.Vector2);
            public get TileSize(): UnityEngine.Vector2;
            public set TileSize(value: UnityEngine.Vector2);
            public SetLayoutHorizontal():void;
            public SetLayoutVertical():void;
            public constructor();
        }
        export class UIVerticalScroller extends UnityEngine.MonoBehaviour{ 
            public scrollRect: UnityEngine.UI.ScrollRect;
            public center: UnityEngine.RectTransform;
            public elementSize: UnityEngine.RectTransform;
            public elementShrinkage: UnityEngine.Vector2;
            public minScale: UnityEngine.Vector2;
            public startingIndex: number;
            public stopMomentumOnEnd: boolean;
            public disableUnfocused: boolean;
            public scrollUpButton: UnityEngine.GameObject;
            public scrollDownButton: UnityEngine.GameObject;
            public OnButtonClicked: UnityEngine.UI.Extensions.UIVerticalScroller.IntEvent;
            public OnFocusChanged: UnityEngine.UI.Extensions.UIVerticalScroller.IntEvent;
            public _arrayOfElements: System.Array$1<UnityEngine.GameObject>;
            public get focusedElementIndex(): number;
            public get result(): string;
            public get scrollingPanel(): UnityEngine.RectTransform;
            public Awake():void;
            public updateChildren($startingIndex?: number, $arrayOfElements?: System.Array$1<UnityEngine.GameObject>):void;
            public Start():void;
            public Update():void;
            public SnapToElement($element: number):void;
            public ScrollUp():void;
            public ScrollDown():void;
            public constructor();
            public constructor($center: UnityEngine.RectTransform, $elementSize: UnityEngine.RectTransform, $scrollRect: UnityEngine.UI.ScrollRect, $arrayOfElements: System.Array$1<UnityEngine.GameObject>);
        }
        export class VerticalScrollSnap extends UnityEngine.UI.Extensions.ScrollSnapBase implements UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEndDragHandler, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.UI.Extensions.IScrollSnap, UnityEngine.EventSystems.IPointerClickHandler{ 
            public DistributePages():void;
            public AddChild($GO: UnityEngine.GameObject):void;
            public AddChild($GO: UnityEngine.GameObject, $WorldPositionStays: boolean):void;
            public RemoveChild($index: number, $ChildRemoved: $Ref<UnityEngine.GameObject>):void;
            public RemoveChild($index: number, $WorldPositionStays: boolean, $ChildRemoved: $Ref<UnityEngine.GameObject>):void;
            public RemoveAllChildren($ChildrenRemoved: $Ref<System.Array$1<UnityEngine.GameObject>>):void;
            public RemoveAllChildren($WorldPositionStays: boolean, $ChildrenRemoved: $Ref<System.Array$1<UnityEngine.GameObject>>):void;
            public UpdateLayout():void;
            public constructor();
        }
        export class Menu extends UnityEngine.MonoBehaviour{ 
            public DestroyWhenClosed: boolean;
            public DisableMenusUnderneath: boolean;
            public OnBackPressed():void;
        }
        export class MenuManager extends UnityEngine.MonoBehaviour{ 
            public get MenuScreens(): System.Array$1<UnityEngine.UI.Extensions.Menu>;
            public set MenuScreens(value: System.Array$1<UnityEngine.UI.Extensions.Menu>);
            public get StartScreen(): number;
            public set StartScreen(value: number);
            public static get Instance(): UnityEngine.UI.Extensions.MenuManager;
            public static set Instance(value: UnityEngine.UI.Extensions.MenuManager);
            public CreateInstance($MenuName: string):UnityEngine.GameObject;
            public CreateInstance($MenuName: string, $menuInstance: $Ref<UnityEngine.GameObject>):void;
            public OpenMenu($menuInstance: UnityEngine.UI.Extensions.Menu):void;
            public CloseMenu($menu: UnityEngine.UI.Extensions.Menu):void;
            public CloseTopMenu():void;
            public constructor();
        }
        export class MenuExtensions extends System.Object{ 
            public static GetMenu($go: UnityEngine.GameObject):UnityEngine.UI.Extensions.Menu;
        }
        export class DiamondGraph extends UnityEngine.UI.Extensions.UIPrimitiveBase implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.ICanvasRaycastFilter, UnityEngine.UI.ICanvasElement, UnityEngine.UI.ILayoutElement, UnityEngine.UI.IClippable{ 
            public get A(): number;
            public set A(value: number);
            public get B(): number;
            public set B(value: number);
            public get C(): number;
            public set C(value: number);
            public get D(): number;
            public set D(value: number);
            public constructor();
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public IsRaycastLocationValid($screenPoint: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
        }
        export class UICircle extends UnityEngine.UI.Extensions.UIPrimitiveBase implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.ICanvasRaycastFilter, UnityEngine.UI.ICanvasElement, UnityEngine.UI.ILayoutElement, UnityEngine.UI.IClippable{ 
            public ArcInvert: boolean;
            public Arc: number;
            public ArcSteps: number;
            public ArcRotation: number;
            public Progress: number;
            public ProgressColor: UnityEngine.Color;
            public Fill: boolean;
            public Thickness: number;
            public Padding: number;
            public SetProgress($progress: number):void;
            public SetArcSteps($steps: number):void;
            public SetInvertArc($invert: boolean):void;
            public SetArcRotation($rotation: number):void;
            public SetFill($fill: boolean):void;
            public SetBaseColor($color: UnityEngine.Color):void;
            public UpdateBaseAlpha($value: number):void;
            public SetProgressColor($color: UnityEngine.Color):void;
            public UpdateProgressAlpha($value: number):void;
            public SetPadding($padding: number):void;
            public SetThickness($thickness: number):void;
            public constructor();
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public IsRaycastLocationValid($screenPoint: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
        }
        export class UICornerCut extends UnityEngine.UI.Extensions.UIPrimitiveBase implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.ICanvasRaycastFilter, UnityEngine.UI.ICanvasElement, UnityEngine.UI.ILayoutElement, UnityEngine.UI.IClippable{ 
            public cornerSize: UnityEngine.Vector2;
            public get CutUL(): boolean;
            public set CutUL(value: boolean);
            public get CutUR(): boolean;
            public set CutUR(value: boolean);
            public get CutLL(): boolean;
            public set CutLL(value: boolean);
            public get CutLR(): boolean;
            public set CutLR(value: boolean);
            public get MakeColumns(): boolean;
            public set MakeColumns(value: boolean);
            public get UseColorUp(): boolean;
            public set UseColorUp(value: boolean);
            public get ColorUp(): UnityEngine.Color32;
            public set ColorUp(value: UnityEngine.Color32);
            public get UseColorDown(): boolean;
            public set UseColorDown(value: boolean);
            public get ColorDown(): UnityEngine.Color32;
            public set ColorDown(value: UnityEngine.Color32);
            public constructor();
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public IsRaycastLocationValid($screenPoint: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
        }
        export class UIGridRenderer extends UnityEngine.UI.Extensions.UILineRenderer implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.ICanvasRaycastFilter, UnityEngine.UI.ICanvasElement, UnityEngine.UI.ILayoutElement, UnityEngine.UI.IClippable{ 
            public get GridColumns(): number;
            public set GridColumns(value: number);
            public get GridRows(): number;
            public set GridRows(value: number);
            public constructor();
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public IsRaycastLocationValid($screenPoint: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public IsRaycastLocationValid($screenPoint: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
        }
        export class UILineRendererList extends UnityEngine.UI.Extensions.UIPrimitiveBase implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.ICanvasRaycastFilter, UnityEngine.UI.ICanvasElement, UnityEngine.UI.ILayoutElement, UnityEngine.UI.IClippable{ 
            public LineJoins: UnityEngine.UI.Extensions.UILineRendererList.JoinType;
            public BezierMode: UnityEngine.UI.Extensions.UILineRendererList.BezierType;
            public drivenExternally: boolean;
            public get LineThickness(): number;
            public set LineThickness(value: number);
            public get RelativeSize(): boolean;
            public set RelativeSize(value: boolean);
            public get LineList(): boolean;
            public set LineList(value: boolean);
            public get LineCaps(): boolean;
            public set LineCaps(value: boolean);
            public get BezierSegmentsPerCurve(): number;
            public set BezierSegmentsPerCurve(value: number);
            public get Points(): System.Collections.Generic.List$1<UnityEngine.Vector2>;
            public set Points(value: System.Collections.Generic.List$1<UnityEngine.Vector2>);
            public AddPoint($pointToAdd: UnityEngine.Vector2):void;
            public RemovePoint($pointToRemove: UnityEngine.Vector2):void;
            public ClearPoints():void;
            public constructor();
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public IsRaycastLocationValid($screenPoint: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
        }
        export class UILineTextureRenderer extends UnityEngine.UI.Extensions.UIPrimitiveBase implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.ICanvasRaycastFilter, UnityEngine.UI.ICanvasElement, UnityEngine.UI.ILayoutElement, UnityEngine.UI.IClippable{ 
            public LineThickness: number;
            public UseMargins: boolean;
            public Margin: UnityEngine.Vector2;
            public relativeSize: boolean;
            public get uvRect(): UnityEngine.Rect;
            public set uvRect(value: UnityEngine.Rect);
            public get Points(): System.Array$1<UnityEngine.Vector2>;
            public set Points(value: System.Array$1<UnityEngine.Vector2>);
            public RotatePointAroundPivot($point: UnityEngine.Vector3, $pivot: UnityEngine.Vector3, $angles: UnityEngine.Vector3):UnityEngine.Vector3;
            public constructor();
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public IsRaycastLocationValid($screenPoint: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
        }
        export class UIPolygon extends UnityEngine.UI.Extensions.UIPrimitiveBase implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.ICanvasRaycastFilter, UnityEngine.UI.ICanvasElement, UnityEngine.UI.ILayoutElement, UnityEngine.UI.IClippable{ 
            public fill: boolean;
            public thickness: number;
            public sides: number;
            public rotation: number;
            public VerticesDistances: System.Array$1<number>;
            public DrawPolygon($_sides: number):void;
            public DrawPolygon($_sides: number, $_VerticesDistances: System.Array$1<number>):void;
            public DrawPolygon($_sides: number, $_VerticesDistances: System.Array$1<number>, $_rotation: number):void;
            public constructor();
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public IsRaycastLocationValid($screenPoint: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public IsRaycastLocationValid($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera):boolean;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
        }
        export enum ResolutionMode{ None = 0, PerSegment = 1, PerLine = 2 }
        export enum NavigationMode{ Auto = 0, Manual = 1 }
        export class TabNavigationHelper extends UnityEngine.MonoBehaviour{ 
            public NavigationPath: System.Array$1<UnityEngine.UI.Selectable>;
            public NavigationMode: UnityEngine.UI.Extensions.NavigationMode;
            public CircularNavigation: boolean;
            public Update():void;
            public constructor();
        }
        export class BoundTooltipItem extends UnityEngine.MonoBehaviour{ 
            public TooltipText: UnityEngine.UI.Text;
            public ToolTipOffset: UnityEngine.Vector3;
            public get IsActive(): boolean;
            public static get Instance(): UnityEngine.UI.Extensions.BoundTooltipItem;
            public ShowTooltip($text: string, $pos: UnityEngine.Vector3):void;
            public HideTooltip():void;
            public constructor();
        }
        export class BoundTooltipTrigger extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler{ 
            public text: string;
            public useMousePosition: boolean;
            public offset: UnityEngine.Vector3;
            public OnPointerEnter($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnSelect($eventData: UnityEngine.EventSystems.BaseEventData):void;
            public OnPointerExit($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnDeselect($eventData: UnityEngine.EventSystems.BaseEventData):void;
            public constructor();
        }
        export class HoverTooltip extends UnityEngine.MonoBehaviour{ 
            public horizontalPadding: number;
            public verticalPadding: number;
            public thisText: UnityEngine.UI.Text;
            public hlG: UnityEngine.UI.HorizontalLayoutGroup;
            public bgImage: UnityEngine.RectTransform;
            public SetTooltip($text: string):void;
            public SetTooltip($texts: System.Array$1<string>):void;
            public SetTooltip($text: string, $test: boolean):void;
            public OnScreenSpaceCamera():void;
            public HideTooltip():void;
            public ActivateTooltipVisibility():void;
            public HideTooltipVisibility():void;
            public constructor();
        }
        export class ToolTip extends UnityEngine.MonoBehaviour{ 
            public canvas: UnityEngine.Canvas;
            public tooltipTriggersCanForceCanvasUpdate: boolean;
            public YShift: number;
            public xShift: number;
            public guiMode: UnityEngine.RenderMode;
            public get GuiCamera(): UnityEngine.Camera;
            public static get Instance(): UnityEngine.UI.Extensions.ToolTip;
            public Awake():void;
            public SetTooltip($ttext: string, $basePos: UnityEngine.Vector3, $refreshCanvasesBeforeGetSize?: boolean):void;
            public HideTooltip():void;
            public RefreshTooltipSize():void;
            public ContextualTooltipUpdate($refreshCanvasesBeforeGettingSize?: boolean):void;
            public OnScreenSpaceCamera($refreshCanvasesBeforeGettingSize?: boolean):void;
            public OnScreenSpaceOverlay($refreshCanvasesBeforeGettingSize?: boolean):void;
            public constructor();
        }
        export class TooltipTrigger extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler{ 
            public text: string;
            public tooltipPositioningType: UnityEngine.UI.Extensions.TooltipTrigger.TooltipPositioningType;
            public offset: UnityEngine.Vector3;
            public get WorldToScreenIsRequired(): boolean;
            public OnPointerEnter($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnSelect($eventData: UnityEngine.EventSystems.BaseEventData):void;
            public OnPointerExit($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnDeselect($eventData: UnityEngine.EventSystems.BaseEventData):void;
            public constructor();
        }
        export class UIWindowBase extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEndDragHandler, UnityEngine.EventSystems.IEventSystemHandler{ 
            public static ResetCoords: boolean;
            public KeepWindowInCanvas: number;
            public RootTransform: UnityEngine.RectTransform;
            public OnDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnBeginDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnEndDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public constructor();
        }
        export class BezierPath extends System.Object{ 
            public SegmentsPerCurve: number;
            public MINIMUM_SQR_DISTANCE: number;
            public DIVISION_THRESHOLD: number;
            public SetControlPoints($newControlPoints: System.Collections.Generic.List$1<UnityEngine.Vector2>):void;
            public SetControlPoints($newControlPoints: System.Array$1<UnityEngine.Vector2>):void;
            public GetControlPoints():System.Collections.Generic.List$1<UnityEngine.Vector2>;
            public Interpolate($segmentPoints: System.Collections.Generic.List$1<UnityEngine.Vector2>, $scale: number):void;
            public SamplePoints($sourcePoints: System.Collections.Generic.List$1<UnityEngine.Vector2>, $minSqrDistance: number, $maxSqrDistance: number, $scale: number):void;
            public CalculateBezierPoint($curveIndex: number, $t: number):UnityEngine.Vector2;
            public GetDrawingPoints0():System.Collections.Generic.List$1<UnityEngine.Vector2>;
            public GetDrawingPoints1():System.Collections.Generic.List$1<UnityEngine.Vector2>;
            public GetDrawingPoints2():System.Collections.Generic.List$1<UnityEngine.Vector2>;
            public constructor();
        }
        export class CableCurve extends System.Object{ 
            public get regenPoints(): boolean;
            public set regenPoints(value: boolean);
            public get start(): UnityEngine.Vector2;
            public set start(value: UnityEngine.Vector2);
            public get end(): UnityEngine.Vector2;
            public set end(value: UnityEngine.Vector2);
            public get slack(): number;
            public set slack(value: number);
            public get steps(): number;
            public set steps(value: number);
            public get midPoint(): UnityEngine.Vector2;
            public Points():System.Array$1<UnityEngine.Vector2>;
            public constructor();
            public constructor($inputPoints: System.Array$1<UnityEngine.Vector2>);
            public constructor($inputPoints: System.Collections.Generic.List$1<UnityEngine.Vector2>);
            public constructor($v: UnityEngine.UI.Extensions.CableCurve);
        }
        export class Circle extends System.Object{ 
            public get X(): number;
            public set X(value: number);
            public get Y(): number;
            public set Y(value: number);
            public get Steps(): number;
            public set Steps(value: number);
            public Evaluate($t: number):UnityEngine.Vector2;
            public Evaluate($t: number, $eval: $Ref<UnityEngine.Vector2>):void;
            public constructor($radius: number);
            public constructor($radius: number, $steps: number);
            public constructor($xAxis: number, $yAxis: number);
            public constructor($xAxis: number, $yAxis: number, $steps: number);
            public constructor();
        }
        export class CLZF2 extends System.Object{ 
            public static Compress($inputBytes: System.Array$1<number>):System.Array$1<number>;
            public static Decompress($inputBytes: System.Array$1<number>):System.Array$1<number>;
            public static lzf_compress($input: System.Array$1<number>, $output: $Ref<System.Array$1<number>>):number;
            public static lzf_decompress($input: System.Array$1<number>, $output: $Ref<System.Array$1<number>>):number;
        }
        export class DragCorrector extends UnityEngine.MonoBehaviour{ 
            public baseTH: number;
            public basePPI: number;
            public dragTH: number;
            public constructor();
        }
        export class ExtentionMethods extends System.Object{ 
        }
        export class InputFieldEnterSubmit extends UnityEngine.MonoBehaviour{ 
            public EnterSubmit: UnityEngine.UI.Extensions.InputFieldEnterSubmit.EnterSubmitEvent;
            public defocusInput: boolean;
            public OnEndEdit($txt: string):void;
            public constructor();
        }
        export class NonDrawingGraphic extends UnityEngine.UI.MaskableGraphic implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.UI.ICanvasElement, UnityEngine.UI.IClippable{ 
            public constructor();
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public GetModifiedMaterial($baseMaterial: UnityEngine.Material):UnityEngine.Material;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public Cull($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($clipRect: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipRect($value: UnityEngine.Rect, $validRect: boolean):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public SetClipSoftness($clipSoftness: UnityEngine.Vector2):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($update: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
        export class PaginationManager extends UnityEngine.UI.ToggleGroup{ 
            public get CurrentPage(): number;
            public GoToScreen($pageNo: number):void;
        }
        export class PPIViewer extends UnityEngine.MonoBehaviour{ 
            public constructor();
        }
        export class ReadOnlyAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class ScrollConflictManager extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEndDragHandler, UnityEngine.EventSystems.IEventSystemHandler{ 
            public ParentScrollRect: UnityEngine.UI.ScrollRect;
            public ParentScrollSnap: UnityEngine.UI.Extensions.ScrollSnapBase;
            public OnBeginDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnEndDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public constructor();
        }
        export class ScrollRectEx extends UnityEngine.UI.ScrollRect implements UnityEngine.UI.ILayoutGroup, UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IInitializePotentialDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEndDragHandler, UnityEngine.UI.ICanvasElement, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IScrollHandler, UnityEngine.UI.ILayoutElement, UnityEngine.UI.ILayoutController{ 
            public constructor();
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
            public Rebuild($executing: UnityEngine.UI.CanvasUpdate):void;
        }
        export class ScrollRectExtensions extends System.Object{ 
            public static ScrollToTop($scrollRect: UnityEngine.UI.ScrollRect):void;
            public static ScrollToBottom($scrollRect: UnityEngine.UI.ScrollRect):void;
        }
        export class ScrollRectLinker extends UnityEngine.MonoBehaviour{ 
            public clamp: boolean;
            public constructor();
        }
        export class ScrollRectTweener extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEventSystemHandler{ 
            public moveSpeed: number;
            public disableDragWhileTweening: boolean;
            public ScrollHorizontal($normalizedX: number):void;
            public ScrollHorizontal($normalizedX: number, $duration: number):void;
            public ScrollVertical($normalizedY: number):void;
            public ScrollVertical($normalizedY: number, $duration: number):void;
            public Scroll($normalizedPos: UnityEngine.Vector2):void;
            public Scroll($normalizedPos: UnityEngine.Vector2, $duration: number):void;
            public EaseVector($currentTime: number, $startValue: UnityEngine.Vector2, $changeInValue: UnityEngine.Vector2, $duration: number):UnityEngine.Vector2;
            public OnDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public constructor();
        }
        export class SelectableScaler extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler{ 
            public animCurve: UnityEngine.AnimationCurve;
            public speed: number;
            public target: UnityEngine.Transform;
            public get Target(): UnityEngine.UI.Selectable;
            public OnPointerDown($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerUp($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public constructor();
        }
        export class RectTransformExtension extends System.Object{ 
            public static switchToRectTransform($from: UnityEngine.RectTransform, $to: UnityEngine.RectTransform):UnityEngine.Vector2;
        }
        export class UIExtensionMethods extends System.Object{ 
            public static GetParentCanvas($rt: UnityEngine.RectTransform):UnityEngine.Canvas;
            public static TransformInputBasedOnCanvasType($input: UnityEngine.Vector2, $canvas: UnityEngine.Canvas):UnityEngine.Vector2;
            public static TransformInputBasedOnCanvasType($input: UnityEngine.Vector2, $rt: UnityEngine.RectTransform):UnityEngine.Vector3;
            public static GetEventCamera($input: UnityEngine.Canvas):UnityEngine.Camera;
        }
        export class UIHighlightable extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler{ 
            public NormalColor: UnityEngine.Color;
            public HighlightedColor: UnityEngine.Color;
            public PressedColor: UnityEngine.Color;
            public DisabledColor: UnityEngine.Color;
            public OnInteractableChanged: UnityEngine.UI.Extensions.UIHighlightable.InteractableChangedEvent;
            public get Interactable(): boolean;
            public set Interactable(value: boolean);
            public get ClickToHold(): boolean;
            public set ClickToHold(value: boolean);
            public OnPointerEnter($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerExit($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerDown($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerUp($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public constructor();
        }
        export class UILineConnector extends UnityEngine.MonoBehaviour{ 
            public transforms: System.Array$1<UnityEngine.RectTransform>;
            public constructor();
        }
        export class UIScrollToSelection extends UnityEngine.MonoBehaviour{ 
            public constructor();
        }
        export class UIScrollToSelectionXY extends UnityEngine.MonoBehaviour{ 
            public scrollSpeed: number;
            public constructor();
        }
        export class UISelectableExtension extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler{ 
            public OnButtonPress: UnityEngine.UI.Extensions.UISelectableExtension.UIButtonEvent;
            public OnButtonRelease: UnityEngine.UI.Extensions.UISelectableExtension.UIButtonEvent;
            public OnButtonHeld: UnityEngine.UI.Extensions.UISelectableExtension.UIButtonEvent;
            public TestClicked():void;
            public TestPressed():void;
            public TestReleased():void;
            public TestHold():void;
            public constructor();
        }
        export class UI_InfiniteScroll extends UnityEngine.MonoBehaviour{ 
            public InitByUser: boolean;
            public Init():void;
            public OnScroll($pos: UnityEngine.Vector2):void;
            public constructor();
        }
        export class UI_ScrollRectOcclusion extends UnityEngine.MonoBehaviour{ 
            public InitByUser: boolean;
            public Init():void;
            public OnScroll($pos: UnityEngine.Vector2):void;
            public constructor();
        }
        export class UI_TweenScale extends UnityEngine.MonoBehaviour{ 
            public animCurve: UnityEngine.AnimationCurve;
            public speed: number;
            public isLoop: boolean;
            public playAtAwake: boolean;
            public isUniform: boolean;
            public animCurveY: UnityEngine.AnimationCurve;
            public Play():void;
            public ResetTween():void;
            public constructor();
        }
        export class VRCursor extends UnityEngine.MonoBehaviour{ 
            public xSens: number;
            public ySens: number;
            public constructor();
        }
        export class VRInputModule extends UnityEngine.EventSystems.BaseInputModule{ 
            public static targetObject: UnityEngine.GameObject;
            public static cursorPosition: UnityEngine.Vector3;
            public static PointerSubmit($obj: UnityEngine.GameObject):void;
            public static PointerExit($obj: UnityEngine.GameObject):void;
            public static PointerEnter($obj: UnityEngine.GameObject):void;
            public constructor();
        }
        export class Menu$1<T> extends UnityEngine.UI.Extensions.Menu{ 
        }
        export class SimpleMenu$1<T> extends UnityEngine.UI.Extensions.Menu$1<T>{ 
        }
    }
    export namespace DrawLine {
        export enum DemoMode{ DragDraw = 0, ClickDraw = 1, Follow = 2 }
    }
    export namespace UnityEngine.EventSystems.Extensions {
        export class AimerInputModule extends UnityEngine.EventSystems.PointerInputModule{ 
            public activateAxis: string;
            public aimerOffset: UnityEngine.Vector2;
            public static objectUnderAimer: UnityEngine.GameObject;
        }
    }
    export namespace UnityEngine.UI.Extensions.Accordion {
        export enum Transition{ Instant = 0, Tween = 1 }
    }
    export namespace UnityEngine.UI.Extensions.BoxSlider {
        export class BoxSliderEvent extends UnityEngine.Events.UnityEvent$2<number, number> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export enum Direction{ LeftToRight = 0, RightToLeft = 1, BottomToTop = 2, TopToBottom = 3 }
    }
    export namespace UnityEngine.UI.Extensions.AutoCompleteComboBox {
        export class SelectionTextChangedEvent extends UnityEngine.Events.UnityEvent$1<string> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class SelectionValidityChangedEvent extends UnityEngine.Events.UnityEvent$1<boolean> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class SelectionChangedEvent extends UnityEngine.Events.UnityEvent$2<string, boolean> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace UnityEngine.UI.Extensions.ComboBox {
        export class SelectionChangedEvent extends UnityEngine.Events.UnityEvent$1<string> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace UnityEngine.UI.Extensions.DropDownList {
        export class SelectionChangedEvent extends UnityEngine.Events.UnityEvent$1<number> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace UnityEngine.UI.Extensions.CooldownButton {
        export class CooldownButtonEvent extends UnityEngine.Events.UnityEvent$1<UnityEngine.EventSystems.PointerEventData.InputButton> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace UnityEngine.EventSystems.PointerEventData {
        export enum InputButton{ Left = 0, Right = 1, Middle = 2 }
    }
    export namespace UnityEngine.UI.Extensions.RadialSlider {
        export class RadialSliderValueChangedEvent extends UnityEngine.Events.UnityEvent$1<number> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class RadialSliderTextValueChangedEvent extends UnityEngine.Events.UnityEvent$1<string> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace UnityEngine.UI.Extensions.RangeSlider {
        export class RangeSliderEvent extends UnityEngine.Events.UnityEvent$2<number, number> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace UnityEngine.UI.Extensions.ReorderableList {
        export class ReorderableListHandler extends UnityEngine.Events.UnityEvent$1<UnityEngine.UI.Extensions.ReorderableList.ReorderableListEventStruct> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class ReorderableListEventStruct extends System.ValueType{ 
            public DroppedObject: UnityEngine.GameObject;
            public FromIndex: number;
            public FromList: UnityEngine.UI.Extensions.ReorderableList;
            public IsAClone: boolean;
            public SourceObject: UnityEngine.GameObject;
            public ToIndex: number;
            public ToList: UnityEngine.UI.Extensions.ReorderableList;
            public Cancel():void;
        }
    }
    export namespace UnityEngine.UI.Extensions.SegmentedControl {
        export class SegmentSelectedEvent extends UnityEngine.Events.UnityEvent$1<number> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace UnityEngine.UI.Extensions.SelectionBox {
        export class SelectionEvent extends UnityEngine.Events.UnityEvent$1<System.Array$1<UnityEngine.UI.Extensions.IBoxSelectable>> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace UnityEngine.UI.Extensions.Stepper {
        export class StepperValueChangedEvent extends UnityEngine.Events.UnityEvent$1<number> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace UnityEngine.UI.Extensions.TextPic {
        export class IconName extends System.ValueType{ 
            public name: string;
            public sprite: UnityEngine.Sprite;
            public offset: UnityEngine.Vector2;
            public scale: UnityEngine.Vector2;
        }
        export class HrefClickEvent extends UnityEngine.Events.UnityEvent$1<string> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class HrefInfo extends System.Object{ 
            public startIndex: number;
            public endIndex: number;
            public name: string;
            public boxes: System.Collections.Generic.List$1<UnityEngine.Rect>;
            public constructor();
        }
    }
    export namespace UnityEngine.UI.Extensions.UI_Knob {
        export enum Direction{ CW = 0, CCW = 1 }
    }
    export namespace UnityEngine.UI.Extensions.Gradient2 {
        export enum Blend{ Override = 0, Add = 1, Multiply = 2 }
        export enum Type{ Horizontal = 0, Vertical = 1, Radial = 2, Diamond = 3 }
    }
    export namespace UnityEngine.UI.Extensions.ContentScrollSnapHorizontal {
        export class MoveInfo extends System.ValueType{ 
            public indexType: UnityEngine.UI.Extensions.ContentScrollSnapHorizontal.MoveInfo.IndexType;
            public index: number;
            public jump: boolean;
            public duration: number;
            public constructor($_indexType: UnityEngine.UI.Extensions.ContentScrollSnapHorizontal.MoveInfo.IndexType, $_index: number);
            public constructor($_indexType: UnityEngine.UI.Extensions.ContentScrollSnapHorizontal.MoveInfo.IndexType, $_index: number, $_jump: boolean, $_duration: number);
            public constructor();
        }
        export class StartMovementEvent extends UnityEngine.Events.UnityEvent implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class CurrentItemChangeEvent extends UnityEngine.Events.UnityEvent$1<number> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class FoundItemToSnapToEvent extends UnityEngine.Events.UnityEvent$1<number> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class SnappedToItemEvent extends UnityEngine.Events.UnityEvent$1<number> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace UnityEngine.UI.Extensions.EasingCore {
        export enum Ease{ Linear = 0, InBack = 1, InBounce = 2, InCirc = 3, InCubic = 4, InElastic = 5, InExpo = 6, InQuad = 7, InQuart = 8, InQuint = 9, InSine = 10, OutBack = 11, OutBounce = 12, OutCirc = 13, OutCubic = 14, OutElastic = 15, OutExpo = 16, OutQuad = 17, OutQuart = 18, OutQuint = 19, OutSine = 20, InOutBack = 21, InOutBounce = 22, InOutCirc = 23, InOutCubic = 24, InOutElastic = 25, InOutExpo = 26, InOutQuad = 27, InOutQuart = 28, InOutQuint = 29, InOutSine = 30 }
        export type EasingFunction = (t: number) => number;
        var EasingFunction: {new (func: (t: number) => number): EasingFunction;}
        export class Easing extends System.Object{ 
            public static Get($type: UnityEngine.UI.Extensions.EasingCore.Ease):UnityEngine.UI.Extensions.EasingCore.EasingFunction;
        }
    }
    export namespace UnityEngine.UI.Extensions.FlowLayoutGroup {
        export enum Axis{ Horizontal = 0, Vertical = 1 }
    }
    export namespace UnityEngine.UI.Extensions.ScrollSnap {
        export enum ScrollDirection{ Horizontal = 0, Vertical = 1 }
        export type PageSnapChange = (page: number) => void;
        var PageSnapChange: {new (func: (page: number) => void): PageSnapChange;}
    }
    export namespace UnityEngine.UI.Extensions.ScrollSnapBase {
        export class SelectionChangeStartEvent extends UnityEngine.Events.UnityEvent implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class SelectionPageChangedEvent extends UnityEngine.Events.UnityEvent$1<number> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class SelectionChangeEndEvent extends UnityEngine.Events.UnityEvent$1<number> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace UnityEngine.UI.Extensions.TableLayoutGroup {
        export enum Corner{ UpperLeft = 0, UpperRight = 1, LowerLeft = 2, LowerRight = 3 }
    }
    export namespace UnityEngine.UI.Extensions.UIVerticalScroller {
        export class IntEvent extends UnityEngine.Events.UnityEvent$1<number> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace UnityEngine.UI.Extensions.UILineRenderer {
        export enum JoinType{ Bevel = 0, Miter = 1 }
        export enum BezierType{ None = 0, Quick = 1, Basic = 2, Improved = 3, Catenary = 4 }
    }
    export namespace UnityEngine.UI.Extensions.UILineRendererList {
        export enum JoinType{ Bevel = 0, Miter = 1 }
        export enum BezierType{ None = 0, Quick = 1, Basic = 2, Improved = 3, Catenary = 4 }
    }
    export namespace UnityEngine.UI.Extensions.TooltipTrigger {
        export enum TooltipPositioningType{ mousePosition = 0, mousePositionAndFollow = 1, transformPosition = 2 }
    }
    export namespace UnityEngine.UI.Extensions.InputFieldEnterSubmit {
        export class EnterSubmitEvent extends UnityEngine.Events.UnityEvent$1<string> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace UnityEngine.UI.Extensions.UIHighlightable {
        export class InteractableChangedEvent extends UnityEngine.Events.UnityEvent$1<boolean> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace UnityEngine.UI.Extensions.UISelectableExtension {
        export class UIButtonEvent extends UnityEngine.Events.UnityEvent$1<UnityEngine.EventSystems.PointerEventData.InputButton> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace UnityEngine.UI.Extensions.ColorPicker {
        export class ColorImage extends UnityEngine.MonoBehaviour{ 
            public picker: UnityEngine.UI.Extensions.ColorPicker.ColorPickerControl;
            public constructor();
        }
        export class ColorPickerControl extends UnityEngine.MonoBehaviour{ 
            public onValueChanged: ColorChangedEvent;
            public onHSVChanged: HSVChangedEvent;
            public get CurrentColor(): UnityEngine.Color;
            public set CurrentColor(value: UnityEngine.Color);
            public get H(): number;
            public set H(value: number);
            public get S(): number;
            public set S(value: number);
            public get V(): number;
            public set V(value: number);
            public get R(): number;
            public set R(value: number);
            public get G(): number;
            public set G(value: number);
            public get B(): number;
            public set B(value: number);
            public SetHSVSlidersOn($value: boolean):void;
            public SetRGBSlidersOn($value: boolean):void;
            public AssignColor($type: UnityEngine.UI.Extensions.ColorPicker.ColorValues, $value: number):void;
            public GetValue($type: UnityEngine.UI.Extensions.ColorPicker.ColorValues):number;
            public constructor();
        }
        export class ColorLabel extends UnityEngine.MonoBehaviour{ 
            public picker: UnityEngine.UI.Extensions.ColorPicker.ColorPickerControl;
            public type: UnityEngine.UI.Extensions.ColorPicker.ColorValues;
            public prefix: string;
            public minValue: number;
            public maxValue: number;
            public precision: number;
            public constructor();
        }
        export enum ColorValues{ R = 0, G = 1, B = 2, A = 3, Hue = 4, Saturation = 5, Value = 6 }
        export class ColorPickerPresets extends UnityEngine.MonoBehaviour{ 
            public picker: UnityEngine.UI.Extensions.ColorPicker.ColorPickerControl;
            public createPresetImage: UnityEngine.UI.Image;
            public createButton: UnityEngine.Transform;
            public saveMode: UnityEngine.UI.Extensions.ColorPicker.ColorPickerPresets.SaveType;
            public get JsonFilePath(): string;
            public CreatePresetButton():void;
            public LoadPresets($saveType: UnityEngine.UI.Extensions.ColorPicker.ColorPickerPresets.SaveType):void;
            public SavePresets($saveType: UnityEngine.UI.Extensions.ColorPicker.ColorPickerPresets.SaveType):void;
            public CreatePreset($color: UnityEngine.Color, $loading: boolean):void;
            public CreatePreset($color: UnityEngine.Color):void;
            public PresetSelect($sender: UnityEngine.UI.Image):void;
            public constructor();
        }
        export class ColorPickerTester extends UnityEngine.MonoBehaviour{ 
            public pickerRenderer: UnityEngine.Renderer;
            public picker: UnityEngine.UI.Extensions.ColorPicker.ColorPickerControl;
            public constructor();
        }
        export class ColorSampler extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler{ 
            public oncolorSelected: ColorChangedEvent;
            public OnPointerDown($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnPointerUp($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public OnDrag($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public constructor();
        }
        export class ColorSlider extends UnityEngine.MonoBehaviour{ 
            public ColorPicker: UnityEngine.UI.Extensions.ColorPicker.ColorPickerControl;
            public type: UnityEngine.UI.Extensions.ColorPicker.ColorValues;
            public constructor();
        }
        export class ColorSliderImage extends UnityEngine.MonoBehaviour{ 
            public picker: UnityEngine.UI.Extensions.ColorPicker.ColorPickerControl;
            public type: UnityEngine.UI.Extensions.ColorPicker.ColorValues;
            public direction: UnityEngine.UI.Slider.Direction;
            public constructor();
        }
        export class HexColorField extends UnityEngine.MonoBehaviour{ 
            public ColorPicker: UnityEngine.UI.Extensions.ColorPicker.ColorPickerControl;
            public displayAlpha: boolean;
            public static HexToColor($hex: string, $color: $Ref<UnityEngine.Color32>):boolean;
            public constructor();
        }
        export class HSVUtil extends System.Object{ 
            public static ConvertRgbToHsv($color: UnityEngine.Color):UnityEngine.UI.Extensions.ColorPicker.HsvColor;
            public static ConvertRgbToHsv($r: number, $b: number, $g: number):UnityEngine.UI.Extensions.ColorPicker.HsvColor;
            public static ConvertHsvToRgb($h: number, $s: number, $v: number, $alpha: number):UnityEngine.Color;
        }
        export class HsvColor extends System.ValueType{ 
            public H: number;
            public S: number;
            public V: number;
            public get NormalizedH(): number;
            public set NormalizedH(value: number);
            public get NormalizedS(): number;
            public set NormalizedS(value: number);
            public get NormalizedV(): number;
            public set NormalizedV(value: number);
            public constructor($h: number, $s: number, $v: number);
            public constructor();
        }
        export class SVBoxSlider extends UnityEngine.MonoBehaviour{ 
            public picker: UnityEngine.UI.Extensions.ColorPicker.ColorPickerControl;
            public get RectTransform(): UnityEngine.RectTransform;
            public constructor();
        }
    }
    export namespace UnityEngine.UI.Extensions.ColorPicker.ColorPickerPresets {
        export enum SaveType{ None = 0, PlayerPrefs = 1, JsonFile = 2 }
    }
    export namespace UnityEngine.UI.Extensions.Tweens {
        export class FloatTween extends System.ValueType implements UnityEngine.UI.Extensions.Tweens.ITweenValue{ 
            public get startFloat(): number;
            public set startFloat(value: number);
            public get targetFloat(): number;
            public set targetFloat(value: number);
            public get duration(): number;
            public set duration(value: number);
            public get ignoreTimeScale(): boolean;
            public set ignoreTimeScale(value: boolean);
            public TweenValue($floatPercentage: number):void;
            public AddOnChangedCallback($callback: UnityEngine.Events.UnityAction$1<number>):void;
            public AddOnFinishCallback($callback: UnityEngine.Events.UnityAction):void;
            public GetIgnoreTimescale():boolean;
            public GetDuration():number;
            public ValidTarget():boolean;
            public Finished():void;
        }
        export interface ITweenValue{ 
        }
    }
    export namespace UnityEngine.UI.Extensions.Examples {
        export class ComboBoxChanged extends UnityEngine.MonoBehaviour{ 
            public ComboBoxChangedEvent($text: string):void;
            public AutoCompleteComboBoxChangedEvent($text: string):void;
            public AutoCompleteComboBoxSelectionChangedEvent($text: string, $valid: boolean):void;
            public DropDownChangedEvent($newValue: number):void;
            public constructor();
        }
        export class CooldownEffect_Image extends UnityEngine.MonoBehaviour{ 
            public cooldown: UnityEngine.UI.Extensions.CooldownButton;
            public displayText: UnityEngine.UI.Text;
            public constructor();
        }
        export class CooldownEffect_SAUIM extends UnityEngine.MonoBehaviour{ 
            public cooldown: UnityEngine.UI.Extensions.CooldownButton;
            public constructor();
        }
        export class PaginationScript extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerClickHandler{ 
            public hss: UnityEngine.UI.Extensions.HorizontalScrollSnap;
            public Page: number;
            public OnPointerClick($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public constructor();
        }
        export class UpdateScrollSnap extends UnityEngine.MonoBehaviour{ 
            public HSS: UnityEngine.UI.Extensions.HorizontalScrollSnap;
            public VSS: UnityEngine.UI.Extensions.VerticalScrollSnap;
            public HorizontalPagePrefab: UnityEngine.GameObject;
            public VerticalPagePrefab: UnityEngine.GameObject;
            public JumpPage: UnityEngine.UI.InputField;
            public AddButton():void;
            public RemoveButton():void;
            public JumpToPage():void;
            public SelectionStartChange():void;
            public SelectionEndChange():void;
            public PageChange($page: number):void;
            public RemoveAll():void;
            public JumpToSelectedToggle($page: number):void;
            public constructor();
        }
        export class AwesomeMenu extends UnityEngine.UI.Extensions.Menu$1<UnityEngine.UI.Extensions.Examples.AwesomeMenu>{ 
            public Background: UnityEngine.UI.Image;
            public Title: UnityEngine.UI.Text;
            public static Show($awesomeness: number):void;
            public static Hide():void;
            public constructor();
        }
        export class GameMenu extends UnityEngine.UI.Extensions.SimpleMenu$1<UnityEngine.UI.Extensions.Examples.GameMenu>{ 
            public constructor();
        }
        export class MainMenu extends UnityEngine.UI.Extensions.SimpleMenu$1<UnityEngine.UI.Extensions.Examples.MainMenu>{ 
            public OnPlayPressed():void;
            public OnOptionsPressed():void;
            public constructor();
        }
        export class OptionsMenu extends UnityEngine.UI.Extensions.SimpleMenu$1<UnityEngine.UI.Extensions.Examples.OptionsMenu>{ 
            public Slider: UnityEngine.UI.Slider;
            public OnMagicButtonPressed():void;
            public constructor();
        }
        export class PauseMenu extends UnityEngine.UI.Extensions.SimpleMenu$1<UnityEngine.UI.Extensions.Examples.PauseMenu>{ 
            public OnQuitPressed():void;
            public constructor();
        }
        export class UpdateRadialValue extends UnityEngine.MonoBehaviour{ 
            public input: UnityEngine.UI.InputField;
            public slider: UnityEngine.UI.Extensions.RadialSlider;
            public UpdateSliderValue():void;
            public UpdateSliderAndle():void;
            public constructor();
        }
        export class AnimateEffects extends UnityEngine.MonoBehaviour{ 
            public letterSpacing: UnityEngine.UI.Extensions.LetterSpacing;
            public curvedText: UnityEngine.UI.Extensions.CurvedText;
            public gradient2: UnityEngine.UI.Extensions.Gradient2;
            public cylinderText: UnityEngine.UI.Extensions.CylinderText;
            public SAUIM: UnityEngine.UI.Extensions.SoftMaskScript;
            public constructor();
        }
        export class testHref extends UnityEngine.MonoBehaviour{ 
            public textPic: UnityEngine.UI.Extensions.TextPic;
            public constructor();
        }
        export class LineRendererOrbit extends UnityEngine.MonoBehaviour{ 
            public OrbitGO: UnityEngine.GameObject;
            public get xAxis(): number;
            public set xAxis(value: number);
            public get yAxis(): number;
            public set yAxis(value: number);
            public get Steps(): number;
            public set Steps(value: number);
            public constructor();
        }
        export class LineRendererOrbitList extends UnityEngine.MonoBehaviour{ 
            public OrbitGO: UnityEngine.GameObject;
            public get xAxis(): number;
            public set xAxis(value: number);
            public get yAxis(): number;
            public set yAxis(value: number);
            public get Steps(): number;
            public set Steps(value: number);
            public constructor();
        }
        export class TestAddingPoints extends UnityEngine.MonoBehaviour{ 
            public LineRenderer: UnityEngine.UI.Extensions.UILineRenderer;
            public XValue: UnityEngine.UI.Text;
            public YValue: UnityEngine.UI.Text;
            public AddNewPoint():void;
            public ClearPoints():void;
            public constructor();
        }
        export class TestAddingPointsList extends UnityEngine.MonoBehaviour{ 
            public LineRenderer: UnityEngine.UI.Extensions.UILineRendererList;
            public XValue: UnityEngine.UI.Text;
            public YValue: UnityEngine.UI.Text;
            public AddNewPoint():void;
            public ClearPoints():void;
            public constructor();
        }
        export class ScrollingCalendar extends UnityEngine.MonoBehaviour{ 
            public monthsScrollingPanel: UnityEngine.RectTransform;
            public yearsScrollingPanel: UnityEngine.RectTransform;
            public daysScrollingPanel: UnityEngine.RectTransform;
            public monthsScrollRect: UnityEngine.UI.ScrollRect;
            public yearsScrollRect: UnityEngine.UI.ScrollRect;
            public daysScrollRect: UnityEngine.UI.ScrollRect;
            public yearsButtonPrefab: UnityEngine.GameObject;
            public monthsButtonPrefab: UnityEngine.GameObject;
            public daysButtonPrefab: UnityEngine.GameObject;
            public monthCenter: UnityEngine.RectTransform;
            public yearsCenter: UnityEngine.RectTransform;
            public daysCenter: UnityEngine.RectTransform;
            public inputFieldDays: UnityEngine.UI.InputField;
            public inputFieldMonths: UnityEngine.UI.InputField;
            public inputFieldYears: UnityEngine.UI.InputField;
            public dateText: UnityEngine.UI.Text;
            public Awake():void;
            public SetDate():void;
            public DaysScrollUp():void;
            public DaysScrollDown():void;
            public MonthsScrollUp():void;
            public MonthsScrollDown():void;
            public YearsScrollUp():void;
            public YearsScrollDown():void;
            public constructor();
        }
    }
    export namespace UnityEngine.UI.Extensions.Examples.FancyScrollViewExample08 {
        export class ItemData extends System.Object{ 
            public get Index(): number;
            public constructor($index: number);
            public constructor();
        }
    }
    export namespace UnityEngine.UI.Extensions.Examples.FancyScrollViewExample07 {
        export class ItemData extends System.Object{ 
            public get Message(): string;
            public constructor($message: string);
            public constructor();
        }
    }
    export namespace UnityEngine.UI.Extensions.Examples.FancyScrollViewExample06 {
        export class ItemData extends System.Object{ 
            public get Message(): string;
            public constructor($message: string);
            public constructor();
        }
    }
    export namespace UnityEngine.UI.Extensions.Examples.FancyScrollViewExample05 {
        export class ItemData extends System.Object{ 
            public get Message(): string;
            public constructor($message: string);
            public constructor();
        }
    }
    export namespace UnityEngine.UI.Extensions.Examples.FancyScrollViewExample04 {
        export class ItemData extends System.Object{ 
            public get Message(): string;
            public constructor($message: string);
            public constructor();
        }
    }
    export namespace UnityEngine.UI.Extensions.Examples.FancyScrollViewExample03 {
        export class ItemData extends System.Object{ 
            public get Message(): string;
            public constructor($message: string);
            public constructor();
        }
    }
    export namespace UnityEngine.UI.Extensions.Examples.FancyScrollViewExample02 {
        export class ItemData extends System.Object{ 
            public get Message(): string;
            public constructor($message: string);
            public constructor();
        }
    }
    export namespace UnityEngine.UI.Extensions.Examples.FancyScrollViewExample01 {
        export class ItemData extends System.Object{ 
            public get Message(): string;
            public constructor($message: string);
            public constructor();
        }
    }
    export namespace SQLiteNetExtensions.Extensions {
        export class ReadOperations extends System.Object{ 
            public static EnableRuntimeAssertions: boolean;
        }
        export enum EnclosedType{ None = 0, Array = 1, List = 2, ObservableCollection = 3 }
        export class ManyToManyMetaInfo extends System.Object{ 
            public get IntermediateType(): System.Type;
            public set IntermediateType(value: System.Type);
            public get OriginProperty(): System.Reflection.PropertyInfo;
            public set OriginProperty(value: System.Reflection.PropertyInfo);
            public get DestinationProperty(): System.Reflection.PropertyInfo;
            public set DestinationProperty(value: System.Reflection.PropertyInfo);
            public constructor();
        }
        export class ReflectionExtensions extends System.Object{ 
            public static GetEntityType($property: System.Reflection.PropertyInfo, $enclosedType: $Ref<SQLiteNetExtensions.Extensions.EnclosedType>):System.Type;
            public static GetDefault($type: System.Type):any;
            public static GetForeignKeyProperty($type: System.Type, $relationshipProperty: System.Reflection.PropertyInfo, $intermediateType?: System.Type, $inverse?: boolean):System.Reflection.PropertyInfo;
            public static GetInverseProperty($elementType: System.Type, $property: System.Reflection.PropertyInfo):System.Reflection.PropertyInfo;
            public static GetManyToManyMetaInfo($type: System.Type, $relationship: System.Reflection.PropertyInfo):SQLiteNetExtensions.Extensions.ManyToManyMetaInfo;
            public static GetRelationshipProperties($type: System.Type):System.Collections.Generic.List$1<System.Reflection.PropertyInfo>;
            public static GetPrimaryKey($type: System.Type):System.Reflection.PropertyInfo;
            public static GetTableName($type: System.Type):string;
            public static GetColumnName($property: System.Reflection.PropertyInfo):string;
        }
        export class WriteOperations extends System.Object{ 
            public static EnableRuntimeAssertions: boolean;
            public static UpdateWithChildren($conn: SqlCipher4Unity3D.SQLiteConnection, $element: any):void;
            public static InsertWithChildren($conn: SqlCipher4Unity3D.SQLiteConnection, $element: any, $recursive?: boolean):void;
            public static InsertOrReplaceWithChildren($conn: SqlCipher4Unity3D.SQLiteConnection, $element: any, $recursive?: boolean):void;
            public static InsertAllWithChildren($conn: SqlCipher4Unity3D.SQLiteConnection, $elements: System.Collections.IEnumerable, $recursive?: boolean):void;
            public static InsertOrReplaceAllWithChildren($conn: SqlCipher4Unity3D.SQLiteConnection, $elements: System.Collections.IEnumerable, $recursive?: boolean):void;
            public static DeleteAll($conn: SqlCipher4Unity3D.SQLiteConnection, $objects: System.Collections.IEnumerable, $recursive?: boolean):void;
            public static Delete($conn: SqlCipher4Unity3D.SQLiteConnection, $element: any, $recursive: boolean):void;
        }
    }
    export namespace SqlCipher4Unity3D {
        export class SQLiteConnection extends System.Object implements System.IDisposable{ 
        }
        interface SQLiteConnection {
            UpdateWithChildren($element: any):void;
            InsertWithChildren($element: any, $recursive?: boolean):void;
            InsertOrReplaceWithChildren($element: any, $recursive?: boolean):void;
            InsertAllWithChildren($elements: System.Collections.IEnumerable, $recursive?: boolean):void;
            InsertOrReplaceAllWithChildren($elements: System.Collections.IEnumerable, $recursive?: boolean):void;
            DeleteAll($objects: System.Collections.IEnumerable, $recursive?: boolean):void;
            Delete($element: any, $recursive: boolean):void;
        }
    }
    export namespace SQLiteNetExtensions.Extensions.TextBlob {
        export interface ITextBlobSerializer{ 
            Serialize($element: any):string;
            Deserialize($text: string, $type: System.Type):any;
        }
        export class TextBlobOperations extends System.Object{ 
            public static SetTextSerializer($serializer: SQLiteNetExtensions.Extensions.TextBlob.ITextBlobSerializer):void;
            public static GetTextSerializer():SQLiteNetExtensions.Extensions.TextBlob.ITextBlobSerializer;
            public static GetTextBlobChild($element: any, $relationshipProperty: System.Reflection.PropertyInfo):void;
            public static UpdateTextBlobProperty($element: any, $relationshipProperty: System.Reflection.PropertyInfo):void;
        }
    }
    export namespace SQLiteNetExtensions.Extensions.TextBlob.Serializers {
        export class JsonBlobSerializer extends System.Object implements SQLiteNetExtensions.Extensions.TextBlob.ITextBlobSerializer{ 
            public Serialize($element: any):string;
            public Deserialize($text: string, $type: System.Type):any;
            public constructor();
            public Serialize($element: any):string;
            public Deserialize($text: string, $type: System.Type):any;
        }
    }
    export namespace SQLiteNetExtensions.Exceptions {
        export class IncorrectRelationshipException extends System.Exception implements System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable{ 
            public get PropertyName(): string;
            public set PropertyName(value: string);
            public get TypeName(): string;
            public set TypeName(value: string);
            public constructor($typeName: string, $propertyName: string, $message: string);
            public constructor();
        }
    }
    export namespace SQLiteNetExtensions.Attributes {
        export enum CascadeOperation{ None = 0, CascadeRead = 2, CascadeInsert = 4, CascadeDelete = 8, All = 14 }
        export class ForeignKeyAttribute extends SQLite.Attributes.IndexedAttribute implements System.Runtime.InteropServices._Attribute{ 
            public get ForeignType(): System.Type;
            public constructor($foreignType: System.Type);
            public constructor();
        }
        export class ManyToManyAttribute extends SQLiteNetExtensions.Attributes.RelationshipAttribute implements System.Runtime.InteropServices._Attribute{ 
            public get IntermediateType(): System.Type;
            public constructor($intermediateType: System.Type, $inverseForeignKey?: string, $inverseProperty?: string);
            public constructor();
        }
        export class RelationshipAttribute extends SQLite.Attributes.IgnoreAttribute implements System.Runtime.InteropServices._Attribute{ 
            public get ForeignKey(): string;
            public get InverseProperty(): string;
            public get InverseForeignKey(): string;
            public get CascadeOperations(): SQLiteNetExtensions.Attributes.CascadeOperation;
            public set CascadeOperations(value: SQLiteNetExtensions.Attributes.CascadeOperation);
            public get ReadOnly(): boolean;
            public set ReadOnly(value: boolean);
            public get IsCascadeRead(): boolean;
            public get IsCascadeInsert(): boolean;
            public get IsCascadeDelete(): boolean;
        }
        export class ManyToOneAttribute extends SQLiteNetExtensions.Attributes.RelationshipAttribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor($foreignKey?: string, $inverseProperty?: string);
            public constructor();
        }
        export class OneToManyAttribute extends SQLiteNetExtensions.Attributes.RelationshipAttribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor($inverseForeignKey?: string, $inverseProperty?: string);
            public constructor();
        }
        export class OneToOneAttribute extends SQLiteNetExtensions.Attributes.RelationshipAttribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor($foreignKey?: string, $inverseProperty?: string);
            public constructor();
        }
        export class TextBlobAttribute extends SQLiteNetExtensions.Attributes.RelationshipAttribute implements System.Runtime.InteropServices._Attribute{ 
            public get TextProperty(): string;
            public get CascadeOperations(): SQLiteNetExtensions.Attributes.CascadeOperation;
            public constructor($textProperty: string);
            public constructor();
        }
    }
    export namespace SQLite.Attributes {
        export class IndexedAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
        }
        export class IgnoreAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
        }
    }
    export namespace qtools.qhierarchy {
        export class QObjectList extends UnityEngine.MonoBehaviour implements UnityEngine.ISerializationCallbackReceiver{ 
            public static instances: System.Collections.Generic.List$1<qtools.qhierarchy.QObjectList>;
            public lockedObjects: System.Collections.Generic.List$1<UnityEngine.GameObject>;
            public editModeVisibileObjects: System.Collections.Generic.List$1<UnityEngine.GameObject>;
            public editModeInvisibleObjects: System.Collections.Generic.List$1<UnityEngine.GameObject>;
            public wireframeHiddenObjects: System.Collections.Generic.List$1<UnityEngine.GameObject>;
            public gameObjectColor: System.Collections.Generic.Dictionary$2<UnityEngine.GameObject, UnityEngine.Color>;
            public gameObjectColorKeys: System.Collections.Generic.List$1<UnityEngine.GameObject>;
            public gameObjectColorValues: System.Collections.Generic.List$1<UnityEngine.Color>;
            public Awake():void;
            public OnEnable():void;
            public OnDestroy():void;
            public merge($anotherInstance: qtools.qhierarchy.QObjectList):void;
            public checkIntegrity():void;
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
            public constructor();
        }
    }
    export namespace FlowCanvas {
        export class BinderConnection extends NodeCanvas.Framework.Connection implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public get sourcePortID(): string;
            public get targetPortID(): string;
            public get sourcePort(): FlowCanvas.Port;
            public get targetPort(): FlowCanvas.Port;
            public get bindingType(): System.Type;
            public get tipConnectionStyle(): NodeCanvas.Framework.Connection.TipConnectionStyle;
            public get direction(): ParadoxNotion.PlanarDirection;
            public get defaultColor(): UnityEngine.Color;
            public get defaultSize(): number;
            public static Create($source: FlowCanvas.Port, $target: FlowCanvas.Port):FlowCanvas.BinderConnection;
            public SetSourcePort($newSourcePort: FlowCanvas.Port):void;
            public SetTargetPort($newTargetPort: FlowCanvas.Port):void;
            public GatherAndValidateSourcePort():void;
            public GatherAndValidateTargetPort():void;
            public static CanBeBound($source: FlowCanvas.Port, $target: FlowCanvas.Port, $refConnection: FlowCanvas.BinderConnection):boolean;
            public static CanBeBoundVerbosed($source: FlowCanvas.Port, $target: FlowCanvas.Port, $refConnection: FlowCanvas.BinderConnection, $verbose: $Ref<string>):boolean;
            public Bind():void;
            public UnBind():void;
            public constructor();
            public static Create($source: NodeCanvas.Framework.Node, $target: NodeCanvas.Framework.Node, $sourceIndex?: number, $targetIndex?: number):NodeCanvas.Framework.Connection;
        }
        export class Port extends System.Object{ 
            public get parent(): FlowCanvas.FlowNode;
            public get ID(): string;
            public get name(): string;
            public get connections(): number;
            public get isConnected(): boolean;
            public get type(): System.Type;
            public CanAcceptConnections():boolean;
            public GetPortConnections():System.Collections.Generic.IEnumerable$1<FlowCanvas.BinderConnection>;
            public GetFirstInputConnection():FlowCanvas.BinderConnection;
            public GetFirstOutputConnection():FlowCanvas.BinderConnection;
            public IsFlowPort():boolean;
            public IsValuePort():boolean;
            public IsInputPort():boolean;
            public IsOutputPort():boolean;
            public IsUnityObject():boolean;
            public IsUnitySceneObject():boolean;
            public IsDelegate():boolean;
            public IsEnumerableCollection():boolean;
            public IsWild():boolean;
        }
        export type FlowHandler = (f: FlowCanvas.Flow) => void;
        var FlowHandler: {new (func: (f: FlowCanvas.Flow) => void): FlowHandler;}
        export class Flow extends System.ValueType{ 
            public eventNode: FlowCanvas.Nodes.EventNode;
            public get ticks(): number;
            public static get New(): FlowCanvas.Flow;
            public Call($port: FlowCanvas.FlowOutput):void;
            public SetReturnData($call: FlowCanvas.FlowReturn, $expectedType: System.Type):void;
            public Return($value: any, $context: FlowCanvas.FlowNode):void;
            public BeginBreakBlock($callback: FlowCanvas.FlowBreak):void;
            public EndBreakBlock():void;
            public Break($context: FlowCanvas.FlowNode):void;
        }
        export type ValueHandlerObject = () => any;
        var ValueHandlerObject: {new (func: () => any): ValueHandlerObject;}
        export type FlowBreak = () => void;
        var FlowBreak: {new (func: () => void): FlowBreak;}
        export type FlowReturn = (value: any) => void;
        var FlowReturn: {new (func: (value: any) => void): FlowReturn;}
        export class FlowNode extends NodeCanvas.Framework.Node implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get maxInConnections(): number;
            public get maxOutConnections(): number;
            public get allowAsPrime(): boolean;
            public get canSelfConnect(): boolean;
            public get outConnectionType(): System.Type;
            public get commentsAlignment(): ParadoxNotion.Alignment2x2;
            public get iconAlignment(): ParadoxNotion.Alignment2x2;
            public get flowGraph(): FlowCanvas.FlowGraph;
            public get ignoreSelfInstancePortAssignment(): boolean;
            public OnPortConnected($port: FlowCanvas.Port, $otherPort: FlowCanvas.Port):void;
            public OnPortDisconnected($port: FlowCanvas.Port, $otherPort: FlowCanvas.Port):void;
            public BindPorts():void;
            public UnBindPorts():void;
            public GetInputPort($ID: string):FlowCanvas.Port;
            public GetOutputPort($ID: string):FlowCanvas.Port;
            public GetAllPorts():System.Collections.Generic.IEnumerable$1<FlowCanvas.Port>;
            public GetOutputFlowPorts():System.Collections.Generic.IEnumerable$1<FlowCanvas.FlowOutput>;
            public GetOutputValuePorts():System.Collections.Generic.IEnumerable$1<FlowCanvas.ValueOutput>;
            public GetInputFlowPorts():System.Collections.Generic.IEnumerable$1<FlowCanvas.FlowInput>;
            public GetInputValuePorts():System.Collections.Generic.IEnumerable$1<FlowCanvas.ValueInput>;
            public GetFirstInputOfType($type: System.Type):FlowCanvas.Port;
            public GetFirstOutputOfType($type: System.Type):FlowCanvas.Port;
            public AssignSelfInstancePort():void;
            public GatherPorts():void;
            public AddFlowInput($name: string, $ID: string, $pointer: FlowCanvas.FlowHandler):FlowCanvas.FlowInput;
            public AddFlowInput($name: string, $pointer: FlowCanvas.FlowHandler, $ID?: string):FlowCanvas.FlowInput;
            public AddFlowOutput($name: string, $ID?: string):FlowCanvas.FlowOutput;
            public AddValueInput($name: string, $ID: string, $type: System.Type):FlowCanvas.ValueInput;
            public AddValueInput($name: string, $type: System.Type, $ID?: string):FlowCanvas.ValueInput;
            public AddValueOutput($name: string, $ID: string, $type: System.Type, $getter: FlowCanvas.ValueHandlerObject):FlowCanvas.ValueOutput;
            public AddValueOutput($name: string, $type: System.Type, $getter: FlowCanvas.ValueHandlerObject, $ID?: string):FlowCanvas.ValueOutput;
            public TryAddReflectionBasedRegistrationForObject($instance: any):void;
            public TryAddMethodFlowInput($method: System.Reflection.MethodInfo, $instance: any):FlowCanvas.FlowInput;
            public TryAddFieldDelegateFlowOutput($field: System.Reflection.FieldInfo, $instance: any):FlowCanvas.FlowOutput;
            public TryAddFieldDelegateValueInput($field: System.Reflection.FieldInfo, $instance: any):FlowCanvas.ValueInput;
            public TryAddPropertyValueOutput($prop: System.Reflection.PropertyInfo, $instance: any):FlowCanvas.ValueOutput;
            public ReplaceWith($t: System.Type):FlowCanvas.FlowNode;
            public GetNodeWildDefinitionType():System.Type;
            public static TryGetNewGenericTypeForWild($wildType: System.Type, $currentType: System.Type, $targetType: System.Type, $content: System.Type, $context: System.Type):System.Type;
            public static TryGetNewGenericMethodForWild($wildType: System.Type, $currentType: System.Type, $targetType: System.Type, $content: System.Reflection.MethodInfo):System.Reflection.MethodInfo;
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
            public ReplaceWith($t: System.Type):null;
        }
        export class FlowOutput extends FlowCanvas.Port{ 
            public get type(): System.Type;
            public add_pointer($value: FlowCanvas.FlowHandler):void;
            public remove_pointer($value: FlowCanvas.FlowHandler):void;
            public Call($f: FlowCanvas.Flow):void;
            public BindTo($target: FlowCanvas.FlowInput):void;
            public Append($callback: FlowCanvas.FlowHandler):void;
            public UnBind():void;
            public constructor($parent: FlowCanvas.FlowNode, $name: string, $ID: string);
            public constructor();
        }
        export class FlowGraph extends NodeCanvas.Framework.Graph implements NodeCanvas.Framework.ITaskSystem, UnityEngine.ISerializationCallbackReceiver{ 
            public get baseNodeType(): System.Type;
            public get allowBlackboardOverrides(): boolean;
            public get requiresAgent(): boolean;
            public get requiresPrimeNode(): boolean;
            public get isTree(): boolean;
            public get canAcceptVariableDrops(): boolean;
            public CallFunction($name: string, ...args: any[]):any;
            public CallFunctionAsync($name: string, $callback: System.Action$1<any>, ...args: any[]):void;
            public GetAgentComponent($type: System.Type):UnityEngine.Object;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
        }
        interface FlowGraph {
            AddFlowNode($type: System.Type, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.FlowNode;
            AddDropedReferenceNode($type: System.Type, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: UnityEngine.Object):FlowCanvas.Nodes.IDropedReferenceNode;
            AddExternalImplementedNodeWrapper($pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: FlowCanvas.Nodes.IExternalImplementedNode):FlowCanvas.Nodes.ExternalImplementedNodeWrapper;
            AddVariableGet($varType: System.Type, $bb: NodeCanvas.Framework.IBlackboard, $variable: NodeCanvas.Framework.Variable, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.ParameterVariableNode;
            AddVariableSet($varType: System.Type, $bb: NodeCanvas.Framework.IBlackboard, $variable: NodeCanvas.Framework.Variable, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.ParameterVariableNode;
            AddSimplexNode($type: System.Type, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.FlowNode;
            AddMacroNode($m: FlowCanvas.Macros.Macro, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Macros.MacroNodeWrapper;
            AddSignalInvokeNode($s: NodeCanvas.Framework.SignalDefinition, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.InvokeSignal;
            AddSignalCallbackNode($s: NodeCanvas.Framework.SignalDefinition, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.SignalCallback;
            AddContructorNode($c: System.Reflection.ConstructorInfo, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.ReflectedConstructorNodeWrapper;
            AddMethodNode($m: System.Reflection.MethodInfo, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.ReflectedMethodNodeWrapper;
            AddFieldGetNode($f: System.Reflection.FieldInfo, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.ReflectedFieldNodeWrapper;
            AddFieldSetNode($f: System.Reflection.FieldInfo, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.ReflectedFieldNodeWrapper;
            AddUnityEventAutoCallbackNode($fieldOrProp: System.Reflection.MemberInfo, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.UnityEventAutoCallbackEvent;
            AddCSharpEventAutoCallbackNode($info: System.Reflection.EventInfo, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.CSharpAutoCallbackEvent;
            AddCSharpGetNode($info: System.Reflection.EventInfo, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.GetSharpEvent;
            AddSimplexExtractorNode($type: System.Type, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.FlowNode;
            AddReflectedExtractorNode($type: System.Type, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.FlowNode;
            GetFullNodesMenu($mousePos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: UnityEngine.Object):UnityEditor.GenericMenu;
            AppendFlowNodesMenu($menu: UnityEditor.GenericMenu, $baseCategory: string, $pos: UnityEngine.Vector2, $contextPort: FlowCanvas.Port, $dropInstance: any):UnityEditor.GenericMenu;
            AppendSimplexNodesMenu($menu: UnityEditor.GenericMenu, $baseCategory: string, $pos: UnityEngine.Vector2, $contextPort: FlowCanvas.Port, $dropInstance: any):UnityEditor.GenericMenu;
            AppendAllReflectionNodesMenu($menu: UnityEditor.GenericMenu, $baseCategory: string, $pos: UnityEngine.Vector2, $contextPort: FlowCanvas.Port, $dropInstance: any):UnityEditor.GenericMenu;
            AppendTypeReflectionNodesMenu($menu: UnityEditor.GenericMenu, $type: System.Type, $baseCategory: string, $pos: UnityEngine.Vector2, $contextPort: FlowCanvas.Port, $dropInstance: any):UnityEditor.GenericMenu;
            AppendVariableNodesMenu($menu: UnityEditor.GenericMenu, $baseCategory: string, $pos: UnityEngine.Vector2, $contextPort: FlowCanvas.Port, $dropInstance: any):UnityEditor.GenericMenu;
            AppendMacroNodesMenu($menu: UnityEditor.GenericMenu, $baseCategory: string, $pos: UnityEngine.Vector2, $contextPort: FlowCanvas.Port, $dropInstance: any):UnityEditor.GenericMenu;
            AppendSignals($menu: UnityEditor.GenericMenu, $baseCategory: string, $pos: UnityEngine.Vector2, $contextPort: FlowCanvas.Port, $dropInstance: any):UnityEditor.GenericMenu;
            AppendMenuCallbackReceivers($menu: UnityEditor.GenericMenu, $baseCategory: string, $pos: UnityEngine.Vector2, $contextPort: FlowCanvas.Port, $dropInstance: any):UnityEditor.GenericMenu;
        }
        export class FlowGraphExtensions extends System.Object{ 
            public static AddFlowNode($graph: FlowCanvas.FlowGraph, $type: System.Type, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.FlowNode;
            public static AddDropedReferenceNode($graph: FlowCanvas.FlowGraph, $type: System.Type, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: UnityEngine.Object):FlowCanvas.Nodes.IDropedReferenceNode;
            public static AddExternalImplementedNodeWrapper($graph: FlowCanvas.FlowGraph, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: FlowCanvas.Nodes.IExternalImplementedNode):FlowCanvas.Nodes.ExternalImplementedNodeWrapper;
            public static AddVariableGet($graph: FlowCanvas.FlowGraph, $varType: System.Type, $bb: NodeCanvas.Framework.IBlackboard, $variable: NodeCanvas.Framework.Variable, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.ParameterVariableNode;
            public static AddVariableSet($graph: FlowCanvas.FlowGraph, $varType: System.Type, $bb: NodeCanvas.Framework.IBlackboard, $variable: NodeCanvas.Framework.Variable, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.ParameterVariableNode;
            public static AddSimplexNode($graph: FlowCanvas.FlowGraph, $type: System.Type, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.FlowNode;
            public static AddMacroNode($graph: FlowCanvas.FlowGraph, $m: FlowCanvas.Macros.Macro, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Macros.MacroNodeWrapper;
            public static AddSignalInvokeNode($graph: FlowCanvas.FlowGraph, $s: NodeCanvas.Framework.SignalDefinition, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.InvokeSignal;
            public static AddSignalCallbackNode($graph: FlowCanvas.FlowGraph, $s: NodeCanvas.Framework.SignalDefinition, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.SignalCallback;
            public static AddContructorNode($graph: FlowCanvas.FlowGraph, $c: System.Reflection.ConstructorInfo, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.ReflectedConstructorNodeWrapper;
            public static AddMethodNode($graph: FlowCanvas.FlowGraph, $m: System.Reflection.MethodInfo, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.ReflectedMethodNodeWrapper;
            public static AddFieldGetNode($graph: FlowCanvas.FlowGraph, $f: System.Reflection.FieldInfo, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.ReflectedFieldNodeWrapper;
            public static AddFieldSetNode($graph: FlowCanvas.FlowGraph, $f: System.Reflection.FieldInfo, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.ReflectedFieldNodeWrapper;
            public static AddUnityEventAutoCallbackNode($graph: FlowCanvas.FlowGraph, $fieldOrProp: System.Reflection.MemberInfo, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.UnityEventAutoCallbackEvent;
            public static AddCSharpEventAutoCallbackNode($graph: FlowCanvas.FlowGraph, $info: System.Reflection.EventInfo, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.CSharpAutoCallbackEvent;
            public static AddCSharpGetNode($graph: FlowCanvas.FlowGraph, $info: System.Reflection.EventInfo, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.Nodes.GetSharpEvent;
            public static AddSimplexExtractorNode($graph: FlowCanvas.FlowGraph, $type: System.Type, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.FlowNode;
            public static AddReflectedExtractorNode($graph: FlowCanvas.FlowGraph, $type: System.Type, $pos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: any):FlowCanvas.FlowNode;
            public static GetFullNodesMenu($flowGraph: FlowCanvas.FlowGraph, $mousePos: UnityEngine.Vector2, $context: FlowCanvas.Port, $dropInstance: UnityEngine.Object):UnityEditor.GenericMenu;
            public static AppendFlowNodesMenu($graph: FlowCanvas.FlowGraph, $menu: UnityEditor.GenericMenu, $baseCategory: string, $pos: UnityEngine.Vector2, $contextPort: FlowCanvas.Port, $dropInstance: any):UnityEditor.GenericMenu;
            public static AppendSimplexNodesMenu($graph: FlowCanvas.FlowGraph, $menu: UnityEditor.GenericMenu, $baseCategory: string, $pos: UnityEngine.Vector2, $contextPort: FlowCanvas.Port, $dropInstance: any):UnityEditor.GenericMenu;
            public static AppendAllReflectionNodesMenu($graph: FlowCanvas.FlowGraph, $menu: UnityEditor.GenericMenu, $baseCategory: string, $pos: UnityEngine.Vector2, $contextPort: FlowCanvas.Port, $dropInstance: any):UnityEditor.GenericMenu;
            public static AppendTypeReflectionNodesMenu($graph: FlowCanvas.FlowGraph, $menu: UnityEditor.GenericMenu, $type: System.Type, $baseCategory: string, $pos: UnityEngine.Vector2, $contextPort: FlowCanvas.Port, $dropInstance: any):UnityEditor.GenericMenu;
            public static AppendVariableNodesMenu($graph: FlowCanvas.FlowGraph, $menu: UnityEditor.GenericMenu, $baseCategory: string, $pos: UnityEngine.Vector2, $contextPort: FlowCanvas.Port, $dropInstance: any):UnityEditor.GenericMenu;
            public static AppendMacroNodesMenu($graph: FlowCanvas.FlowGraph, $menu: UnityEditor.GenericMenu, $baseCategory: string, $pos: UnityEngine.Vector2, $contextPort: FlowCanvas.Port, $dropInstance: any):UnityEditor.GenericMenu;
            public static AppendSignals($graph: FlowCanvas.FlowGraph, $menu: UnityEditor.GenericMenu, $baseCategory: string, $pos: UnityEngine.Vector2, $contextPort: FlowCanvas.Port, $dropInstance: any):UnityEditor.GenericMenu;
            public static AppendMenuCallbackReceivers($graph: FlowCanvas.FlowGraph, $menu: UnityEditor.GenericMenu, $baseCategory: string, $pos: UnityEngine.Vector2, $contextPort: FlowCanvas.Port, $dropInstance: any):UnityEditor.GenericMenu;
            public static ConvertNodesToMacro($originalNodes: System.Collections.Generic.List$1<NodeCanvas.Framework.Node>):void;
        }
        export class FlowScriptBase extends FlowCanvas.FlowGraph implements NodeCanvas.Framework.ITaskSystem, UnityEngine.ISerializationCallbackReceiver{ 
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
        }
        export class ValueOutput extends FlowCanvas.Port{ 
            public static CreateInstance($t: System.Type, $parent: FlowCanvas.FlowNode, $name: string, $ID: string, $getter: FlowCanvas.ValueHandlerObject):FlowCanvas.ValueOutput;
            public GetObjectValue():any;
        }
        export class FlowInput extends FlowCanvas.Port{ 
            public get pointer(): FlowCanvas.FlowHandler;
            public get type(): System.Type;
            public constructor($parent: FlowCanvas.FlowNode, $name: string, $ID: string, $pointer: FlowCanvas.FlowHandler);
            public constructor();
        }
        export class ValueInput extends FlowCanvas.Port{ 
            public get value(): any;
            public get skipSelfInstanceAssignment(): boolean;
            public set skipSelfInstanceAssignment(value: boolean);
            public get defaultValue(): any;
            public set defaultValue(value: any);
            public get serializedValue(): any;
            public set serializedValue(value: any);
            public get isDefaultValue(): boolean;
            public get type(): System.Type;
            public static CreateInstance($t: System.Type, $parent: FlowCanvas.FlowNode, $name: string, $ID: string):FlowCanvas.ValueInput;
            public SetDefaultAndSerializedValue($v: any):FlowCanvas.ValueInput;
            public SkipSelfInstanceAssignment($skip: boolean):FlowCanvas.ValueInput;
            public BindTo($target: FlowCanvas.ValueOutput):void;
            public UnBind():void;
            public GetObjectValue():any;
        }
        export class ValueInput$1<T> extends FlowCanvas.ValueInput{ 
        }
        export class ValueOutput$1<T> extends FlowCanvas.ValueOutput{ 
        }
        export type ValueHandler$1<T> = () => T;
        export class FlowScript extends FlowCanvas.FlowScriptBase implements NodeCanvas.Framework.ITaskSystem, UnityEngine.ISerializationCallbackReceiver{ 
            public static CreateFlowScript():void;
            public constructor();
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
        }
        export class FlowScriptController extends NodeCanvas.Framework.GraphOwner$1<FlowCanvas.FlowScript> implements UnityEngine.ISerializationCallbackReceiver{ 
            public CallFunction($name: string):void;
            public CallFunction($name: string, ...args: any[]):any;
            public CallFunctionAsync($name: string, $callback: System.Action$1<any>, ...args: any[]):void;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export interface IEditorMenuCallbackReceiver{ 
        }
        export class RenderImageEvent extends FlowCanvas.Nodes.RouterEventNode$1<UnityEngine.Camera> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class TypeConverter extends System.Object{ 
            public static HasConvertion($sourceType: System.Type, $targetType: System.Type):boolean;
            public static QuickConvert($obj: any, $type: System.Type):any;
        }
        export class Wild extends System.Object{ 
            public constructor();
        }
        export class FlowNodeNested$1<T> extends FlowCanvas.FlowNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<T>{ 
            public get subGraph(): NodeCanvas.Framework.Graph;
            public set subGraph(value: NodeCanvas.Framework.Graph);
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
        }
    }
    export namespace NodeCanvas.Framework.Connection {
        export enum TipConnectionStyle{ None = 0, Circle = 1, Arrow = 2 }
        export enum RelinkState{ None = 0, Source = 1, Target = 2 }
    }
    export namespace ParadoxNotion {
        export enum PlanarDirection{ Horizontal = 0, Vertical = 1, Auto = 2 }
        export enum Alignment2x2{ Default = 0, Left = 1, Right = 2, Top = 3, Bottom = 4 }
        export class DynamicParameterDefinition extends System.Object implements UnityEngine.ISerializationCallbackReceiver{ 
            public get ID(): string;
            public get name(): string;
            public set name(value: string);
            public get type(): System.Type;
            public set type(value: System.Type);
            public constructor();
            public constructor($name: string, $type: System.Type);
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export enum CompareMethod{ EqualTo = 0, GreaterThan = 1, LessThan = 2, GreaterOrEqualTo = 3, LessOrEqualTo = 4 }
        export enum PressTypes{ Down = 0, Up = 1, Pressed = 2 }
        export enum ButtonKeys{ Left = 0, Right = 1, Middle = 2 }
        export enum CollisionTypes{ CollisionEnter = 0, CollisionExit = 1, CollisionStay = 2 }
        export class EventData$1<T> extends System.ValueType implements ParadoxNotion.IEventData{ 
            public get receiver(): UnityEngine.GameObject;
            public get sender(): any;
            public get valueBoxed(): any;
        }
        export interface IEventData{ 
            receiver: UnityEngine.GameObject;
            sender: any;
            valueBoxed: any;
        }
        export enum MouseInteractionTypes{ MouseEnter = 0, MouseExit = 1, MouseOver = 2 }
        export enum MouseClickEvent{ MouseDown = 0, MouseUp = 1 }
        export enum TriggerTypes{ TriggerEnter = 0, TriggerExit = 1, TriggerStay = 2 }
        export enum PlayDirections{ Forward = 0, Backward = 1, Toggle = 2 }
        export enum OperationMethod{ Set = 0, Add = 1, Subtract = 2, Multiply = 3, Divide = 4 }
        export enum CompactStatus{ Failure = 0, Success = 1 }
        export type ActionCall = () => void;
        var ActionCall: {new (func: () => void): ActionCall;}
        export enum Alignment3x3{ TopLeft = 0, TopCenter = 1, TopRight = 2, MiddleLeft = 3, MiddleCenter = 4, MiddleRight = 5, BottomLeft = 6, BottomCenter = 7, BottomRight = 8 }
        export class HierarchyTree extends System.Object{ 
            public constructor();
        }
        export class EventData extends System.ValueType implements ParadoxNotion.IEventData{ 
            public get receiver(): UnityEngine.GameObject;
            public get sender(): any;
            public get value(): any;
            public get valueBoxed(): any;
            public constructor($value: any, $receiver: UnityEngine.GameObject, $sender: any);
            public constructor($receiver: UnityEngine.GameObject, $sender: any);
            public constructor();
        }
        export class OperationTools extends System.Object{ 
            public static GetOperationString($om: ParadoxNotion.OperationMethod):string;
            public static Operate($a: number, $b: number, $om: ParadoxNotion.OperationMethod, $delta?: number):number;
            public static Operate($a: number, $b: number, $om: ParadoxNotion.OperationMethod):number;
            public static Operate($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $om: ParadoxNotion.OperationMethod, $delta?: number):UnityEngine.Vector3;
            public static GetCompareString($cm: ParadoxNotion.CompareMethod):string;
            public static Compare($a: number, $b: number, $cm: ParadoxNotion.CompareMethod, $floatingPoint: number):boolean;
            public static Compare($a: number, $b: number, $cm: ParadoxNotion.CompareMethod):boolean;
        }
        export class ReflectionTools extends System.Object{ 
            public static FLAGS_ALL: System.Reflection.BindingFlags;
            public static FLAGS_ALL_DECLARED: System.Reflection.BindingFlags;
            public static op_FriendlyNamesLong: System.Collections.Generic.Dictionary$2<string, string>;
            public static op_FriendlyNamesShort: System.Collections.Generic.Dictionary$2<string, string>;
            public static op_CSharpAliases: System.Collections.Generic.Dictionary$2<string, string>;
            public static METHOD_SPECIAL_NAME_GET: string;
            public static METHOD_SPECIAL_NAME_SET: string;
            public static METHOD_SPECIAL_NAME_ADD: string;
            public static METHOD_SPECIAL_NAME_REMOVE: string;
            public static METHOD_SPECIAL_NAME_OP: string;
            public static FlushMem():void;
            public static GetType($typeFullName: string):System.Type;
            public static GetType($typeFullName: string, $fallbackAssignable: System.Type):System.Type;
            public static GetType($typeFullName: string, $fallbackNoNamespace?: boolean, $fallbackAssignable?: System.Type):System.Type;
            public static GetAllTypes($includeObsolete: boolean):System.Array$1<System.Type>;
            public static GetImplementationsOf($baseType: System.Type):System.Array$1<System.Type>;
            public static SingleTempArgsArray($arg: any):System.Array$1<any>;
            public static GetMethodSpecialType($method: System.Reflection.MethodBase):ParadoxNotion.ReflectionTools.MethodType;
            public static FriendlyName($t: System.Type, $compileSafe?: boolean):string;
            public static FriendlyName($info: System.Reflection.MemberInfo):string;
            public static FriendlyName($method: System.Reflection.MethodBase):string;
            public static FriendlyName($method: System.Reflection.MethodBase, $specialNameType: $Ref<ParadoxNotion.ReflectionTools.MethodType>):string;
            public static SignatureName($method: System.Reflection.MethodBase):string;
            public static FriendlyTypeName($fullName: string):string;
            public static RTReflectedOrDeclaredType($member: System.Reflection.MemberInfo):System.Type;
            public static RTIsAssignableFrom($type: System.Type, $other: System.Type):boolean;
            public static RTIsAssignableTo($type: System.Type, $other: System.Type):boolean;
            public static RTIsAbstract($type: System.Type):boolean;
            public static RTIsValueType($type: System.Type):boolean;
            public static RTIsArray($type: System.Type):boolean;
            public static RTIsInterface($type: System.Type):boolean;
            public static RTIsSubclassOf($type: System.Type, $other: System.Type):boolean;
            public static RTIsGenericParameter($type: System.Type):boolean;
            public static RTIsGenericType($type: System.Type):boolean;
            public static RTGetGetMethod($prop: System.Reflection.PropertyInfo):System.Reflection.MethodInfo;
            public static RTGetSetMethod($prop: System.Reflection.PropertyInfo):System.Reflection.MethodInfo;
            public static RTGetDelegateMethodInfo($del: Function):System.Reflection.MethodInfo;
            public static RTMakeGenericType($type: System.Type, ...typeArgs: System.Type[]):System.Type;
            public static RTGetGenericArguments($type: System.Type):System.Array$1<System.Type>;
            public static RTGetGenericArguments($method: System.Reflection.MethodInfo):System.Array$1<System.Type>;
            public static RTGetEmptyTypes():System.Array$1<System.Type>;
            public static RTGetElementType($type: System.Type):System.Type;
            public static RTIsByRef($type: System.Type):boolean;
            public static CreateObject($type: System.Type):any;
            public static CreateObjectUninitialized($type: System.Type):any;
            public static RTGetDefaultConstructor($type: System.Type):System.Reflection.ConstructorInfo;
            public static RTGetConstructor($type: System.Type, $paramTypes: System.Array$1<System.Type>):System.Reflection.ConstructorInfo;
            public static RTGetMethod($type: System.Type, $name: string):System.Reflection.MethodInfo;
            public static RTGetMethod($type: System.Type, $name: string, $paramTypes: System.Array$1<System.Type>, $returnType?: System.Type, $genericArgumentTypes?: System.Array$1<System.Type>):System.Reflection.MethodInfo;
            public static RTGetField($type: System.Type, $name: string, $includePrivateBase?: boolean):System.Reflection.FieldInfo;
            public static RTGetProperty($type: System.Type, $name: string):System.Reflection.PropertyInfo;
            public static RTGetFieldOrProp($type: System.Type, $name: string):System.Reflection.MemberInfo;
            public static RTGetEvent($type: System.Type, $name: string):System.Reflection.EventInfo;
            public static RTGetConstructors($type: System.Type):System.Array$1<System.Reflection.ConstructorInfo>;
            public static RTGetMethods($type: System.Type):System.Array$1<System.Reflection.MethodInfo>;
            public static RTGetFields($type: System.Type):System.Array$1<System.Reflection.FieldInfo>;
            public static RTGetProperties($type: System.Type):System.Array$1<System.Reflection.PropertyInfo>;
            public static RTGetEvents($type: System.Type):System.Array$1<System.Reflection.EventInfo>;
            public static RTGetAllAttributes($type: System.Type):System.Array$1<any>;
            public static RTIsDefined($type: System.Type, $attributeType: System.Type, $inherited: boolean):boolean;
            public static RTGetAttribute($type: System.Type, $attributeType: System.Type, $inherited: boolean):System.Attribute;
            public static RTGetAllAttributes($member: System.Reflection.MemberInfo):System.Array$1<any>;
            public static RTIsDefined($member: System.Reflection.MemberInfo, $attributeType: System.Type, $inherited: boolean):boolean;
            public static RTGetAttribute($member: System.Reflection.MemberInfo, $attributeType: System.Type, $inherited: boolean):System.Attribute;
            public static RTGetDelegateTypeParameters($delegateType: System.Type):System.Array$1<System.Reflection.ParameterInfo>;
            public static RTCreateDelegate($method: System.Reflection.MethodInfo, $type: System.Type, $instance: any):Function;
            public static ConvertDelegate($originalDelegate: Function, $targetDelegateType: System.Type):Function;
            public static IsReadOnly($field: System.Reflection.FieldInfo):boolean;
            public static IsConstant($field: System.Reflection.FieldInfo):boolean;
            public static IsStatic($info: System.Reflection.EventInfo):boolean;
            public static IsStatic($info: System.Reflection.PropertyInfo):boolean;
            public static IsParams($parameter: System.Reflection.ParameterInfo, $parameters: System.Array$1<System.Reflection.ParameterInfo>):boolean;
            public static IsObsolete($member: System.Reflection.MemberInfo, $inherited?: boolean):boolean;
            public static GetBaseDefinition($propertyInfo: System.Reflection.PropertyInfo):System.Reflection.PropertyInfo;
            public static GetBaseDefinition($fieldInfo: System.Reflection.FieldInfo):System.Reflection.FieldInfo;
            public static GetExtensionMethods($targetType: System.Type):System.Array$1<System.Reflection.MethodInfo>;
            public static IsExtensionMethod($method: System.Reflection.MethodInfo):boolean;
            public static IsPropertyAccessor($method: System.Reflection.MethodInfo):boolean;
            public static IsIndexerProperty($property: System.Reflection.PropertyInfo):boolean;
            public static IsAutoProperty($property: System.Reflection.PropertyInfo):boolean;
            public static GetAccessorProperty($method: System.Reflection.MethodInfo):System.Reflection.PropertyInfo;
            public static IsEnumerableCollection($type: System.Type):boolean;
            public static GetEnumerableElementType($type: System.Type):System.Type;
            public static GetSingleGenericArgument($type: System.Type):System.Type;
            public static GetFirstGenericParameterConstraintType($type: System.Type):System.Type;
            public static GetFirstGenericParameterConstraintType($method: System.Reflection.MethodInfo):System.Type;
            public static CanBeMadeGenericWith($def: System.Type, $type: System.Type):boolean;
            public static CanBeMadeGenericWith($def: System.Reflection.MethodInfo, $type: System.Type):boolean;
            public static IsAllowedByGenericArgument($type: System.Type, $genericArgument: System.Type):boolean;
            public static Resize($array: System.Array, $newSize: number):System.Array;
            public static CanConvert($fromType: System.Type, $toType: System.Type, $exp: $Ref<System.Linq.Expressions.UnaryExpression>):boolean;
            public static DigFields($root: any, $move: System.Predicate$1<System.Reflection.FieldInfo>, $push: System.Action$1<any>, $pop: System.Action$1<any>):void;
            public GetType():System.Type;
        }
        export class TypeConverter extends System.Object{ 
            public static add_customConverter($value: ParadoxNotion.TypeConverter.CustomConverter):void;
            public static remove_customConverter($value: ParadoxNotion.TypeConverter.CustomConverter):void;
            public static Get($fromType: System.Type, $toType: System.Type):System.Func$2<any, any>;
            public static CanConvert($fromType: System.Type, $toType: System.Type):boolean;
        }
        export class ColorUtils extends System.Object{ 
            public static WithAlpha($color: UnityEngine.Color, $alpha: number):UnityEngine.Color;
            public static Grey($value: number):UnityEngine.Color;
            public static ColorToHex($color: UnityEngine.Color32):string;
            public static HexToColor($hex: string):UnityEngine.Color;
        }
        export class CurveUtils extends System.Object{ 
            public static GetPosAlongCurve($from: UnityEngine.Vector2, $to: UnityEngine.Vector2, $fromTangent: UnityEngine.Vector2, $toTangent: UnityEngine.Vector2, $t: number):UnityEngine.Vector2;
            public static IsPosAlongCurve($from: UnityEngine.Vector2, $to: UnityEngine.Vector2, $fromTangent: UnityEngine.Vector2, $toTangent: UnityEngine.Vector2, $targetPosition: UnityEngine.Vector2):boolean;
            public static IsPosAlongCurve($from: UnityEngine.Vector2, $to: UnityEngine.Vector2, $fromTangent: UnityEngine.Vector2, $toTangent: UnityEngine.Vector2, $targetPosition: UnityEngine.Vector2, $norm: $Ref<number>):boolean;
            public static ResolveTangents($from: UnityEngine.Vector2, $to: UnityEngine.Vector2, $rigidMlt: number, $direction: ParadoxNotion.PlanarDirection, $fromTangent: $Ref<UnityEngine.Vector2>, $toTangent: $Ref<UnityEngine.Vector2>):void;
            public static ResolveTangents($from: UnityEngine.Vector2, $to: UnityEngine.Vector2, $fromRect: UnityEngine.Rect, $toRect: UnityEngine.Rect, $rigidMlt: number, $direction: ParadoxNotion.PlanarDirection, $fromTangent: $Ref<UnityEngine.Vector2>, $toTangent: $Ref<UnityEngine.Vector2>):void;
        }
        export class GUIStyleUtils extends System.Object{ 
            public static Margin($style: UnityEngine.GUIStyle, $left: number, $right: number, $top: number, $bottom: number):UnityEngine.GUIStyle;
            public static Padding($style: UnityEngine.GUIStyle, $left: number, $right: number, $top: number, $bottom: number):UnityEngine.GUIStyle;
            public static Border($style: UnityEngine.GUIStyle, $left: number, $right: number, $top: number, $bottom: number):UnityEngine.GUIStyle;
            public static Overflow($style: UnityEngine.GUIStyle, $left: number, $right: number, $top: number, $bottom: number):UnityEngine.GUIStyle;
            public static TextAlignment($style: UnityEngine.GUIStyle, $anchor: UnityEngine.TextAnchor):UnityEngine.GUIStyle;
            public static RichText($style: UnityEngine.GUIStyle, $rich: boolean):UnityEngine.GUIStyle;
        }
        export class LayerUtils extends System.Object{ 
            public static CreateFromNames(...layerNames: string[]):UnityEngine.LayerMask;
            public static CreateFromNumbers(...layerNumbers: number[]):UnityEngine.LayerMask;
            public static LayerNamesToMask(...layerNames: string[]):UnityEngine.LayerMask;
            public static LayerNumbersToMask(...layerNumbers: number[]):UnityEngine.LayerMask;
            public static Inverse($mask: UnityEngine.LayerMask):UnityEngine.LayerMask;
            public static AddToMask($mask: UnityEngine.LayerMask, ...layerNames: string[]):UnityEngine.LayerMask;
            public static RemoveFromMask($mask: UnityEngine.LayerMask, ...layerNames: string[]):UnityEngine.LayerMask;
            public static ContainsAnyLayer($mask: UnityEngine.LayerMask, ...layerNames: string[]):boolean;
            public static ContainsAllLayers($mask: UnityEngine.LayerMask, ...layerNames: string[]):boolean;
            public static MaskToNames($mask: UnityEngine.LayerMask):System.Array$1<string>;
            public static MaskToString($mask: UnityEngine.LayerMask):string;
            public static MaskToString($mask: UnityEngine.LayerMask, $delimiter: string):string;
        }
        export class ObjectUtils extends System.Object{ 
            public static AnyEquals($a: any, $b: any):boolean;
            public static TransformToType($current: UnityEngine.Component, $type: System.Type):UnityEngine.Component;
            public static FindGameObjectsWithinLayerMask($mask: UnityEngine.LayerMask, $exclude?: UnityEngine.GameObject):System.Collections.Generic.IEnumerable$1<UnityEngine.GameObject>;
            public static IsInLayerMask($gameObject: UnityEngine.GameObject, $mask: UnityEngine.LayerMask):boolean;
        }
        export class RectUtils extends System.Object{ 
            public static GetBoundRect(...rects: UnityEngine.Rect[]):UnityEngine.Rect;
            public static GetBoundRect(...positions: UnityEngine.Vector2[]):UnityEngine.Rect;
            public static Encapsulates($a: UnityEngine.Rect, $b: UnityEngine.Rect):boolean;
            public static ExpandBy($rect: UnityEngine.Rect, $margin: number):UnityEngine.Rect;
            public static ExpandBy($rect: UnityEngine.Rect, $xMargin: number, $yMargin: number):UnityEngine.Rect;
            public static ExpandBy($rect: UnityEngine.Rect, $left: number, $top: number, $right: number, $bottom: number):UnityEngine.Rect;
            public static TransformSpace($rect: UnityEngine.Rect, $oldContainer: UnityEngine.Rect, $newContainer: UnityEngine.Rect):UnityEngine.Rect;
            public static TransformSpace($vector: UnityEngine.Vector2, $oldContainer: UnityEngine.Rect, $newContainer: UnityEngine.Rect):UnityEngine.Vector2;
            public static DrawDebugRect($rect: UnityEngine.Rect, $label?: string, $color?: UnityEngine.Color):void;
        }
        export class StringUtils extends System.Object{ 
            public static SPACE: string;
            public static ALPHABET: string;
            public static CHAR_SPACE_ARRAY: System.Array$1<number>;
            public static SplitCamelCase($s: string):string;
            public static CapitalizeFirst($s: string):string;
            public static CapLength($s: string, $max: number):string;
            public static GetCapitals($s: string):string;
            public static FormatError($input: string):string;
            public static GetAlphabetLetter($index: number):string;
            public static GetStringWithinOuter($input: string, $from: number, $to: number):string;
            public static GetStringWithinInner($input: string, $from: number, $to: number):string;
            public static ReplaceWithin($text: string, $startChar: number, $endChar: number, $Process: System.Func$2<string, string>):string;
            public static ScoreSearchMatch($input: string, $leafName: string, $categoryName?: string):number;
            public static SearchMatch($input: string, $leafName: string, $categoryName?: string):boolean;
            public static ToStringAdvanced($o: any):string;
            public ToStringAdvanced():null;
        }
    }
    export namespace FlowCanvas.Nodes {
        export class EventNode extends FlowCanvas.FlowNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
        }
        export interface IDropedReferenceNode extends NodeCanvas.Framework.IGraphElement{ 
            name: string;
            UID: string;
            graph: NodeCanvas.Framework.Graph;
            status: NodeCanvas.Framework.Status;
            SetTarget($target: UnityEngine.Object):void;
        }
        export class ExternalImplementedNodeWrapper extends FlowCanvas.FlowNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get target(): FlowCanvas.Nodes.IExternalImplementedNode;
            public set target(value: FlowCanvas.Nodes.IExternalImplementedNode);
            public get name(): string;
            public SetTarget($target: FlowCanvas.Nodes.IExternalImplementedNode):void;
            public constructor();
        }
        export interface IExternalImplementedNode{ 
            RegisterPorts($parent: FlowCanvas.FlowNode):void;
        }
        export class ParameterVariableNode extends FlowCanvas.FlowNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get parameter(): NodeCanvas.Framework.BBParameter;
        }
        export class InvokeSignal extends FlowCanvas.FlowNode implements FlowCanvas.Nodes.IDropedReferenceNode, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public _signalDefinition: NodeCanvas.Framework.BBParameter$1<NodeCanvas.Framework.SignalDefinition>;
            public global: boolean;
            public get name(): string;
            public SetTarget($target: UnityEngine.Object):void;
            public constructor();
            public SetTarget($target: UnityEngine.Object):void;
        }
        export class SignalCallback extends FlowCanvas.Nodes.RouterEventNode$1<UnityEngine.Transform> implements FlowCanvas.Nodes.IDropedReferenceNode, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public _signalDefinition: NodeCanvas.Framework.BBParameter$1<NodeCanvas.Framework.SignalDefinition>;
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public SetTarget($target: UnityEngine.Object):void;
            public constructor();
            public SetTarget($target: UnityEngine.Object):void;
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class RouterEventNode$1<T> extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
        }
        export class ReflectedConstructorNodeWrapper extends FlowCanvas.Nodes.ReflectedMethodBaseNodeWrapper implements NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get description(): string;
            public constructor();
        }
        export class ReflectedMethodBaseNodeWrapper extends FlowCanvas.FlowNode implements NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get description(): string;
            public get callable(): boolean;
            public set callable(value: boolean);
            public get exposeParams(): boolean;
            public set exposeParams(value: boolean);
            public get exposedParamsCount(): number;
            public set exposedParamsCount(value: number);
            public GetRuntimeIconType():System.Type;
            public SetMethodBase($newMethod: System.Reflection.MethodBase, $instance?: any):void;
            public SetDefaultParameterValues($newMethod: System.Reflection.MethodBase):void;
            public SetDropInstanceReference($newMethod: System.Reflection.MethodBase, $instance?: any):void;
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class ReflectedMethodNodeWrapper extends FlowCanvas.Nodes.ReflectedMethodBaseNodeWrapper implements NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public constructor();
        }
        export class ReflectedFieldNodeWrapper extends FlowCanvas.FlowNode implements ParadoxNotion.Serialization.FullSerializer.IMigratable, ParadoxNotion.Serialization.FullSerializer.IMigratable$1<FlowCanvas.Nodes.ReflectedFieldNodeWrapper_0>, NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get description(): string;
            public SetField($newField: System.Reflection.FieldInfo, $mode: FlowCanvas.Nodes.ReflectedFieldNodeWrapper.AccessMode, $instance?: any):void;
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class ReflectedFieldNodeWrapper_0 extends System.Object{ 
        }
        export class UnityEventAutoCallbackEvent extends FlowCanvas.Nodes.EventNode implements NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public SetEvent($newMember: System.Reflection.MemberInfo, $instance?: any):void;
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class CSharpAutoCallbackEvent extends FlowCanvas.Nodes.EventNode implements NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public SetEvent($info: System.Reflection.EventInfo, $instance?: any):void;
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class GetSharpEvent extends FlowCanvas.FlowNode implements NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public SetEvent($info: System.Reflection.EventInfo, $instance?: any):void;
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class FlowNestedBT extends FlowCanvas.Nodes.FlowNestedBase$1<NodeCanvas.BehaviourTrees.BehaviourTree> implements FlowCanvas.Nodes.IDropedReferenceNode, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, UnityEngine.ISerializationCallbackReceiver, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<NodeCanvas.BehaviourTrees.BehaviourTree>{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public get subGraph(): NodeCanvas.Framework.Graph;
            public set subGraph(value: NodeCanvas.Framework.Graph);
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public constructor();
            public SetTarget($target: UnityEngine.Object):void;
            public Update():void;
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
        }
        export class FlowNestedBase$1<T> extends FlowCanvas.FlowNodeNested$1<T> implements FlowCanvas.Nodes.IDropedReferenceNode, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, UnityEngine.ISerializationCallbackReceiver, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<T>{ 
            public SetTarget($target: UnityEngine.Object):void;
            public Update():void;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
        }
        export class FlowNestedFSM extends FlowCanvas.Nodes.FlowNestedBase$1<NodeCanvas.StateMachines.FSM> implements FlowCanvas.Nodes.IDropedReferenceNode, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, UnityEngine.ISerializationCallbackReceiver, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<NodeCanvas.StateMachines.FSM>{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public get subGraph(): NodeCanvas.Framework.Graph;
            public set subGraph(value: NodeCanvas.Framework.Graph);
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public constructor();
            public SetTarget($target: UnityEngine.Object):void;
            public Update():void;
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
        }
        export class FlowNestedDT extends FlowCanvas.Nodes.FlowNestedBase$1<NodeCanvas.DialogueTrees.DialogueTree> implements FlowCanvas.Nodes.IDropedReferenceNode, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, UnityEngine.ISerializationCallbackReceiver, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<NodeCanvas.DialogueTrees.DialogueTree>{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public get subGraph(): NodeCanvas.Framework.Graph;
            public set subGraph(value: NodeCanvas.Framework.Graph);
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public constructor();
            public SetTarget($target: UnityEngine.Object):void;
            public Update():void;
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
        }
        export class TaskAction extends FlowCanvas.FlowNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver, NodeCanvas.Framework.ITaskAssignable, NodeCanvas.Framework.ITaskAssignable$1<NodeCanvas.Framework.ActionTask>{ 
            public get name(): string;
            public get action(): NodeCanvas.Framework.ActionTask;
            public set action(value: NodeCanvas.Framework.ActionTask);
            public get task(): NodeCanvas.Framework.Task;
            public set task(value: NodeCanvas.Framework.Task);
            public constructor();
        }
        export class TaskCondition extends FlowCanvas.FlowNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver, NodeCanvas.Framework.ITaskAssignable, NodeCanvas.Framework.ITaskAssignable$1<NodeCanvas.Framework.ConditionTask>{ 
            public get name(): string;
            public get condition(): NodeCanvas.Framework.ConditionTask;
            public set condition(value: NodeCanvas.Framework.ConditionTask);
            public get task(): NodeCanvas.Framework.Task;
            public set task(value: NodeCanvas.Framework.Task);
            public constructor();
        }
        export class ApplicationPauseEvent extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class ApplicationQuitEvent extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class CSharpEventCallback extends FlowCanvas.Nodes.EventNode implements NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class CustomEvent extends FlowCanvas.Nodes.RouterEventNode$1<NodeCanvas.Framework.GraphOwner> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public eventName: NodeCanvas.Framework.BBParameter$1<string>;
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class DelegateCallbackEvent extends FlowCanvas.Nodes.EventNode implements NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class UnityEventCallbackEvent extends FlowCanvas.Nodes.EventNode implements NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get autoHandleRegistration(): boolean;
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class ConstructionEvent extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class DisableEvent extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class EnableEvent extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class FixedUpdateEvent extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class LateUpdateEvent extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class StartEvent extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class UpdateEvent extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, UnityEngine.ISerializationCallbackReceiver{ 
            public updateInterval: NodeCanvas.Framework.BBParameter$1<number>;
            public Update():void;
            public constructor();
        }
        export class InputAxisEvent extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, UnityEngine.ISerializationCallbackReceiver{ 
            public Update():void;
            public constructor();
        }
        export class InputButtonEvents extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, UnityEngine.ISerializationCallbackReceiver{ 
            public buttonName: NodeCanvas.Framework.BBParameter$1<string>;
            public get name(): string;
            public Update():void;
            public constructor();
        }
        export class InputCustomAxisEvent extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, UnityEngine.ISerializationCallbackReceiver{ 
            public axis: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<string>>;
            public Update():void;
            public constructor();
        }
        export class KeyboardEvents extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, UnityEngine.ISerializationCallbackReceiver{ 
            public keyCode: NodeCanvas.Framework.BBParameter$1<UnityEngine.KeyCode>;
            public get name(): string;
            public Update():void;
            public constructor();
        }
        export class MouseEvents extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, UnityEngine.ISerializationCallbackReceiver{ 
            public buttonKey: NodeCanvas.Framework.BBParameter$1<FlowCanvas.Nodes.MouseEvents.ButtonKeys>;
            public get name(): string;
            public Update():void;
            public constructor();
        }
        export class MousePickEvent extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, UnityEngine.ISerializationCallbackReceiver{ 
            public buttonKey: NodeCanvas.Framework.BBParameter$1<FlowCanvas.Nodes.MousePickEvent.ButtonKeys>;
            public mask: NodeCanvas.Framework.BBParameter$1<UnityEngine.LayerMask>;
            public get name(): string;
            public Update():void;
            public constructor();
        }
        export class AnimatorEvents extends FlowCanvas.Nodes.RouterEventNode$1<UnityEngine.Animator> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CharacterControllerEvents extends FlowCanvas.Nodes.RouterEventNode$1<UnityEngine.CharacterController> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public Update():void;
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class Collision2DEvents_Rigidbody extends FlowCanvas.Nodes.RouterEventNode$1<UnityEngine.Rigidbody2D> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class Collision2DEvents extends FlowCanvas.Nodes.RouterEventNode$1<UnityEngine.Collider2D> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CollisionEvents_Rigidbody extends FlowCanvas.Nodes.RouterEventNode$1<UnityEngine.Rigidbody> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CollisionEvents extends FlowCanvas.Nodes.RouterEventNode$1<UnityEngine.Collider> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class MouseAgent2DEvents extends FlowCanvas.Nodes.RouterEventNode$1<UnityEngine.Collider2D> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class MouseAgentEvents extends FlowCanvas.Nodes.RouterEventNode$1<UnityEngine.Collider> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class ObjectStateEvents extends FlowCanvas.Nodes.RouterEventNode$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class ParticleCollision2DEvents extends FlowCanvas.Nodes.RouterEventNode$1<UnityEngine.Collider2D> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class ParticleCollisionEvents extends FlowCanvas.Nodes.RouterEventNode$1<UnityEngine.Collider> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class TransformEvents extends FlowCanvas.Nodes.RouterEventNode$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class Trigger2DEvents_Transform extends FlowCanvas.Nodes.RouterEventNode$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class Trigger2DEvents extends FlowCanvas.Nodes.RouterEventNode$1<UnityEngine.Collider2D> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class TriggerEvents_Transform extends FlowCanvas.Nodes.RouterEventNode$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class TriggerEvents extends FlowCanvas.Nodes.RouterEventNode$1<UnityEngine.Collider> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class UIButtonEvent extends FlowCanvas.Nodes.EventNode$1<UnityEngine.UI.Button> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class EventNode$1<T> extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
        }
        export class UIDropdownEvent extends FlowCanvas.Nodes.EventNode$1<UnityEngine.UI.Dropdown> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class UIInputFieldEvent extends FlowCanvas.Nodes.EventNode$1<UnityEngine.UI.InputField> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class UIPointerEvents extends FlowCanvas.Nodes.RouterEventNode$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class UIScrollbarEvent extends FlowCanvas.Nodes.EventNode$1<UnityEngine.UI.Scrollbar> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class UISliderEvent extends FlowCanvas.Nodes.EventNode$1<UnityEngine.UI.Slider> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class UIToggleEvent extends FlowCanvas.Nodes.EventNode$1<UnityEngine.UI.Toggle> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class VisibilityEvents extends FlowCanvas.Nodes.RouterEventNode$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class ConditionalUpdateEvent extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, UnityEngine.ISerializationCallbackReceiver{ 
            public Update():void;
            public constructor();
        }
        export class DebugEvent extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public Update():void;
        }
        export class OscillatorEvent extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, UnityEngine.ISerializationCallbackReceiver{ 
            public curve: NodeCanvas.Framework.BBParameter$1<UnityEngine.AnimationCurve>;
            public Update():void;
            public constructor();
        }
        export class VariableChangedEvent extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public targetVariable: NodeCanvas.Framework.Internal.BBObjectParameter;
            public get name(): string;
            public constructor();
        }
        export class Chance extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class FlowControlNode extends FlowCanvas.FlowNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
        }
        export class Cooldown extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public constructor();
        }
        export class DoOnce extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class LatchBool extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class LatchInt extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class ANDMerge extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public maxAwaitTime: number;
            public constructor();
        }
        export class AwaitAll extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public maxAwaitTime: number;
            public constructor();
        }
        export class ORMerge extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class XORMerge extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class Break extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class ForEach extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class ForLoop extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public reverse: boolean;
            public constructor();
        }
        export class Dummy extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public constructor();
        }
        export class Finish extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class GoToLabel extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, FlowCanvas.IEditorMenuCallbackReceiver, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public identifier: string;
            public get port(): FlowCanvas.FlowOutput;
            public get name(): string;
            public constructor();
        }
        export class GoToStatement extends FlowCanvas.Nodes.FlowControlNode implements NodeCanvas.Framework.IHaveNodeReference, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public _targetLabel: NodeCanvas.Framework.NodeReference$1<FlowCanvas.Nodes.GoToLabel>;
            public get name(): string;
            public get targetReference(): NodeCanvas.Framework.INodeReference;
            public SetTarget($newTarget: FlowCanvas.Nodes.GoToLabel):void;
            public constructor();
        }
        export class Merge extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class Split extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class TryCatch extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class CoroutineState extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class While extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class Random extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class SwitchBool extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class SwitchComparison extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class SwitchEnum extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class SwitchInt extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class SwitchIntCustom extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public intCases: System.Collections.Generic.List$1<number>;
            public constructor();
        }
        export class SwitchProbability extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class SwitchString extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public comparisonOutputs: System.Collections.Generic.List$1<string>;
            public constructor();
        }
        export class SwitchTag extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class FlipFlop extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public isFlip: boolean;
            public get name(): string;
            public constructor();
        }
        export class MultiToggle extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public current: number;
            public get name(): string;
            public constructor();
        }
        export class Sequence extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public current: number;
            public get name(): string;
            public constructor();
        }
        export class Toggle extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public open: boolean;
            public get name(): string;
            public constructor();
        }
        export class CustomFunctionCall extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get sourceFunction(): FlowCanvas.Nodes.CustomFunctionEvent;
            public get name(): string;
            public get description(): string;
            public SetFunction($func: FlowCanvas.Nodes.CustomFunctionEvent):void;
            public constructor();
        }
        export class CustomFunctionEvent extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, FlowCanvas.IEditorMenuCallbackReceiver, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver, NodeCanvas.Framework.IInvokable{ 
            public identifier: string;
            public get parameters(): System.Collections.Generic.List$1<ParadoxNotion.DynamicParameterDefinition>;
            public get returns(): ParadoxNotion.DynamicParameterDefinition;
            public get name(): string;
            public Invoke($f: FlowCanvas.Flow, ...args: any[]):any;
            public InvokeAsync($f: FlowCanvas.Flow, $flowCallback: FlowCanvas.FlowHandler, ...args: any[]):void;
            public GetReturnValue():any;
            public constructor();
            public GetInvocationID():string;
            public Invoke(...args: any[]):any;
            public InvokeAsync($callback: System.Action$1<any>, ...args: any[]):void;
        }
        export class Return extends FlowCanvas.Nodes.FlowControlNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public useReturnValue: boolean;
            public constructor();
        }
        export class CallableActionNodeBase extends FlowCanvas.Nodes.SimplexNode{ 
        }
        export class SimplexNode extends System.Object{ 
            public get name(): string;
            public get description(): string;
            public get parameters(): System.Array$1<System.Reflection.ParameterInfo>;
            public RegisterPorts($node: FlowCanvas.FlowNode):void;
            public SetDefaultParameters($node: FlowCanvas.FlowNode):void;
            public OnGraphStarted():void;
            public OnGraphPaused():void;
            public OnGraphUnpaused():void;
            public OnGraphStoped():void;
        }
        export class CallableActionNode extends FlowCanvas.Nodes.CallableActionNodeBase{ 
            public Invoke():void;
        }
        export class CallableFunctionNodeBase extends FlowCanvas.Nodes.SimplexNode{ 
        }
        export class ExtractorNode extends FlowCanvas.Nodes.SimplexNode{ 
            public static GetExtractorType($type: System.Type):System.Type;
        }
        export class ClearDictionary extends FlowCanvas.Nodes.CallableFunctionNode$2<System.Collections.IDictionary, System.Collections.IDictionary>{ 
            public constructor();
        }
        export class CallableFunctionNode$2<TResult, T1> extends FlowCanvas.Nodes.CallableFunctionNodeBase{ 
        }
        export class ClearList extends FlowCanvas.Nodes.CallableFunctionNode$2<System.Collections.IList, System.Collections.IList>{ 
            public constructor();
        }
        export class GetListItemIndex extends FlowCanvas.Nodes.PureFunctionNode$3<number, System.Collections.IList, any>{ 
            public constructor();
        }
        export class PureFunctionNode$3<TResult, T1, T2> extends FlowCanvas.Nodes.PureFunctionNodeBase{ 
        }
        export class PureFunctionNodeBase extends FlowCanvas.Nodes.SimplexNode{ 
        }
        export class IsNotNull extends FlowCanvas.Nodes.PureFunctionNode$2<boolean, any>{ 
            public constructor();
        }
        export class PureFunctionNode$2<TResult, T1> extends FlowCanvas.Nodes.PureFunctionNodeBase{ 
        }
        export class IsOfType extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, any, System.Type>{ 
            public get OBJECT(): any;
            public constructor();
        }
        export class AnyGreaterThan extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, System.IComparable, System.IComparable>{ 
            public constructor();
        }
        export class AnyGreaterEqualThan extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, System.IComparable, System.IComparable>{ 
            public constructor();
        }
        export class AnyLessThan extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, System.IComparable, System.IComparable>{ 
            public constructor();
        }
        export class AnyLessEqualThan extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, System.IComparable, System.IComparable>{ 
            public constructor();
        }
        export class AnyEqual extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, any, any>{ 
            public constructor();
        }
        export class AnyNotEqual extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, any, any>{ 
            public constructor();
        }
        export class FloatAdd extends FlowCanvas.Nodes.PureFunctionNode$3<number, number, number>{ 
            public constructor();
        }
        export class FloatSubtract extends FlowCanvas.Nodes.PureFunctionNode$3<number, number, number>{ 
            public constructor();
        }
        export class FloatMultiply extends FlowCanvas.Nodes.PureFunctionNode$3<number, number, number>{ 
            public constructor();
        }
        export class FloatDivide extends FlowCanvas.Nodes.PureFunctionNode$3<number, number, number>{ 
            public constructor();
        }
        export class FloatModulo extends FlowCanvas.Nodes.PureFunctionNode$3<number, number, number>{ 
            public constructor();
        }
        export class FloatGreaterThan extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, number, number>{ 
            public constructor();
        }
        export class FloatGreaterEqualThan extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, number, number>{ 
            public constructor();
        }
        export class FloatLessThan extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, number, number>{ 
            public constructor();
        }
        export class FloatLessEqualThan extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, number, number>{ 
            public constructor();
        }
        export class FloatEqual extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, number, number>{ 
            public constructor();
        }
        export class FloatNotEqual extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, number, number>{ 
            public constructor();
        }
        export class FloatInvert extends FlowCanvas.Nodes.PureFunctionNode$2<number, number>{ 
            public constructor();
        }
        export class FloatSnap extends FlowCanvas.Nodes.PureFunctionNode$3<number, number, number>{ 
            public constructor();
        }
        export class IntegerAdd extends FlowCanvas.Nodes.PureFunctionNode$3<number, number, number>{ 
            public constructor();
        }
        export class IntegerSubtract extends FlowCanvas.Nodes.PureFunctionNode$3<number, number, number>{ 
            public constructor();
        }
        export class IntegerMultiply extends FlowCanvas.Nodes.PureFunctionNode$3<number, number, number>{ 
            public constructor();
        }
        export class IntegerDivide extends FlowCanvas.Nodes.PureFunctionNode$3<number, number, number>{ 
            public constructor();
        }
        export class IntegerModulo extends FlowCanvas.Nodes.PureFunctionNode$3<number, number, number>{ 
            public constructor();
        }
        export class IntegerGreaterThan extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, number, number>{ 
            public constructor();
        }
        export class IntegerGreaterEqualThan extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, number, number>{ 
            public constructor();
        }
        export class IntegerLessThan extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, number, number>{ 
            public constructor();
        }
        export class IntegerLessEqualThan extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, number, number>{ 
            public constructor();
        }
        export class IntegerEqual extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, number, number>{ 
            public constructor();
        }
        export class IntegerNotEqual extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, number, number>{ 
            public constructor();
        }
        export class IntegerInvert extends FlowCanvas.Nodes.PureFunctionNode$2<number, number>{ 
            public constructor();
        }
        export class IntegerSnap extends FlowCanvas.Nodes.PureFunctionNode$3<number, number, number>{ 
            public constructor();
        }
        export class BooleanEqual extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, boolean, boolean>{ 
            public constructor();
        }
        export class BooleanNotEqual extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, boolean, boolean>{ 
            public constructor();
        }
        export class AND extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, boolean, boolean>{ 
            public constructor();
        }
        export class OR extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, boolean, boolean>{ 
            public constructor();
        }
        export class XOR extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, boolean, boolean>{ 
            public constructor();
        }
        export class NOT extends FlowCanvas.Nodes.PureFunctionNode$2<boolean, boolean>{ 
            public constructor();
        }
        export class Vector3Equal extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, UnityEngine.Vector3, UnityEngine.Vector3>{ 
            public constructor();
        }
        export class Vector3NotEqual extends FlowCanvas.Nodes.PureFunctionNode$3<boolean, UnityEngine.Vector3, UnityEngine.Vector3>{ 
            public constructor();
        }
        export class Vector3Add extends FlowCanvas.Nodes.PureFunctionNode$3<UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3>{ 
            public constructor();
        }
        export class Vector3Subtract extends FlowCanvas.Nodes.PureFunctionNode$3<UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3>{ 
            public constructor();
        }
        export class Vector3Multiply extends FlowCanvas.Nodes.PureFunctionNode$3<UnityEngine.Vector3, UnityEngine.Vector3, number>{ 
            public constructor();
        }
        export class Vector3Divide extends FlowCanvas.Nodes.PureFunctionNode$3<UnityEngine.Vector3, UnityEngine.Vector3, number>{ 
            public constructor();
        }
        export class Vector3Invert extends FlowCanvas.Nodes.PureFunctionNode$2<UnityEngine.Vector3, UnityEngine.Vector3>{ 
            public constructor();
        }
        export class Wait extends FlowCanvas.Nodes.LatentActionNode$1<number>{ 
            public get timeLeft(): number;
            public get normalized(): number;
            public constructor();
        }
        export class LatentActionNode$1<T1> extends FlowCanvas.Nodes.LatentActionNodeBase{ 
        }
        export class LatentActionNodeBase extends FlowCanvas.Nodes.SimplexNode{ 
            public invocationMode: FlowCanvas.Nodes.LatentActionNodeBase.InvocationMode;
            public get name(): string;
            public get allowRoutineQueueing(): boolean;
            public OnBreak():void;
        }
        export class WaitForOneFrame extends FlowCanvas.Nodes.LatentActionNode{ 
            public get allowRoutineQueueing(): boolean;
            public constructor();
        }
        export class LatentActionNode extends FlowCanvas.Nodes.LatentActionNodeBase{ 
            public Invoke():System.Collections.IEnumerator;
        }
        export class WaitForPhysicsFrame extends FlowCanvas.Nodes.LatentActionNode{ 
            public get allowRoutineQueueing(): boolean;
            public constructor();
        }
        export class WaitForEndOfFrame extends FlowCanvas.Nodes.LatentActionNode{ 
            public get allowRoutineQueueing(): boolean;
            public constructor();
        }
        export class WaitUntil extends FlowCanvas.Nodes.LatentActionNode{ 
            public get allowRoutineQueueing(): boolean;
            public constructor();
        }
        export class WaitWhile extends FlowCanvas.Nodes.LatentActionNode{ 
            public get allowRoutineQueueing(): boolean;
            public constructor();
        }
        export class DeltaTimed extends FlowCanvas.Nodes.PureFunctionNode$3<number, number, number>{ 
            public constructor();
        }
        export class DeltaTimedVector3 extends FlowCanvas.Nodes.PureFunctionNode$3<UnityEngine.Vector3, UnityEngine.Vector3, number>{ 
            public constructor();
        }
        export class DampFloat extends FlowCanvas.Nodes.PureFunctionNode$4<number, number, number, number>{ 
            public constructor();
        }
        export class PureFunctionNode$4<TResult, T1, T2, T3> extends FlowCanvas.Nodes.PureFunctionNodeBase{ 
        }
        export class DampVector3 extends FlowCanvas.Nodes.PureFunctionNode$4<UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, number>{ 
            public constructor();
        }
        export class LerpFloat extends FlowCanvas.Nodes.PureFunctionNode$5<number, number, number, number, ParadoxNotion.Animation.EaseType>{ 
            public constructor();
        }
        export class PureFunctionNode$5<TResult, T1, T2, T3, T4> extends FlowCanvas.Nodes.PureFunctionNodeBase{ 
        }
        export class LerpVector3 extends FlowCanvas.Nodes.PureFunctionNode$5<UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, number, ParadoxNotion.Animation.EaseType>{ 
            public constructor();
        }
        export class LerpQuaternion extends FlowCanvas.Nodes.PureFunctionNode$5<UnityEngine.Quaternion, UnityEngine.Quaternion, UnityEngine.Quaternion, number, ParadoxNotion.Animation.EaseType>{ 
            public constructor();
        }
        export class LerpColor extends FlowCanvas.Nodes.PureFunctionNode$5<UnityEngine.Color, UnityEngine.Color, UnityEngine.Color, number, ParadoxNotion.Animation.EaseType>{ 
            public constructor();
        }
        export class TweenFloat extends FlowCanvas.Nodes.LatentActionNode$4<number, number, number, ParadoxNotion.Animation.EaseType>{ 
            public get value(): number;
            public constructor();
        }
        export class LatentActionNode$4<T1, T2, T3, T4> extends FlowCanvas.Nodes.LatentActionNodeBase{ 
        }
        export class TweenVector3 extends FlowCanvas.Nodes.LatentActionNode$4<UnityEngine.Vector3, UnityEngine.Vector3, number, ParadoxNotion.Animation.EaseType>{ 
            public get value(): UnityEngine.Vector3;
            public constructor();
        }
        export class TweenQuaternion extends FlowCanvas.Nodes.LatentActionNode$4<UnityEngine.Quaternion, UnityEngine.Quaternion, number, ParadoxNotion.Animation.EaseType>{ 
            public get value(): UnityEngine.Quaternion;
            public constructor();
        }
        export class TweenColor extends FlowCanvas.Nodes.LatentActionNode$4<UnityEngine.Color, UnityEngine.Color, number, ParadoxNotion.Animation.EaseType>{ 
            public get value(): UnityEngine.Color;
            public constructor();
        }
        export class TweenPosition extends FlowCanvas.Nodes.LatentActionNode$5<UnityEngine.Transform, UnityEngine.Vector3, number, ParadoxNotion.Animation.EaseType, boolean>{ 
            public constructor();
        }
        export class LatentActionNode$5<T1, T2, T3, T4, T5> extends FlowCanvas.Nodes.LatentActionNodeBase{ 
        }
        export class TweenRotation extends FlowCanvas.Nodes.LatentActionNode$5<UnityEngine.Transform, UnityEngine.Vector3, number, ParadoxNotion.Animation.EaseType, boolean>{ 
            public constructor();
        }
        export class TweenScale extends FlowCanvas.Nodes.LatentActionNode$5<UnityEngine.Transform, UnityEngine.Vector3, number, ParadoxNotion.Animation.EaseType, boolean>{ 
            public constructor();
        }
        export class GetChildTransforms extends FlowCanvas.Nodes.PureFunctionNode$2<System.Collections.Generic.IEnumerable$1<UnityEngine.Transform>, UnityEngine.Transform>{ 
            public constructor();
        }
        export class MoveTo extends FlowCanvas.Nodes.LatentActionNode$4<UnityEngine.AI.NavMeshAgent, UnityEngine.Vector3, number, number>{ 
            public constructor();
        }
        export class RemapFloat extends FlowCanvas.Nodes.PureFunctionNode$6<number, number, number, number, number, number>{ 
            public constructor();
        }
        export class PureFunctionNode$6<TResult, T1, T2, T3, T4, T5> extends FlowCanvas.Nodes.PureFunctionNodeBase{ 
        }
        export class RemapVector3 extends FlowCanvas.Nodes.PureFunctionNode$6<UnityEngine.Vector3, number, number, number, UnityEngine.Vector3, UnityEngine.Vector3>{ 
            public constructor();
        }
        export class LogValue extends FlowCanvas.Nodes.CallableActionNode$1<any>{ 
            public constructor();
        }
        export class CallableActionNode$1<T1> extends FlowCanvas.Nodes.CallableActionNodeBase{ 
        }
        export class LogText extends FlowCanvas.Nodes.CallableActionNode$1<string>{ 
            public constructor();
        }
        export class SendEvent extends FlowCanvas.Nodes.CallableActionNode$2<NodeCanvas.Framework.GraphOwner, string>{ 
            public constructor();
        }
        export class CallableActionNode$2<T1, T2> extends FlowCanvas.Nodes.CallableActionNodeBase{ 
        }
        export class SendGlobalEvent extends FlowCanvas.Nodes.CallableActionNode$1<string>{ 
            public constructor();
        }
        export class SimplexNodeWrapper extends FlowCanvas.FlowNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
        }
        export type EventUniversalDelegate = () => void;
        var EventUniversalDelegate: {new (func: () => void): EventUniversalDelegate;}
        export class GeneratedKeyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public get MemberName(): string;
            public constructor($memberName: string);
            public constructor();
        }
        export class ParamDef extends System.ValueType{ 
            public paramType: System.Type;
            public arrayType: System.Type;
            public paramMode: FlowCanvas.Nodes.ParamMode;
            public portName: string;
            public portId: string;
            public isParamsArray: boolean;
            public presentedInfo: System.Reflection.MemberInfo;
        }
        export enum ParamMode{ Undefined = 0, In = 1, Out = 2, Ref = 3, Instance = 4, Result = 6 }
        export class ParametresDef extends System.ValueType{ 
            public paramDefinitions: System.Collections.Generic.List$1<FlowCanvas.Nodes.ParamDef>;
            public instanceDef: FlowCanvas.Nodes.ParamDef;
            public resultDef: FlowCanvas.Nodes.ParamDef;
        }
        export class ReflectedNodesHelper extends System.Object{ 
            public static GetGetterDefFromInfo($info: System.Reflection.MemberInfo):FlowCanvas.Nodes.ParamDef;
            public static GetDefFromInfo($info: System.Reflection.ParameterInfo, $last: boolean):FlowCanvas.Nodes.ParamDef;
            public static InitParams($targetType: System.Type, $isStatic: boolean, $infos: System.Array$1<System.Reflection.MemberInfo>, $parametres: $Ref<FlowCanvas.Nodes.ParametresDef>):boolean;
            public static InitParams($constructor: System.Reflection.ConstructorInfo, $parametres: $Ref<FlowCanvas.Nodes.ParametresDef>):boolean;
            public static InitParams($method: System.Reflection.MethodInfo, $parametres: $Ref<FlowCanvas.Nodes.ParametresDef>):boolean;
            public static InitParams($field: System.Reflection.FieldInfo, $parametres: $Ref<FlowCanvas.Nodes.ParametresDef>):boolean;
            public static GetGeneratedKey($memberInfo: System.Reflection.MemberInfo):string;
        }
        export type UniversalDelegate = (delegateParams: System.Array$1<FlowCanvas.Nodes.UniversalDelegateParam>) => void;
        var UniversalDelegate: {new (func: (delegateParams: System.Array$1<FlowCanvas.Nodes.UniversalDelegateParam>) => void): UniversalDelegate;}
        export class UniversalDelegateParam extends System.Object{ 
            public paramDef: FlowCanvas.Nodes.ParamDef;
            public paramsArrayNeeded: boolean;
            public paramsArrayCount: number;
            public referencedDelegate: FlowCanvas.Nodes.UniversalDelegate;
            public referencedParams: System.Array$1<FlowCanvas.Nodes.UniversalDelegateParam>;
            public get ValueField(): System.Reflection.FieldInfo;
            public GetCurrentType():System.Type;
            public RegisterAsInput($node: FlowCanvas.FlowNode):void;
            public RegisterAsOutput($node: FlowCanvas.FlowNode):void;
            public RegisterAsOutput($node: FlowCanvas.FlowNode, $beforeReturn: System.Action):void;
            public RegisterAsOutput($node: FlowCanvas.FlowNode, $beforeReturn: System.Action$1<FlowCanvas.Nodes.UniversalDelegateParam>):void;
            public SetFromInput():void;
            public SetFromValue($value: any):void;
        }
        export class BaseReflectedConstructorNode extends System.Object{ 
            public static GetConstructorNode($targetConstructor: System.Reflection.ConstructorInfo, $options: FlowCanvas.Nodes.ReflectedMethodRegistrationOptions):FlowCanvas.Nodes.BaseReflectedConstructorNode;
            public RegisterPorts($node: FlowCanvas.FlowNode, $options: FlowCanvas.Nodes.ReflectedMethodRegistrationOptions):void;
        }
        export class ReflectedMethodRegistrationOptions extends System.ValueType{ 
            public callable: boolean;
            public exposeParams: boolean;
            public exposedParamsCount: number;
        }
        export class JitConstructorNode extends FlowCanvas.Nodes.BaseReflectedConstructorNode{ 
            public constructor();
        }
        export class PureReflectionConstructorNode extends FlowCanvas.Nodes.BaseReflectedConstructorNode{ 
            public constructor();
        }
        export class ReflectedDelegateEvent extends System.Object{ 
            public Add($callback: FlowCanvas.Nodes.ReflectedDelegateEvent.DelegateEventCallback):void;
            public Remove($callback: FlowCanvas.Nodes.ReflectedDelegateEvent.DelegateEventCallback):void;
            public AsDelegate():Function;
            public Callback0():void;
            public static op_Explicit($that: FlowCanvas.Nodes.ReflectedDelegateEvent):Function;
            public constructor();
            public constructor($delegateType: System.Type);
        }
        export class ReflectedUnityEvent extends System.Object{ 
            public get parameters(): System.Array$1<System.Reflection.ParameterInfo>;
            public get eventType(): System.Type;
            public InitForEventType($eventType: System.Type):void;
            public StartListening($targetEvent: UnityEngine.Events.UnityEventBase, $callback: FlowCanvas.Nodes.ReflectedUnityEvent.UnityEventCallback):void;
            public StopListening($targetEvent: UnityEngine.Events.UnityEventBase, $callback: FlowCanvas.Nodes.ReflectedUnityEvent.UnityEventCallback):void;
            public CallbackMethod0():void;
            public constructor();
            public constructor($eventType: System.Type);
        }
        export class SharpEvent extends System.Object{ 
            public get instance(): any;
            public get eventInfo(): System.Reflection.EventInfo;
            public static Create($eventInfo: System.Reflection.EventInfo):FlowCanvas.Nodes.SharpEvent;
            public SetInstance($instance: any):void;
            public StartListening($reflectedEvent: FlowCanvas.Nodes.ReflectedDelegateEvent, $callback: FlowCanvas.Nodes.ReflectedDelegateEvent.DelegateEventCallback):void;
            public StopListening($reflectedEvent: FlowCanvas.Nodes.ReflectedDelegateEvent, $callback: FlowCanvas.Nodes.ReflectedDelegateEvent.DelegateEventCallback):void;
        }
        export class BaseReflectedExtractorNode extends System.Object{ 
            public static GetExtractorNode($targetType: System.Type, $isStatic: boolean, $infos: System.Array$1<System.Reflection.MemberInfo>):FlowCanvas.Nodes.BaseReflectedExtractorNode;
            public RegisterPorts($node: FlowCanvas.FlowNode):void;
        }
        export class JitExtractorNode extends FlowCanvas.Nodes.BaseReflectedExtractorNode{ 
            public constructor();
        }
        export class PureReflectedExtractorNode extends FlowCanvas.Nodes.BaseReflectedExtractorNode{ 
            public constructor();
        }
        export class BaseReflectedFieldNode extends System.Object{ 
            public static GetFieldNode($targetField: System.Reflection.FieldInfo):FlowCanvas.Nodes.BaseReflectedFieldNode;
            public RegisterPorts($node: FlowCanvas.FlowNode, $accessMode: FlowCanvas.Nodes.ReflectedFieldNodeWrapper.AccessMode):void;
        }
        export class JitFieldNode extends FlowCanvas.Nodes.BaseReflectedFieldNode{ 
            public constructor();
        }
        export class PureReflectedFieldNode extends FlowCanvas.Nodes.BaseReflectedFieldNode{ 
            public constructor();
        }
        export class BaseReflectedMethodNode extends System.Object{ 
            public static GetMethodNode($targetMethod: System.Reflection.MethodInfo, $options: FlowCanvas.Nodes.ReflectedMethodRegistrationOptions):FlowCanvas.Nodes.BaseReflectedMethodNode;
            public RegisterPorts($node: FlowCanvas.FlowNode, $options: FlowCanvas.Nodes.ReflectedMethodRegistrationOptions):void;
        }
        export class JitMethodNode extends FlowCanvas.Nodes.BaseReflectedMethodNode{ 
            public constructor();
        }
        export class PureReflectedMethodNode extends FlowCanvas.Nodes.BaseReflectedMethodNode{ 
            public constructor();
        }
        export class FlowNestedFlow extends FlowCanvas.Nodes.FlowNestedBase$1<FlowCanvas.FlowScript> implements FlowCanvas.Nodes.IDropedReferenceNode, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, UnityEngine.ISerializationCallbackReceiver, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<FlowCanvas.FlowScript>{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public get subGraph(): NodeCanvas.Framework.Graph;
            public set subGraph(value: NodeCanvas.Framework.Graph);
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public constructor();
            public SetTarget($target: UnityEngine.Object):void;
            public Update():void;
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
        }
        export class RelayValueInputBase extends FlowCanvas.FlowNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get relayType(): System.Type;
        }
        export class RelayValueOutputBase extends FlowCanvas.FlowNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public SetSource($source: FlowCanvas.Nodes.RelayValueInputBase):void;
        }
        export class NullObject extends FlowCanvas.FlowNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class OwnerVariable extends FlowCanvas.FlowNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public constructor();
        }
        export class CodeEventBase extends FlowCanvas.Nodes.EventNode$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public SetEvent($e: System.Reflection.EventInfo, $instace?: any):void;
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CodeEvent extends FlowCanvas.Nodes.CodeEventBase implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class NewGameObject extends FlowCanvas.Nodes.CallableFunctionNode$4<UnityEngine.GameObject, string, UnityEngine.Vector3, UnityEngine.Quaternion>{ 
            public constructor();
        }
        export class CallableFunctionNode$4<TResult, T1, T2, T3> extends FlowCanvas.Nodes.CallableFunctionNodeBase{ 
        }
        export class NewVector2 extends FlowCanvas.Nodes.PureFunctionNode$3<UnityEngine.Vector2, number, number>{ 
            public constructor();
        }
        export class NewVector3 extends FlowCanvas.Nodes.PureFunctionNode$4<UnityEngine.Vector3, number, number, number>{ 
            public constructor();
        }
        export class NewVector4 extends FlowCanvas.Nodes.PureFunctionNode$5<UnityEngine.Vector4, number, number, number, number>{ 
            public constructor();
        }
        export class NewQuaternion extends FlowCanvas.Nodes.PureFunctionNode$5<UnityEngine.Quaternion, number, number, number, number>{ 
            public constructor();
        }
        export class NewColor extends FlowCanvas.Nodes.PureFunctionNode$5<UnityEngine.Color, number, number, number, number>{ 
            public constructor();
        }
        export class NewBounds extends FlowCanvas.Nodes.PureFunctionNode$3<UnityEngine.Bounds, UnityEngine.Vector3, UnityEngine.Vector3>{ 
            public constructor();
        }
        export class NewRect extends FlowCanvas.Nodes.PureFunctionNode$5<UnityEngine.Rect, number, number, number, number>{ 
            public constructor();
        }
        export class NewRay extends FlowCanvas.Nodes.PureFunctionNode$3<UnityEngine.Ray, UnityEngine.Vector3, UnityEngine.Vector3>{ 
            public constructor();
        }
        export class CustomObjectWrapper extends FlowCanvas.FlowNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public SetTarget($target: UnityEngine.Object):void;
        }
        export class ExtractVector2 extends FlowCanvas.Nodes.ExtractorNode$3<UnityEngine.Vector2, number, number>{ 
            public constructor();
        }
        export class ExtractorNode$3<TInstance, T1, T2> extends FlowCanvas.Nodes.ExtractorNode{ 
        }
        export class ExtractVector3 extends FlowCanvas.Nodes.ExtractorNode$4<UnityEngine.Vector3, number, number, number>{ 
            public constructor();
        }
        export class ExtractorNode$4<TInstance, T1, T2, T3> extends FlowCanvas.Nodes.ExtractorNode{ 
        }
        export class ExtractVector4 extends FlowCanvas.Nodes.ExtractorNode$5<UnityEngine.Vector4, number, number, number, number>{ 
            public constructor();
        }
        export class ExtractorNode$5<TInstance, T1, T2, T3, T4> extends FlowCanvas.Nodes.ExtractorNode{ 
        }
        export class ExtractQuaternion extends FlowCanvas.Nodes.ExtractorNode$6<UnityEngine.Quaternion, number, number, number, number, UnityEngine.Vector3>{ 
            public constructor();
        }
        export class ExtractorNode$6<TInstance, T1, T2, T3, T4, T5> extends FlowCanvas.Nodes.ExtractorNode{ 
        }
        export class ExtractRect extends FlowCanvas.Nodes.ExtractorNode$6<UnityEngine.Rect, UnityEngine.Vector2, number, number, number, number>{ 
            public constructor();
        }
        export class ExtractColor extends FlowCanvas.Nodes.ExtractorNode$5<UnityEngine.Color, number, number, number, number>{ 
            public constructor();
        }
        export class ExtractRaycastHit extends FlowCanvas.Nodes.ExtractorNode$5<UnityEngine.RaycastHit, UnityEngine.GameObject, number, UnityEngine.Vector3, UnityEngine.Vector3>{ 
            public constructor();
        }
        export class ExtractRaycastHit2D extends FlowCanvas.Nodes.ExtractorNode$6<UnityEngine.RaycastHit2D, UnityEngine.GameObject, number, number, UnityEngine.Vector3, UnityEngine.Vector3>{ 
            public constructor();
        }
        export class ExtractRay extends FlowCanvas.Nodes.ExtractorNode$3<UnityEngine.Ray, UnityEngine.Vector3, UnityEngine.Vector3>{ 
            public constructor();
        }
        export class ExtractBounds extends FlowCanvas.Nodes.ExtractorNode$6<UnityEngine.Bounds, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3>{ 
            public constructor();
        }
        export class ExtractCollision extends FlowCanvas.Nodes.ExtractorNode$5<UnityEngine.Collision, System.Array$1<UnityEngine.ContactPoint>, UnityEngine.ContactPoint, UnityEngine.GameObject, UnityEngine.Vector3>{ 
            public constructor();
        }
        export class ExtractCollision2D extends FlowCanvas.Nodes.ExtractorNode$5<UnityEngine.Collision2D, System.Array$1<UnityEngine.ContactPoint2D>, UnityEngine.ContactPoint2D, UnityEngine.GameObject, UnityEngine.Vector2>{ 
            public constructor();
        }
        export class ExtractContactPoint extends FlowCanvas.Nodes.ExtractorNode$5<UnityEngine.ContactPoint, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Collider, UnityEngine.Collider>{ 
            public constructor();
        }
        export class ExtractContactPoint2D extends FlowCanvas.Nodes.ExtractorNode$5<UnityEngine.ContactPoint2D, UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Collider2D, UnityEngine.Collider2D>{ 
            public constructor();
        }
        export class ExtractAnimationCurve extends FlowCanvas.Nodes.ExtractorNode$5<UnityEngine.AnimationCurve, System.Array$1<UnityEngine.Keyframe>, number, UnityEngine.WrapMode, UnityEngine.WrapMode>{ 
            public constructor();
        }
        export class ExtractKeyFrame extends FlowCanvas.Nodes.ExtractorNode$5<UnityEngine.Keyframe, number, number, number, number>{ 
            public constructor();
        }
        export class StaticCodeEventBase extends FlowCanvas.Nodes.EventNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public SetEvent($e: System.Reflection.EventInfo):void;
        }
        export class StaticCodeEvent extends FlowCanvas.Nodes.StaticCodeEventBase implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
    }
    export namespace FlowCanvas.Macros {
        export class MacroNodeWrapper extends FlowCanvas.FlowNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, UnityEngine.ISerializationCallbackReceiver, NodeCanvas.Framework.IGraphAssignable{ 
            public get name(): string;
            public get description(): string;
            public get macro(): FlowCanvas.Macros.Macro;
            public set macro(value: FlowCanvas.Macros.Macro);
            public get subGraph(): NodeCanvas.Framework.Graph;
            public set subGraph(value: NodeCanvas.Framework.Graph);
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public MakeInstance():void;
            public constructor();
            public Update():void;
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
        }
        export class Macro extends FlowCanvas.FlowScriptBase implements NodeCanvas.Framework.ITaskSystem, UnityEngine.ISerializationCallbackReceiver{ 
            public inputDefinitions: System.Collections.Generic.List$1<ParadoxNotion.DynamicParameterDefinition>;
            public outputDefinitions: System.Collections.Generic.List$1<ParadoxNotion.DynamicParameterDefinition>;
            public entryActionMap: System.Collections.Generic.Dictionary$2<string, FlowCanvas.FlowHandler>;
            public exitActionMap: System.Collections.Generic.Dictionary$2<string, FlowCanvas.FlowHandler>;
            public entryFunctionMap: System.Collections.Generic.Dictionary$2<string, FlowCanvas.ValueHandlerObject>;
            public exitFunctionMap: System.Collections.Generic.Dictionary$2<string, FlowCanvas.ValueHandlerObject>;
            public get allowBlackboardOverrides(): boolean;
            public get entry(): FlowCanvas.Macros.MacroInputNode;
            public get exit(): FlowCanvas.Macros.MacroOutputNode;
            public AddInputDefinition($def: ParadoxNotion.DynamicParameterDefinition):FlowCanvas.Port;
            public AddOutputDefinition($def: ParadoxNotion.DynamicParameterDefinition):FlowCanvas.Port;
            public AddExamplePorts():void;
            public CallFlowInput($name: string):void;
            public static CreateMacro():void;
            public constructor();
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
        }
        export class MacroInputNode extends FlowCanvas.FlowNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get iconAlignment(): ParadoxNotion.Alignment2x2;
            public constructor();
        }
        export class MacroOutputNode extends FlowCanvas.FlowNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, UnityEngine.ISerializationCallbackReceiver{ 
            public get iconAlignment(): ParadoxNotion.Alignment2x2;
            public constructor();
        }
    }
    export namespace NodeCanvas.BehaviourTrees {
        export class BehaviourTree extends NodeCanvas.Framework.Graph implements NodeCanvas.Framework.ITaskSystem, UnityEngine.ISerializationCallbackReceiver{ 
            public repeat: boolean;
            public updateInterval: number;
            public get rootStatus(): NodeCanvas.Framework.Status;
            public get baseNodeType(): System.Type;
            public get requiresAgent(): boolean;
            public get requiresPrimeNode(): boolean;
            public get isTree(): boolean;
            public get allowBlackboardOverrides(): boolean;
            public get canAcceptVariableDrops(): boolean;
            public static add_onRootStatusChanged($value: System.Action$2<NodeCanvas.BehaviourTrees.BehaviourTree, NodeCanvas.Framework.Status>):void;
            public static remove_onRootStatusChanged($value: System.Action$2<NodeCanvas.BehaviourTrees.BehaviourTree, NodeCanvas.Framework.Status>):void;
            public constructor();
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
        }
        export class BehaviourTreeOwner extends NodeCanvas.Framework.GraphOwner$1<NodeCanvas.BehaviourTrees.BehaviourTree> implements UnityEngine.ISerializationCallbackReceiver{ 
            public get repeat(): boolean;
            public set repeat(value: boolean);
            public get updateInterval(): number;
            public set updateInterval(value: number);
            public get rootStatus(): NodeCanvas.Framework.Status;
            public Tick():NodeCanvas.Framework.Status;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class BehaviourTreeExtensions extends System.Object{ 
            public static ReplaceWith($node: NodeCanvas.Framework.Node, $t: System.Type):NodeCanvas.Framework.Node;
            public static ConvertToSubTree($root: NodeCanvas.BehaviourTrees.BTNode):NodeCanvas.BehaviourTrees.BehaviourTree;
            public static DeleteBranch($root: NodeCanvas.BehaviourTrees.BTNode):void;
            public static DuplicateBranch($root: NodeCanvas.BehaviourTrees.BTNode, $targetGraph: NodeCanvas.Framework.Graph):NodeCanvas.Framework.Node;
            public static DecorateWith($node: NodeCanvas.BehaviourTrees.BTNode, $t: System.Type):NodeCanvas.Framework.Node;
            public static GetAllChildNodesRecursively($root: NodeCanvas.BehaviourTrees.BTNode, $includeThis: boolean):System.Collections.Generic.List$1<NodeCanvas.BehaviourTrees.BTNode>;
            public static GetAllChildNodesWithDepthRecursively($root: NodeCanvas.BehaviourTrees.BTNode, $includeThis: boolean, $startIndex: number):System.Collections.Generic.Dictionary$2<NodeCanvas.BehaviourTrees.BTNode, number>;
        }
        export class BTNode extends NodeCanvas.Framework.Node implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public get outConnectionType(): System.Type;
            public get allowAsPrime(): boolean;
            public get canSelfConnect(): boolean;
            public get commentsAlignment(): ParadoxNotion.Alignment2x2;
            public get iconAlignment(): ParadoxNotion.Alignment2x2;
            public get maxInConnections(): number;
            public get maxOutConnections(): number;
        }
        interface BTNode {
            ConvertToSubTree():NodeCanvas.BehaviourTrees.BehaviourTree;
            DeleteBranch():void;
            DuplicateBranch($targetGraph: NodeCanvas.Framework.Graph):NodeCanvas.Framework.Node;
            DecorateWith($t: System.Type):NodeCanvas.Framework.Node;
            GetAllChildNodesRecursively($includeThis: boolean):System.Collections.Generic.List$1<NodeCanvas.BehaviourTrees.BTNode>;
            GetAllChildNodesWithDepthRecursively($includeThis: boolean, $startIndex: number):System.Collections.Generic.Dictionary$2<NodeCanvas.BehaviourTrees.BTNode, number>;
        }
        export class BTConnection extends NodeCanvas.Framework.Connection implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public get direction(): ParadoxNotion.PlanarDirection;
            public constructor();
        }
        export class BTComposite extends NodeCanvas.BehaviourTrees.BTNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public get name(): string;
            public get maxOutConnections(): number;
            public get commentsAlignment(): ParadoxNotion.Alignment2x2;
        }
        export class BTDecorator extends NodeCanvas.BehaviourTrees.BTNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public get maxOutConnections(): number;
            public get commentsAlignment(): ParadoxNotion.Alignment2x2;
        }
        export class BinarySelector extends NodeCanvas.BehaviourTrees.BTNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.ITaskAssignable, NodeCanvas.Framework.ITaskAssignable$1<NodeCanvas.Framework.ConditionTask>{ 
            public dynamic: boolean;
            public get maxOutConnections(): number;
            public get commentsAlignment(): ParadoxNotion.Alignment2x2;
            public get name(): string;
            public get task(): NodeCanvas.Framework.Task;
            public set task(value: NodeCanvas.Framework.Task);
            public constructor();
        }
        export class FlipSelector extends NodeCanvas.BehaviourTrees.BTComposite implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public constructor();
        }
        export class Parallel extends NodeCanvas.BehaviourTrees.BTComposite implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public policy: NodeCanvas.BehaviourTrees.Parallel.ParallelPolicy;
            public dynamic: boolean;
            public constructor();
        }
        export class PrioritySelector extends NodeCanvas.BehaviourTrees.BTComposite implements ParadoxNotion.Serialization.FullSerializer.IMigratable, ParadoxNotion.Serialization.FullSerializer.IMigratable$1<NodeCanvas.BehaviourTrees.PrioritySelector_0>, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public desires: System.Collections.Generic.List$1<NodeCanvas.BehaviourTrees.PrioritySelector.Desire>;
            public constructor();
        }
        export class PrioritySelector_0 extends NodeCanvas.BehaviourTrees.BTComposite implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
        }
        export class ProbabilitySelector extends NodeCanvas.BehaviourTrees.BTComposite implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public childWeights: System.Collections.Generic.List$1<NodeCanvas.Framework.BBParameter$1<number>>;
            public failChance: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
        }
        export class Selector extends NodeCanvas.BehaviourTrees.BTComposite implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public dynamic: boolean;
            public random: boolean;
            public constructor();
        }
        export class Sequencer extends NodeCanvas.BehaviourTrees.BTComposite implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public dynamic: boolean;
            public random: boolean;
            public constructor();
        }
        export class StepIterator extends NodeCanvas.BehaviourTrees.BTComposite implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public constructor();
        }
        export class Switch extends NodeCanvas.BehaviourTrees.BTComposite implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public dynamic: boolean;
            public selectionMode: NodeCanvas.BehaviourTrees.Switch.CaseSelectionMode;
            public intCase: NodeCanvas.Framework.BBParameter$1<number>;
            public outOfRangeMode: NodeCanvas.BehaviourTrees.Switch.OutOfRangeMode;
            public enumCase: NodeCanvas.Framework.Internal.BBObjectParameter;
            public constructor();
        }
        export class ConditionalEvaluator extends NodeCanvas.BehaviourTrees.BTDecorator implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.ITaskAssignable, NodeCanvas.Framework.ITaskAssignable$1<NodeCanvas.Framework.ConditionTask>{ 
            public isDynamic: boolean;
            public conditionFailReturn: ParadoxNotion.CompactStatus;
            public get task(): NodeCanvas.Framework.Task;
            public set task(value: NodeCanvas.Framework.Task);
            public constructor();
        }
        export class Filter extends NodeCanvas.BehaviourTrees.BTDecorator implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public filterMode: NodeCanvas.BehaviourTrees.Filter.FilterMode;
            public maxCount: NodeCanvas.Framework.BBParameter$1<number>;
            public policy: NodeCanvas.BehaviourTrees.Filter.Policy;
            public coolDownTime: NodeCanvas.Framework.BBParameter$1<number>;
            public inactiveWhenLimited: boolean;
            public constructor();
        }
        export class Guard extends NodeCanvas.BehaviourTrees.BTDecorator implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public token: NodeCanvas.Framework.BBParameter$1<string>;
            public ifGuarded: NodeCanvas.BehaviourTrees.Guard.GuardMode;
            public constructor();
        }
        export class Interruptor extends NodeCanvas.BehaviourTrees.BTDecorator implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.ITaskAssignable, NodeCanvas.Framework.ITaskAssignable$1<NodeCanvas.Framework.ConditionTask>{ 
            public get condition(): NodeCanvas.Framework.ConditionTask;
            public set condition(value: NodeCanvas.Framework.ConditionTask);
            public get task(): NodeCanvas.Framework.Task;
            public set task(value: NodeCanvas.Framework.Task);
            public constructor();
        }
        export class Inverter extends NodeCanvas.BehaviourTrees.BTDecorator implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public constructor();
        }
        export class Iterator extends NodeCanvas.BehaviourTrees.BTDecorator implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public targetList: NodeCanvas.Framework.BBParameter$1<System.Collections.IList>;
            public current: NodeCanvas.Framework.Internal.BBObjectParameter;
            public storeIndex: NodeCanvas.Framework.BBParameter$1<number>;
            public maxIteration: NodeCanvas.Framework.BBParameter$1<number>;
            public terminationCondition: NodeCanvas.BehaviourTrees.Iterator.TerminationConditions;
            public resetIndex: boolean;
            public constructor();
        }
        export class Merge extends NodeCanvas.BehaviourTrees.BTDecorator implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public get maxInConnections(): number;
            public constructor();
        }
        export class Monitor extends NodeCanvas.BehaviourTrees.BTDecorator implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.ITaskAssignable, NodeCanvas.Framework.ITaskAssignable$1<NodeCanvas.Framework.ActionTask>{ 
            public monitorMode: NodeCanvas.BehaviourTrees.Monitor.MonitorMode;
            public returnMode: NodeCanvas.BehaviourTrees.Monitor.ReturnStatusMode;
            public get action(): NodeCanvas.Framework.ActionTask;
            public set action(value: NodeCanvas.Framework.ActionTask);
            public get task(): NodeCanvas.Framework.Task;
            public set task(value: NodeCanvas.Framework.Task);
            public constructor();
        }
        export class Optional extends NodeCanvas.BehaviourTrees.BTDecorator implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public constructor();
        }
        export class Remapper extends NodeCanvas.BehaviourTrees.BTDecorator implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public successRemap: NodeCanvas.BehaviourTrees.Remapper.RemapStatus;
            public failureRemap: NodeCanvas.BehaviourTrees.Remapper.RemapStatus;
            public constructor();
        }
        export class Repeater extends NodeCanvas.BehaviourTrees.BTDecorator implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public repeaterMode: NodeCanvas.BehaviourTrees.Repeater.RepeaterMode;
            public repeatTimes: NodeCanvas.Framework.BBParameter$1<number>;
            public repeatUntilStatus: NodeCanvas.BehaviourTrees.Repeater.RepeatUntilStatus;
            public constructor();
        }
        export class Setter extends NodeCanvas.BehaviourTrees.BTDecorator implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public revertToOriginal: boolean;
            public newAgent: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public constructor();
        }
        export class Timeout extends NodeCanvas.BehaviourTrees.BTDecorator implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public timeout: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
        }
        export class WaitUntil extends NodeCanvas.BehaviourTrees.BTDecorator implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.ITaskAssignable, NodeCanvas.Framework.ITaskAssignable$1<NodeCanvas.Framework.ConditionTask>{ 
            public get task(): NodeCanvas.Framework.Task;
            public set task(value: NodeCanvas.Framework.Task);
            public constructor();
        }
        export class ActionNode extends NodeCanvas.BehaviourTrees.BTNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.ITaskAssignable, NodeCanvas.Framework.ITaskAssignable$1<NodeCanvas.Framework.ActionTask>{ 
            public get task(): NodeCanvas.Framework.Task;
            public set task(value: NodeCanvas.Framework.Task);
            public get action(): NodeCanvas.Framework.ActionTask;
            public set action(value: NodeCanvas.Framework.ActionTask);
            public get name(): string;
            public constructor();
        }
        export class ConditionNode extends NodeCanvas.BehaviourTrees.BTNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.ITaskAssignable, NodeCanvas.Framework.ITaskAssignable$1<NodeCanvas.Framework.ConditionTask>{ 
            public get task(): NodeCanvas.Framework.Task;
            public set task(value: NodeCanvas.Framework.Task);
            public get condition(): NodeCanvas.Framework.ConditionTask;
            public set condition(value: NodeCanvas.Framework.ConditionTask);
            public get name(): string;
            public constructor();
        }
        export class NestedDT extends NodeCanvas.BehaviourTrees.BTNodeNested$1<NodeCanvas.DialogueTrees.DialogueTree> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<NodeCanvas.DialogueTrees.DialogueTree>{ 
            public get subGraph(): NodeCanvas.DialogueTrees.DialogueTree;
            public set subGraph(value: NodeCanvas.DialogueTrees.DialogueTree);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public constructor();
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
        }
        export class BTNodeNested$1<T> extends NodeCanvas.BehaviourTrees.BTNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<T>{ 
            public get subGraph(): NodeCanvas.Framework.Graph;
            public set subGraph(value: NodeCanvas.Framework.Graph);
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
        }
        export class NestedFSM extends NodeCanvas.BehaviourTrees.BTNodeNested$1<NodeCanvas.StateMachines.FSM> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<NodeCanvas.StateMachines.FSM>{ 
            public successState: string;
            public failureState: string;
            public get subGraph(): NodeCanvas.StateMachines.FSM;
            public set subGraph(value: NodeCanvas.StateMachines.FSM);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public constructor();
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
        }
        export class SubTree extends NodeCanvas.BehaviourTrees.BTNodeNested$1<NodeCanvas.BehaviourTrees.BehaviourTree> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<NodeCanvas.BehaviourTrees.BehaviourTree>{ 
            public get subGraph(): NodeCanvas.BehaviourTrees.BehaviourTree;
            public set subGraph(value: NodeCanvas.BehaviourTrees.BehaviourTree);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public constructor();
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
        }
        export class BTNestedFlowScript extends NodeCanvas.BehaviourTrees.BTNodeNested$1<FlowCanvas.FlowScript> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<FlowCanvas.FlowScript>{ 
            public get subGraph(): FlowCanvas.FlowScript;
            public set subGraph(value: FlowCanvas.FlowScript);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public constructor();
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
        }
        export class NodeToggler extends NodeCanvas.BehaviourTrees.BTNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public toggleMode: NodeCanvas.BehaviourTrees.NodeToggler.ToggleMode;
            public targetNodeTag: string;
            public constructor();
        }
        export class RootSwitcher extends NodeCanvas.BehaviourTrees.BTNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public targetNodeTag: string;
            public constructor();
        }
    }
    export namespace NodeCanvas.StateMachines {
        export class FSM extends NodeCanvas.Framework.Graph implements NodeCanvas.Framework.ITaskSystem, UnityEngine.ISerializationCallbackReceiver{ 
            public get currentState(): NodeCanvas.StateMachines.FSMState;
            public get previousState(): NodeCanvas.StateMachines.FSMState;
            public get currentStateName(): string;
            public get previousStateName(): string;
            public get baseNodeType(): System.Type;
            public get requiresAgent(): boolean;
            public get requiresPrimeNode(): boolean;
            public get isTree(): boolean;
            public get allowBlackboardOverrides(): boolean;
            public get canAcceptVariableDrops(): boolean;
            public add_onStateEnter($value: System.Action$1<NodeCanvas.StateMachines.IState>):void;
            public remove_onStateEnter($value: System.Action$1<NodeCanvas.StateMachines.IState>):void;
            public add_onStateUpdate($value: System.Action$1<NodeCanvas.StateMachines.IState>):void;
            public remove_onStateUpdate($value: System.Action$1<NodeCanvas.StateMachines.IState>):void;
            public add_onStateExit($value: System.Action$1<NodeCanvas.StateMachines.IState>):void;
            public remove_onStateExit($value: System.Action$1<NodeCanvas.StateMachines.IState>):void;
            public add_onStateTransition($value: System.Action$1<NodeCanvas.StateMachines.IState>):void;
            public remove_onStateTransition($value: System.Action$1<NodeCanvas.StateMachines.IState>):void;
            public EnterState($newState: NodeCanvas.StateMachines.FSMState, $callMode: NodeCanvas.StateMachines.FSM.TransitionCallMode):boolean;
            public TriggerState($stateName: string, $callMode: NodeCanvas.StateMachines.FSM.TransitionCallMode):NodeCanvas.StateMachines.FSMState;
            public GetStateNames():System.Array$1<string>;
            public GetStateWithName($name: string):NodeCanvas.StateMachines.FSMState;
            public PeekStack():NodeCanvas.StateMachines.FSMState;
            public constructor();
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
        }
        export class FSMOwner extends NodeCanvas.Framework.GraphOwner$1<NodeCanvas.StateMachines.FSM> implements UnityEngine.ISerializationCallbackReceiver{ 
            public get currentRootStateName(): string;
            public get previousRootStateName(): string;
            public get currentDeepStateName(): string;
            public get previousDeepStateName(): string;
            public GetCurrentState($includeSubFSMs?: boolean):NodeCanvas.StateMachines.IState;
            public GetPreviousState($includeSubFSMs?: boolean):NodeCanvas.StateMachines.IState;
            public TriggerState($stateName: string):NodeCanvas.StateMachines.IState;
            public TriggerState($stateName: string, $callMode: NodeCanvas.StateMachines.FSM.TransitionCallMode):NodeCanvas.StateMachines.IState;
            public GetStateNames():System.Array$1<string>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export interface IState{ 
            name: string;
            tag: string;
            elapsedTime: number;
            FSM: NodeCanvas.StateMachines.FSM;
            GetTransitions():System.Array$1<NodeCanvas.StateMachines.FSMConnection>;
            CheckTransitions():boolean;
            Finish($success: boolean):void;
        }
        export class FSMState extends NodeCanvas.StateMachines.FSMNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.StateMachines.IState{ 
            public get allowAsPrime(): boolean;
            public get canSelfConnect(): boolean;
            public get maxInConnections(): number;
            public get maxOutConnections(): number;
            public get transitionEvaluation(): NodeCanvas.StateMachines.FSMState.TransitionEvaluationMode;
            public set transitionEvaluation(value: NodeCanvas.StateMachines.FSMState.TransitionEvaluationMode);
            public GetTransitions():System.Array$1<NodeCanvas.StateMachines.FSMConnection>;
            public Finish():void;
            public Finish($inSuccess: boolean):void;
            public Finish($status: NodeCanvas.Framework.Status):void;
            public Update():void;
            public CheckTransitions():boolean;
            public Finish($success: boolean):void;
        }
        export class FSMNode extends NodeCanvas.Framework.Node implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public get allowAsPrime(): boolean;
            public get canSelfConnect(): boolean;
            public get maxInConnections(): number;
            public get maxOutConnections(): number;
            public get outConnectionType(): System.Type;
            public get commentsAlignment(): ParadoxNotion.Alignment2x2;
            public get iconAlignment(): ParadoxNotion.Alignment2x2;
            public get FSM(): NodeCanvas.StateMachines.FSM;
        }
        export class FSMConnection extends NodeCanvas.Framework.Connection implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.ITaskAssignable, NodeCanvas.Framework.ITaskAssignable$1<NodeCanvas.Framework.ConditionTask>{ 
            public get condition(): NodeCanvas.Framework.ConditionTask;
            public set condition(value: NodeCanvas.Framework.ConditionTask);
            public get task(): NodeCanvas.Framework.Task;
            public set task(value: NodeCanvas.Framework.Task);
            public get transitionCallMode(): NodeCanvas.StateMachines.FSM.TransitionCallMode;
            public get direction(): ParadoxNotion.PlanarDirection;
            public get tipConnectionStyle(): NodeCanvas.Framework.Connection.TipConnectionStyle;
            public get animate(): boolean;
            public EnableCondition($agent: UnityEngine.Component, $blackboard: NodeCanvas.Framework.IBlackboard):void;
            public DisableCondition():void;
            public PerformTransition():void;
            public constructor();
        }
        export interface IStateCallbackReceiver{ 
            OnStateEnter($state: NodeCanvas.StateMachines.IState):void;
            OnStateUpdate($state: NodeCanvas.StateMachines.IState):void;
            OnStateExit($state: NodeCanvas.StateMachines.IState):void;
        }
        export class ActionState extends NodeCanvas.StateMachines.FSMState implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.StateMachines.IState, NodeCanvas.Framework.ITaskAssignable{ 
            public get task(): NodeCanvas.Framework.Task;
            public set task(value: NodeCanvas.Framework.Task);
            public get actionList(): NodeCanvas.Framework.ActionList;
            public set actionList(value: NodeCanvas.Framework.ActionList);
            public get repeatStateActions(): boolean;
            public set repeatStateActions(value: boolean);
            public constructor();
            public Finish($success: boolean):void;
            public Finish():void;
            public Finish($inSuccess: boolean):void;
            public Finish($status: NodeCanvas.Framework.Status):void;
            public Finish($success: boolean):void;
        }
        export class AnyState extends NodeCanvas.StateMachines.FSMNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable{ 
            public dontRetriggerStates: boolean;
            public get name(): string;
            public get maxInConnections(): number;
            public get maxOutConnections(): number;
            public get allowAsPrime(): boolean;
            public constructor();
            public Update():void;
        }
        export class ConcurrentState extends NodeCanvas.StateMachines.FSMNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable{ 
            public get conditionList(): NodeCanvas.Framework.ConditionList;
            public set conditionList(value: NodeCanvas.Framework.ConditionList);
            public get actionList(): NodeCanvas.Framework.ActionList;
            public set actionList(value: NodeCanvas.Framework.ActionList);
            public get repeatStateActions(): boolean;
            public set repeatStateActions(value: boolean);
            public get name(): string;
            public get maxInConnections(): number;
            public get maxOutConnections(): number;
            public get allowAsPrime(): boolean;
            public constructor();
            public Update():void;
        }
        export class ConcurrentSubFSM extends NodeCanvas.StateMachines.FSMNodeNested$1<NodeCanvas.StateMachines.FSM> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<NodeCanvas.StateMachines.FSM>{ 
            public get name(): string;
            public get maxInConnections(): number;
            public get maxOutConnections(): number;
            public get allowAsPrime(): boolean;
            public get subGraph(): NodeCanvas.StateMachines.FSM;
            public set subGraph(value: NodeCanvas.StateMachines.FSM);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public constructor();
            public Update():void;
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
        }
        export class FSMNodeNested$1<T> extends NodeCanvas.StateMachines.FSMNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<T>{ 
            public get subGraph(): NodeCanvas.Framework.Graph;
            public set subGraph(value: NodeCanvas.Framework.Graph);
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
        }
        export class ConcurrentSubTree extends NodeCanvas.StateMachines.FSMNodeNested$1<NodeCanvas.BehaviourTrees.BehaviourTree> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<NodeCanvas.BehaviourTrees.BehaviourTree>{ 
            public get name(): string;
            public get maxInConnections(): number;
            public get maxOutConnections(): number;
            public get allowAsPrime(): boolean;
            public get subGraph(): NodeCanvas.BehaviourTrees.BehaviourTree;
            public set subGraph(value: NodeCanvas.BehaviourTrees.BehaviourTree);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public constructor();
            public Update():void;
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
        }
        export class EmptyState extends NodeCanvas.StateMachines.FSMState implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.StateMachines.IState{ 
            public get name(): string;
            public constructor();
            public Finish($success: boolean):void;
            public Finish():void;
            public Finish($inSuccess: boolean):void;
            public Finish($status: NodeCanvas.Framework.Status):void;
            public Finish($success: boolean):void;
        }
        export class NestedBTState extends NodeCanvas.StateMachines.FSMStateNested$1<NodeCanvas.BehaviourTrees.BehaviourTree> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<NodeCanvas.BehaviourTrees.BehaviourTree>, NodeCanvas.StateMachines.IState{ 
            public exitMode: NodeCanvas.StateMachines.NestedBTState.BTExitMode;
            public executionMode: NodeCanvas.StateMachines.NestedBTState.BTExecutionMode;
            public successEvent: string;
            public failureEvent: string;
            public get subGraph(): NodeCanvas.BehaviourTrees.BehaviourTree;
            public set subGraph(value: NodeCanvas.BehaviourTrees.BehaviourTree);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public get tag(): string;
            public get elapsedTime(): number;
            public get FSM(): NodeCanvas.StateMachines.FSM;
            public constructor();
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
            public GetTransitions():System.Array$1<NodeCanvas.StateMachines.FSMConnection>;
            public CheckTransitions():boolean;
            public Finish($success: boolean):void;
        }
        export class FSMStateNested$1<T> extends NodeCanvas.StateMachines.FSMState implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<T>, NodeCanvas.StateMachines.IState{ 
            public get subGraph(): NodeCanvas.Framework.Graph;
            public set subGraph(value: NodeCanvas.Framework.Graph);
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public Finish($success: boolean):void;
            public Finish():void;
            public Finish($inSuccess: boolean):void;
            public Finish($status: NodeCanvas.Framework.Status):void;
            public Finish($success: boolean):void;
        }
        export class NestedDTState extends NodeCanvas.StateMachines.FSMStateNested$1<NodeCanvas.DialogueTrees.DialogueTree> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<NodeCanvas.DialogueTrees.DialogueTree>, NodeCanvas.StateMachines.IState{ 
            public successEvent: string;
            public failureEvent: string;
            public get subGraph(): NodeCanvas.DialogueTrees.DialogueTree;
            public set subGraph(value: NodeCanvas.DialogueTrees.DialogueTree);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public get tag(): string;
            public get elapsedTime(): number;
            public get FSM(): NodeCanvas.StateMachines.FSM;
            public constructor();
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
            public GetTransitions():System.Array$1<NodeCanvas.StateMachines.FSMConnection>;
            public CheckTransitions():boolean;
            public Finish($success: boolean):void;
        }
        export class NestedFSMState extends NodeCanvas.StateMachines.FSMStateNested$1<NodeCanvas.StateMachines.FSM> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<NodeCanvas.StateMachines.FSM>, NodeCanvas.StateMachines.IState{ 
            public exitMode: NodeCanvas.StateMachines.NestedFSMState.FSMExitMode;
            public get subGraph(): NodeCanvas.StateMachines.FSM;
            public set subGraph(value: NodeCanvas.StateMachines.FSM);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public get tag(): string;
            public get elapsedTime(): number;
            public get FSM(): NodeCanvas.StateMachines.FSM;
            public constructor();
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
            public GetTransitions():System.Array$1<NodeCanvas.StateMachines.FSMConnection>;
            public CheckTransitions():boolean;
            public Finish($success: boolean):void;
        }
        export class SuperActionState extends NodeCanvas.StateMachines.FSMState implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.StateMachines.IState{ 
            public constructor();
            public Finish($success: boolean):void;
            public Finish():void;
            public Finish($inSuccess: boolean):void;
            public Finish($status: NodeCanvas.Framework.Status):void;
            public Finish($success: boolean):void;
        }
        export class ConcurrentSubFlowScript extends NodeCanvas.StateMachines.FSMNodeNested$1<FlowCanvas.FlowScript> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<FlowCanvas.FlowScript>{ 
            public get name(): string;
            public get maxInConnections(): number;
            public get maxOutConnections(): number;
            public get allowAsPrime(): boolean;
            public get subGraph(): FlowCanvas.FlowScript;
            public set subGraph(value: FlowCanvas.FlowScript);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public constructor();
            public Update():void;
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
        }
        export class FlowScriptState extends NodeCanvas.StateMachines.FSMStateNested$1<FlowCanvas.FlowScript> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<FlowCanvas.FlowScript>, NodeCanvas.StateMachines.IState{ 
            public successEvent: string;
            public failureEvent: string;
            public get subGraph(): FlowCanvas.FlowScript;
            public set subGraph(value: FlowCanvas.FlowScript);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public get tag(): string;
            public get elapsedTime(): number;
            public get FSM(): NodeCanvas.StateMachines.FSM;
            public constructor();
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
            public GetTransitions():System.Array$1<NodeCanvas.StateMachines.FSMConnection>;
            public CheckTransitions():boolean;
            public Finish($success: boolean):void;
        }
    }
    export namespace NodeCanvas.DialogueTrees {
        export class DialogueTree extends NodeCanvas.Framework.Graph implements NodeCanvas.Framework.ITaskSystem, UnityEngine.ISerializationCallbackReceiver{ 
            public static INSTIGATOR_NAME: string;
            public actorParameters: System.Collections.Generic.List$1<NodeCanvas.DialogueTrees.DialogueTree.ActorParameter>;
            public static get currentDialogue(): NodeCanvas.DialogueTrees.DialogueTree;
            public static get previousDialogue(): NodeCanvas.DialogueTrees.DialogueTree;
            public get currentNode(): NodeCanvas.DialogueTrees.DTNode;
            public get baseNodeType(): System.Type;
            public get requiresAgent(): boolean;
            public get requiresPrimeNode(): boolean;
            public get isTree(): boolean;
            public get allowBlackboardOverrides(): boolean;
            public get canAcceptVariableDrops(): boolean;
            public get definedActorParameterNames(): System.Collections.Generic.List$1<string>;
            public static add_OnDialogueStarted($value: System.Action$1<NodeCanvas.DialogueTrees.DialogueTree>):void;
            public static remove_OnDialogueStarted($value: System.Action$1<NodeCanvas.DialogueTrees.DialogueTree>):void;
            public static add_OnDialoguePaused($value: System.Action$1<NodeCanvas.DialogueTrees.DialogueTree>):void;
            public static remove_OnDialoguePaused($value: System.Action$1<NodeCanvas.DialogueTrees.DialogueTree>):void;
            public static add_OnDialogueFinished($value: System.Action$1<NodeCanvas.DialogueTrees.DialogueTree>):void;
            public static remove_OnDialogueFinished($value: System.Action$1<NodeCanvas.DialogueTrees.DialogueTree>):void;
            public static add_OnSubtitlesRequest($value: System.Action$1<NodeCanvas.DialogueTrees.SubtitlesRequestInfo>):void;
            public static remove_OnSubtitlesRequest($value: System.Action$1<NodeCanvas.DialogueTrees.SubtitlesRequestInfo>):void;
            public static add_OnMultipleChoiceRequest($value: System.Action$1<NodeCanvas.DialogueTrees.MultipleChoiceRequestInfo>):void;
            public static remove_OnMultipleChoiceRequest($value: System.Action$1<NodeCanvas.DialogueTrees.MultipleChoiceRequestInfo>):void;
            public GetParameterByID($id: string):NodeCanvas.DialogueTrees.DialogueTree.ActorParameter;
            public GetParameterByName($paramName: string):NodeCanvas.DialogueTrees.DialogueTree.ActorParameter;
            public GetActorReferenceByID($id: string):NodeCanvas.DialogueTrees.IDialogueActor;
            public GetActorReferenceByName($paramName: string):NodeCanvas.DialogueTrees.IDialogueActor;
            public SetActorReference($paramName: string, $actor: NodeCanvas.DialogueTrees.IDialogueActor):void;
            public SetActorReferences($actors: System.Collections.Generic.Dictionary$2<string, NodeCanvas.DialogueTrees.IDialogueActor>):void;
            public Continue($index?: number):void;
            public EnterNode($node: NodeCanvas.DialogueTrees.DTNode):void;
            public static RequestSubtitles($info: NodeCanvas.DialogueTrees.SubtitlesRequestInfo):void;
            public static RequestMultipleChoices($info: NodeCanvas.DialogueTrees.MultipleChoiceRequestInfo):void;
            public constructor();
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
            public SendEvent($name: string, $value: any, $sender: any):void;
        }
        export interface IDialogueActor{ 
            name: string;
            portrait: UnityEngine.Texture2D;
            portraitSprite: UnityEngine.Sprite;
            dialogueColor: UnityEngine.Color;
            dialoguePosition: UnityEngine.Vector3;
            transform: UnityEngine.Transform;
        }
        export class Statement extends System.Object implements NodeCanvas.DialogueTrees.IStatement{ 
            public get text(): string;
            public set text(value: string);
            public get audio(): UnityEngine.AudioClip;
            public set audio(value: UnityEngine.AudioClip);
            public get meta(): string;
            public set meta(value: string);
            public BlackboardReplace($bb: NodeCanvas.Framework.IBlackboard):NodeCanvas.DialogueTrees.IStatement;
            public constructor();
            public constructor($text: string);
            public constructor($text: string, $audio: UnityEngine.AudioClip);
            public constructor($text: string, $audio: UnityEngine.AudioClip, $meta: string);
        }
        export interface IStatement{ 
            text: string;
            audio: UnityEngine.AudioClip;
            meta: string;
        }
        export class DialogueTreeController extends NodeCanvas.Framework.GraphOwner$1<NodeCanvas.DialogueTrees.DialogueTree> implements UnityEngine.ISerializationCallbackReceiver, NodeCanvas.DialogueTrees.IDialogueActor{ 
            public get name(): string;
            public get portrait(): UnityEngine.Texture2D;
            public get portraitSprite(): UnityEngine.Sprite;
            public get dialogueColor(): UnityEngine.Color;
            public get dialoguePosition(): UnityEngine.Vector3;
            public get transform(): UnityEngine.Transform;
            public StartDialogue():void;
            public StartDialogue($callback: System.Action$1<boolean>):void;
            public StartDialogue($instigator: NodeCanvas.DialogueTrees.IDialogueActor):void;
            public StartDialogue($newTree: NodeCanvas.DialogueTrees.DialogueTree, $instigator: NodeCanvas.DialogueTrees.IDialogueActor, $callback: System.Action$1<boolean>):void;
            public StartDialogue($instigator: NodeCanvas.DialogueTrees.IDialogueActor, $callback: System.Action$1<boolean>):void;
            public PauseDialogue():void;
            public StopDialogue():void;
            public SetActorReference($paramName: string, $actor: NodeCanvas.DialogueTrees.IDialogueActor):void;
            public SetActorReferences($actors: System.Collections.Generic.Dictionary$2<string, NodeCanvas.DialogueTrees.IDialogueActor>):void;
            public GetActorReferenceByName($paramName: string):NodeCanvas.DialogueTrees.IDialogueActor;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class DialogueActor extends UnityEngine.MonoBehaviour implements NodeCanvas.DialogueTrees.IDialogueActor{ 
            public get name(): string;
            public get portrait(): UnityEngine.Texture2D;
            public get portraitSprite(): UnityEngine.Sprite;
            public get dialogueColor(): UnityEngine.Color;
            public get dialoguePosition(): UnityEngine.Vector3;
            public constructor();
        }
        export class SubtitlesRequestInfo extends System.Object{ 
            public actor: NodeCanvas.DialogueTrees.IDialogueActor;
            public statement: NodeCanvas.DialogueTrees.IStatement;
            public Continue: System.Action;
            public constructor($actor: NodeCanvas.DialogueTrees.IDialogueActor, $statement: NodeCanvas.DialogueTrees.IStatement, $callback: System.Action);
            public constructor();
        }
        export class MultipleChoiceRequestInfo extends System.Object{ 
            public actor: NodeCanvas.DialogueTrees.IDialogueActor;
            public options: System.Collections.Generic.Dictionary$2<NodeCanvas.DialogueTrees.IStatement, number>;
            public availableTime: number;
            public showLastStatement: boolean;
            public SelectOption: System.Action$1<number>;
            public constructor($actor: NodeCanvas.DialogueTrees.IDialogueActor, $options: System.Collections.Generic.Dictionary$2<NodeCanvas.DialogueTrees.IStatement, number>, $availableTime: number, $showLastStatement: boolean, $callback: System.Action$1<number>);
            public constructor($actor: NodeCanvas.DialogueTrees.IDialogueActor, $options: System.Collections.Generic.Dictionary$2<NodeCanvas.DialogueTrees.IStatement, number>, $availableTime: number, $callback: System.Action$1<number>);
            public constructor();
        }
        export class DTNode extends NodeCanvas.Framework.Node implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public get name(): string;
            public get requireActorSelection(): boolean;
            public get maxInConnections(): number;
            public get maxOutConnections(): number;
            public get outConnectionType(): System.Type;
            public get allowAsPrime(): boolean;
            public get canSelfConnect(): boolean;
            public get commentsAlignment(): ParadoxNotion.Alignment2x2;
            public get iconAlignment(): ParadoxNotion.Alignment2x2;
            public get actorName(): string;
            public get finalActor(): NodeCanvas.DialogueTrees.IDialogueActor;
        }
        export class DTConnection extends NodeCanvas.Framework.Connection implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public get direction(): ParadoxNotion.PlanarDirection;
            public constructor();
        }
        export class ProxyDialogueActor extends System.Object implements NodeCanvas.DialogueTrees.IDialogueActor{ 
            public get name(): string;
            public get portrait(): UnityEngine.Texture2D;
            public get portraitSprite(): UnityEngine.Sprite;
            public get dialogueColor(): UnityEngine.Color;
            public get dialoguePosition(): UnityEngine.Vector3;
            public get transform(): UnityEngine.Transform;
            public constructor($name: string, $transform: UnityEngine.Transform);
            public constructor();
        }
        export class ActionNode extends NodeCanvas.DialogueTrees.DTNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.ITaskAssignable, NodeCanvas.Framework.ITaskAssignable$1<NodeCanvas.Framework.ActionTask>{ 
            public get action(): NodeCanvas.Framework.ActionTask;
            public set action(value: NodeCanvas.Framework.ActionTask);
            public get task(): NodeCanvas.Framework.Task;
            public set task(value: NodeCanvas.Framework.Task);
            public get requireActorSelection(): boolean;
            public constructor();
        }
        export class ConditionNode extends NodeCanvas.DialogueTrees.DTNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.ITaskAssignable, NodeCanvas.Framework.ITaskAssignable$1<NodeCanvas.Framework.ConditionTask>{ 
            public get condition(): NodeCanvas.Framework.ConditionTask;
            public set condition(value: NodeCanvas.Framework.ConditionTask);
            public get task(): NodeCanvas.Framework.Task;
            public set task(value: NodeCanvas.Framework.Task);
            public get maxOutConnections(): number;
            public get requireActorSelection(): boolean;
            public constructor();
        }
        export class FinishNode extends NodeCanvas.DialogueTrees.DTNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public finishState: ParadoxNotion.CompactStatus;
            public get maxOutConnections(): number;
            public get requireActorSelection(): boolean;
            public constructor();
        }
        export class Jumper extends NodeCanvas.DialogueTrees.DTNode implements NodeCanvas.Framework.IHaveNodeReference, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public _targetNode: NodeCanvas.Framework.NodeReference$1<NodeCanvas.DialogueTrees.DTNode>;
            public get maxOutConnections(): number;
            public get requireActorSelection(): boolean;
            public get targetReference(): NodeCanvas.Framework.INodeReference;
            public constructor();
        }
        export class MultipleChoiceNode extends NodeCanvas.DialogueTrees.DTNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public availableTime: number;
            public saySelection: boolean;
            public get maxOutConnections(): number;
            public get requireActorSelection(): boolean;
            public constructor();
        }
        export class MultipleConditionNode extends NodeCanvas.DialogueTrees.DTNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public get maxOutConnections(): number;
            public constructor();
        }
        export class ProbabilitySelector extends NodeCanvas.DialogueTrees.DTNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public get maxOutConnections(): number;
            public constructor();
        }
        export class StatementNode extends NodeCanvas.DialogueTrees.DTNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public statement: NodeCanvas.DialogueTrees.Statement;
            public get requireActorSelection(): boolean;
            public constructor();
        }
        export class SubDialogueTree extends NodeCanvas.DialogueTrees.DTNodeNested$1<NodeCanvas.DialogueTrees.DialogueTree> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<NodeCanvas.DialogueTrees.DialogueTree>{ 
            public get maxOutConnections(): number;
            public get subGraph(): NodeCanvas.DialogueTrees.DialogueTree;
            public set subGraph(value: NodeCanvas.DialogueTrees.DialogueTree);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public constructor();
            public Update():void;
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
        }
        export class DTNodeNested$1<T> extends NodeCanvas.DialogueTrees.DTNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<T>{ 
            public get subGraph(): NodeCanvas.Framework.Graph;
            public set subGraph(value: NodeCanvas.Framework.Graph);
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
        }
        export class DTNestedFlowScript extends NodeCanvas.DialogueTrees.DTNodeNested$1<FlowCanvas.FlowScript> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement, NodeCanvas.Framework.IUpdatable, NodeCanvas.Framework.IGraphAssignable, NodeCanvas.Framework.IGraphAssignable$1<FlowCanvas.FlowScript>{ 
            public get maxOutConnections(): number;
            public get subGraph(): FlowCanvas.FlowScript;
            public set subGraph(value: FlowCanvas.FlowScript);
            public get subGraphParameter(): NodeCanvas.Framework.BBParameter;
            public get name(): string;
            public get UID(): string;
            public get graph(): NodeCanvas.Framework.Graph;
            public get status(): NodeCanvas.Framework.Status;
            public get currentInstance(): NodeCanvas.Framework.Graph;
            public set currentInstance(value: NodeCanvas.Framework.Graph);
            public get instances(): System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>;
            public set instances(value: System.Collections.Generic.Dictionary$2<NodeCanvas.Framework.Graph, NodeCanvas.Framework.Graph>);
            public get variablesMap(): System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>;
            public set variablesMap(value: System.Collections.Generic.List$1<NodeCanvas.Framework.Internal.BBMappingParameter>);
            public constructor();
            public Update():void;
            public CheckInstance():null;
            public TryStartSubGraph($agent: UnityEngine.Component, $callback?: System.Action$1<boolean>):null;
            public TryStopSubGraph():null;
            public TryPauseSubGraph():null;
            public TryResumeSubGraph():null;
            public TryUpdateSubGraph():null;
            public TryWriteMappedVariables():null;
            public TryReadMappedVariables():null;
            public ValidateSubGraphAndParameters():null;
            public AutoLinkByName():null;
            public ShowVariablesMappingGUI():null;
        }
        export class GoToNode extends NodeCanvas.DialogueTrees.DTNode implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.IGraphElement{ 
            public get maxOutConnections(): number;
            public get requireActorSelection(): boolean;
            public constructor();
        }
    }
    export namespace FlowCanvas.Nodes.MouseEvents {
        export enum ButtonKeys{ Left = 0, Right = 1, Middle = 2 }
    }
    export namespace FlowCanvas.Nodes.MousePickEvent {
        export enum ButtonKeys{ Left = 0, Right = 1, Middle = 2 }
    }
    export namespace ParadoxNotion.Animation {
        export enum EaseType{ Linear = 0, QuadraticIn = 1, QuadraticOut = 2, QuadraticInOut = 3, QuarticIn = 4, QuarticOut = 5, QuarticInOut = 6, QuinticIn = 7, QuinticOut = 8, QuinticInOut = 9, CubicIn = 10, CubicOut = 11, CubicInOut = 12, ExponentialIn = 13, ExponentialOut = 14, ExponentialInOut = 15, CircularIn = 16, CircularOut = 17, CircularInOut = 18, SinusoidalIn = 19, SinusoidalOut = 20, SinusoidalInOut = 21, ElasticIn = 22, ElasticOut = 23, ElasticInOut = 24, BounceIn = 25, BounceOut = 26, BounceInOut = 27, BackIn = 28, BackOut = 29, BackInOut = 30 }
        export class Easing extends System.Object{ 
            public static Ease($type: ParadoxNotion.Animation.EaseType, $from: number, $to: number, $t: number):number;
            public static Ease($type: ParadoxNotion.Animation.EaseType, $from: UnityEngine.Vector3, $to: UnityEngine.Vector3, $t: number):UnityEngine.Vector3;
            public static Ease($type: ParadoxNotion.Animation.EaseType, $from: UnityEngine.Quaternion, $to: UnityEngine.Quaternion, $t: number):UnityEngine.Quaternion;
            public static Ease($type: ParadoxNotion.Animation.EaseType, $from: UnityEngine.Color, $to: UnityEngine.Color, $t: number):UnityEngine.Color;
            public static Difference($f: number, $a: number, $b: number):number;
            public static Linear($from: number, $to: number, $t: number):number;
            public static QuadraticIn($from: number, $to: number, $t: number):number;
            public static QuadraticOut($from: number, $to: number, $t: number):number;
            public static QuadraticInOut($from: number, $to: number, $t: number):number;
            public static QuarticIn($from: number, $to: number, $t: number):number;
            public static QuarticOut($from: number, $to: number, $t: number):number;
            public static QuarticInOut($from: number, $to: number, $t: number):number;
            public static QuinticIn($from: number, $to: number, $t: number):number;
            public static QuinticOut($from: number, $to: number, $t: number):number;
            public static QuinticInOut($from: number, $to: number, $t: number):number;
            public static CubicIn($from: number, $to: number, $t: number):number;
            public static CubicOut($from: number, $to: number, $t: number):number;
            public static CubicInOut($from: number, $to: number, $t: number):number;
            public static SinusoidalIn($from: number, $to: number, $t: number):number;
            public static SinusoidalOut($from: number, $to: number, $t: number):number;
            public static SinusoidalInOut($from: number, $to: number, $t: number):number;
            public static ExponentialIn($from: number, $to: number, $t: number):number;
            public static ExponentialOut($from: number, $to: number, $t: number):number;
            public static ExponentialInOut($from: number, $to: number, $t: number):number;
            public static CircularIn($from: number, $to: number, $t: number):number;
            public static CircularOut($from: number, $to: number, $t: number):number;
            public static CircularInOut($from: number, $to: number, $t: number):number;
            public static ElasticIn($from: number, $to: number, $t: number):number;
            public static ElasticOut($from: number, $to: number, $t: number):number;
            public static ElasticInOut($from: number, $to: number, $t: number):number;
            public static BounceIn($from: number, $to: number, $t: number):number;
            public static BounceOut($from: number, $to: number, $t: number):number;
            public static BounceInOut($from: number, $to: number, $t: number):number;
            public static BackIn($from: number, $to: number, $t: number):number;
            public static BackOut($from: number, $to: number, $t: number):number;
            public static BackInOut($from: number, $to: number, $t: number):number;
            public static Function($type: ParadoxNotion.Animation.EaseType):System.Func$4<number, number, number, number>;
        }
    }
    export namespace FlowCanvas.Nodes.LatentActionNodeBase {
        export enum InvocationMode{ QueueCalls = 0, FilterCalls = 1 }
    }
    export namespace FlowCanvas.Nodes.ReflectedDelegateEvent {
        export type DelegateEventCallback = (args: System.Array$1<any>) => void;
        var DelegateEventCallback: {new (func: (args: System.Array$1<any>) => void): DelegateEventCallback;}
    }
    export namespace FlowCanvas.Nodes.ReflectedUnityEvent {
        export type UnityEventCallback = (args: System.Array$1<any>) => void;
        var UnityEventCallback: {new (func: (args: System.Array$1<any>) => void): UnityEventCallback;}
    }
    export namespace FlowCanvas.Nodes.ReflectedFieldNodeWrapper {
        export enum AccessMode{ GetField = 0, SetField = 1 }
    }
    export namespace FlowCanvas.Nodes.Legacy {
        export class ReflectedFieldNode extends System.Object{ 
            public static Create($field: System.Reflection.FieldInfo):FlowCanvas.Nodes.Legacy.ReflectedFieldNode;
            public RegisterPorts($node: FlowCanvas.FlowNode, $field: System.Reflection.FieldInfo, $accessMode: FlowCanvas.Nodes.ReflectedFieldNodeWrapper.AccessMode):void;
        }
        export class PureReflectedFieldNode extends FlowCanvas.Nodes.Legacy.ReflectedFieldNode{ 
            public constructor();
        }
        export class ReflectedMethodNode extends System.Object{ 
            public static Create($method: System.Reflection.MethodInfo):FlowCanvas.Nodes.Legacy.ReflectedMethodNode;
            public GetName($method: System.Reflection.MethodInfo, $i: number):string;
            public RegisterPorts($node: FlowCanvas.FlowNode, $method: System.Reflection.MethodInfo, $options: FlowCanvas.Nodes.ReflectedMethodRegistrationOptions):void;
        }
        export class PureReflectedMethodNode extends FlowCanvas.Nodes.Legacy.ReflectedMethodNode{ 
            public constructor();
        }
        export class ReflectedActionNode extends FlowCanvas.Nodes.Legacy.ReflectedMethodNode{ 
            public constructor();
        }
    }
    export namespace FlowCanvas.Editor {
        export class Commands extends System.Object{ 
        }
    }
    export namespace NodeCanvas {
        export class ActionListPlayer extends UnityEngine.MonoBehaviour implements NodeCanvas.Framework.ITaskSystem, UnityEngine.ISerializationCallbackReceiver{ 
            public playOnAwake: boolean;
            public get actionList(): NodeCanvas.Framework.ActionList;
            public get elapsedTime(): number;
            public get blackboard(): NodeCanvas.Framework.IBlackboard;
            public set blackboard(value: NodeCanvas.Framework.IBlackboard);
            public get agent(): UnityEngine.Component;
            public get contextObject(): UnityEngine.Object;
            public static Create():NodeCanvas.ActionListPlayer;
            public UpdateTasksOwner():void;
            public Play():void;
            public Play($OnFinish: System.Action$1<NodeCanvas.Framework.Status>):void;
            public Play($agent: UnityEngine.Component, $blackboard: NodeCanvas.Framework.IBlackboard, $OnFinish: System.Action$1<NodeCanvas.Framework.Status>):void;
            public Execute():NodeCanvas.Framework.Status;
            public Execute($agent: UnityEngine.Component):NodeCanvas.Framework.Status;
            public constructor();
            public SendEvent($name: string, $value: any, $sender: any):void;
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace NodeCanvas.Tasks.Conditions {
        export class InvokeSignal extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public signalDefinition: NodeCanvas.Framework.BBParameter$1<NodeCanvas.Framework.SignalDefinition>;
            public global: boolean;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class MecanimCheckBool extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Animator> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public parameter: NodeCanvas.Framework.BBParameter$1<string>;
            public value: NodeCanvas.Framework.BBParameter$1<boolean>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class MecanimCheckFloat extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Animator> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public parameter: NodeCanvas.Framework.BBParameter$1<string>;
            public comparison: ParadoxNotion.CompareMethod;
            public value: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class MecanimCheckInt extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Animator> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public parameter: NodeCanvas.Framework.BBParameter$1<string>;
            public comparison: ParadoxNotion.CompareMethod;
            public value: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class MecanimIsInTransition extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Animator> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public layerIndex: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckBoolean extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public valueA: NodeCanvas.Framework.BBParameter$1<boolean>;
            public valueB: NodeCanvas.Framework.BBParameter$1<boolean>;
            public constructor();
        }
        export class CheckBooleanTrigger extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public trigger: NodeCanvas.Framework.BBParameter$1<boolean>;
            public constructor();
        }
        export class CheckEnum extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public valueA: NodeCanvas.Framework.Internal.BBObjectParameter;
            public valueB: NodeCanvas.Framework.Internal.BBObjectParameter;
            public constructor();
        }
        export class CheckFloat extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public valueA: NodeCanvas.Framework.BBParameter$1<number>;
            public checkType: ParadoxNotion.CompareMethod;
            public valueB: NodeCanvas.Framework.BBParameter$1<number>;
            public differenceThreshold: number;
            public constructor();
        }
        export class CheckInt extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public valueA: NodeCanvas.Framework.BBParameter$1<number>;
            public checkType: ParadoxNotion.CompareMethod;
            public valueB: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
        }
        export class CheckString extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public valueA: NodeCanvas.Framework.BBParameter$1<string>;
            public valueB: NodeCanvas.Framework.BBParameter$1<string>;
            public constructor();
        }
        export class CheckUnityObject extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public valueA: NodeCanvas.Framework.BBParameter$1<UnityEngine.Object>;
            public valueB: NodeCanvas.Framework.BBParameter$1<UnityEngine.Object>;
            public constructor();
        }
        export class CheckVectorDistance extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public vectorA: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public vectorB: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public comparison: ParadoxNotion.CompareMethod;
            public distance: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
        }
        export class ListIsEmpty extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetList: NodeCanvas.Framework.BBParameter$1<System.Collections.IList>;
            public constructor();
        }
        export class BBVariableChanged extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetVariable: NodeCanvas.Framework.Internal.BBObjectParameter;
            public constructor();
        }
        export class StringContains extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetString: NodeCanvas.Framework.BBParameter$1<string>;
            public checkString: NodeCanvas.Framework.BBParameter$1<string>;
            public constructor();
        }
        export class CanSeeTarget extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public target: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public maxDistance: NodeCanvas.Framework.BBParameter$1<number>;
            public awarnessDistance: NodeCanvas.Framework.BBParameter$1<number>;
            public viewAngle: NodeCanvas.Framework.BBParameter$1<number>;
            public offset: UnityEngine.Vector3;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CanSeeTarget2D extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public target: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public maxDistance: NodeCanvas.Framework.BBParameter$1<number>;
            public awarnessDistance: NodeCanvas.Framework.BBParameter$1<number>;
            public viewAngle: NodeCanvas.Framework.BBParameter$1<number>;
            public offset: UnityEngine.Vector2;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CanSeeTargetAny extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetObjects: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.GameObject>>;
            public maxDistance: NodeCanvas.Framework.BBParameter$1<number>;
            public awarnessDistance: NodeCanvas.Framework.BBParameter$1<number>;
            public viewAngle: NodeCanvas.Framework.BBParameter$1<number>;
            public offset: UnityEngine.Vector3;
            public allResults: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.GameObject>>;
            public closerResult: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CanSeeTargetAny2D extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetObjects: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.GameObject>>;
            public maxDistance: NodeCanvas.Framework.BBParameter$1<number>;
            public awarnessDistance: NodeCanvas.Framework.BBParameter$1<number>;
            public viewAngle: NodeCanvas.Framework.BBParameter$1<number>;
            public offset: UnityEngine.Vector2;
            public allResults: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.GameObject>>;
            public closerResult: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckDistanceToGameObject extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public checkTarget: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public checkType: ParadoxNotion.CompareMethod;
            public distance: NodeCanvas.Framework.BBParameter$1<number>;
            public floatingPoint: number;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckDistanceToGameObject2D extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public checkTarget: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public checkType: ParadoxNotion.CompareMethod;
            public distance: NodeCanvas.Framework.BBParameter$1<number>;
            public floatingPoint: number;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckDistanceToGameObjectAny extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetObjects: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.GameObject>>;
            public checkType: ParadoxNotion.CompareMethod;
            public distance: NodeCanvas.Framework.BBParameter$1<number>;
            public floatingPoint: number;
            public allResults: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.GameObject>>;
            public closerResult: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckDistanceToGameObjectAny2D extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetObjects: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.GameObject>>;
            public checkType: ParadoxNotion.CompareMethod;
            public distance: NodeCanvas.Framework.BBParameter$1<number>;
            public floatingPoint: number;
            public allResults: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.GameObject>>;
            public closerResult: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckLOS extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public LOSTarget: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public layerMask: NodeCanvas.Framework.BBParameter$1<UnityEngine.LayerMask>;
            public offset: UnityEngine.Vector3;
            public saveDistanceAs: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckLOS2D extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public LOSTarget: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public layerMask: NodeCanvas.Framework.BBParameter$1<UnityEngine.LayerMask>;
            public saveDistanceAs: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class IsActive extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class IsInFront extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public checkTarget: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public viewAngle: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class IsInFront2D extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public checkTarget: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public viewAngle: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class IsWithinLayerMask extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetLayers: NodeCanvas.Framework.BBParameter$1<UnityEngine.LayerMask>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckButtonInput extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public pressType: ParadoxNotion.PressTypes;
            public buttonName: NodeCanvas.Framework.BBParameter$1<string>;
            public constructor();
        }
        export class CheckKeyboardInput extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public pressType: ParadoxNotion.PressTypes;
            public key: UnityEngine.KeyCode;
            public constructor();
        }
        export class CheckMousePick extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public buttonKey: ParadoxNotion.ButtonKeys;
            public layer: number;
            public saveGoAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public saveDistanceAs: NodeCanvas.Framework.BBParameter$1<number>;
            public savePosAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public constructor();
        }
        export class CheckMousePick2D extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public buttonKey: ParadoxNotion.ButtonKeys;
            public mask: UnityEngine.LayerMask;
            public saveGoAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public saveDistanceAs: NodeCanvas.Framework.BBParameter$1<number>;
            public savePosAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public constructor();
        }
        export class PathExists extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.AI.NavMeshAgent> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetPosition: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public savePathAs: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.Vector3>>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckCSharpEvent extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.IMigratable, ParadoxNotion.Serialization.FullSerializer.IMigratable$1<NodeCanvas.Tasks.Conditions.CheckStaticCSharpEvent>, ParadoxNotion.Serialization.FullSerializer.IMigratable$1<NodeCanvas.Tasks.Conditions.CheckCSharpEvent_0>, NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public get agentType(): System.Type;
            public Raised():void;
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class CheckStaticCSharpEvent extends System.Object{ 
        }
        export class CheckCSharpEvent_0 extends System.Object{ 
        }
        export class CheckField extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.IMigratable, ParadoxNotion.Serialization.FullSerializer.IMigratable$1<NodeCanvas.Tasks.Conditions.CheckField_0>, NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public get agentType(): System.Type;
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class CheckField_0 extends System.Object{ 
        }
        export class CheckFunction_Multiplatform extends NodeCanvas.Framework.ConditionTask implements NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public get agentType(): System.Type;
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class CheckProperty_Multiplatform extends NodeCanvas.Framework.ConditionTask implements NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public get agentType(): System.Type;
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class CheckUnityEvent extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.IMigratable, ParadoxNotion.Serialization.FullSerializer.IMigratable$1<NodeCanvas.Tasks.Conditions.CheckUnityEvent_0>, NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public get agentType(): System.Type;
            public Raised():void;
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class CheckUnityEvent_0 extends System.Object{ 
        }
        export class CheckFunction extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public get agentType(): System.Type;
            public constructor();
        }
        export class CheckProperty extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public get agentType(): System.Type;
            public constructor();
        }
        export class CheckCollision_Rigidbody extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Rigidbody> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public checkType: ParadoxNotion.CollisionTypes;
            public specifiedTagOnly: boolean;
            public objectTag: string;
            public saveGameObjectAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public saveContactPoint: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public saveContactNormal: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public OnCollisionEnter($data: ParadoxNotion.EventData$1<UnityEngine.Collision>):void;
            public OnCollisionExit($data: ParadoxNotion.EventData$1<UnityEngine.Collision>):void;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckCollision extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Collider> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public checkType: ParadoxNotion.CollisionTypes;
            public specifiedTagOnly: boolean;
            public objectTag: string;
            public saveGameObjectAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public saveContactPoint: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public saveContactNormal: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public OnCollisionEnter($data: ParadoxNotion.EventData$1<UnityEngine.Collision>):void;
            public OnCollisionExit($data: ParadoxNotion.EventData$1<UnityEngine.Collision>):void;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckCollision2D_Rigidbody extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Rigidbody2D> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public checkType: ParadoxNotion.CollisionTypes;
            public specifiedTagOnly: boolean;
            public objectTag: string;
            public saveGameObjectAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public saveContactPoint: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public saveContactNormal: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckCollision2D extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Collider2D> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public checkType: ParadoxNotion.CollisionTypes;
            public specifiedTagOnly: boolean;
            public objectTag: string;
            public saveGameObjectAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public saveContactPoint: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public saveContactNormal: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckMouse extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Collider> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public checkType: ParadoxNotion.MouseInteractionTypes;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckMouse2D extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Collider2D> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public checkType: ParadoxNotion.MouseInteractionTypes;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckMouseClick extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Collider> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public checkType: ParadoxNotion.MouseClickEvent;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckMouseClick2D extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Collider2D> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public checkType: ParadoxNotion.MouseClickEvent;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckTrigger_Transform extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public checkType: ParadoxNotion.TriggerTypes;
            public specifiedTagOnly: boolean;
            public objectTag: string;
            public saveGameObjectAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public OnTriggerEnter($data: ParadoxNotion.EventData$1<UnityEngine.Collider>):void;
            public OnTriggerExit($data: ParadoxNotion.EventData$1<UnityEngine.Collider>):void;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckTrigger extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Collider> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public checkType: ParadoxNotion.TriggerTypes;
            public specifiedTagOnly: boolean;
            public objectTag: string;
            public saveGameObjectAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public OnTriggerEnter($data: ParadoxNotion.EventData$1<UnityEngine.Collider>):void;
            public OnTriggerExit($data: ParadoxNotion.EventData$1<UnityEngine.Collider>):void;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckTrigger2D_Transform extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public CheckType: ParadoxNotion.TriggerTypes;
            public specifiedTagOnly: boolean;
            public objectTag: string;
            public saveGameObjectAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public OnTriggerEnter2D($data: ParadoxNotion.EventData$1<UnityEngine.Collider2D>):void;
            public OnTriggerExit2D($data: ParadoxNotion.EventData$1<UnityEngine.Collider2D>):void;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckTrigger2D extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Collider2D> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public CheckType: ParadoxNotion.TriggerTypes;
            public specifiedTagOnly: boolean;
            public objectTag: string;
            public saveGameObjectAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public OnTriggerEnter2D($data: ParadoxNotion.EventData$1<UnityEngine.Collider2D>):void;
            public OnTriggerExit2D($data: ParadoxNotion.EventData$1<UnityEngine.Collider2D>):void;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class ButtonClicked extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public button: NodeCanvas.Framework.BBParameter$1<UnityEngine.UI.Button>;
            public constructor();
        }
        export class InterceptEvent extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public eventType: UnityEngine.EventSystems.EventTriggerType;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckEvent extends NodeCanvas.Framework.ConditionTask$1<NodeCanvas.Framework.GraphOwner> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public eventName: NodeCanvas.Framework.BBParameter$1<string>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CheckSignal extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public signalDefinition: NodeCanvas.Framework.BBParameter$1<NodeCanvas.Framework.SignalDefinition>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class DebugCondition extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class Probability extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public probability: NodeCanvas.Framework.BBParameter$1<number>;
            public maxValue: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
        }
        export class Timeout extends NodeCanvas.Framework.ConditionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public timeout: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
        }
    }
    export namespace NodeCanvas.Tasks.Actions {
        export class PlayAnimationAdvanced extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Animation> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public animationClip: NodeCanvas.Framework.BBParameter$1<UnityEngine.AnimationClip>;
            public animationWrap: UnityEngine.WrapMode;
            public blendMode: UnityEngine.AnimationBlendMode;
            public playbackSpeed: number;
            public crossFadeTime: number;
            public playDirection: ParadoxNotion.PlayDirections;
            public mixTransformName: NodeCanvas.Framework.BBParameter$1<string>;
            public animationLayer: NodeCanvas.Framework.BBParameter$1<number>;
            public queueAnimation: boolean;
            public waitActionFinish: boolean;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class PlayAnimationSimple extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Animation> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public animationClip: NodeCanvas.Framework.BBParameter$1<UnityEngine.AnimationClip>;
            public crossFadeTime: number;
            public animationWrap: UnityEngine.WrapMode;
            public waitActionFinish: boolean;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class MecanimPlayAnimation extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Animator> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public layerIndex: NodeCanvas.Framework.BBParameter$1<number>;
            public stateName: NodeCanvas.Framework.BBParameter$1<string>;
            public transitTime: number;
            public waitUntilFinish: boolean;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class MecanimSetBool extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Animator> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public parameter: NodeCanvas.Framework.BBParameter$1<string>;
            public parameterHashID: NodeCanvas.Framework.BBParameter$1<number>;
            public setTo: NodeCanvas.Framework.BBParameter$1<boolean>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class MecanimSetFloat extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Animator> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public parameter: NodeCanvas.Framework.BBParameter$1<string>;
            public parameterHashID: NodeCanvas.Framework.BBParameter$1<number>;
            public setTo: NodeCanvas.Framework.BBParameter$1<number>;
            public transitTime: number;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class MecanimSetIK extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Animator> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public IKGoal: UnityEngine.AvatarIKGoal;
            public goal: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public weight: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class MecanimSetInt extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Animator> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public parameter: NodeCanvas.Framework.BBParameter$1<string>;
            public parameterHashID: NodeCanvas.Framework.BBParameter$1<number>;
            public setTo: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class MecanimSetLayerWeight extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Animator> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public layerIndex: NodeCanvas.Framework.BBParameter$1<number>;
            public layerWeight: NodeCanvas.Framework.BBParameter$1<number>;
            public transitTime: number;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class MecanimSetLookAt extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Animator> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetPosition: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public targetWeight: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class MecanimSetTrigger extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Animator> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public parameter: NodeCanvas.Framework.BBParameter$1<string>;
            public parameterHashID: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class LoadScene extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public sceneName: NodeCanvas.Framework.BBParameter$1<string>;
            public mode: NodeCanvas.Framework.BBParameter$1<UnityEngine.SceneManagement.LoadSceneMode>;
            public constructor();
        }
        export class PlayAudioAtPosition extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public audioClip: NodeCanvas.Framework.BBParameter$1<UnityEngine.AudioClip>;
            public volume: number;
            public waitActionFinish: boolean;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class ComposeVector extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public x: NodeCanvas.Framework.BBParameter$1<number>;
            public y: NodeCanvas.Framework.BBParameter$1<number>;
            public z: NodeCanvas.Framework.BBParameter$1<number>;
            public saveAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public constructor();
        }
        export class DecomposeVector extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetVector: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public x: NodeCanvas.Framework.BBParameter$1<number>;
            public y: NodeCanvas.Framework.BBParameter$1<number>;
            public z: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
        }
        export class EvaluateCurve extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public curve: NodeCanvas.Framework.BBParameter$1<UnityEngine.AnimationCurve>;
            public from: NodeCanvas.Framework.BBParameter$1<number>;
            public to: NodeCanvas.Framework.BBParameter$1<number>;
            public time: NodeCanvas.Framework.BBParameter$1<number>;
            public saveAs: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
        }
        export class GetSelf extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public saveAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public constructor();
        }
        export class GetOtherBlackboardVariable extends NodeCanvas.Framework.ActionTask$1<NodeCanvas.Framework.Blackboard> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetVariableName: NodeCanvas.Framework.BBParameter$1<string>;
            public saveAs: NodeCanvas.Framework.Internal.BBObjectParameter;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class GetToString extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public variable: NodeCanvas.Framework.BBParameter$1<any>;
            public constructor();
        }
        export class ClearList extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetList: NodeCanvas.Framework.BBParameter$1<System.Collections.IList>;
            public constructor();
        }
        export class GetCloserGameObjectInList extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public list: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.GameObject>>;
            public saveAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class GetListCount extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetList: NodeCanvas.Framework.BBParameter$1<System.Collections.IList>;
            public saveAs: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
        }
        export class ShuffleList extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetList: NodeCanvas.Framework.BBParameter$1<System.Collections.IList>;
            public constructor();
        }
        export class SortGameObjectListByDistance extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetList: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.GameObject>>;
            public saveAs: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.GameObject>>;
            public reverse: boolean;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class LoadBlackboard extends NodeCanvas.Framework.ActionTask$1<NodeCanvas.Framework.Blackboard> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public saveKey: NodeCanvas.Framework.BBParameter$1<string>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class NormalizeVector extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetVector: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public multiply: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
        }
        export class SampleCurve extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public curve: NodeCanvas.Framework.BBParameter$1<UnityEngine.AnimationCurve>;
            public sampleAt: NodeCanvas.Framework.BBParameter$1<number>;
            public saveAs: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
        }
        export class SaveBlackboard extends NodeCanvas.Framework.ActionTask$1<NodeCanvas.Framework.Blackboard> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public saveKey: NodeCanvas.Framework.BBParameter$1<string>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class SetBoolean extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public boolVariable: NodeCanvas.Framework.BBParameter$1<boolean>;
            public setTo: NodeCanvas.Tasks.Actions.SetBoolean.BoolSetModes;
            public constructor();
        }
        export class SetBooleanRandom extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public boolVariable: NodeCanvas.Framework.BBParameter$1<boolean>;
            public constructor();
        }
        export class SetEnum extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public valueA: NodeCanvas.Framework.Internal.BBObjectParameter;
            public valueB: NodeCanvas.Framework.Internal.BBObjectParameter;
            public constructor();
        }
        export class SetFloat extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public valueA: NodeCanvas.Framework.BBParameter$1<number>;
            public Operation: ParadoxNotion.OperationMethod;
            public valueB: NodeCanvas.Framework.BBParameter$1<number>;
            public perSecond: boolean;
            public constructor();
        }
        export class SetFloatRandom extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public minValue: NodeCanvas.Framework.BBParameter$1<number>;
            public maxValue: NodeCanvas.Framework.BBParameter$1<number>;
            public floatVariable: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
        }
        export class SetInt extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public valueA: NodeCanvas.Framework.BBParameter$1<number>;
            public Operation: ParadoxNotion.OperationMethod;
            public valueB: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
        }
        export class SetIntRandom extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public minValue: NodeCanvas.Framework.BBParameter$1<number>;
            public maxValue: NodeCanvas.Framework.BBParameter$1<number>;
            public intVariable: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
        }
        export class SetOtherBlackboardVariable extends NodeCanvas.Framework.ActionTask$1<NodeCanvas.Framework.Blackboard> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetVariableName: NodeCanvas.Framework.BBParameter$1<string>;
            public newValue: NodeCanvas.Framework.Internal.BBObjectParameter;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class SetVector3 extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public valueA: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public operation: ParadoxNotion.OperationMethod;
            public valueB: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public perSecond: boolean;
            public constructor();
        }
        export class TriggerBoolean extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public variable: NodeCanvas.Framework.BBParameter$1<boolean>;
            public constructor();
        }
        export class CameraFader extends UnityEngine.MonoBehaviour{ 
            public static get current(): NodeCanvas.Tasks.Actions.CameraFader;
            public FadeIn($time: number):void;
            public FadeOut($time: number):void;
            public constructor();
        }
        export class FadeIn extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public fadeTime: number;
            public constructor();
        }
        export class FadeOut extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public fadeTime: number;
            public constructor();
        }
        export class Say extends NodeCanvas.Framework.ActionTask$1<NodeCanvas.DialogueTrees.IDialogueActor> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public statement: NodeCanvas.DialogueTrees.Statement;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class SayRandom extends NodeCanvas.Framework.ActionTask$1<NodeCanvas.DialogueTrees.IDialogueActor> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public statements: System.Collections.Generic.List$1<NodeCanvas.DialogueTrees.Statement>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class StartDialogueTree extends NodeCanvas.Framework.ActionTask$1<NodeCanvas.DialogueTrees.IDialogueActor> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public dialogueTreeController: NodeCanvas.Framework.BBParameter$1<NodeCanvas.DialogueTrees.DialogueTreeController>;
            public waitActionFinish: boolean;
            public isPrefab: boolean;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class CreateGameObject extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public objectName: NodeCanvas.Framework.BBParameter$1<string>;
            public position: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public rotation: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public saveAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public constructor();
        }
        export class CreatePrimitive extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public objectName: NodeCanvas.Framework.BBParameter$1<string>;
            public position: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public rotation: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public type: NodeCanvas.Framework.BBParameter$1<UnityEngine.PrimitiveType>;
            public saveAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public constructor();
        }
        export class DestroyGameObject extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public immediately: boolean;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class FindAllWithLayer extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetLayers: NodeCanvas.Framework.BBParameter$1<UnityEngine.LayerMask>;
            public saveAs: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.GameObject>>;
            public constructor();
        }
        export class FindAllWithName extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public searchName: NodeCanvas.Framework.BBParameter$1<string>;
            public saveAs: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.GameObject>>;
            public constructor();
        }
        export class FindAllWithTag extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public searchTag: NodeCanvas.Framework.BBParameter$1<string>;
            public saveAs: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.GameObject>>;
            public constructor();
        }
        export class FindChildByName extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public childName: NodeCanvas.Framework.BBParameter$1<string>;
            public saveAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.Transform>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class FindClosestWithTag extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public searchTag: NodeCanvas.Framework.BBParameter$1<string>;
            public ignoreChildren: NodeCanvas.Framework.BBParameter$1<boolean>;
            public saveObjectAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public saveDistanceAs: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class FindWithName extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public gameObjectName: NodeCanvas.Framework.BBParameter$1<string>;
            public saveAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public constructor();
        }
        export class FindWithTag extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public searchTag: string;
            public saveAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public constructor();
        }
        export class GetAllChildGameObjects extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public saveAs: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.GameObject>>;
            public recursive: boolean;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class GetDistance extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public target: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public saveAs: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class GetGameObjectPosition extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public saveAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class InstantiateGameObject extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public parent: NodeCanvas.Framework.BBParameter$1<UnityEngine.Transform>;
            public clonePosition: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public cloneRotation: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public saveCloneAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class LookAt extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public lookTarget: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public repeat: boolean;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class SetObjectActive extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public setTo: NodeCanvas.Tasks.Actions.SetObjectActive.SetActiveMode;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class SetObjectVisibility extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Renderer> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public setTo: NodeCanvas.Tasks.Actions.SetObjectVisibility.SetVisibleMode;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class GetInputAxis extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public xAxisName: NodeCanvas.Framework.BBParameter$1<string>;
            public yAxisName: NodeCanvas.Framework.BBParameter$1<string>;
            public zAxisName: NodeCanvas.Framework.BBParameter$1<string>;
            public multiplier: NodeCanvas.Framework.BBParameter$1<number>;
            public saveAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public saveXAs: NodeCanvas.Framework.BBParameter$1<number>;
            public saveYAs: NodeCanvas.Framework.BBParameter$1<number>;
            public saveZAs: NodeCanvas.Framework.BBParameter$1<number>;
            public repeat: boolean;
            public constructor();
        }
        export class GetMousePosition extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public saveAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public repeat: boolean;
            public constructor();
        }
        export class GetMouseScrollDelta extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public saveAs: NodeCanvas.Framework.BBParameter$1<number>;
            public repeat: boolean;
            public constructor();
        }
        export class WaitMousePick extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public buttonKey: NodeCanvas.Tasks.Actions.WaitMousePick.ButtonKeys;
            public mask: UnityEngine.LayerMask;
            public saveObjectAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public saveDistanceAs: NodeCanvas.Framework.BBParameter$1<number>;
            public savePositionAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public constructor();
        }
        export class WaitMousePick2D extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public buttonKey: NodeCanvas.Tasks.Actions.WaitMousePick2D.ButtonKeys;
            public mask: UnityEngine.LayerMask;
            public saveObjectAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public saveDistanceAs: NodeCanvas.Framework.BBParameter$1<number>;
            public savePositionAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public constructor();
        }
        export class CurveTransformTween extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public transformMode: NodeCanvas.Tasks.Actions.CurveTransformTween.TransformMode;
            public mode: NodeCanvas.Tasks.Actions.CurveTransformTween.TweenMode;
            public playMode: NodeCanvas.Tasks.Actions.CurveTransformTween.PlayMode;
            public targetPosition: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public curve: NodeCanvas.Framework.BBParameter$1<UnityEngine.AnimationCurve>;
            public time: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class InputMove extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public strafe: NodeCanvas.Framework.BBParameter$1<number>;
            public turn: NodeCanvas.Framework.BBParameter$1<number>;
            public forward: NodeCanvas.Framework.BBParameter$1<number>;
            public up: NodeCanvas.Framework.BBParameter$1<number>;
            public moveSpeed: NodeCanvas.Framework.BBParameter$1<number>;
            public rotationSpeed: NodeCanvas.Framework.BBParameter$1<number>;
            public repeat: boolean;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class MoveAway extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public target: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public speed: NodeCanvas.Framework.BBParameter$1<number>;
            public stopDistance: NodeCanvas.Framework.BBParameter$1<number>;
            public waitActionFinish: boolean;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class MoveTowards extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public target: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public speed: NodeCanvas.Framework.BBParameter$1<number>;
            public stopDistance: NodeCanvas.Framework.BBParameter$1<number>;
            public waitActionFinish: boolean;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class RotateAway extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public target: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public speed: NodeCanvas.Framework.BBParameter$1<number>;
            public angleDifference: NodeCanvas.Framework.BBParameter$1<number>;
            public upVector: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public waitActionFinish: boolean;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class RotateTowards extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public target: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public speed: NodeCanvas.Framework.BBParameter$1<number>;
            public angleDifference: NodeCanvas.Framework.BBParameter$1<number>;
            public upVector: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public waitActionFinish: boolean;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class FindClosestEdge extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetPosition: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public saveFoundPosition: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public constructor();
        }
        export class Flee extends NodeCanvas.Framework.ActionTask$1<UnityEngine.AI.NavMeshAgent> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public target: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public speed: NodeCanvas.Framework.BBParameter$1<number>;
            public fledDistance: NodeCanvas.Framework.BBParameter$1<number>;
            public lookAhead: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class MoveToGameObject extends NodeCanvas.Framework.ActionTask$1<UnityEngine.AI.NavMeshAgent> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public target: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public speed: NodeCanvas.Framework.BBParameter$1<number>;
            public keepDistance: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class MoveToPosition extends NodeCanvas.Framework.ActionTask$1<UnityEngine.AI.NavMeshAgent> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetPosition: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public speed: NodeCanvas.Framework.BBParameter$1<number>;
            public keepDistance: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class Patrol extends NodeCanvas.Framework.ActionTask$1<UnityEngine.AI.NavMeshAgent> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetList: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.GameObject>>;
            public patrolMode: NodeCanvas.Framework.BBParameter$1<NodeCanvas.Tasks.Actions.Patrol.PatrolMode>;
            public speed: NodeCanvas.Framework.BBParameter$1<number>;
            public keepDistance: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class Wander extends NodeCanvas.Framework.ActionTask$1<UnityEngine.AI.NavMeshAgent> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public speed: NodeCanvas.Framework.BBParameter$1<number>;
            public keepDistance: NodeCanvas.Framework.BBParameter$1<number>;
            public minWanderDistance: NodeCanvas.Framework.BBParameter$1<number>;
            public maxWanderDistance: NodeCanvas.Framework.BBParameter$1<number>;
            public repeat: boolean;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class GetLinecastInfo extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public target: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public layerMask: NodeCanvas.Framework.BBParameter$1<UnityEngine.LayerMask>;
            public saveHitGameObjectAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public saveDistanceAs: NodeCanvas.Framework.BBParameter$1<number>;
            public savePointAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public saveNormalAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class GetLinecastInfo2D extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public target: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public mask: UnityEngine.LayerMask;
            public saveHitGameObjectAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public saveDistanceAs: NodeCanvas.Framework.BBParameter$1<number>;
            public savePointAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public saveNormalAs: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class GetLinecastInfo2DAll extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public target: NodeCanvas.Framework.BBParameter$1<UnityEngine.GameObject>;
            public mask: UnityEngine.LayerMask;
            public saveHitGameObjectsAs: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.GameObject>>;
            public saveDistancesAs: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<number>>;
            public savePointsAs: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.Vector3>>;
            public saveNormalsAs: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.Vector3>>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class GetOverlapSphereObjects extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public layerMask: UnityEngine.LayerMask;
            public radius: NodeCanvas.Framework.BBParameter$1<number>;
            public saveObjectsAs: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.GameObject>>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class ExecuteFunction_Multiplatform extends NodeCanvas.Framework.ActionTask implements NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public get agentType(): System.Type;
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class GetField extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.IMigratable, ParadoxNotion.Serialization.FullSerializer.IMigratable$1<NodeCanvas.Tasks.Actions.GetField_0>, NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public get agentType(): System.Type;
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class GetField_0 extends System.Object{ 
        }
        export class GetProperty_Multiplatform extends NodeCanvas.Framework.ActionTask implements NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public get agentType(): System.Type;
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class ImplementedAction_Multiplatform extends NodeCanvas.Framework.ActionTask implements NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public get agentType(): System.Type;
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class SendMessage extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public methodName: NodeCanvas.Framework.BBParameter$1<string>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class SetField extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.IMigratable, ParadoxNotion.Serialization.FullSerializer.IMigratable$1<NodeCanvas.Tasks.Actions.SetField_0>, NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public get agentType(): System.Type;
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class SetField_0 extends System.Object{ 
        }
        export class SetProperty_Multiplatform extends NodeCanvas.Framework.ActionTask implements NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public get agentType(): System.Type;
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class ExecuteFunction extends NodeCanvas.Framework.ActionTask implements NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public get agentType(): System.Type;
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class GetProperty extends NodeCanvas.Framework.ActionTask implements NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public get agentType(): System.Type;
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class ImplementedAction extends NodeCanvas.Framework.ActionTask implements NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public get agentType(): System.Type;
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class SetProperty extends NodeCanvas.Framework.ActionTask implements NodeCanvas.Framework.IReflectedWrapper, ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public get agentType(): System.Type;
            public constructor();
            public GetSerializedInfo():ParadoxNotion.Serialization.ISerializedReflectedInfo;
        }
        export class DebugBeep extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class DebugDrawLine extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public from: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public to: NodeCanvas.Framework.BBParameter$1<UnityEngine.Vector3>;
            public color: UnityEngine.Color;
            public timeToShow: number;
            public constructor();
        }
        export class DebugLogText extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public log: NodeCanvas.Framework.BBParameter$1<string>;
            public labelYOffset: number;
            public secondsToRun: number;
            public color: UnityEngine.Color;
            public verboseMode: NodeCanvas.Tasks.Actions.DebugLogText.VerboseMode;
            public logMode: NodeCanvas.Tasks.Actions.DebugLogText.LogMode;
            public finishStatus: ParadoxNotion.CompactStatus;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class DebugLogVariable extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public log: NodeCanvas.Framework.BBParameter$1<any>;
            public prefix: NodeCanvas.Framework.BBParameter$1<string>;
            public secondsToRun: number;
            public finishStatus: ParadoxNotion.CompactStatus;
            public constructor();
        }
        export class ForceFinishGraph extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public finishStatus: ParadoxNotion.CompactStatus;
            public constructor();
        }
        export class GraphOwnerControl extends NodeCanvas.Framework.ActionTask$1<NodeCanvas.Framework.GraphOwner> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public control: NodeCanvas.Tasks.Actions.GraphOwnerControl.Control;
            public waitActionFinish: boolean;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class RunForever extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class SendEvent extends NodeCanvas.Framework.ActionTask$1<NodeCanvas.Framework.GraphOwner> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public eventName: NodeCanvas.Framework.BBParameter$1<string>;
            public delay: NodeCanvas.Framework.BBParameter$1<number>;
            public sendGlobal: boolean;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class SendEventToObjects extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public targetObjects: NodeCanvas.Framework.BBParameter$1<System.Collections.Generic.List$1<UnityEngine.GameObject>>;
            public eventName: NodeCanvas.Framework.BBParameter$1<string>;
            public constructor();
        }
        export class ShoutEvent extends NodeCanvas.Framework.ActionTask$1<UnityEngine.Transform> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public eventName: NodeCanvas.Framework.BBParameter$1<string>;
            public shoutRange: NodeCanvas.Framework.BBParameter$1<number>;
            public completionTime: NodeCanvas.Framework.BBParameter$1<number>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class SwitchBehaviourTree extends NodeCanvas.Framework.ActionTask$1<NodeCanvas.BehaviourTrees.BehaviourTreeOwner> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public behaviourTree: NodeCanvas.Framework.BBParameter$1<NodeCanvas.BehaviourTrees.BehaviourTree>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class SwitchFSM extends NodeCanvas.Framework.ActionTask$1<NodeCanvas.StateMachines.FSMOwner> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public fsm: NodeCanvas.Framework.BBParameter$1<NodeCanvas.StateMachines.FSM>;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class Wait extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public waitTime: NodeCanvas.Framework.BBParameter$1<number>;
            public finishStatus: ParadoxNotion.CompactStatus;
            public constructor();
        }
        export class CheckSpeed extends NodeCanvas.Framework.ConditionTask$1<UnityEngine.Rigidbody> implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public checkType: ParadoxNotion.CompareMethod;
            public value: NodeCanvas.Framework.BBParameter$1<number>;
            public differenceThreshold: number;
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class ExecuteStaticFunction extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, NodeCanvas.Framework.ISubParametersContainer, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public GetSubParameters():System.Array$1<NodeCanvas.Framework.BBParameter>;
        }
        export class ExecuteStaticFunction_Multiplatform extends NodeCanvas.Framework.ActionTask implements ParadoxNotion.Serialization.FullSerializer.ISerializationCollectable, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
    }
    export namespace NodeCanvas.Tasks.Actions.SetBoolean {
        export enum BoolSetModes{ False = 0, True = 1, Toggle = 2 }
    }
    export namespace NodeCanvas.Tasks.Actions.SetObjectActive {
        export enum SetActiveMode{ Deactivate = 0, Activate = 1, Toggle = 2 }
    }
    export namespace NodeCanvas.Tasks.Actions.SetObjectVisibility {
        export enum SetVisibleMode{ Hide = 0, Show = 1, Toggle = 2 }
    }
    export namespace NodeCanvas.Tasks.Actions.WaitMousePick {
        export enum ButtonKeys{ Left = 0, Right = 1, Middle = 2 }
    }
    export namespace NodeCanvas.Tasks.Actions.WaitMousePick2D {
        export enum ButtonKeys{ Left = 0, Right = 1, Middle = 2 }
    }
    export namespace NodeCanvas.Tasks.Actions.CurveTransformTween {
        export enum TransformMode{ Position = 0, Rotation = 1, Scale = 2 }
        export enum TweenMode{ Absolute = 0, Additive = 1 }
        export enum PlayMode{ Normal = 0, PingPong = 1 }
    }
    export namespace NodeCanvas.Tasks.Actions.Patrol {
        export enum PatrolMode{ Progressive = 0, Random = 1 }
    }
    export namespace NodeCanvas.Tasks.Actions.DebugLogText {
        export enum VerboseMode{ LogAndDisplayLabel = 0, LogOnly = 1, DisplayLabelOnly = 2 }
        export enum LogMode{ Log = 0, Warning = 1, Error = 2 }
    }
    export namespace NodeCanvas.Tasks.Actions.GraphOwnerControl {
        export enum Control{ StartBehaviour = 0, StopBehaviour = 1, PauseBehaviour = 2 }
    }
    export namespace NodeCanvas.StateMachines.FSM {
        export enum TransitionCallMode{ Normal = 0, Stacked = 1, Clean = 2 }
    }
    export namespace NodeCanvas.StateMachines.FSMState {
        export enum TransitionEvaluationMode{ CheckContinuously = 0, CheckAfterStateFinished = 1, CheckManually = 2 }
    }
    export namespace NodeCanvas.StateMachines.NestedBTState {
        export enum BTExitMode{ StopAndRestart = 0, PauseAndResume = 1 }
        export enum BTExecutionMode{ Once = 0, Repeat = 1 }
    }
    export namespace NodeCanvas.StateMachines.NestedFSMState {
        export enum FSMExitMode{ StopAndRestart = 0, PauseAndResume = 1 }
    }
    export namespace NodeCanvas.DialogueTrees.DialogueTree {
        export class ActorParameter extends System.Object{ 
            public get name(): string;
            public set name(value: string);
            public get ID(): string;
            public get actor(): NodeCanvas.DialogueTrees.IDialogueActor;
            public set actor(value: NodeCanvas.DialogueTrees.IDialogueActor);
            public constructor();
            public constructor($name: string);
            public constructor($name: string, $actor: NodeCanvas.DialogueTrees.IDialogueActor);
        }
    }
    export namespace NodeCanvas.DialogueTrees.UI.Examples {
        export class DialogueUGUI extends UnityEngine.MonoBehaviour{ 
            public skipOnInput: boolean;
            public waitForInput: boolean;
            public subtitlesGroup: UnityEngine.RectTransform;
            public actorSpeech: UnityEngine.UI.Text;
            public actorName: UnityEngine.UI.Text;
            public actorPortrait: UnityEngine.UI.Image;
            public waitInputIndicator: UnityEngine.RectTransform;
            public subtitleDelays: NodeCanvas.DialogueTrees.UI.Examples.DialogueUGUI.SubtitleDelays;
            public typingSounds: System.Collections.Generic.List$1<UnityEngine.AudioClip>;
            public optionsGroup: UnityEngine.RectTransform;
            public optionButton: UnityEngine.UI.Button;
            public constructor();
        }
    }
    export namespace NodeCanvas.DialogueTrees.UI.Examples.DialogueUGUI {
        export class SubtitleDelays extends System.Object{ 
            public characterDelay: number;
            public sentenceDelay: number;
            public commaDelay: number;
            public finalDelay: number;
            public constructor();
        }
    }
    export namespace NodeCanvas.BehaviourTrees.Parallel {
        export enum ParallelPolicy{ FirstFailure = 0, FirstSuccess = 1, FirstSuccessOrFailure = 2 }
    }
    export namespace NodeCanvas.BehaviourTrees.PrioritySelector {
        export class Desire extends System.Object{ 
            public name: string;
            public foldout: boolean;
            public considerations: System.Collections.Generic.List$1<NodeCanvas.BehaviourTrees.PrioritySelector.Consideration>;
            public AddConsideration($bb: NodeCanvas.Framework.IBlackboard):NodeCanvas.BehaviourTrees.PrioritySelector.Consideration;
            public RemoveConsideration($consideration: NodeCanvas.BehaviourTrees.PrioritySelector.Consideration):void;
            public GetCompoundUtility():number;
            public constructor();
        }
        export class Consideration extends System.Object{ 
            public input: NodeCanvas.Framework.BBParameter$1<number>;
            public function: NodeCanvas.Framework.BBParameter$1<UnityEngine.AnimationCurve>;
            public get utility(): number;
            public constructor($blackboard: NodeCanvas.Framework.IBlackboard);
            public constructor();
        }
    }
    export namespace NodeCanvas.BehaviourTrees.Switch {
        export enum CaseSelectionMode{ IndexBased = 0, EnumBased = 1 }
        export enum OutOfRangeMode{ ReturnFailure = 0, LoopIndex = 1 }
    }
    export namespace NodeCanvas.BehaviourTrees.Filter {
        export enum FilterMode{ LimitNumberOfTimes = 0, CoolDown = 1 }
        export enum Policy{ SuccessOrFailure = 0, SuccessOnly = 1, FailureOnly = 2 }
    }
    export namespace NodeCanvas.BehaviourTrees.Guard {
        export enum GuardMode{ ReturnFailure = 0, WaitUntilReleased = 1 }
    }
    export namespace NodeCanvas.BehaviourTrees.Iterator {
        export enum TerminationConditions{ None = 0, FirstSuccess = 1, FirstFailure = 2 }
    }
    export namespace NodeCanvas.BehaviourTrees.Monitor {
        export enum MonitorMode{ Failure = 0, Success = 1, AnyStatus = 10 }
        export enum ReturnStatusMode{ OriginalDecoratedChildStatus = 0, NewDecoratorActionStatus = 1 }
    }
    export namespace NodeCanvas.BehaviourTrees.Remapper {
        export enum RemapStatus{ Failure = 0, Success = 1 }
    }
    export namespace NodeCanvas.BehaviourTrees.Repeater {
        export enum RepeaterMode{ RepeatTimes = 0, RepeatUntil = 1, RepeatForever = 2 }
        export enum RepeatUntilStatus{ Failure = 0, Success = 1 }
    }
    export namespace NodeCanvas.BehaviourTrees.NodeToggler {
        export enum ToggleMode{ Enable = 0, Disable = 1, Toggle = 2 }
    }
    export namespace NodeCanvas.Framework.Graph {
        export enum UpdateMode{ NormalUpdate = 0, LateUpdate = 1, FixedUpdate = 2, Manual = 3 }
    }
    export namespace ParadoxNotion.HierarchyTree {
        export class Element extends System.Object{ 
            public get reference(): any;
            public get parent(): ParadoxNotion.HierarchyTree.Element;
            public get children(): System.Collections.Generic.IEnumerable$1<ParadoxNotion.HierarchyTree.Element>;
            public AddChild($child: ParadoxNotion.HierarchyTree.Element):ParadoxNotion.HierarchyTree.Element;
            public RemoveChild($child: ParadoxNotion.HierarchyTree.Element):void;
            public GetRoot():ParadoxNotion.HierarchyTree.Element;
            public FindReferenceElement($target: any):ParadoxNotion.HierarchyTree.Element;
            public constructor($reference: any);
            public constructor();
        }
    }
    export namespace NodeCanvas.Framework.Node {
        export enum VerboseLevel{ Compact = 0, Partial = 1, Full = 2 }
    }
    export namespace NodeCanvas.Framework.SignalDefinition {
        export type InvokeArguments = (sender: UnityEngine.Transform, receiver: UnityEngine.Transform, isGlobal: boolean, args: System.Array$1<any>) => void;
        var InvokeArguments: {new (func: (sender: UnityEngine.Transform, receiver: UnityEngine.Transform, isGlobal: boolean, args: System.Array$1<any>) => void): InvokeArguments;}
    }
    export namespace NodeCanvas.Framework.CanvasGroup {
        export enum EditState{ None = 0, Dragging = 1, Renaming = 2, Scaling = 3 }
    }
    export namespace NodeCanvas.Framework.GraphOwner {
        export enum FirstActivation{ OnEnable = 0, OnStart = 1, Async = 2 }
        export enum EnableAction{ EnableBehaviour = 0, DoNothing = 1 }
        export enum DisableAction{ DisableBehaviour = 0, PauseBehaviour = 1, DoNothing = 2 }
    }
    export namespace ParadoxNotion.Serialization {
        export interface ISerializedReflectedInfo extends UnityEngine.ISerializationCallbackReceiver{ 
            AsMemberInfo():System.Reflection.MemberInfo;
            AsString():string;
            OnBeforeSerialize():void;
            OnAfterDeserialize():void;
        }
        export interface IMissingRecoverable{ 
            missingType: string;
            recoveryState: string;
        }
        export class SerializedMethodInfo extends System.Object implements UnityEngine.ISerializationCallbackReceiver, ParadoxNotion.Serialization.ISerializedMethodBaseInfo, ParadoxNotion.Serialization.ISerializedReflectedInfo{ 
            public AsMemberInfo():System.Reflection.MemberInfo;
            public GetMethodBase():System.Reflection.MethodBase;
            public HasChanged():boolean;
            public AsString():string;
            public static op_Implicit($value: ParadoxNotion.Serialization.SerializedMethodInfo):System.Reflection.MethodInfo;
            public constructor();
            public constructor($method: System.Reflection.MethodInfo);
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
            public AsString():null;
        }
        export interface ISerializedMethodBaseInfo extends UnityEngine.ISerializationCallbackReceiver, ParadoxNotion.Serialization.ISerializedReflectedInfo{ 
            GetMethodBase():System.Reflection.MethodBase;
            HasChanged():boolean;
            OnBeforeSerialize():void;
            OnAfterDeserialize():void;
            AsMemberInfo():System.Reflection.MemberInfo;
            AsString():string;
        }
        export class fsRecoveryProcessor$2<TCanProcess, TMissing> extends ParadoxNotion.Serialization.FullSerializer.fsObjectProcessor{ 
        }
        export class DeserializeFromAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public previousTypeFullName: string;
            public constructor($previousTypeFullName: string);
            public constructor();
        }
        export class fsUnityObjectConverter extends ParadoxNotion.Serialization.FullSerializer.fsConverter{ 
            public constructor();
        }
        export class JSONSerializer extends System.Object{ 
            public static FlushMem():void;
            public static Serialize($type: System.Type, $instance: any, $references?: System.Collections.Generic.List$1<UnityEngine.Object>, $pretyJson?: boolean):string;
            public static Deserialize($type: System.Type, $json: string, $references?: System.Collections.Generic.List$1<UnityEngine.Object>):any;
            public static TryDeserializeOverwrite($instance: any, $json: string, $references?: System.Collections.Generic.List$1<UnityEngine.Object>):any;
            public static SerializeAndExecuteNoCycles($type: System.Type, $instance: any, $call: System.Action$2<any, ParadoxNotion.Serialization.FullSerializer.fsData>):void;
            public static SerializeAndExecuteNoCycles($type: System.Type, $instance: any, $beforeCall: System.Action$1<any>, $afterCall: System.Action$2<any, ParadoxNotion.Serialization.FullSerializer.fsData>):void;
            public static Clone($original: any):any;
            public static CopySerialized($source: any, $target: any):void;
            public static ShowData($json: string, $fileName?: string):void;
            public static PrettifyJson($json: string):string;
        }
        export class SerializationPair extends System.Object{ 
            public _json: string;
            public _references: System.Collections.Generic.List$1<UnityEngine.Object>;
            public constructor();
        }
        export class SerializedConstructorInfo extends System.Object implements UnityEngine.ISerializationCallbackReceiver, ParadoxNotion.Serialization.ISerializedMethodBaseInfo, ParadoxNotion.Serialization.ISerializedReflectedInfo{ 
            public AsMemberInfo():System.Reflection.MemberInfo;
            public GetMethodBase():System.Reflection.MethodBase;
            public HasChanged():boolean;
            public AsString():string;
            public static op_Implicit($value: ParadoxNotion.Serialization.SerializedConstructorInfo):System.Reflection.ConstructorInfo;
            public constructor();
            public constructor($constructor: System.Reflection.ConstructorInfo);
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
            public AsString():null;
        }
        export class SerializedEventInfo extends System.Object implements UnityEngine.ISerializationCallbackReceiver, ParadoxNotion.Serialization.ISerializedReflectedInfo{ 
            public AsMemberInfo():System.Reflection.MemberInfo;
            public AsString():string;
            public static op_Implicit($value: ParadoxNotion.Serialization.SerializedEventInfo):System.Reflection.EventInfo;
            public constructor();
            public constructor($info: System.Reflection.EventInfo);
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
            public AsString():null;
        }
        export class SerializedFieldInfo extends System.Object implements UnityEngine.ISerializationCallbackReceiver, ParadoxNotion.Serialization.ISerializedReflectedInfo{ 
            public AsMemberInfo():System.Reflection.MemberInfo;
            public AsString():string;
            public static op_Implicit($value: ParadoxNotion.Serialization.SerializedFieldInfo):System.Reflection.FieldInfo;
            public constructor();
            public constructor($info: System.Reflection.FieldInfo);
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
            public AsString():null;
        }
        export class SerializedTypeInfo extends System.Object implements UnityEngine.ISerializationCallbackReceiver, ParadoxNotion.Serialization.ISerializedReflectedInfo{ 
            public AsMemberInfo():System.Reflection.MemberInfo;
            public AsString():string;
            public static op_Implicit($value: ParadoxNotion.Serialization.SerializedTypeInfo):System.Type;
            public constructor();
            public constructor($info: System.Type);
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
            public AsString():null;
        }
        export class SerializedUnityEventInfo extends System.Object implements UnityEngine.ISerializationCallbackReceiver, ParadoxNotion.Serialization.ISerializedReflectedInfo{ 
            public get isStatic(): boolean;
            public get memberType(): System.Type;
            public AsMemberInfo():System.Reflection.MemberInfo;
            public AsString():string;
            public static op_Implicit($value: ParadoxNotion.Serialization.SerializedUnityEventInfo):System.Reflection.FieldInfo;
            public static op_Implicit($value: ParadoxNotion.Serialization.SerializedUnityEventInfo):System.Reflection.PropertyInfo;
            public constructor();
            public constructor($info: System.Reflection.FieldInfo);
            public constructor($info: System.Reflection.PropertyInfo);
            public constructor($info: System.Reflection.MemberInfo);
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
            public AsString():null;
        }
    }
    export namespace NodeCanvas.Framework.ActionList {
        export enum ActionsExecutionMode{ ActionsRunInSequence = 0, ActionsRunInParallel = 1 }
    }
    export namespace NodeCanvas.Framework.ConditionList {
        export enum ConditionsCheckMode{ AllTrueRequired = 0, AnyTrueSuffice = 1 }
    }
    export namespace ParadoxNotion.Services {
        export class EventRouter extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IDropHandler, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IScrollHandler, UnityEngine.EventSystems.IUpdateSelectedHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IMoveHandler, UnityEngine.EventSystems.IPointerUpHandler, UnityEngine.EventSystems.ISubmitHandler, UnityEngine.EventSystems.IPointerClickHandler{ 
            public add_onPointerEnter($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.PointerEventData>):void;
            public remove_onPointerEnter($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.PointerEventData>):void;
            public add_onPointerExit($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.PointerEventData>):void;
            public remove_onPointerExit($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.PointerEventData>):void;
            public add_onPointerDown($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.PointerEventData>):void;
            public remove_onPointerDown($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.PointerEventData>):void;
            public add_onPointerUp($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.PointerEventData>):void;
            public remove_onPointerUp($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.PointerEventData>):void;
            public add_onPointerClick($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.PointerEventData>):void;
            public remove_onPointerClick($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.PointerEventData>):void;
            public add_onDrag($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.PointerEventData>):void;
            public remove_onDrag($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.PointerEventData>):void;
            public add_onDrop($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.PointerEventData>):void;
            public remove_onDrop($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.PointerEventData>):void;
            public add_onScroll($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.PointerEventData>):void;
            public remove_onScroll($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.PointerEventData>):void;
            public add_onUpdateSelected($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.BaseEventData>):void;
            public remove_onUpdateSelected($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.BaseEventData>):void;
            public add_onSelect($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.BaseEventData>):void;
            public remove_onSelect($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.BaseEventData>):void;
            public add_onDeselect($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.BaseEventData>):void;
            public remove_onDeselect($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.BaseEventData>):void;
            public add_onMove($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.AxisEventData>):void;
            public remove_onMove($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.AxisEventData>):void;
            public add_onSubmit($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.BaseEventData>):void;
            public remove_onSubmit($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.EventSystems.BaseEventData>):void;
            public add_onMouseDown($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public remove_onMouseDown($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public add_onMouseDrag($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public remove_onMouseDrag($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public add_onMouseEnter($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public remove_onMouseEnter($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public add_onMouseExit($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public remove_onMouseExit($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public add_onMouseOver($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public remove_onMouseOver($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public add_onMouseUp($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public remove_onMouseUp($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public add_onEnable($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public remove_onEnable($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public add_onDisable($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public remove_onDisable($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public add_onDestroy($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public remove_onDestroy($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public add_onTransformChildrenChanged($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public remove_onTransformChildrenChanged($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public add_onTransformParentChanged($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public remove_onTransformParentChanged($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public add_onAnimatorIK($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<number>):void;
            public remove_onAnimatorIK($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<number>):void;
            public add_onAnimatorMove($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public remove_onAnimatorMove($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public add_onBecameInvisible($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public remove_onBecameInvisible($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public add_onBecameVisible($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public remove_onBecameVisible($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public add_onControllerColliderHit($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.ControllerColliderHit>):void;
            public remove_onControllerColliderHit($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.ControllerColliderHit>):void;
            public add_onParticleCollision($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.GameObject>):void;
            public remove_onParticleCollision($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.GameObject>):void;
            public add_onCollisionEnter($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collision>):void;
            public remove_onCollisionEnter($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collision>):void;
            public add_onCollisionExit($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collision>):void;
            public remove_onCollisionExit($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collision>):void;
            public add_onCollisionStay($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collision>):void;
            public remove_onCollisionStay($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collision>):void;
            public add_onCollisionEnter2D($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collision2D>):void;
            public remove_onCollisionEnter2D($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collision2D>):void;
            public add_onCollisionExit2D($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collision2D>):void;
            public remove_onCollisionExit2D($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collision2D>):void;
            public add_onCollisionStay2D($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collision2D>):void;
            public remove_onCollisionStay2D($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collision2D>):void;
            public add_onTriggerEnter($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collider>):void;
            public remove_onTriggerEnter($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collider>):void;
            public add_onTriggerExit($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collider>):void;
            public remove_onTriggerExit($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collider>):void;
            public add_onTriggerStay($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collider>):void;
            public remove_onTriggerStay($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collider>):void;
            public add_onTriggerEnter2D($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collider2D>):void;
            public remove_onTriggerEnter2D($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collider2D>):void;
            public add_onTriggerExit2D($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collider2D>):void;
            public remove_onTriggerExit2D($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collider2D>):void;
            public add_onTriggerStay2D($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collider2D>):void;
            public remove_onTriggerStay2D($value: ParadoxNotion.Services.EventRouter.EventDelegate$1<UnityEngine.Collider2D>):void;
            public add_onRenderImage($value: System.Action$2<UnityEngine.RenderTexture, UnityEngine.RenderTexture>):void;
            public remove_onRenderImage($value: System.Action$2<UnityEngine.RenderTexture, UnityEngine.RenderTexture>):void;
            public add_onCustomEvent($value: ParadoxNotion.Services.EventRouter.CustomEventDelegate):void;
            public remove_onCustomEvent($value: ParadoxNotion.Services.EventRouter.CustomEventDelegate):void;
            public InvokeCustomEvent($name: string, $value: any, $sender: any):void;
            public constructor();
        }
        export class EventRouterAnimatorMove extends UnityEngine.MonoBehaviour{ 
            public add_onAnimatorMove($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public remove_onAnimatorMove($value: ParadoxNotion.Services.EventRouter.EventDelegate):void;
            public constructor();
        }
        export class Logger extends System.Object{ 
            public static AddListener($callback: ParadoxNotion.Services.Logger.LogHandler):void;
            public static RemoveListener($callback: ParadoxNotion.Services.Logger.LogHandler):void;
            public static Log($message: any, $tag?: string, $context?: any):void;
            public static LogWarning($message: any, $tag?: string, $context?: any):void;
            public static LogError($message: any, $tag?: string, $context?: any):void;
            public static LogException($exception: System.Exception, $tag?: string, $context?: any):void;
        }
        export class MonoManager extends UnityEngine.MonoBehaviour{ 
            public static get current(): ParadoxNotion.Services.MonoManager;
            public add_onUpdate($value: System.Action):void;
            public remove_onUpdate($value: System.Action):void;
            public add_onLateUpdate($value: System.Action):void;
            public remove_onLateUpdate($value: System.Action):void;
            public add_onFixedUpdate($value: System.Action):void;
            public remove_onFixedUpdate($value: System.Action):void;
            public add_onApplicationQuit($value: System.Action):void;
            public remove_onApplicationQuit($value: System.Action):void;
            public add_onApplicationPause($value: System.Action$1<boolean>):void;
            public remove_onApplicationPause($value: System.Action$1<boolean>):void;
            public add_onGUI($value: System.Action):void;
            public remove_onGUI($value: System.Action):void;
            public static Create():void;
            public AddUpdateCall($mode: ParadoxNotion.Services.MonoManager.UpdateMode, $call: System.Action):void;
            public RemoveUpdateCall($mode: ParadoxNotion.Services.MonoManager.UpdateMode, $call: System.Action):void;
            public constructor();
        }
        export class Threader extends System.Object{ 
            public static get applicationIsPlaying(): boolean;
            public static get isMainThread(): boolean;
            public static StartAction($thread: System.Threading.Thread, $function: System.Action, $callback?: System.Action):System.Threading.Thread;
        }
    }
    export namespace NodeCanvas.Editor {
        export class GraphAssetPostProcessor extends System.Object{ 
        }
        export class AssetBlackboardInspector extends UnityEditor.Editor implements UnityEditor.IPreviewable, UnityEditor.IToolModeOwner{ 
        }
        export class BlackboardInspector extends Sirenix.OdinInspector.Editor.OdinEditor implements UnityEditor.IPreviewable, UnityEditor.IToolModeOwner{ 
        }
        export class GlobalBlackboardInspector extends UnityEditor.Editor implements UnityEditor.IPreviewable, UnityEditor.IToolModeOwner{ 
        }
        export class GraphInspector extends UnityEditor.Editor implements UnityEditor.IPreviewable, UnityEditor.IToolModeOwner{ 
        }
        export class GraphOwnerInspector extends UnityEditor.Editor implements UnityEditor.IPreviewable, UnityEditor.IToolModeOwner{ 
        }
        export class SignalDefinitionInspector extends UnityEditor.Editor implements UnityEditor.IPreviewable, UnityEditor.IToolModeOwner{ 
        }
        export class ActiveOwnersOverview extends UnityEditor.EditorWindow{ 
        }
        export class ExternalInspectorWindow extends UnityEditor.EditorWindow{ 
        }
        export class GraphConsole extends UnityEditor.EditorWindow{ 
        }
        export class GraphEditor extends UnityEditor.EditorWindow{ 
        }
        export class GraphExplorer extends UnityEditor.EditorWindow{ 
        }
        export class GraphRefactor extends UnityEditor.EditorWindow{ 
        }
        export class QuickPopup extends UnityEditor.PopupWindowContent{ 
        }
        export class TaskWizardWindow extends UnityEditor.EditorWindow{ 
        }
        export class WelcomeWindow extends UnityEditor.EditorWindow{ 
        }
        export class BBParameterDrawer extends ParadoxNotion.Design.ObjectDrawer$1<NodeCanvas.Framework.BBParameter> implements ParadoxNotion.Design.IObjectDrawer{ 
            public DrawGUI($content: UnityEngine.GUIContent, $instance: any, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
            public MoveNextDrawer():any;
        }
        export class BlackboardSourceDrawer extends ParadoxNotion.Design.ObjectDrawer$1<NodeCanvas.Framework.Internal.BlackboardSource> implements ParadoxNotion.Design.IObjectDrawer{ 
            public DrawGUI($content: UnityEngine.GUIContent, $instance: any, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
            public MoveNextDrawer():any;
        }
        export class NodeReferenceDrawer extends ParadoxNotion.Design.ObjectDrawer$1<NodeCanvas.Framework.INodeReference> implements ParadoxNotion.Design.IObjectDrawer{ 
            public DrawGUI($content: UnityEngine.GUIContent, $instance: any, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
            public MoveNextDrawer():any;
        }
        export class TaskDrawer extends ParadoxNotion.Design.ObjectDrawer$1<NodeCanvas.Framework.Task> implements ParadoxNotion.Design.IObjectDrawer{ 
            public DrawGUI($content: UnityEngine.GUIContent, $instance: any, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
            public MoveNextDrawer():any;
        }
        export class BBParameterEditor extends System.Object{ 
        }
        export class BlackboardEditor extends ParadoxNotion.Design.EditorObjectWrapper$1<NodeCanvas.Framework.IBlackboard> implements System.IDisposable{ 
        }
        export class TaskEditor extends ParadoxNotion.Design.EditorObjectWrapper$1<NodeCanvas.Framework.Task> implements System.IDisposable{ 
        }
        export class TaskSO extends Sirenix.OdinInspector.SerializedScriptableObject implements UnityEngine.ISerializationCallbackReceiver{ 
        }
        export class GraphEditorUtility extends System.Object{ 
        }
        export class Prefs extends System.Object{ 
        }
        export class StyleSheet extends UnityEngine.ScriptableObject{ 
        }
        export class Commands extends System.Object{ 
        }
        export class StatementDrawer extends ParadoxNotion.Design.ObjectDrawer$1<NodeCanvas.DialogueTrees.Statement> implements ParadoxNotion.Design.IObjectDrawer{ 
            public DrawGUI($content: UnityEngine.GUIContent, $instance: any, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
            public MoveNextDrawer():any;
        }
        export class ActionListPlayerInspector extends UnityEditor.Editor implements UnityEditor.IPreviewable, UnityEditor.IToolModeOwner{ 
        }
        export class BehaviourTreeOwnerInspector extends NodeCanvas.Editor.GraphOwnerInspector implements UnityEditor.IPreviewable, UnityEditor.IToolModeOwner{ 
        }
        export class DialogueTreeControllerInspector extends NodeCanvas.Editor.GraphOwnerInspector implements UnityEditor.IPreviewable, UnityEditor.IToolModeOwner{ 
        }
        export class DialogueTreeInspector extends NodeCanvas.Editor.GraphInspector implements UnityEditor.IPreviewable, UnityEditor.IToolModeOwner{ 
        }
    }
    export namespace Sirenix.OdinInspector.Editor {
        export class OdinEditor extends UnityEditor.Editor implements UnityEditor.IPreviewable, UnityEditor.IToolModeOwner{ 
        }
        export class OdinEditorWindow extends UnityEditor.EditorWindow implements UnityEngine.ISerializationCallbackReceiver{ 
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace ParadoxNotion.Services.Logger {
        export class Message extends System.ValueType{ 
            public type: UnityEngine.LogType;
            public text: string;
            public tag: string;
            public get context(): any;
            public set context(value: any);
            public IsValid():boolean;
        }
        export type LogHandler = (message: ParadoxNotion.Services.Logger.Message) => boolean;
        var LogHandler: {new (func: (message: ParadoxNotion.Services.Logger.Message) => boolean): LogHandler;}
    }
    export namespace ParadoxNotion.Design {
        export class ObjectDrawer$1<T> extends System.Object implements ParadoxNotion.Design.IObjectDrawer{ 
            public DrawGUI($content: UnityEngine.GUIContent, $instance: any, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
            public MoveNextDrawer():any;
        }
        export interface IObjectDrawer{ 
            DrawGUI($content: UnityEngine.GUIContent, $instance: any, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
            MoveNextDrawer():any;
        }
        export class InspectedFieldInfo extends System.ValueType{ 
            public field: System.Reflection.FieldInfo;
            public unityObjectContext: UnityEngine.Object;
            public parentInstanceContext: any;
            public wrapperInstanceContext: any;
            public attributes: System.Array$1<any>;
            public editor: UnityEditor.Editor;
            public editors: System.Collections.Generic.List$1<UnityEditor.Editor>;
            public dummy: NodeCanvas.Framework.EdtDummy;
            public constructor($unityObjectContext: UnityEngine.Object, $field: System.Reflection.FieldInfo, $parentInstanceContext: any, $attributes: System.Array$1<any>);
            public constructor();
        }
        export class EditorObjectWrapper$1<T> extends ParadoxNotion.Design.EditorObjectWrapper implements System.IDisposable{ 
        }
        export class EditorObjectWrapper extends System.Object implements System.IDisposable{ 
        }
        export class SpoofAOTAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class DoNotListAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class ProtectedSingletonAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class ExecutionPriorityAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public priority: number;
            public constructor($priority: number);
            public constructor();
        }
        export class ExposeAsDefinitionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class ExposeFieldAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class ListInspectorOptionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public allowAdd: boolean;
            public allowRemove: boolean;
            public showFoldout: boolean;
            public constructor($allowAdd: boolean, $allowRemove: boolean, $alwaysExpanded: boolean);
            public constructor();
        }
        export class NameAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public name: string;
            public priority: number;
            public constructor($name: string, $priority?: number);
            public constructor();
        }
        export class CategoryAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public category: string;
            public constructor($category: string);
            public constructor();
        }
        export class DescriptionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public description: string;
            public constructor($description: string);
            public constructor();
        }
        export class IconAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public iconName: string;
            public fixedColor: boolean;
            public runtimeIconTypeCallback: string;
            public fromType: System.Type;
            public constructor($iconName?: string, $fixedColor?: boolean, $runtimeIconTypeCallback?: string);
            public constructor($fromType: System.Type);
            public constructor();
        }
        export class ColorAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public hexColor: string;
            public constructor($hexColor: string);
            public constructor();
        }
        export class DrawerAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public get priority(): number;
            public get isDecorator(): boolean;
        }
        export class DimIfDefaultAttribute extends ParadoxNotion.Design.DrawerAttribute implements System.Runtime.InteropServices._Attribute{ 
            public get isDecorator(): boolean;
            public get priority(): number;
            public constructor();
        }
        export class ShowIfAttribute extends ParadoxNotion.Design.DrawerAttribute implements System.Runtime.InteropServices._Attribute{ 
            public fieldName: string;
            public checkValue: number;
            public get isDecorator(): boolean;
            public get priority(): number;
            public constructor($fieldName: string, $checkValue: number);
            public constructor();
        }
        export class RequiredFieldAttribute extends ParadoxNotion.Design.DrawerAttribute implements System.Runtime.InteropServices._Attribute{ 
            public get isDecorator(): boolean;
            public get priority(): number;
            public constructor();
        }
        export class ShowButtonAttribute extends ParadoxNotion.Design.DrawerAttribute implements System.Runtime.InteropServices._Attribute{ 
            public buttonTitle: string;
            public methodName: string;
            public get isDecorator(): boolean;
            public get priority(): number;
            public constructor($buttonTitle: string, $methodnameCallback: string);
            public constructor();
        }
        export class CallbackAttribute extends ParadoxNotion.Design.DrawerAttribute implements System.Runtime.InteropServices._Attribute{ 
            public methodName: string;
            public get isDecorator(): boolean;
            public get priority(): number;
            public constructor($methodName: string);
            public constructor();
        }
        export class MinValueAttribute extends ParadoxNotion.Design.DrawerAttribute implements System.Runtime.InteropServices._Attribute{ 
            public min: number;
            public get priority(): number;
            public constructor($min: number);
            public constructor($min: number);
            public constructor();
        }
        export class DelayedFieldAttribute extends ParadoxNotion.Design.DrawerAttribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class LayerFieldAttribute extends ParadoxNotion.Design.DrawerAttribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class TagFieldAttribute extends ParadoxNotion.Design.DrawerAttribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class TextAreaFieldAttribute extends ParadoxNotion.Design.DrawerAttribute implements System.Runtime.InteropServices._Attribute{ 
            public numberOfLines: number;
            public constructor($numberOfLines: number);
            public constructor();
        }
        export class PopupFieldAttribute extends ParadoxNotion.Design.DrawerAttribute implements System.Runtime.InteropServices._Attribute{ 
            public options: System.Array$1<any>;
            public constructor(...options: any[]);
            public constructor();
        }
        export class SliderFieldAttribute extends ParadoxNotion.Design.DrawerAttribute implements System.Runtime.InteropServices._Attribute{ 
            public min: number;
            public max: number;
            public constructor($min: number, $max: number);
            public constructor($min: number, $max: number);
            public constructor();
        }
        export class ForceObjectFieldAttribute extends ParadoxNotion.Design.DrawerAttribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class AOTClassesGenerator extends System.Object{ 
            public static GenerateAOTClasses($path: string, $targetTypes: System.Array$1<System.Type>):void;
            public static GenerateLinkXML($path: string, $targetTypes: System.Array$1<System.Type>):void;
        }
        export class AssetTracker extends UnityEditor.AssetPostprocessor{ 
            public static get trackedAssets(): System.Collections.Generic.Dictionary$2<string, UnityEngine.Object>;
            public static get trackedTypes(): System.Collections.Generic.List$1<System.Type>;
            public static add_onAssetsImported($value: System.Action$1<System.Array$1<string>>):void;
            public static remove_onAssetsImported($value: System.Action$1<System.Array$1<string>>):void;
            public static add_onAssetsDeleted($value: System.Action$1<System.Array$1<string>>):void;
            public static remove_onAssetsDeleted($value: System.Action$1<System.Array$1<string>>):void;
            public static add_onAssetsMoved($value: System.Action$2<System.Array$1<string>, System.Array$1<string>>):void;
            public static remove_onAssetsMoved($value: System.Action$2<System.Array$1<string>, System.Array$1<string>>):void;
            public static BeginTrackingAssetsOfType($type: System.Type):void;
            public constructor();
        }
        export class DimIfDefaultDrawer extends ParadoxNotion.Design.AttributeDrawer$1<ParadoxNotion.Design.DimIfDefaultAttribute> implements ParadoxNotion.Design.IAttributeDrawer{ 
            public constructor();
            public DrawGUI($objectDrawer: ParadoxNotion.Design.IObjectDrawer, $content: UnityEngine.GUIContent, $instance: any, $attribute: ParadoxNotion.Design.DrawerAttribute, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
        }
        export class AttributeDrawer$1<T> extends System.Object implements ParadoxNotion.Design.IAttributeDrawer{ 
            public DrawGUI($objectDrawer: ParadoxNotion.Design.IObjectDrawer, $content: UnityEngine.GUIContent, $instance: any, $attribute: ParadoxNotion.Design.DrawerAttribute, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
        }
        export interface IAttributeDrawer{ 
            DrawGUI($objectDrawer: ParadoxNotion.Design.IObjectDrawer, $content: UnityEngine.GUIContent, $instance: any, $attribute: ParadoxNotion.Design.DrawerAttribute, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
        }
        export class ShowIfDrawer extends ParadoxNotion.Design.AttributeDrawer$1<ParadoxNotion.Design.ShowIfAttribute> implements ParadoxNotion.Design.IAttributeDrawer{ 
            public constructor();
            public DrawGUI($objectDrawer: ParadoxNotion.Design.IObjectDrawer, $content: UnityEngine.GUIContent, $instance: any, $attribute: ParadoxNotion.Design.DrawerAttribute, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
        }
        export class RequiredFieldDrawer extends ParadoxNotion.Design.AttributeDrawer$1<ParadoxNotion.Design.RequiredFieldAttribute> implements ParadoxNotion.Design.IAttributeDrawer{ 
            public constructor();
            public DrawGUI($objectDrawer: ParadoxNotion.Design.IObjectDrawer, $content: UnityEngine.GUIContent, $instance: any, $attribute: ParadoxNotion.Design.DrawerAttribute, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
        }
        export class ShowButtonDrawer extends ParadoxNotion.Design.AttributeDrawer$1<ParadoxNotion.Design.ShowButtonAttribute> implements ParadoxNotion.Design.IAttributeDrawer{ 
            public constructor();
            public DrawGUI($objectDrawer: ParadoxNotion.Design.IObjectDrawer, $content: UnityEngine.GUIContent, $instance: any, $attribute: ParadoxNotion.Design.DrawerAttribute, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
        }
        export class CallbackDrawer extends ParadoxNotion.Design.AttributeDrawer$1<ParadoxNotion.Design.CallbackAttribute> implements ParadoxNotion.Design.IAttributeDrawer{ 
            public constructor();
            public DrawGUI($objectDrawer: ParadoxNotion.Design.IObjectDrawer, $content: UnityEngine.GUIContent, $instance: any, $attribute: ParadoxNotion.Design.DrawerAttribute, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
        }
        export class MinValueDrawer extends ParadoxNotion.Design.AttributeDrawer$1<ParadoxNotion.Design.MinValueAttribute> implements ParadoxNotion.Design.IAttributeDrawer{ 
            public constructor();
            public DrawGUI($objectDrawer: ParadoxNotion.Design.IObjectDrawer, $content: UnityEngine.GUIContent, $instance: any, $attribute: ParadoxNotion.Design.DrawerAttribute, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
        }
        export class DelayedFieldDrawer extends ParadoxNotion.Design.AttributeDrawer$1<ParadoxNotion.Design.DelayedFieldAttribute> implements ParadoxNotion.Design.IAttributeDrawer{ 
            public constructor();
            public DrawGUI($objectDrawer: ParadoxNotion.Design.IObjectDrawer, $content: UnityEngine.GUIContent, $instance: any, $attribute: ParadoxNotion.Design.DrawerAttribute, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
        }
        export class ForceObjectFieldDrawer extends ParadoxNotion.Design.AttributeDrawer$1<ParadoxNotion.Design.ForceObjectFieldAttribute> implements ParadoxNotion.Design.IAttributeDrawer{ 
            public constructor();
            public DrawGUI($objectDrawer: ParadoxNotion.Design.IObjectDrawer, $content: UnityEngine.GUIContent, $instance: any, $attribute: ParadoxNotion.Design.DrawerAttribute, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
        }
        export class PopupFieldDrawer extends ParadoxNotion.Design.AttributeDrawer$1<ParadoxNotion.Design.PopupFieldAttribute> implements ParadoxNotion.Design.IAttributeDrawer{ 
            public constructor();
            public DrawGUI($objectDrawer: ParadoxNotion.Design.IObjectDrawer, $content: UnityEngine.GUIContent, $instance: any, $attribute: ParadoxNotion.Design.DrawerAttribute, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
        }
        export class SliderFieldDrawer extends ParadoxNotion.Design.AttributeDrawer$1<ParadoxNotion.Design.SliderFieldAttribute> implements ParadoxNotion.Design.IAttributeDrawer{ 
            public constructor();
            public DrawGUI($objectDrawer: ParadoxNotion.Design.IObjectDrawer, $content: UnityEngine.GUIContent, $instance: any, $attribute: ParadoxNotion.Design.DrawerAttribute, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
        }
        export class LayerFieldDrawer extends ParadoxNotion.Design.AttributeDrawer$1<ParadoxNotion.Design.LayerFieldAttribute> implements ParadoxNotion.Design.IAttributeDrawer{ 
            public constructor();
            public DrawGUI($objectDrawer: ParadoxNotion.Design.IObjectDrawer, $content: UnityEngine.GUIContent, $instance: any, $attribute: ParadoxNotion.Design.DrawerAttribute, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
        }
        export class TagFieldDrawer extends ParadoxNotion.Design.AttributeDrawer$1<ParadoxNotion.Design.TagFieldAttribute> implements ParadoxNotion.Design.IAttributeDrawer{ 
            public constructor();
            public DrawGUI($objectDrawer: ParadoxNotion.Design.IObjectDrawer, $content: UnityEngine.GUIContent, $instance: any, $attribute: ParadoxNotion.Design.DrawerAttribute, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
        }
        export class TextAreaDrawer extends ParadoxNotion.Design.AttributeDrawer$1<ParadoxNotion.Design.TextAreaFieldAttribute> implements ParadoxNotion.Design.IAttributeDrawer{ 
            public constructor();
            public DrawGUI($objectDrawer: ParadoxNotion.Design.IObjectDrawer, $content: UnityEngine.GUIContent, $instance: any, $attribute: ParadoxNotion.Design.DrawerAttribute, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
        }
        export class CopyBuffer extends System.Object{ 
            public static FlushMem():void;
        }
        export class Colors extends System.Object{ 
            public static HEX_LIGHT: string;
            public static HEX_DARK: string;
            public static get lightOrange(): UnityEngine.Color;
            public static get lightBlue(): UnityEngine.Color;
            public static get lightRed(): UnityEngine.Color;
            public static get prefabOverrideColor(): UnityEngine.Color;
            public static Grey($value: number):UnityEngine.Color;
            public static GetTypeColor($type: System.Type):UnityEngine.Color;
            public static GetTypeHexColor($type: System.Type):string;
        }
        export class Icons extends System.Object{ 
            public static get playIcon(): UnityEngine.Texture2D;
            public static get pauseIcon(): UnityEngine.Texture2D;
            public static get stepIcon(): UnityEngine.Texture2D;
            public static get viewIcon(): UnityEngine.Texture2D;
            public static get csIcon(): UnityEngine.Texture2D;
            public static get tagIcon(): UnityEngine.Texture2D;
            public static get searchIcon(): UnityEngine.Texture2D;
            public static get infoIcon(): UnityEngine.Texture2D;
            public static get warningIcon(): UnityEngine.Texture2D;
            public static get warningIconBig(): UnityEngine.Texture2D;
            public static get errorIcon(): UnityEngine.Texture2D;
            public static get errorIconBig(): UnityEngine.Texture2D;
            public static get redCircle(): UnityEngine.Texture2D;
            public static get folderIcon(): UnityEngine.Texture2D;
            public static get favoriteIcon(): UnityEngine.Texture2D;
            public static get gearPopupIcon(): UnityEngine.Texture2D;
            public static get gearIcon(): UnityEngine.Texture2D;
            public static get scaleIcon(): UnityEngine.Texture2D;
            public static get minMaxIcon(): UnityEngine.Texture2D;
            public static get plusIcon(): UnityEngine.Texture2D;
            public static GetTypeIcon($type: System.Type):UnityEngine.Texture;
        }
        export class Styles extends System.Object{ 
            public static get centerLabel(): UnityEngine.GUIStyle;
            public static get topCenterLabel(): UnityEngine.GUIStyle;
            public static get leftLabel(): UnityEngine.GUIStyle;
            public static get rightLabel(): UnityEngine.GUIStyle;
            public static get topLeftLabel(): UnityEngine.GUIStyle;
            public static get topRightLabel(): UnityEngine.GUIStyle;
            public static get bottomCenterLabel(): UnityEngine.GUIStyle;
            public static get proxyContentImage(): UnityEngine.GUIStyle;
            public static get proxyRightContentLabel(): UnityEngine.GUIStyle;
            public static get proxyLeftContentLabel(): UnityEngine.GUIStyle;
            public static get wrapTextArea(): UnityEngine.GUIStyle;
            public static get roundedBox(): UnityEngine.GUIStyle;
            public static get buttonLeft(): UnityEngine.GUIStyle;
            public static get buttonMid(): UnityEngine.GUIStyle;
            public static get buttonRight(): UnityEngine.GUIStyle;
            public static get highlightBox(): UnityEngine.GUIStyle;
            public static get toolbarSearchTextField(): UnityEngine.GUIStyle;
            public static get toolbarSearchCancelButton(): UnityEngine.GUIStyle;
            public static get shadowedBackground(): UnityEngine.GUIStyle;
            public static Draw($position: UnityEngine.Rect, $style: UnityEngine.GUIStyle):void;
        }
        export class DocsByReflection extends System.Object{ 
            public static GetXmlElementForMember($memberInfo: System.Reflection.MemberInfo):System.Xml.XmlElement;
            public static GetMemberSummary($memberInfo: System.Reflection.MemberInfo):string;
            public static GetMethodReturn($method: System.Reflection.MethodBase):string;
            public static GetMethodParameter($method: System.Reflection.MethodBase, $parameter: System.Reflection.ParameterInfo):string;
            public static GetMethodParameter($method: System.Reflection.MethodBase, $parameterName: string):string;
            public static XMLFromMember($methodInfo: System.Reflection.MethodInfo):System.Xml.XmlElement;
            public static XMLFromMember($memberInfo: System.Reflection.MemberInfo):System.Xml.XmlElement;
            public static XMLFromType($type: System.Type):System.Xml.XmlElement;
            public static XMLFromAssembly($assembly: System.Reflection.Assembly):System.Xml.XmlDocument;
        }
        export class EditorUtils extends System.Object{ 
        }
        export class EditorWrapperFactory extends System.Object{ 
        }
        export class EditorPropertyWrapper$1<T> extends System.Object{ 
        }
        export class EditorMethodWrapper extends System.Object{ 
        }
        export class GenericInspectorWindow extends Sirenix.OdinInspector.Editor.OdinEditorWindow implements UnityEngine.ISerializationCallbackReceiver{ 
            public static Show($title: string, $targetType: System.Type, $unityObjectContext: UnityEngine.Object, $read: System.Func$1<any>, $write: System.Action$1<any>):void;
            public constructor();
        }
        export class GenericMenuBrowser extends UnityEditor.PopupWindowContent{ 
            public static get current(): ParadoxNotion.Design.GenericMenuBrowser;
            public static ShowAsync($pos: UnityEngine.Vector2, $title: string, $keyType: System.Type, $getMenu: System.Func$1<UnityEditor.GenericMenu>):void;
            public static Show($newMenu: UnityEditor.GenericMenu, $pos: UnityEngine.Vector2, $title: string, $keyType: System.Type):ParadoxNotion.Design.GenericMenuBrowser;
            public SetMenu($newMenu: UnityEditor.GenericMenu):void;
            public AddFavorite($path: string):void;
            public RemoveFavorite($path: string):void;
            public constructor($newMenu: UnityEditor.GenericMenu, $title: string, $keyType: System.Type);
            public constructor();
        }
        export class PropertyDrawerFactory extends System.Object{ 
            public static FlushMem():void;
            public static GetObjectDrawer($objectType: System.Type):ParadoxNotion.Design.IObjectDrawer;
            public static GetAttributeDrawer($att: ParadoxNotion.Design.DrawerAttribute):ParadoxNotion.Design.IAttributeDrawer;
            public static GetAttributeDrawer($attributeType: System.Type):ParadoxNotion.Design.IAttributeDrawer;
        }
        export class DefaultObjectDrawer extends ParadoxNotion.Design.ObjectDrawer$1<any> implements ParadoxNotion.Design.IObjectDrawer{ 
            public constructor($objectType: System.Type);
            public DrawGUI($content: UnityEngine.GUIContent, $instance: any, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
            public MoveNextDrawer():any;
        }
        export class DefaultAttributeDrawer extends ParadoxNotion.Design.AttributeDrawer$1<ParadoxNotion.Design.DrawerAttribute> implements ParadoxNotion.Design.IAttributeDrawer{ 
            public constructor($attributeType: System.Type);
            public DrawGUI($objectDrawer: ParadoxNotion.Design.IObjectDrawer, $content: UnityEngine.GUIContent, $instance: any, $attribute: ParadoxNotion.Design.DrawerAttribute, $info: ParadoxNotion.Design.InspectedFieldInfo):any;
        }
        export class TypePrefs extends System.Object{ 
            public static SYNC_FILE_NAME: string;
            public static LIST_MENU_STRING: string;
            public static DICT_MENU_STRING: string;
            public static functionalTypesBlacklist: System.Collections.Generic.List$1<System.Type>;
            public static add_onPreferredTypesChanged($value: System.Action):void;
            public static remove_onPreferredTypesChanged($value: System.Action):void;
            public static GetPreferedTypesList($filterOutFunctionalOnlyTypes?: boolean):System.Collections.Generic.List$1<System.Type>;
            public static GetPreferedTypesList($baseType: System.Type, $filterOutFunctionalOnlyTypes?: boolean):System.Collections.Generic.List$1<System.Type>;
            public static SetPreferedTypesList($types: System.Collections.Generic.List$1<System.Type>):void;
            public static AddType($type: System.Type):void;
            public static ResetTypeConfiguration():void;
            public static SyncFilePath():string;
            public static GetTypeColor($info: System.Reflection.MemberInfo):UnityEngine.Color;
            public static GetTypeHexColor($type: System.Type):string;
            public static GetTypeIcon($info: System.Reflection.MemberInfo, $fallbackToDefault?: boolean):UnityEngine.Texture;
            public static GetTypeIcon($iconAttribute: ParadoxNotion.Design.IconAttribute, $instance?: any):UnityEngine.Texture;
            public static GetTypeDoc($info: System.Reflection.MemberInfo):string;
        }
        export class TypePrefsEditorWindow extends UnityEditor.EditorWindow{ 
        }
        export class UndoUtility extends System.Object{ 
            public static get lastOperationName(): string;
            public static RecordObject($target: UnityEngine.Object, $name: string):void;
            public static RecordObjectComplete($target: UnityEngine.Object, $name: string):void;
            public static SetDirty($target: UnityEngine.Object):void;
            public static RecordObject($target: UnityEngine.Object, $name: string, $operation: System.Action):void;
            public static RecordObjectComplete($target: UnityEngine.Object, $name: string, $operation: System.Action):void;
            public static GetLastOperationNameOr($operation: string):string;
            public static CheckUndo($target: UnityEngine.Object, $name: string):void;
            public static CheckDirty($target: UnityEngine.Object):void;
        }
    }
    export namespace NodeCanvas.Editor.Prefs {
        export enum ConsoleLogOrder{ Ascending = 0, Descending = 1 }
    }
    export namespace NodeCanvas.Editor.StyleSheet {
        export class Styles extends System.Object{ 
        }
        export class Icons extends System.Object{ 
        }
    }
    export namespace ParadoxNotion.ReflectionTools {
        export enum MethodType{ Normal = 0, PropertyAccessor = 1, Event = 2, Operator = 3 }
    }
    export namespace ParadoxNotion.TypeConverter {
        export type CustomConverter = (fromType: System.Type, toType: System.Type) => System.Func$2<any, any>;
        var CustomConverter: {new (func: (fromType: System.Type, toType: System.Type) => System.Func$2<any, any>): CustomConverter;}
    }
    export namespace ParadoxNotion.Services.EventRouter {
        export type EventDelegate$1<T> = (msg: ParadoxNotion.EventData$1<T>) => void;
        export type EventDelegate = (msg: ParadoxNotion.EventData) => void;
        var EventDelegate: {new (func: (msg: ParadoxNotion.EventData) => void): EventDelegate;}
        export type CustomEventDelegate = (name: string, data: ParadoxNotion.IEventData) => void;
        var CustomEventDelegate: {new (func: (name: string, data: ParadoxNotion.IEventData) => void): CustomEventDelegate;}
    }
    export namespace ParadoxNotion.Services.MonoManager {
        export enum UpdateMode{ NormalUpdate = 0, LateUpdate = 1, FixedUpdate = 2 }
    }
    export namespace System.Runtime.ConstrainedExecution {
        export class CriticalFinalizerObject extends System.Object{ 
        }
    }
    export namespace ParadoxNotion.Serialization.FullSerializer.Internal {
        export class fsArrayConverter extends ParadoxNotion.Serialization.FullSerializer.fsConverter{ 
            public constructor();
        }
        export class fsDictionaryConverter extends ParadoxNotion.Serialization.FullSerializer.fsConverter{ 
            public constructor();
        }
        export class fsEnumConverter extends ParadoxNotion.Serialization.FullSerializer.fsConverter{ 
            public constructor();
        }
        export class fsForwardConverter extends ParadoxNotion.Serialization.FullSerializer.fsConverter{ 
            public constructor($attribute: ParadoxNotion.Serialization.FullSerializer.fsForwardAttribute);
            public constructor();
        }
        export class fsListConverter extends ParadoxNotion.Serialization.FullSerializer.fsConverter{ 
            public constructor();
        }
        export class fsPrimitiveConverter extends ParadoxNotion.Serialization.FullSerializer.fsConverter{ 
            public constructor();
        }
        export class fsReflectedConverter extends ParadoxNotion.Serialization.FullSerializer.fsConverter{ 
            public constructor();
        }
        export class fsTypeConverter extends ParadoxNotion.Serialization.FullSerializer.fsConverter{ 
            public constructor();
        }
    }
    export namespace ParadoxNotion.Serialization.FullSerializer.Internal.DirectConverters {
        export class AnimationCurve_DirectConverter extends ParadoxNotion.Serialization.FullSerializer.fsDirectConverter$1<UnityEngine.AnimationCurve>{ 
            public constructor();
        }
        export class Bounds_DirectConverter extends ParadoxNotion.Serialization.FullSerializer.fsDirectConverter$1<UnityEngine.Bounds>{ 
            public constructor();
        }
        export class Gradient_DirectConverter extends ParadoxNotion.Serialization.FullSerializer.fsDirectConverter$1<UnityEngine.Gradient>{ 
            public constructor();
        }
        export class GUIStyleState_DirectConverter extends ParadoxNotion.Serialization.FullSerializer.fsDirectConverter$1<UnityEngine.GUIStyleState>{ 
            public constructor();
        }
        export class GUIStyle_DirectConverter extends ParadoxNotion.Serialization.FullSerializer.fsDirectConverter$1<UnityEngine.GUIStyle>{ 
            public constructor();
        }
        export class Keyframe_DirectConverter extends ParadoxNotion.Serialization.FullSerializer.fsDirectConverter$1<UnityEngine.Keyframe>{ 
            public constructor();
        }
        export class LayerMask_DirectConverter extends ParadoxNotion.Serialization.FullSerializer.fsDirectConverter$1<UnityEngine.LayerMask>{ 
            public constructor();
        }
        export class RectOffset_DirectConverter extends ParadoxNotion.Serialization.FullSerializer.fsDirectConverter$1<UnityEngine.RectOffset>{ 
            public constructor();
        }
        export class Rect_DirectConverter extends ParadoxNotion.Serialization.FullSerializer.fsDirectConverter$1<UnityEngine.Rect>{ 
            public constructor();
        }
        export class Vector2Int_DirectConverter extends ParadoxNotion.Serialization.FullSerializer.fsDirectConverter$1<UnityEngine.Vector2Int>{ 
            public constructor();
        }
        export class Vector2_DirectConverter extends ParadoxNotion.Serialization.FullSerializer.fsDirectConverter$1<UnityEngine.Vector2>{ 
            public constructor();
        }
        export class Vector3Int_DirectConverter extends ParadoxNotion.Serialization.FullSerializer.fsDirectConverter$1<UnityEngine.Vector3Int>{ 
            public constructor();
        }
    }
    export namespace System.Xml {
        export class XmlElement extends System.Xml.XmlLinkedNode implements System.ICloneable, System.Collections.IEnumerable, System.Xml.XPath.IXPathNavigable{ 
        }
        export class XmlLinkedNode extends System.Xml.XmlNode implements System.ICloneable, System.Collections.IEnumerable, System.Xml.XPath.IXPathNavigable{ 
        }
        export class XmlNode extends System.Object implements System.ICloneable, System.Collections.IEnumerable, System.Xml.XPath.IXPathNavigable{ 
        }
        export class XmlDocument extends System.Xml.XmlNode implements System.ICloneable, System.Collections.IEnumerable, System.Xml.XPath.IXPathNavigable{ 
        }
    }
    export namespace System.Xml.XPath {
        export interface IXPathNavigable{ 
        }
    }
    export namespace ParadoxNotion.Design.EditorUtils {
        export class MenuItemInfo extends System.ValueType{ 
        }
        export type ReorderableListCallback = (index: number, isPicked: boolean) => void;
        var ReorderableListCallback: {new (func: (index: number, isPicked: boolean) => void): ReorderableListCallback;}
        export class ReorderableListOptions extends System.ValueType{ 
        }
        export class ScriptInfo extends System.ValueType{ 
        }
        interface ScriptInfo {
            MakeGenericInfo($targetType: System.Type, $subCategory?: string, $priorityShift?: number):ParadoxNotion.Design.EditorUtils.ScriptInfo;
        }
    }
    export namespace Newtonsoft.Json.Unity {
        export class ConverterInitializer extends System.Object{ 
        }
        export class JsonQuaternionConverter extends Newtonsoft.Json.JsonConverter$1<UnityEngine.Quaternion>{ 
            public get CanWrite(): boolean;
            public get CanRead(): boolean;
            public constructor();
        }
        export class JsonVector2Converter extends Newtonsoft.Json.JsonConverter$1<UnityEngine.Vector2>{ 
            public get CanWrite(): boolean;
            public get CanRead(): boolean;
            public constructor();
        }
        export class JsonVector3Converter extends Newtonsoft.Json.JsonConverter$1<UnityEngine.Vector3>{ 
            public get CanWrite(): boolean;
            public get CanRead(): boolean;
            public constructor();
        }
        export class JsonVector4Converter extends Newtonsoft.Json.JsonConverter$1<UnityEngine.Vector4>{ 
            public get CanWrite(): boolean;
            public get CanRead(): boolean;
            public constructor();
        }
    }
    export namespace Newtonsoft.Json {
        export class JsonConverter$1<T> extends Newtonsoft.Json.JsonConverter{ 
        }
        export class JsonConverter extends System.Object{ 
        }
        export class JsonWriter extends System.Object implements System.IDisposable{ 
        }
        export class JsonSerializer extends System.Object{ 
        }
        export class JsonReader extends System.Object implements System.IDisposable{ 
        }
    }
    export namespace MoreTags {
        export class Extensions extends System.Object{ 
            public static AddTag($go: UnityEngine.GameObject, ...tags: string[]):void;
            public static RemoveTag($go: UnityEngine.GameObject, ...tags: string[]):void;
            public static ChangeTag($go: UnityEngine.GameObject, $old: string, $tag: string):void;
            public static HasTag($go: UnityEngine.GameObject, $tag: string):boolean;
            public static AnyTags($go: UnityEngine.GameObject, ...tags: string[]):boolean;
            public static BothTags($go: UnityEngine.GameObject, ...tags: string[]):boolean;
            public static GetTags($go: UnityEngine.GameObject):System.Array$1<string>;
            public static FindTags($go: UnityEngine.GameObject, $tags: MoreTags.TagNames):System.Array$1<string>;
            public static GetChildrenList($go: UnityEngine.GameObject, $self?: boolean):System.Collections.Generic.IEnumerable$1<UnityEngine.GameObject>;
        }
        export class TagNames extends System.Object implements System.Collections.IEnumerable, System.Collections.Generic.IEnumerable$1<string>{ 
            public get both(): MoreTags.TagPattern;
            public get either(): MoreTags.TagPattern;
            public Add($n: MoreTags.TagNames):void;
            public Remove($n: MoreTags.TagNames):void;
            public GetEnumerator():System.Collections.Generic.IEnumerator$1<string>;
            public static op_Implicit($str: string):MoreTags.TagNames;
            public static op_Addition($a: MoreTags.TagNames, $b: MoreTags.TagNames):MoreTags.TagNames;
            public static op_Subtraction($a: MoreTags.TagNames, $b: MoreTags.TagNames):MoreTags.TagNames;
            public constructor(...n: string[]);
            public constructor($n: System.Collections.Generic.IEnumerable$1<string>);
            public constructor();
        }
        export class PrefabTags extends UnityEngine.MonoBehaviour{ 
            public Tags: System.Collections.Generic.List$1<string>;
            public constructor();
        }
        export class TagName extends System.Object{ 
            public name: string;
            public last: string;
            public parts: System.Array$1<string>;
            public static op_Implicit($name: string):MoreTags.TagName;
            public static op_Implicit($name: MoreTags.TagName):string;
            public static op_Implicit($name: MoreTags.TagName):MoreTags.TagPattern;
            public static op_BitwiseAnd($a: MoreTags.TagName, $b: MoreTags.TagName):MoreTags.TagPattern;
            public static op_BitwiseOr($a: MoreTags.TagName, $b: MoreTags.TagName):MoreTags.TagPattern;
            public static op_Subtraction($a: MoreTags.TagName, $b: MoreTags.TagName):MoreTags.TagPattern;
            public static op_UnaryNegation($a: MoreTags.TagName):MoreTags.TagPattern;
            public static op_Implicit($name: MoreTags.TagName):MoreTags.TagNames;
            public static op_Addition($a: MoreTags.TagName, $b: MoreTags.TagName):MoreTags.TagNames;
            public constructor($n: string);
            public constructor();
        }
        export class TagPattern extends System.Object{ 
            public GameObject():UnityEngine.GameObject;
            public GameObjects():System.Array$1<UnityEngine.GameObject>;
            public Count():number;
            public And():MoreTags.TagPattern;
            public Or():MoreTags.TagPattern;
            public Exclude():MoreTags.TagPattern;
            public And($pattern: MoreTags.TagPattern):MoreTags.TagPattern;
            public Or($pattern: MoreTags.TagPattern):MoreTags.TagPattern;
            public Exclude($pattern: MoreTags.TagPattern):MoreTags.TagPattern;
            public Combine($pattern: MoreTags.TagPattern):MoreTags.TagPattern;
            public All():MoreTags.TagPattern;
            public With($tag: string):MoreTags.TagPattern;
            public Both(...tags: string[]):MoreTags.TagPattern;
            public Either(...tags: string[]):MoreTags.TagPattern;
            public static op_Implicit($pattern: string):MoreTags.TagPattern;
            public static op_BitwiseAnd($a: MoreTags.TagPattern, $b: MoreTags.TagPattern):MoreTags.TagPattern;
            public static op_BitwiseOr($a: MoreTags.TagPattern, $b: MoreTags.TagPattern):MoreTags.TagPattern;
            public static op_Subtraction($a: MoreTags.TagPattern, $b: MoreTags.TagPattern):MoreTags.TagPattern;
            public static op_UnaryNegation($a: MoreTags.TagPattern):MoreTags.TagPattern;
            public static op_BitwiseAnd($a: MoreTags.TagName, $b: MoreTags.TagPattern):MoreTags.TagPattern;
            public static op_BitwiseOr($a: MoreTags.TagName, $b: MoreTags.TagPattern):MoreTags.TagPattern;
            public static op_Subtraction($a: MoreTags.TagName, $b: MoreTags.TagPattern):MoreTags.TagPattern;
        }
        export class TagGroup extends MoreTags.TagName{ 
            public get children(): MoreTags.TagNames;
            public get all(): MoreTags.TagNames;
            public static op_Implicit($cat: string):MoreTags.TagGroup;
            public constructor($n: string);
            public static op_Implicit($name: string):MoreTags.TagName;
            public static op_Implicit($name: MoreTags.TagName):string;
            public static op_Implicit($name: MoreTags.TagName):MoreTags.TagPattern;
            public static op_Implicit($name: MoreTags.TagName):MoreTags.TagNames;
            public constructor($n: string);
            public constructor();
        }
        export class TagChildren extends MoreTags.TagNames implements System.Collections.IEnumerable, System.Collections.Generic.IEnumerable$1<string>{ 
            public name: string;
            public get children(): MoreTags.TagNames;
            public get all(): MoreTags.TagNames;
            public static op_Implicit($child: string):MoreTags.TagChildren;
            public constructor($n: string);
            public static op_Implicit($str: string):MoreTags.TagNames;
            public constructor(...n: string[]);
            public constructor($n: System.Collections.Generic.IEnumerable$1<string>);
            public constructor();
        }
        export class TagHelper extends System.Object{ 
            public static StringToPattern($str: string):MoreTags.TagPattern;
            public static StringToTagNames($str: string):MoreTags.TagNames;
            public static CreateGameObject():UnityEngine.GameObject;
            public static CreateGameObject($count: number):System.Array$1<UnityEngine.GameObject>;
            public static DestroyGameObject($go: UnityEngine.GameObject):void;
            public static DestroyGameObject(...list: UnityEngine.GameObject[]):void;
            public static Test():MoreTags.TagPattern;
        }
        export class Tag extends System.Object{ 
            public static all: MoreTags.AllTags;
            public static Object: MoreTags.ObjectGroup;
            public static Color: MoreTags.ColorGroup;
        }
        export class AllTags extends MoreTags.TagNames implements System.Collections.IEnumerable, System.Collections.Generic.IEnumerable$1<string>{ 
            public Cube: MoreTags.TagChildren;
            public Sphere: MoreTags.TagChildren;
            public Capsule: MoreTags.TagChildren;
            public Cylinder: MoreTags.TagChildren;
            public Red: MoreTags.TagChildren;
            public Green: MoreTags.TagChildren;
            public Blue: MoreTags.TagChildren;
            public Yellow: MoreTags.TagChildren;
            public Cyan: MoreTags.TagChildren;
            public Magenta: MoreTags.TagChildren;
            public constructor();
        }
        export class ObjectGroup extends MoreTags.TagGroup{ 
            public Cube: MoreTags.TagName;
            public Sphere: MoreTags.TagName;
            public Capsule: MoreTags.TagName;
            public Cylinder: MoreTags.TagName;
            public constructor($name: string);
            public constructor($n: string);
            public constructor($n: string);
            public constructor();
            public constructor($n: string);
        }
        export class ColorGroup extends MoreTags.TagGroup{ 
            public Red: MoreTags.TagName;
            public Green: MoreTags.TagName;
            public Blue: MoreTags.TagName;
            public Yellow: MoreTags.TagName;
            public Cyan: MoreTags.TagName;
            public Magenta: MoreTags.TagName;
            public constructor($name: string);
            public constructor($n: string);
            public constructor($n: string);
            public constructor();
            public constructor($n: string);
        }
        export class TagData extends System.Object{ 
            public name: string;
            public color: UnityEngine.Color;
            public gameObjects: System.Array$1<UnityEngine.GameObject>;
            public constructor();
        }
        export class TagManager extends UnityEngine.MonoBehaviour implements UnityEngine.ISerializationCallbackReceiver{ 
            public OnAfterDeserialize():void;
            public OnBeforeSerialize():void;
            public constructor();
        }
        export class Tags extends UnityEngine.MonoBehaviour{ 
            public constructor();
        }
        export class TagTableData extends System.Object{ 
            public color: UnityEngine.Color;
            public gameObjects: System.Collections.Generic.HashSet$1<UnityEngine.GameObject>;
            public constructor();
        }
        export class TagSystem extends System.Object{ 
            public static get pattern(): MoreTags.TagPattern;
            public static Reset():void;
            public static BeforeSerialize($m_tags: $Ref<System.Array$1<MoreTags.TagData>>, $scene: UnityEngine.SceneManagement.Scene):void;
            public static LoadDataToTable($m_tags: System.Array$1<MoreTags.TagData>):void;
            public static CheckTagManager($scene: UnityEngine.SceneManagement.Scene):void;
            public static CheckGameObjectTag($go: UnityEngine.GameObject):void;
            public static RemoveUnusedTag():void;
            public static RemoveNullGameObject():void;
            public static SearchFrom($list?: System.Collections.Generic.IEnumerable$1<UnityEngine.GameObject>):void;
            public static AddTag(...tags: string[]):void;
            public static RemoveTag(...tags: string[]):void;
            public static RenameTag($old: string, $tag: string):void;
            public static SetTagColor($tag: string, $col: UnityEngine.Color):void;
            public static GetTagColor($tag: string):UnityEngine.Color;
            public static AddGameObjectTag($go: UnityEngine.GameObject, ...tags: string[]):void;
            public static RemoveGameObjectTag($go: UnityEngine.GameObject, ...tags: string[]):void;
            public static GetGameObjectTags($go: UnityEngine.GameObject):System.Array$1<string>;
            public static GetAllTags():System.Array$1<string>;
            public static GetGameObject($tag: string):UnityEngine.GameObject;
            public static GetGameObjects($tag: string):System.Array$1<UnityEngine.GameObject>;
            public static GameObjectTags($go: UnityEngine.GameObject):System.Collections.Generic.IEnumerable$1<string>;
            public static AllTags():System.Collections.Generic.IEnumerable$1<string>;
        }
    }
    export namespace pointcache.Minimap {
        export class MinimapIcon extends UnityEngine.MonoBehaviour{ 
            public target: pointcache.Minimap.MinimapObject;
            public rectTransform: UnityEngine.RectTransform;
            public constructor();
        }
        export class MinimapObject extends UnityEngine.MonoBehaviour{ 
            public get config(): pointcache.Minimap.MinimapObject.Config;
            public constructor();
        }
        export class MinimapSystem extends UnityEngine.MonoBehaviour{ 
            public static get Instance(): pointcache.Minimap.MinimapSystem;
            public constructor();
        }
    }
    export namespace pointcache.Minimap.MinimapObject {
        export class Config extends System.Object{ 
            public icon: UnityEngine.Sprite;
            public color: UnityEngine.Color;
            public constructor();
        }
    }
    export namespace __Mask3D {
        export class Mask3D_Object extends UnityEngine.MonoBehaviour{ 
            public constructor();
        }
    }
    export namespace __Assembly_Define__ {
        export class AssemblyNotStrip extends System.Object{ 
            public constructor();
        }
    }
    export namespace zFrame.UI {
        export class DirectionArrow extends UnityEngine.MonoBehaviour{ 
            public constructor();
        }
        export class EnumFlagsAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class Joystick extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler{ 
            public maxRadius: number;
            public static instance: zFrame.UI.Joystick;
            public activatedAxis: zFrame.UI.Joystick.Direction;
            public OnValueChanged: zFrame.UI.Joystick.JoystickEvent;
            public OnPointerDown: zFrame.UI.Joystick.JoystickEvent;
            public OnPointerUp: zFrame.UI.Joystick.JoystickEvent;
            public get IsDraging(): boolean;
            public get DynamicJoystick(): boolean;
            public set DynamicJoystick(value: boolean);
            public constructor();
        }
    }
    export namespace zFrame.UI.Joystick {
        export enum Direction{ Horizontal = 1, Vertical = 2 }
        export class JoystickEvent extends UnityEngine.Events.UnityEvent$1<UnityEngine.Vector2> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
    }
    export namespace zFrame.Example {
        export class ConfigurationDemo extends UnityEngine.MonoBehaviour{ 
            public joystick: zFrame.UI.Joystick;
            public text2: UnityEngine.UI.Text;
            public constructor();
        }
        export class FirstPersonSolution extends UnityEngine.MonoBehaviour{ 
            public speed: number;
            public rotateRange: number;
            public viewRange: number;
            public constructor();
        }
        export class ThirdPersonSolution extends UnityEngine.MonoBehaviour{ 
            public speed: number;
            public constructor();
        }
        export class TransformMoveSolution extends UnityEngine.MonoBehaviour{ 
            public speed: number;
            public constructor();
        }
    }
    export namespace IngameDebugConsole {
        export class ChangeResolution extends UnityEngine.MonoBehaviour{ 
            public min: UnityEngine.Vector2Int;
            public max: UnityEngine.Vector2Int;
            public Change():void;
            public constructor();
        }
        export class ConsoleMethodAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public get Command(): string;
            public get Description(): string;
            public constructor($command: string, $description: string);
            public constructor();
        }
        export class ConsoleMethodInfo extends System.Object{ 
            public method: System.Reflection.MethodInfo;
            public parameterTypes: System.Array$1<System.Type>;
            public instance: any;
            public command: string;
            public signature: string;
            public parameters: System.Array$1<string>;
            public IsValid():boolean;
            public constructor($method: System.Reflection.MethodInfo, $parameterTypes: System.Array$1<System.Type>, $instance: any, $command: string, $signature: string, $parameters: System.Array$1<string>);
            public constructor();
        }
        export class DebugLogConsole extends System.Object{ 
            public static OnCommandNotFound: System.Action$1<System.Collections.Generic.List$1<string>>;
            public static LogAllCommands():void;
            public static LogSystemInfo():void;
            public static AddCustomParameterType($type: System.Type, $parseFunction: IngameDebugConsole.DebugLogConsole.ParseFunction, $typeReadableName?: string):void;
            public static RemoveCustomParameterType($type: System.Type):void;
            public static AddCommandInstance($command: string, $description: string, $methodName: string, $instance: any):void;
            public static AddCommandStatic($command: string, $description: string, $methodName: string, $ownerType: System.Type):void;
            public static AddCommand($command: string, $description: string, $method: System.Action):void;
            public static AddCommand($command: string, $description: string, $method: Function):void;
            public static AddCommand($command: string, $description: string, $method: System.Reflection.MethodInfo, $instance?: any):void;
            public static RemoveCommand($command: string):void;
            public static RemoveCommand($method: System.Action):void;
            public static RemoveCommand($method: Function):void;
            public static RemoveCommand($method: System.Reflection.MethodInfo):void;
            public static GetAutoCompleteCommand($commandStart: string):string;
            public static ExecuteCommand($command: string):void;
            public static FetchArgumentsFromCommand($command: string, $commandArguments: System.Collections.Generic.List$1<string>):void;
            public static IsSupportedArrayType($type: System.Type):boolean;
            public static GetTypeReadableName($type: System.Type):string;
            public static ParseArgument($input: string, $argumentType: System.Type, $output: $Ref<any>):boolean;
            public static ParseString($input: string, $output: $Ref<any>):boolean;
            public static ParseBool($input: string, $output: $Ref<any>):boolean;
            public static ParseInt($input: string, $output: $Ref<any>):boolean;
            public static ParseUInt($input: string, $output: $Ref<any>):boolean;
            public static ParseLong($input: string, $output: $Ref<any>):boolean;
            public static ParseULong($input: string, $output: $Ref<any>):boolean;
            public static ParseByte($input: string, $output: $Ref<any>):boolean;
            public static ParseSByte($input: string, $output: $Ref<any>):boolean;
            public static ParseShort($input: string, $output: $Ref<any>):boolean;
            public static ParseUShort($input: string, $output: $Ref<any>):boolean;
            public static ParseChar($input: string, $output: $Ref<any>):boolean;
            public static ParseFloat($input: string, $output: $Ref<any>):boolean;
            public static ParseDouble($input: string, $output: $Ref<any>):boolean;
            public static ParseDecimal($input: string, $output: $Ref<any>):boolean;
            public static ParseVector2($input: string, $output: $Ref<any>):boolean;
            public static ParseVector3($input: string, $output: $Ref<any>):boolean;
            public static ParseVector4($input: string, $output: $Ref<any>):boolean;
            public static ParseQuaternion($input: string, $output: $Ref<any>):boolean;
            public static ParseColor($input: string, $output: $Ref<any>):boolean;
            public static ParseColor32($input: string, $output: $Ref<any>):boolean;
            public static ParseRect($input: string, $output: $Ref<any>):boolean;
            public static ParseRectOffset($input: string, $output: $Ref<any>):boolean;
            public static ParseBounds($input: string, $output: $Ref<any>):boolean;
            public static ParseVector2Int($input: string, $output: $Ref<any>):boolean;
            public static ParseVector3Int($input: string, $output: $Ref<any>):boolean;
            public static ParseRectInt($input: string, $output: $Ref<any>):boolean;
            public static ParseBoundsInt($input: string, $output: $Ref<any>):boolean;
            public static ParseGameObject($input: string, $output: $Ref<any>):boolean;
            public static ParseComponent($input: string, $componentType: System.Type, $output: $Ref<any>):boolean;
            public static ParseEnum($input: string, $enumType: System.Type, $output: $Ref<any>):boolean;
            public static ParseArray($input: string, $arrayType: System.Type, $output: $Ref<any>):boolean;
        }
        export class DebugLogEntry extends System.Object implements System.IEquatable$1<IngameDebugConsole.DebugLogEntry>{ 
            public logString: string;
            public stackTrace: string;
            public logTypeSpriteRepresentation: UnityEngine.Sprite;
            public count: number;
            public Initialize($logString: string, $stackTrace: string):void;
            public Equals($other: IngameDebugConsole.DebugLogEntry):boolean;
            public MatchesSearchTerm($searchTerm: string):boolean;
            public constructor();
            public Equals($obj: any):boolean;
            public static Equals($objA: any, $objB: any):boolean;
        }
        export class QueuedDebugLogEntry extends System.ValueType{ 
            public logString: string;
            public stackTrace: string;
            public logType: UnityEngine.LogType;
            public MatchesSearchTerm($searchTerm: string):boolean;
            public constructor($logString: string, $stackTrace: string, $logType: UnityEngine.LogType);
            public constructor();
        }
        export class DebugLogIndexList extends System.Object{ 
            public get Count(): number;
            public get_Item($index: number):number;
            public Add($index: number):void;
            public Clear():void;
            public IndexOf($index: number):number;
            public constructor();
        }
        export class DebugLogItem extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerClickHandler{ 
            public get Transform(): UnityEngine.RectTransform;
            public get Image(): UnityEngine.UI.Image;
            public get Index(): number;
            public Initialize($manager: IngameDebugConsole.DebugLogRecycledListView):void;
            public SetContent($logEntry: IngameDebugConsole.DebugLogEntry, $entryIndex: number, $isExpanded: boolean):void;
            public ShowCount():void;
            public HideCount():void;
            public OnPointerClick($eventData: UnityEngine.EventSystems.PointerEventData):void;
            public CopyLog():void;
            public CalculateExpandedHeight($content: string):number;
            public constructor();
        }
        export class DebugLogRecycledListView extends UnityEngine.MonoBehaviour{ 
            public get ItemHeight(): number;
            public get SelectedItemHeight(): number;
            public Initialize($manager: IngameDebugConsole.DebugLogManager, $collapsedLogEntries: System.Collections.Generic.List$1<IngameDebugConsole.DebugLogEntry>, $indicesOfEntriesToShow: IngameDebugConsole.DebugLogIndexList, $logItemHeight: number):void;
            public SetCollapseMode($collapse: boolean):void;
            public OnLogItemClicked($item: IngameDebugConsole.DebugLogItem):void;
            public SelectAndFocusOnLogItemAtIndex($itemIndex: number):void;
            public DeselectSelectedLogItem():void;
            public OnLogEntriesUpdated($updateAllVisibleItemContents: boolean):void;
            public OnCollapsedLogEntryAtIndexUpdated($index: number):void;
            public OnViewportDimensionsChanged():void;
            public UpdateItemsInTheList($updateAllVisibleItemContents: boolean):void;
            public constructor();
        }
        export enum DebugLogFilter{ None = 0, Info = 1, Warning = 2, Error = 4, All = 7 }
        export class DebugLogManager extends UnityEngine.MonoBehaviour{ 
            public OnLogWindowShown: System.Action;
            public OnLogWindowHidden: System.Action;
            public static get Instance(): IngameDebugConsole.DebugLogManager;
            public get IsLogWindowVisible(): boolean;
            public get PopupEnabled(): boolean;
            public set PopupEnabled(value: boolean);
            public ShowLogWindow():void;
            public HideLogWindow():void;
            public SetSnapToBottom($snapToBottom: boolean):void;
            public ClearLogs():void;
            public GetAllLogs():string;
            public constructor();
        }
        export class DebugLogPopup extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEndDragHandler, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerClickHandler{ 
            public OnViewportDimensionsChanged():void;
            public NewInfoLogArrived():void;
            public NewWarningLogArrived():void;
            public NewErrorLogArrived():void;
            public OnPointerClick($data: UnityEngine.EventSystems.PointerEventData):void;
            public Show():void;
            public Hide():void;
            public OnBeginDrag($data: UnityEngine.EventSystems.PointerEventData):void;
            public OnDrag($data: UnityEngine.EventSystems.PointerEventData):void;
            public OnEndDrag($data: UnityEngine.EventSystems.PointerEventData):void;
            public constructor();
            public Show():null;
            public Hide():null;
        }
        export class DebugLogResizeListener extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEventSystemHandler{ 
            public constructor();
        }
        export class DebugsOnScrollListener extends UnityEngine.MonoBehaviour implements UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IEndDragHandler, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IScrollHandler{ 
            public debugsScrollRect: UnityEngine.UI.ScrollRect;
            public debugLogManager: IngameDebugConsole.DebugLogManager;
            public OnScroll($data: UnityEngine.EventSystems.PointerEventData):void;
            public OnBeginDrag($data: UnityEngine.EventSystems.PointerEventData):void;
            public OnEndDrag($data: UnityEngine.EventSystems.PointerEventData):void;
            public OnScrollbarDragStart($data: UnityEngine.EventSystems.BaseEventData):void;
            public OnScrollbarDragEnd($data: UnityEngine.EventSystems.BaseEventData):void;
            public constructor();
        }
    }
    export namespace IngameDebugConsole.DebugLogConsole {
        export type ParseFunction = (input: string, output: $Ref<any>) => boolean;
        var ParseFunction: {new (func: (input: string, output: $Ref<any>) => boolean): ParseFunction;}
    }
    export namespace UniWebServer {
        export class Headers extends System.Object{ 
            public get Keys(): System.Array$1<string>;
            public Add($name: string, $value: string):void;
            public Get($name: string):string;
            public Contains($name: string):boolean;
            public GetAll($name: string):System.Collections.Generic.List$1<string>;
            public Set($name: string, $value: any):void;
            public Pop($name: string):void;
            public Clear():void;
            public Read($headerText: string):void;
            public Read($bytes: System.Array$1<number>):void;
            public Read($stream: System.IO.Stream):void;
            public AddHeaderLine($line: string):void;
            public Read($reader: System.IO.StreamReader):void;
            public constructor();
        }
        export class Helper extends System.Object{ 
            public static GetFolderRoot($folderPath: string):string;
        }
        export interface IWebResource{ 
            HandleRequest($request: UniWebServer.Request, $response: UniWebServer.Response):void;
        }
        export class Request extends System.Object{ 
            public method: string;
            public path: string;
            public protocol: string;
            public query: string;
            public fragment: string;
            public uri: System.Uri;
            public headers: UniWebServer.Headers;
            public body: string;
            public stream: System.Net.Sockets.NetworkStream;
            public formData: System.Collections.Generic.Dictionary$2<string, UniWebServer.MultiPartEntry>;
            public Write($response: UniWebServer.Response):void;
            public Close():void;
            public constructor();
        }
        export class Response extends System.Object{ 
            public statusCode: number;
            public message: string;
            public useBytes: boolean;
            public dataBytes: System.Array$1<number>;
            public headers: UniWebServer.Headers;
            public stream: System.IO.MemoryStream;
            public writer: System.IO.StreamWriter;
            public SetBytes($data: System.Array$1<number>):void;
            public WriteJson($text: string):void;
            public Write($text: string):void;
            public constructor();
        }
        export class MimeTypeMap extends System.Object{ 
            public static GetMimeType($extension: string):string;
            public static GetExtension($mimeType: string):string;
            public static GetExtension($mimeType: string, $throwErrorIfNotFound: boolean):string;
        }
        export class MultiPartEntry extends System.Object{ 
            public headers: UniWebServer.Headers;
            public get Value(): string;
            public get Name(): string;
            public get Filename(): string;
            public static Parse($request: UniWebServer.Request):System.Collections.Generic.Dictionary$2<string, UniWebServer.MultiPartEntry>;
            public constructor();
        }
        export class JsonResponse extends System.Collections.Generic.Dictionary$2<string, any> implements System.Collections.IDictionary, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<System.Collections.Generic.KeyValuePair$2<string, any>>, System.Collections.Generic.IReadOnlyDictionary$2<string, any>, System.Runtime.Serialization.IDeserializationCallback, System.Collections.Generic.ICollection$1<System.Collections.Generic.KeyValuePair$2<string, any>>, System.Runtime.Serialization.ISerializable, System.Collections.ICollection, System.Collections.Generic.IDictionary$2<string, any>, System.Collections.Generic.IEnumerable$1<System.Collections.Generic.KeyValuePair$2<string, any>>{ 
            public get_Item($index: string):any;
            public set_Item($index: string, $value: any):void;
            public static op_Implicit($target: UniWebServer.JsonResponse):string;
            public ToJson():string;
            public constructor();
        }
        export class ThreadedTaskQueue extends System.Object implements System.IDisposable{ 
            public PushTask($task: System.Action):void;
            public PopTask():System.Action;
            public Dispose():void;
            public constructor($workerCount: number);
            public constructor();
        }
        export class WebServer extends System.Object implements System.IDisposable{ 
            public port: number;
            public workerThreads: number;
            public processRequestsInMainThread: boolean;
            public logRequests: boolean;
            public add_HandleRequest($value: System.Action$2<UniWebServer.Request, UniWebServer.Response>):void;
            public remove_HandleRequest($value: System.Action$2<UniWebServer.Request, UniWebServer.Response>):void;
            public Start():void;
            public Stop():void;
            public ProcessRequests():void;
            public Dispose():void;
            public constructor($port: number, $workerThreads: number, $processRequestsInMainThread: boolean);
            public constructor();
        }
        export class EmbeddedWebServerComponent extends UnityEngine.MonoBehaviour{ 
            public startOnAwake: boolean;
            public port: number;
            public workerThreads: number;
            public processRequestsInMainThread: boolean;
            public logRequests: boolean;
            public AddResource($path: string, $resource: UniWebServer.IWebResource):void;
            public constructor();
        }
        export class FileServer extends UnityEngine.MonoBehaviour implements UniWebServer.IWebResource{ 
            public folderPath: string;
            public HandleRequest($request: UniWebServer.Request, $response: UniWebServer.Response):void;
            public constructor();
            public HandleRequest($request: UniWebServer.Request, $response: UniWebServer.Response):void;
        }
    }
    export namespace System.Net.Sockets {
        export class NetworkStream extends System.IO.Stream implements System.IDisposable{ 
        }
    }
    export namespace FavouritesEd {
        export class FavouritesAsset extends UnityEngine.ScriptableObject{ 
            public favs: System.Collections.Generic.List$1<FavouritesEd.FavouritesElement>;
            public categories: System.Collections.Generic.List$1<FavouritesEd.FavouritesCategory>;
            public static instance: FavouritesEd.FavouritesAsset;
            public RefleshAction: System.Action;
            public AddObject($category: string, $target: UnityEngine.Object):string;
            public AddCategory($catName: string):FavouritesEd.FavouritesCategory;
            public constructor();
        }
        export class FavouritesElement extends System.Object{ 
            public categoryId: number;
            public obj: UnityEngine.Object;
            public constructor();
        }
        export class FavouritesCategory extends System.Object{ 
            public id: number;
            public name: string;
            public constructor();
        }
        export class FavouritesContainer extends UnityEngine.MonoBehaviour{ 
            public favs: System.Collections.Generic.List$1<FavouritesEd.FavouritesElement>;
            public constructor();
        }
        export class TreeElement extends System.Object{ 
            public get Depth(): number;
            public set Depth(value: number);
            public get Parent(): FavouritesEd.TreeElement;
            public set Parent(value: FavouritesEd.TreeElement);
            public get Children(): System.Collections.Generic.List$1<FavouritesEd.TreeElement>;
            public set Children(value: System.Collections.Generic.List$1<FavouritesEd.TreeElement>);
            public get HasChildren(): boolean;
            public get Name(): string;
            public set Name(value: string);
            public get SearchHelper(): string;
            public get ID(): number;
            public set ID(value: number);
            public get Icon(): UnityEngine.Texture2D;
            public set Icon(value: UnityEngine.Texture2D);
            public constructor();
            public constructor($name: string, $depth: number, $id: number);
            public constructor($name: string, $depth: number, $id: number, $icon: UnityEngine.Texture2D);
        }
        export class TreeElementUtility extends System.Object{ 
            public static TreeToList($root: FavouritesEd.TreeElement, $result: System.Collections.Generic.IList$1<T>):void;
            public static UpdateDepthValues($root: FavouritesEd.TreeElement):void;
        }
    }
    export namespace EasyDOTween {
        export class BaseAnimation extends UnityEngine.MonoBehaviour{ 
            public get playingTween(): DG.Tweening.Tween;
            public Play():DG.Tweening.Tween;
        }
        export class TweenPreviewAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute{ 
            public funcFilter: string;
            public constructor();
            public constructor($funcFilter: string);
        }
        export class Animation$1<T> extends EasyDOTween.BaseAnimation{ 
        }
        export class PocoAnimation$2<T, V> extends System.Object{ 
        }
        export class PocoSequence$3<A, T, V> extends System.Object{ 
        }
    }
    export namespace EasyDOTween.Animation.Transform {
        export class DOLocalMove extends EasyDOTween.Animation$1<UnityEngine.Transform>{ 
            public constructor();
        }
        export class DOLocalMoveX extends EasyDOTween.Animation$1<UnityEngine.Transform>{ 
            public constructor();
        }
        export class DOLocalMoveY extends EasyDOTween.Animation$1<UnityEngine.Transform>{ 
            public constructor();
        }
        export class DOLocalMoveZ extends EasyDOTween.Animation$1<UnityEngine.Transform>{ 
            public constructor();
        }
        export class DOLocalRotate extends EasyDOTween.Animation$1<UnityEngine.Transform>{ 
            public constructor();
        }
        export class DOLocalRotateQuaternion extends EasyDOTween.Animation$1<UnityEngine.Transform>{ 
            public constructor();
        }
        export class DOMove extends EasyDOTween.Animation$1<UnityEngine.Transform>{ 
            public constructor();
        }
        export class DOMoveX extends EasyDOTween.Animation$1<UnityEngine.Transform>{ 
            public constructor();
        }
        export class DOMoveY extends EasyDOTween.Animation$1<UnityEngine.Transform>{ 
            public constructor();
        }
        export class DOMoveZ extends EasyDOTween.Animation$1<UnityEngine.Transform>{ 
            public constructor();
        }
        export class DORotate extends EasyDOTween.Animation$1<UnityEngine.Transform>{ 
            public constructor();
        }
        export class DORotateQuaternion extends EasyDOTween.Animation$1<UnityEngine.Transform>{ 
            public constructor();
        }
        export class DOScale extends EasyDOTween.Animation$1<UnityEngine.Transform>{ 
            public constructor();
        }
        export class DOScaleX extends EasyDOTween.Animation$1<UnityEngine.Transform>{ 
            public constructor();
        }
        export class DOScaleY extends EasyDOTween.Animation$1<UnityEngine.Transform>{ 
            public constructor();
        }
        export class DOScaleZ extends EasyDOTween.Animation$1<UnityEngine.Transform>{ 
            public constructor();
        }
    }
    export namespace EasyDOTween.Animation.Text {
        export class DOText extends EasyDOTween.Animation$1<UnityEngine.UI.Text>{ 
            public constructor();
        }
    }
    export namespace EasyDOTween.Animation.Slider {
        export class DOValue extends EasyDOTween.Animation$1<UnityEngine.UI.Slider>{ 
            public constructor();
        }
    }
    export namespace EasyDOTween.Animation.ScrollRect {
        export class DOHorizontalNormalizedPos extends EasyDOTween.Animation$1<UnityEngine.UI.ScrollRect>{ 
            public constructor();
        }
        export class DONormalizedPos extends EasyDOTween.Animation$1<UnityEngine.UI.ScrollRect>{ 
            public constructor();
        }
        export class DOVerticalNormalizedPos extends EasyDOTween.Animation$1<UnityEngine.UI.ScrollRect>{ 
            public constructor();
        }
    }
    export namespace EasyDOTween.Animation.RectTransform {
        export class DOAnchorPos extends EasyDOTween.Animation$1<UnityEngine.RectTransform>{ 
            public constructor();
        }
        export class DOSizeDelta extends EasyDOTween.Animation$1<UnityEngine.RectTransform>{ 
            public constructor();
        }
    }
    export namespace EasyDOTween.Animation.Image {
        export class DOFillAmount extends EasyDOTween.Animation$1<UnityEngine.UI.Image>{ 
            public constructor();
        }
        export class DOGradientColor extends EasyDOTween.Animation$1<UnityEngine.UI.Image>{ 
            public constructor();
        }
    }
    export namespace EasyDOTween.Animation.Graphic {
        export class DOBlendableColor extends EasyDOTween.Animation$1<UnityEngine.UI.Graphic>{ 
            public constructor();
        }
        export class DOColor extends EasyDOTween.Animation$1<UnityEngine.UI.Graphic>{ 
            public constructor();
        }
        export class DOFade extends EasyDOTween.Animation$1<UnityEngine.UI.Graphic>{ 
            public constructor();
        }
    }
    export namespace EasyDOTween.Animation.CanvasGroup {
        export class DOFade extends EasyDOTween.Animation$1<UnityEngine.CanvasGroup>{ 
            public constructor();
        }
    }
    export namespace DG.Tweening.Plugins.Options {
        export class FloatOptions extends System.ValueType implements DG.Tweening.Plugins.Options.IPlugOptions{ 
        }
        export interface IPlugOptions{ 
        }
        export class VectorOptions extends System.ValueType implements DG.Tweening.Plugins.Options.IPlugOptions{ 
        }
        export class QuaternionOptions extends System.ValueType implements DG.Tweening.Plugins.Options.IPlugOptions{ 
        }
        export class PathOptions extends System.ValueType implements DG.Tweening.Plugins.Options.IPlugOptions{ 
        }
        export class ColorOptions extends System.ValueType implements DG.Tweening.Plugins.Options.IPlugOptions{ 
        }
        export class NoOptions extends System.ValueType implements DG.Tweening.Plugins.Options.IPlugOptions{ 
        }
        export class StringOptions extends System.ValueType implements DG.Tweening.Plugins.Options.IPlugOptions{ 
        }
    }
    export namespace DG.Tweening.Plugins.Core.PathCore {
        export class Path extends System.Object{ 
        }
    }
    export namespace DG.Tweening.Plugins {
        export class CircleOptions extends System.ValueType implements DG.Tweening.Plugins.Options.IPlugOptions{ 
        }
    }
    export namespace BetterEvents {
        export class BetterEvent extends System.ValueType{ 
            public Events: System.Collections.Generic.List$1<BetterEvents.BetterEventEntry>;
            public get uEvent(): UnityEngine.Events.UnityEvent;
            public set uEvent(value: UnityEngine.Events.UnityEvent);
            public Invoke():void;
        }
        export class BetterEventEntry extends System.Object implements UnityEngine.ISerializationCallbackReceiver{ 
            public Delegate: Function;
            public ParameterValues: System.Array$1<any>;
            public Invoke():void;
            public OnAfterDeserialize():void;
            public OnBeforeSerialize():void;
            public constructor($del: Function);
            public constructor();
        }
        export class ExampleMonoBehaviour extends UnityEngine.MonoBehaviour{ 
            public MyEvent: BetterEvents.BetterEvent;
            public constructor();
        }
    }
    export namespace Helpers {
        export class HotReload extends Sirenix.OdinInspector.SerializedMonoBehaviour implements Sirenix.Serialization.ISupportsPrefabSerialization, UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
        export class NodeTscAndHotReload extends System.Object{ 
            public static addDebugger: System.Action$1<number>;
            public static removeDebugger: System.Action$1<number>;
            public static Reload():void;
            public static HoverTreeClearMark($input: string):string;
            public static Watch():void;
            public static UnWatch():void;
            public constructor();
        }
    }
    export namespace Test {
        export class PocoDOScale extends EasyDOTween.PocoAnimation$2<UnityEngine.Transform, UnityEngine.Vector3>{ 
            public constructor();
        }
        export class PocoDOScaleSequence extends EasyDOTween.PocoSequence$3<Test.PocoDOScale, UnityEngine.Transform, UnityEngine.Vector3>{ 
            public constructor();
        }
    }
    export namespace UnityEngine.UI.Extensions.ContentScrollSnapHorizontal.MoveInfo {
        export enum IndexType{ childIndex = 0, positionIndex = 1 }
    }
    export namespace UnityEngine.UI.Extensions.UIScrollToSelection {
        export enum ScrollType{ VERTICAL = 0, HORIZONTAL = 1, BOTH = 2 }
    }
    export namespace UnityEngine.UI.Extensions.Tweens.FloatTween {
        export class FloatTweenCallback extends UnityEngine.Events.UnityEvent$1<number> implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
            public OnBeforeSerialize():void;
            public OnAfterDeserialize():void;
        }
        export class FloatFinishCallback extends UnityEngine.Events.UnityEvent implements UnityEngine.ISerializationCallbackReceiver{ 
            public constructor();
        }
    }
    export namespace FlowCanvas.Flow {
        export class ReturnData extends System.ValueType{ 
            public get returnCall(): FlowCanvas.FlowReturn;
            public get returnType(): System.Type;
            public constructor($call: FlowCanvas.FlowReturn, $type: System.Type);
            public constructor();
        }
    }
    export namespace FlowCanvas.FlowNode {
        export class ContextDefinedInputsAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public types: System.Array$1<System.Type>;
            public constructor(...types: System.Type[]);
            public constructor();
        }
        export class ContextDefinedOutputsAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public types: System.Array$1<System.Type>;
            public constructor(...types: System.Type[]);
            public constructor();
        }
        export class HasRefreshButtonAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
        export class GatherPortsCallbackAttribute extends ParadoxNotion.Design.CallbackAttribute implements System.Runtime.InteropServices._Attribute{ 
            public constructor();
        }
    }
    export namespace FlowCanvas.Port {
        export enum BindStatus{ Valid = 0, Missing = 1, InvalidCast = 2 }
    }
    export namespace NodeCanvas.DialogueTrees.MultipleChoiceNode {
        export class Choice extends System.Object{ 
            public isUnfolded: boolean;
            public statement: NodeCanvas.DialogueTrees.Statement;
            public condition: NodeCanvas.Framework.ConditionTask;
            public constructor();
            public constructor($statement: NodeCanvas.DialogueTrees.Statement);
        }
    }
    export namespace NodeCanvas.DialogueTrees.ProbabilitySelector {
        export class Option extends System.Object{ 
            public weight: NodeCanvas.Framework.BBParameter$1<number>;
            public condition: NodeCanvas.Framework.ConditionTask;
            public constructor($weightValue: number, $bbValue: NodeCanvas.Framework.IBlackboard);
            public constructor();
        }
    }
    export namespace NodeCanvas.Framework.GlobalBlackboard {
        export enum SingletonMode{ DestroyComponentOnly = 0, DestroyEntireGameObject = 1 }
    }
    export namespace UnityEditor.GenericMenu {
        export type MenuFunction = () => void;
        var MenuFunction: {new (func: () => void): MenuFunction;}
        export type MenuFunction2 = (userData: any) => void;
        var MenuFunction2: {new (func: (userData: any) => void): MenuFunction2;}
    }
    export namespace ParadoxNotion.Design.EditorUtils.ReorderableListOptions {
        export type GetItemMenuDelegate = (i: number) => UnityEditor.GenericMenu;
        var GetItemMenuDelegate: {new (func: (i: number) => UnityEditor.GenericMenu): GetItemMenuDelegate;}
    }
    export namespace DG.Tweening.DOTweenModuleUI {
        export class Utils extends System.Object{ 
            public static SwitchToRectTransform($from: UnityEngine.RectTransform, $to: UnityEngine.RectTransform):UnityEngine.Vector2;
        }
    }
    export namespace DG.Tweening.DOTweenCYInstruction {
        export class WaitForCompletion extends UnityEngine.CustomYieldInstruction implements System.Collections.IEnumerator{ 
            public get keepWaiting(): boolean;
            public constructor($tween: DG.Tweening.Tween);
            public constructor();
        }
        export class WaitForRewind extends UnityEngine.CustomYieldInstruction implements System.Collections.IEnumerator{ 
            public get keepWaiting(): boolean;
            public constructor($tween: DG.Tweening.Tween);
            public constructor();
        }
        export class WaitForKill extends UnityEngine.CustomYieldInstruction implements System.Collections.IEnumerator{ 
            public get keepWaiting(): boolean;
            public constructor($tween: DG.Tweening.Tween);
            public constructor();
        }
        export class WaitForElapsedLoops extends UnityEngine.CustomYieldInstruction implements System.Collections.IEnumerator{ 
            public get keepWaiting(): boolean;
            public constructor($tween: DG.Tweening.Tween, $elapsedLoops: number);
            public constructor();
        }
        export class WaitForPosition extends UnityEngine.CustomYieldInstruction implements System.Collections.IEnumerator{ 
            public get keepWaiting(): boolean;
            public constructor($tween: DG.Tweening.Tween, $position: number);
            public constructor();
        }
        export class WaitForStart extends UnityEngine.CustomYieldInstruction implements System.Collections.IEnumerator{ 
            public get keepWaiting(): boolean;
            public constructor($tween: DG.Tweening.Tween);
            public constructor();
        }
    }
    export namespace DG.Tweening.DOTweenModuleUtils {
        export class Physics extends System.Object{ 
            public static SetOrientationOnPath($options: DG.Tweening.Plugins.Options.PathOptions, $t: DG.Tweening.Tween, $newRot: UnityEngine.Quaternion, $trans: UnityEngine.Transform):void;
            public static HasRigidbody2D($target: UnityEngine.Component):boolean;
            public static HasRigidbody($target: UnityEngine.Component):boolean;
            public static CreateDOTweenPathTween($target: UnityEngine.MonoBehaviour, $tweenRigidbody: boolean, $isLocal: boolean, $path: DG.Tweening.Plugins.Core.PathCore.Path, $duration: number, $pathMode: DG.Tweening.PathMode):DG.Tweening.Core.TweenerCore$3<UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions>;
        }
    }
    export namespace Puerts.JsEnv {
        export type JsEnvCreateCallback = (env: Puerts.JsEnv, loader: Puerts.ILoader, debugPort: number) => void;
        var JsEnvCreateCallback: {new (func: (env: Puerts.JsEnv, loader: Puerts.ILoader, debugPort: number) => void): JsEnvCreateCallback;}
        export type JsEnvDisposeCallback = (env: Puerts.JsEnv) => void;
        var JsEnvDisposeCallback: {new (func: (env: Puerts.JsEnv) => void): JsEnvDisposeCallback;}
    }
